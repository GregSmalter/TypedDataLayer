using System;
using System.Globalization;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using TypedDataLayer;
using TypedDataLayer.Tools;
using TypedDataLayer.Exceptions;
using TypedDataLayer.DatabaseSpecification;
using TypedDataLayer.DatabaseSpecification.Databases;
using TypedDataLayer.DataAccess;
using TypedDataLayer.DataAccess.StandardModification;
using TypedDataLayer.DataAccess.RetrievalCaching;
using TypedDataLayer.DataAccess.CommandWriting;
using TypedDataLayer.DataAccess.CommandWriting.InlineConditionAbstraction;
using TypedDataLayer.DataAccess.CommandWriting.InlineConditionAbstraction.Conditions;
using TypedDataLayer.DataAccess.CommandWriting.Commands;
using TypedDataLayer.Containers;
using TypedDataLayer.Collections;

namespace ExampleNamespace.DataAccess.TableConstants {
/// <summary>
/// This object represents the constants of the Administrators table.
/// </summary>
public class @AdministratorsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "Administrators";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @AdministratorIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "AdministratorId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UserIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UserId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PhoneNumberColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PhoneNumber";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 25;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PhotoFileCollectionIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PhotoFileCollectionId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
}
/// <summary>
/// This object represents the constants of the AdvancedDirectivesHistory table.
/// </summary>
public class @AdvancedDirectivesHistoryTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "AdvancedDirectivesHistory";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @AdvancedDirectivesHistoryIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "AdvancedDirectivesHistoryId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @DateAndTimeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "DateAndTime";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @IvColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Iv";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UserIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UserId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 32;
}
}
/// <summary>
/// This object represents the constants of the AppContent table.
/// </summary>
public class @AppContentTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "AppContent";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @NameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Name";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ValueColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Value";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 2147483647;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @InstructionsColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Instructions";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 500;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ShowInGeneralListColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ShowInGeneralList";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
}
/// <summary>
/// This object represents the constants of the AppEnums table.
/// </summary>
public class @AppEnumsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "AppEnums";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @CategoryColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Category";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ParamNameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ParamName";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ParamValueColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ParamValue";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
}
/// <summary>
/// This object represents the constants of the aspnet_Applications table.
/// </summary>
public class @aspnet_ApplicationsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "aspnet_Applications";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ApplicationNameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ApplicationName";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 256;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LoweredApplicationNameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LoweredApplicationName";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 256;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ApplicationIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ApplicationId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @DescriptionColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Description";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 256;
}
}
/// <summary>
/// This object represents the constants of the aspnet_Membership table.
/// </summary>
public class @aspnet_MembershipTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "aspnet_Membership";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ApplicationIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ApplicationId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UserIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UserId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PasswordColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Password";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 128;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PasswordFormatColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PasswordFormat";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PasswordSaltColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PasswordSalt";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 128;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @MobilePINColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "MobilePIN";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EmailColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Email";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 256;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LoweredEmailColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LoweredEmail";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 256;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PasswordQuestionColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PasswordQuestion";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 256;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PasswordAnswerColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PasswordAnswer";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 128;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @IsApprovedColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "IsApproved";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @IsLockedOutColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "IsLockedOut";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @CreateDateColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "CreateDate";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LastLoginDateColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LastLoginDate";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LastPasswordChangedDateColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LastPasswordChangedDate";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LastLockoutDateColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LastLockoutDate";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @FailedPasswordAttemptCountColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "FailedPasswordAttemptCount";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @FailedPasswordAttemptWindowStartColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "FailedPasswordAttemptWindowStart";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @FailedPasswordAnswerAttemptCountColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "FailedPasswordAnswerAttemptCount";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @FailedPasswordAnswerAttemptWindowStartColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "FailedPasswordAnswerAttemptWindowStart";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @CommentColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Comment";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1073741823;
}
}
/// <summary>
/// This object represents the constants of the aspnet_Paths table.
/// </summary>
public class @aspnet_PathsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "aspnet_Paths";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ApplicationIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ApplicationId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PathIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PathId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PathColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Path";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 256;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LoweredPathColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LoweredPath";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 256;
}
}
/// <summary>
/// This object represents the constants of the aspnet_PersonalizationAllUsers table.
/// </summary>
public class @aspnet_PersonalizationAllUsersTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "aspnet_PersonalizationAllUsers";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PathIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PathId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PageSettingsColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PageSettings";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 2147483647;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LastUpdatedDateColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LastUpdatedDate";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
}
/// <summary>
/// This object represents the constants of the aspnet_PersonalizationPerUser table.
/// </summary>
public class @aspnet_PersonalizationPerUserTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "aspnet_PersonalizationPerUser";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @IdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Id";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PathIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PathId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UserIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UserId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PageSettingsColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PageSettings";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 2147483647;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LastUpdatedDateColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LastUpdatedDate";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
}
/// <summary>
/// This object represents the constants of the aspnet_Profile table.
/// </summary>
public class @aspnet_ProfileTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "aspnet_Profile";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UserIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UserId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PropertyNamesColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PropertyNames";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1073741823;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PropertyValuesStringColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PropertyValuesString";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1073741823;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PropertyValuesBinaryColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PropertyValuesBinary";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 2147483647;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LastUpdatedDateColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LastUpdatedDate";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
}
/// <summary>
/// This object represents the constants of the aspnet_Roles table.
/// </summary>
public class @aspnet_RolesTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "aspnet_Roles";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ApplicationIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ApplicationId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @RoleIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "RoleId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @RoleNameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "RoleName";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 256;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LoweredRoleNameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LoweredRoleName";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 256;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @DescriptionColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Description";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 256;
}
}
/// <summary>
/// This object represents the constants of the aspnet_SchemaVersions table.
/// </summary>
public class @aspnet_SchemaVersionsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "aspnet_SchemaVersions";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @FeatureColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Feature";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 128;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @CompatibleSchemaVersionColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "CompatibleSchemaVersion";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 128;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @IsCurrentVersionColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "IsCurrentVersion";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
}
/// <summary>
/// This object represents the constants of the aspnet_Users table.
/// </summary>
public class @aspnet_UsersTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "aspnet_Users";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ApplicationIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ApplicationId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UserIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UserId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UserNameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UserName";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 256;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LoweredUserNameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LoweredUserName";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 256;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @MobileAliasColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "MobileAlias";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @IsAnonymousColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "IsAnonymous";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LastActivityDateColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LastActivityDate";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
}
/// <summary>
/// This object represents the constants of the aspnet_UsersInRoles table.
/// </summary>
public class @aspnet_UsersInRolesTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "aspnet_UsersInRoles";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UserIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UserId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @RoleIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "RoleId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
}
/// <summary>
/// This object represents the constants of the aspnet_WebEvent_Events table.
/// </summary>
public class @aspnet_WebEvent_EventsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "aspnet_WebEvent_Events";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EventIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EventId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 32;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EventTimeUtcColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EventTimeUtc";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EventTimeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EventTime";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EventTypeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EventType";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 256;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EventSequenceColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EventSequence";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 17;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EventOccurrenceColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EventOccurrence";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 17;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EventCodeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EventCode";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EventDetailCodeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EventDetailCode";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @MessageColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Message";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1024;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ApplicationPathColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ApplicationPath";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 256;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ApplicationVirtualPathColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ApplicationVirtualPath";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 256;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @MachineNameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "MachineName";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 256;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @RequestUrlColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "RequestUrl";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1024;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ExceptionTypeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ExceptionType";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 256;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @DetailsColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Details";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1073741823;
}
}
/// <summary>
/// This object represents the constants of the BackgroundNotifierLogs table.
/// </summary>
public class @BackgroundNotifierLogsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "BackgroundNotifierLogs";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @BackgroundNotifierLogIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "BackgroundNotifierLogId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UserIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UserId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @IsErrorColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "IsError";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @DetailsColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Details";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 2147483647;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @SentDateTimeUtcColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "SentDateTimeUtc";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
}
/// <summary>
/// This object represents the constants of the CareZones table.
/// </summary>
public class @CareZonesTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "CareZones";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @CareZoneIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "CareZoneId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @NameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Name";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 100;
}
}
/// <summary>
/// This object represents the constants of the CareZonesToWorkGroups table.
/// </summary>
public class @CareZonesToWorkGroupsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "CareZonesToWorkGroups";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @CareZoneToWorkGroupIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "CareZoneToWorkGroupId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @CareZoneIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "CareZoneId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @WorkGroupIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "WorkGroupId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
}
/// <summary>
/// This object represents the constants of the ClinicianPatients table.
/// </summary>
public class @ClinicianPatientsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "ClinicianPatients";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ClinicianPatientIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ClinicianPatientId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EncryptionKeyVersionColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EncryptionKeyVersion";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EncryptionIvColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EncryptionIv";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 100;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ClinicianIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ClinicianId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PatientInfoIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PatientInfoId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 64;
}
}
/// <summary>
/// This object represents the constants of the Clinicians table.
/// </summary>
public class @CliniciansTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "Clinicians";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ClinicianIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ClinicianId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @FirstNameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "FirstName";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LastNameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LastName";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @WorkGroupIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "WorkGroupId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UserIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UserId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
}
/// <summary>
/// This object represents the constants of the CompletedCourses table.
/// </summary>
public class @CompletedCoursesTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "CompletedCourses";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @CompletedCourseIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "CompletedCourseId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @TrainingCourseIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "TrainingCourseId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @StartDateTimeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "StartDateTime";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @FinishedDateTimeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "FinishedDateTime";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UserIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UserId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
}
/// <summary>
/// This object represents the constants of the ConsentTypes table.
/// </summary>
public class @ConsentTypesTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "ConsentTypes";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ConsentTypeIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ConsentTypeId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @NameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Name";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 10;
}
}
/// <summary>
/// This object represents the constants of the Content table.
/// </summary>
public class @ContentTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "Content";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ContentIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ContentId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @TextColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Text";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 255;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @HtmlBlockIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "HtmlBlockId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @OrderRankIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "OrderRankId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ContentTabIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ContentTabId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
}
/// <summary>
/// This object represents the constants of the ContentTabs table.
/// </summary>
public class @ContentTabsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "ContentTabs";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ContentTabIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ContentTabId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @NameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Name";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @HasProviderPortalTabColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "HasProviderPortalTab";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
}
/// <summary>
/// This object represents the constants of the DirectAccessLogs table.
/// </summary>
public class @DirectAccessLogsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "DirectAccessLogs";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @DirectAccessLogsColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "DirectAccessLogs";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UserIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UserId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @DateTimeUtcColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "DateTimeUtc";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
}
/// <summary>
/// This object represents the constants of the EmailTemplates table.
/// </summary>
public class @EmailTemplatesTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "EmailTemplates";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EmailTemplateIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EmailTemplateId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @NameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Name";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 100;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @SubjectColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Subject";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 255;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @HtmlBlockIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "HtmlBlockId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @RoleIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "RoleId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EmailTemplateTypeIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EmailTemplateTypeId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
}
/// <summary>
/// This object represents the constants of the EmailTemplateTypes table.
/// </summary>
public class @EmailTemplateTypesTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "EmailTemplateTypes";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EmailTemplateTypeIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EmailTemplateTypeId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @NameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Name";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 20;
}
}
/// <summary>
/// This object represents the constants of the EventLog table.
/// </summary>
public class @EventLogTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "EventLog";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EventIDColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EventID";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EventTimeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EventTime";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @CategoryColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Category";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @SubCategoryColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "SubCategory";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 75;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ErrorLevelColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ErrorLevel";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EventCodeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EventCode";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EncKVColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EncKV";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 10;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EncIVColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EncIV";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 100;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UserIDColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UserID";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UserTypeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UserType";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 20;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @IPAddressColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "IPAddress";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 39;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EventSummaryColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EventSummary";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 300;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EventURLColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EventURL";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 200;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @AdditionalDataColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "AdditionalData";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 2147483647;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ProtectedDataColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ProtectedData";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 2147483647;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @AccessReasonCodeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "AccessReasonCode";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 20;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @AccessReasonTextColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "AccessReasonText";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 100;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @AccessScopeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "AccessScope";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 20;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @AccessTypeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "AccessType";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ReviewStatusColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ReviewStatus";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 20;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @SuggestedActionColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "SuggestedAction";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 200;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ReviewedByColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ReviewedBy";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ReviewDateColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ReviewDate";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ReviewSummaryColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ReviewSummary";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 300;
}
}
/// <summary>
/// This object represents the constants of the FileCollections table.
/// </summary>
public class @FileCollectionsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "FileCollections";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @FileCollectionIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "FileCollectionId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
}
/// <summary>
/// This object represents the constants of the Files table.
/// </summary>
public class @FilesTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "Files";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @FileIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "FileId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @FileCollectionIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "FileCollectionId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @FileNameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "FileName";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 256;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ContentTypeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ContentType";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 100;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ContentsColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Contents";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 2147483647;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UploadedDateColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UploadedDate";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
}
/// <summary>
/// This object represents the constants of the FormInputs table.
/// </summary>
public class @FormInputsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "FormInputs";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @FormInputIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "FormInputId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @FormIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "FormId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @InputNameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "InputName";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 100;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LabelColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Label";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 200;
}
}
/// <summary>
/// This object represents the constants of the FormInstances table.
/// </summary>
public class @FormInstancesTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "FormInstances";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @FormInstanceIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "FormInstanceId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @FormIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "FormId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @SignedByUserIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "SignedByUserId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @SignedDateTimeUtcColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "SignedDateTimeUtc";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
}
/// <summary>
/// This object represents the constants of the Forms table.
/// </summary>
public class @FormsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "Forms";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @FormIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "FormId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @FormNameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "FormName";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 100;
}
}
/// <summary>
/// This object represents the constants of the FormValues table.
/// </summary>
public class @FormValuesTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "FormValues";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @FormValueIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "FormValueId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @FormInstanceIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "FormInstanceId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @FormInputIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "FormInputId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @InputValueColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "InputValue";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 2147483647;
}
}
/// <summary>
/// This object represents the constants of the GlobalDates table.
/// </summary>
public class @GlobalDatesTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "GlobalDates";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @NameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Name";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ValueColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Value";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
}
/// <summary>
/// This object represents the constants of the GlobalInts table.
/// </summary>
public class @GlobalIntsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "GlobalInts";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ParameterNameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ParameterName";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ParameterValueColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ParameterValue";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
}
/// <summary>
/// This object represents the constants of the GlobalStrings table.
/// </summary>
public class @GlobalStringsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "GlobalStrings";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @NameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Name";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ValueColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Value";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 2147483647;
}
}
/// <summary>
/// This object represents the constants of the HealthPlan table.
/// </summary>
public class @HealthPlanTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "HealthPlan";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @HealthPlanIDColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "HealthPlanID";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @HealthPlanNameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "HealthPlanName";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 100;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @VisibleColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Visible";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LogoDataColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LogoData";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 2147483647;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LogoContentTypeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LogoContentType";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 30;
}
}
/// <summary>
/// This object represents the constants of the HtmlBlocks table.
/// </summary>
public class @HtmlBlocksTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "HtmlBlocks";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @HtmlBlockIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "HtmlBlockId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @HtmlColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Html";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 2147483647;
}
}
/// <summary>
/// This object represents the constants of the MainSequence table.
/// </summary>
public class @MainSequenceTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "MainSequence";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @MainSequenceIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "MainSequenceId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
}
/// <summary>
/// This object represents the constants of the MaintenanceWindowDays table.
/// </summary>
public class @MaintenanceWindowDaysTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "MaintenanceWindowDays";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @MaintenanceWindowDayIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "MaintenanceWindowDayId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @DayColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Day";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 10;
}
}
/// <summary>
/// This object represents the constants of the MaintenanceWindows table.
/// </summary>
public class @MaintenanceWindowsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "MaintenanceWindows";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @MaintenanceWindowIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "MaintenanceWindowId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EnabledColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Enabled";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @MaintenanceWindowDayIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "MaintenanceWindowDayId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @StartTimeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "StartTime";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 5;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @DurationHoursColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "DurationHours";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 17;
}
}
/// <summary>
/// This object represents the constants of the MediaFiles table.
/// </summary>
public class @MediaFilesTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "MediaFiles";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @MediaFileIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "MediaFileId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @FileIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "FileId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @MediaFolderIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "MediaFolderId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
}
/// <summary>
/// This object represents the constants of the MediaFolders table.
/// </summary>
public class @MediaFoldersTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "MediaFolders";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @MediaFolderIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "MediaFolderId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @NameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Name";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
}
/// <summary>
/// This object represents the constants of the Notification table.
/// </summary>
public class @NotificationTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "Notification";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @NotificationIDColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "NotificationID";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @TypeNameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "TypeName";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @FromUserColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "FromUser";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 100;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ToUserColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ToUser";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 100;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EmailBodyColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EmailBody";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1073741823;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EmailSubjectColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EmailSubject";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 255;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @SuccessColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Success";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @CreatedColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Created";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @FailureMsgColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "FailureMsg";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 200;
}
}
/// <summary>
/// This object represents the constants of the NotificationParameter table.
/// </summary>
public class @NotificationParameterTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "NotificationParameter";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ParameterIDColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ParameterID";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @NameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Name";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @DataTypeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "DataType";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 10;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ProtocolColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Protocol";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 10;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @DefaultValueColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "DefaultValue";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 255;
}
}
/// <summary>
/// This object represents the constants of the NotificationType table.
/// </summary>
public class @NotificationTypeTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "NotificationType";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @TypeIDColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "TypeID";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @NameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Name";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LastModifiedColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LastModified";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @CreatedColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Created";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @FromCodeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "FromCode";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 10;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ToCodeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ToCode";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 20;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ProtocolColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Protocol";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 20;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @SubjectColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Subject";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @BodyColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Body";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 2147483647;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @HtmlBodyColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "HtmlBody";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
}
/// <summary>
/// This object represents the constants of the OrderRanks table.
/// </summary>
public class @OrderRanksTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "OrderRanks";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @OrderRankIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "OrderRankId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @RankColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Rank";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
}
/// <summary>
/// This object represents the constants of the Organizations table.
/// </summary>
public class @OrganizationsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "Organizations";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @OrganizationIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "OrganizationId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @NameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Name";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 300;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @DisabledEndDateColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "DisabledEndDate";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 3;
}
}
/// <summary>
/// This object represents the constants of the PasswordResetQuestions table.
/// </summary>
public class @PasswordResetQuestionsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "PasswordResetQuestions";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PasswordResetQuestionIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PasswordResetQuestionId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @QuestionColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Question";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 100;
}
}
/// <summary>
/// This object represents the constants of the PatientAuditRequest table.
/// </summary>
public class @PatientAuditRequestTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "PatientAuditRequest";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PatientAuditIDColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PatientAuditID";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EncKVColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EncKV";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 10;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EncIVColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EncIV";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 100;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @DateRequestedColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "DateRequested";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @AuditStatusColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "AuditStatus";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 25;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LastModifiedDateColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LastModifiedDate";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LastModifiedUserColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LastModifiedUser";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PatientUserIDColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PatientUserID";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 100;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ElysiumIDColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ElysiumID";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 12;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @BillableAmountColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "BillableAmount";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 17;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PaymentConfirmedColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PaymentConfirmed";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
}
/// <summary>
/// This object represents the constants of the PatientConsentServiceCache table.
/// </summary>
public class @PatientConsentServiceCacheTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "PatientConsentServiceCache";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PatientConsentServiceCacheIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PatientConsentServiceCacheId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @IvColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Iv";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PatientConsentServiceCacheDateIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PatientConsentServiceCacheDateId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @WorkgroupIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "WorkgroupId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ConsentTypeIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ConsentTypeId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
}
/// <summary>
/// This object represents the constants of the PatientConsentServiceCacheDates table.
/// </summary>
public class @PatientConsentServiceCacheDatesTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "PatientConsentServiceCacheDates";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PatientConsentServiceCacheDateIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PatientConsentServiceCacheDateId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ElysiumIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ElysiumId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 12;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LastRequestedDateColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LastRequestedDate";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 3;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @GoodforColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Goodfor";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 3;
}
}
/// <summary>
/// This object represents the constants of the PatientInfo table.
/// </summary>
public class @PatientInfoTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "PatientInfo";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UserIDColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UserID";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EncKVColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EncKV";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 10;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EncIVColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EncIV";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 100;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @FirstNameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "FirstName";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8000;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @MiddleNameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "MiddleName";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8000;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LastNameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LastName";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8000;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @Address1Column {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Address1";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8000;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @Address2Column {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Address2";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8000;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @CityColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "City";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8000;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @StateColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "State";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8000;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ZipCodeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ZipCode";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8000;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EmailColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Email";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8000;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PhoneColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Phone";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8000;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @GenderColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Gender";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8000;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @DOBColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "DOB";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8000;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ElysiumIDColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ElysiumID";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8000;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PhrStatusIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PhrStatusId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @SignupCompleteColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "SignupComplete";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @TfaMethodIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "TfaMethodId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ForcePasswordExpiredColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ForcePasswordExpired";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @SignupDateColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "SignupDate";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
}
/// <summary>
/// This object represents the constants of the PatientPortalConsentHistory table.
/// </summary>
public class @PatientPortalConsentHistoryTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "PatientPortalConsentHistory";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PatientPortalConsentHistoryIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PatientPortalConsentHistoryId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @IvColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Iv";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ElysiumIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ElysiumId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 12;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @WorkgroupIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "WorkgroupId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ConsentTypeIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ConsentTypeId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UpdatedByPatientDateTimeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UpdatedByPatientDateTime";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
}
/// <summary>
/// This object represents the constants of the Payment table.
/// </summary>
public class @PaymentTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "Payment";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PaymentIDColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PaymentID";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UserIDColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UserID";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PaymentTypeIDColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PaymentTypeID";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PaymentMethodIDColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PaymentMethodID";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @TotalColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Total";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @CreatedColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Created";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LastModifiedColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LastModified";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
}
/// <summary>
/// This object represents the constants of the PaymentMethod table.
/// </summary>
public class @PaymentMethodTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "PaymentMethod";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @MethodIDColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "MethodID";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @NameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Name";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EnabledColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Enabled";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @CreatedColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Created";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LastModifiedColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LastModified";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
}
/// <summary>
/// This object represents the constants of the PaymentType table.
/// </summary>
public class @PaymentTypeTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "PaymentType";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @TypeIDColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "TypeID";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @NameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Name";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PriceColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Price";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @CreatedColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Created";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LastUpdatedColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LastUpdated";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
}
/// <summary>
/// This object represents the constants of the PerfLog table.
/// </summary>
public class @PerfLogTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "PerfLog";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PerfLogIDColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PerfLogID";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @TStampColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "TStamp";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @CategoryColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Category";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @CodeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Code";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ElapsedTimeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ElapsedTime";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 17;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UnitsColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Units";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 10;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @IsTestColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "IsTest";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @Factor1Column {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Factor1";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 17;
}
}
/// <summary>
/// This object represents the constants of the PhrStatuses table.
/// </summary>
public class @PhrStatusesTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "PhrStatuses";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PhrStatusIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PhrStatusId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PhrStatusColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PhrStatus";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 10;
}
}
/// <summary>
/// This object represents the constants of the Physician table.
/// </summary>
public class @PhysicianTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "Physician";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PhysicianIDColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PhysicianID";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ExternalIDColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ExternalID";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @SpecialtyIDColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "SpecialtyID";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @WorkGroupIDColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "WorkGroupID";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @FirstNameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "FirstName";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LastNameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LastName";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @MiddleInitialColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "MiddleInitial";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @CompanyColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Company";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 250;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @AddressColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Address";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 250;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @CityColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "City";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 80;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @StateColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "State";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ZipColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Zip";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PhoneColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Phone";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LastUpdatedColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LastUpdated";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @CreatedColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Created";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @HiddenColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Hidden";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ProviderNPIColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ProviderNPI";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 10;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @WorkgroupLocationIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "WorkgroupLocationId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
}
/// <summary>
/// This object represents the constants of the PreviousPasswords table.
/// </summary>
public class @PreviousPasswordsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "PreviousPasswords";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PreviousPasswordIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PreviousPasswordId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UserIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UserId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @SaltColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Salt";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PasswordColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Password";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 20;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @DateColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Date";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
}
/// <summary>
/// This object represents the constants of the Provider table.
/// </summary>
public class @ProviderTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "Provider";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ProviderIDColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ProviderID";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @TypeIDColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "TypeID";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @NameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Name";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @NamespaceColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Namespace";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 100;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @IsEnabledColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "IsEnabled";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @IsCurrentColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "IsCurrent";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LastModifiedColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LastModified";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @CreatedColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Created";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
}
/// <summary>
/// This object represents the constants of the ProviderPortalUsers table.
/// </summary>
public class @ProviderPortalUsersTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "ProviderPortalUsers";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ProviderPortalUserIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ProviderPortalUserId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @RhioUserNameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "RhioUserName";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 30;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UserIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UserId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @NationalProviderIdentifierColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "NationalProviderIdentifier";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 20;
}
}
/// <summary>
/// This object represents the constants of the ProviderPortalUsersToCareZones table.
/// </summary>
public class @ProviderPortalUsersToCareZonesTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "ProviderPortalUsersToCareZones";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ProviderPortalUsersToCareZonesIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ProviderPortalUsersToCareZonesId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ProviderPortalUserIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ProviderPortalUserId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @CareZoneIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "CareZoneId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
}
/// <summary>
/// This object represents the constants of the ProviderPortalUsersToNewCareZones table.
/// </summary>
public class @ProviderPortalUsersToNewCareZonesTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "ProviderPortalUsersToNewCareZones";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ProviderPortalUserIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ProviderPortalUserId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @CareZoneIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "CareZoneId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
}
/// <summary>
/// This object represents the constants of the ProviderType table.
/// </summary>
public class @ProviderTypeTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "ProviderType";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @TypeIDColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "TypeID";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @NameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Name";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LastModifiedColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LastModified";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @CreatedColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Created";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
}
/// <summary>
/// This object represents the constants of the Roles table.
/// </summary>
public class @RolesTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "Roles";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @RoleIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "RoleId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @RoleNameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "RoleName";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
}
/// <summary>
/// This object represents the constants of the SalesforceContacts table.
/// </summary>
public class @SalesforceContactsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "SalesforceContacts";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @SalesforceContactIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "SalesforceContactId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PersonalDirectAddressColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PersonalDirectAddress";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 200;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @TitleColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Title";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 100;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @FirstNameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "FirstName";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LastNameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LastName";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 100;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PhoneNumberColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PhoneNumber";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 100;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @SalesforceOrganizationIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "SalesforceOrganizationId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @IsVhrUserColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "IsVhrUser";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
}
/// <summary>
/// This object represents the constants of the SalesforceOrganizations table.
/// </summary>
public class @SalesforceOrganizationsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "SalesforceOrganizations";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @SalesforceOrganizationIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "SalesforceOrganizationId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @OrganizationNameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "OrganizationName";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 300;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ParentOrganizationIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ParentOrganizationId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @DirectAddressColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "DirectAddress";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 2147483647;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PhoneNumberColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PhoneNumber";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 100;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @StreetColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Street";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 200;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @Street2Column {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Street2";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 200;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @CityColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "City";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 200;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @StateIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "StateId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ZipCodeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ZipCode";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 20;
}
}
/// <summary>
/// This object represents the constants of the ScanAttachFile table.
/// </summary>
public class @ScanAttachFileTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "ScanAttachFile";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @FileIDColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "FileID";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EncKVColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EncKV";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 10;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EncIVColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EncIV";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 100;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ElysiumIDColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ElysiumID";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 12;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @CategoryColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Category";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @FileStatusColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "FileStatus";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 20;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @DateUploadedColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "DateUploaded";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @DateUpdatedColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "DateUpdated";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @SuggestedFileNameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "SuggestedFileName";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @FileMimeTypeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "FileMimeType";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @FileBytesEncryptedColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "FileBytesEncrypted";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 2147483647;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PatientUserIDColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PatientUserID";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 100;
}
}
/// <summary>
/// This object represents the constants of the Specialty table.
/// </summary>
public class @SpecialtyTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "Specialty";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @SpecialtyIDColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "SpecialtyID";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @NameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Name";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 100;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LastModifiedColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LastModified";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @CreatedColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Created";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
}
/// <summary>
/// This object represents the constants of the States table.
/// </summary>
public class @StatesTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "States";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @StateIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "StateId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @NameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Name";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 20;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @AbbreviationColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Abbreviation";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 2;
}
}
/// <summary>
/// This object represents the constants of the sysdiagrams table.
/// </summary>
public class @sysdiagramsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "sysdiagrams";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @nameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "name";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 128;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @principal_idColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "principal_id";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @diagram_idColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "diagram_id";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @versionColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "version";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @definitionColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "definition";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 2147483647;
}
}
/// <summary>
/// This object represents the constants of the TempPreDertEventLogs table.
/// </summary>
public class @TempPreDertEventLogsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "TempPreDertEventLogs";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @TempPreDertEventLogIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "TempPreDertEventLogId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EventDateColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EventDate";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @AdministratorUserIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "AdministratorUserId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @AffectedUserIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "AffectedUserId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EventCodeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EventCode";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 100;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LogMessageColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LogMessage";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 2147483647;
}
}
/// <summary>
/// This object represents the constants of the TfaMethods table.
/// </summary>
public class @TfaMethodsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "TfaMethods";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @TfaMethodIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "TfaMethodId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @MethodColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Method";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 10;
}
}
/// <summary>
/// This object represents the constants of the TrainingContent table.
/// </summary>
public class @TrainingContentTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "TrainingContent";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @TrainingContentIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "TrainingContentId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @TextColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Text";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 255;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @HtmlBlockIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "HtmlBlockId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @OrderRankIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "OrderRankId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @TrainingCourseTypeIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "TrainingCourseTypeId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
}
/// <summary>
/// This object represents the constants of the TrainingCourses table.
/// </summary>
public class @TrainingCoursesTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "TrainingCourses";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @TrainingCourseIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "TrainingCourseId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @NameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Name";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 255;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @DestinationUrlColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "DestinationUrl";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4000;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @IsPerpetualColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "IsPerpetual";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @IsArchivedColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "IsArchived";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @TrainingCourseTypeIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "TrainingCourseTypeId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
}
/// <summary>
/// This object represents the constants of the TrainingCourseTypes table.
/// </summary>
public class @TrainingCourseTypesTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "TrainingCourseTypes";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @TrainingCourseTypeIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "TrainingCourseTypeId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @NameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Name";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
}
/// <summary>
/// This object represents the constants of the UserLoginLogs table.
/// </summary>
public class @UserLoginLogsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "UserLoginLogs";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UserLoginLogIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UserLoginLogId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UserIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UserId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @DateTimeUtcColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "DateTimeUtc";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
}
/// <summary>
/// This object represents the constants of the UserLogMessages table.
/// </summary>
public class @UserLogMessagesTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "UserLogMessages";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UserLogMessageIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UserLogMessageId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UserIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UserId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @DateAndTimeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "DateAndTime";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @IvColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Iv";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @MessageColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Message";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 2147483647;
}
}
/// <summary>
/// This object represents the constants of the Users table.
/// </summary>
public class @UsersTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "Users";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UserIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UserId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EmailAddressColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EmailAddress";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 100;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @RoleIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "RoleId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @SaltColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Salt";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PasswordColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Password";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 20;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LastRequestDateTimeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LastRequestDateTime";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @MustChangePasswordColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "MustChangePassword";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @DisabledColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Disabled";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @InvalidPasswordAttemptsColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "InvalidPasswordAttempts";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LastPasswordChangeDateColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LastPasswordChangeDate";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @FirstNameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "FirstName";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LastNameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LastName";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 100;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LastAlertEmailSentDateTimeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LastAlertEmailSentDateTime";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @CreatedDateTimeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "CreatedDateTime";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EmailVerificationCodeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EmailVerificationCode";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 200;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EmailVerifiedDateUtcColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EmailVerifiedDateUtc";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @DeletedColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Deleted";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @Random2Column {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Random2";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
}
/// <summary>
/// This object represents the constants of the UsersToHiddenTrainingCourseTypes table.
/// </summary>
public class @UsersToHiddenTrainingCourseTypesTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "UsersToHiddenTrainingCourseTypes";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UserIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UserId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @TrainingCourseTypeIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "TrainingCourseTypeId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
}
/// <summary>
/// This object represents the constants of the UsersToOrganizations table.
/// </summary>
public class @UsersToOrganizationsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "UsersToOrganizations";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UsersToOrganizationIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UsersToOrganizationId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UserIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UserId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @OrganizationIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "OrganizationId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @StartDateColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "StartDate";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 3;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EndDateColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EndDate";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 3;
}
}
/// <summary>
/// This object represents the constants of the UsersToPasswordResetQuestions table.
/// </summary>
public class @UsersToPasswordResetQuestionsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "UsersToPasswordResetQuestions";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UsersToPasswordResetQuestionIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UsersToPasswordResetQuestionId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UserIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UserId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PasswordResetQuestionIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PasswordResetQuestionId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @IvColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Iv";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @AnswerColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Answer";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 200;
}
}
/// <summary>
/// This object represents the constants of the VhrAccessLogs table.
/// </summary>
public class @VhrAccessLogsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "VhrAccessLogs";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @VhrAccessLogIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "VhrAccessLogId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @VhrProfileIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "VhrProfileId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @DateTimeUtcColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "DateTimeUtc";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
}
/// <summary>
/// This object represents the constants of the VhrEnvironmentConfigurations table.
/// </summary>
public class @VhrEnvironmentConfigurationsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "VhrEnvironmentConfigurations";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @VhrProviderIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "VhrProviderId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @VhrEnvironmentIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "VhrEnvironmentId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EndpointUrlColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EndpointUrl";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 2147483647;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @SsoSiteIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "SsoSiteId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 20;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @SsoCertificateColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "SsoCertificate";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 2147483647;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @SsoPasswordColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "SsoPassword";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 2147483647;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @SsoIvColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "SsoIv";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ClientCertificateColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ClientCertificate";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 2147483647;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ClientPasswordColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ClientPassword";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 2147483647;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ClientIvColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ClientIv";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 16;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @SsoSendingPartyColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "SsoSendingParty";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 2147483647;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @RedirectToUrlColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "RedirectToUrl";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 2147483647;
}
}
/// <summary>
/// This object represents the constants of the VhrEnvironments table.
/// </summary>
public class @VhrEnvironmentsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "VhrEnvironments";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @VhrEnvironmentIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "VhrEnvironmentId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @NameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Name";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 20;
}
}
/// <summary>
/// This object represents the constants of the VhrProfiles table.
/// </summary>
public class @VhrProfilesTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "VhrProfiles";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @VhrProfileIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "VhrProfileId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @VhrUserNameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "VhrUserName";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @DescriptionColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Description";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 100;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @DeletedColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Deleted";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @VhrProviderIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "VhrProviderId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @DisabledColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Disabled";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UserIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UserId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @VhrEnvironmentIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "VhrEnvironmentId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
}
/// <summary>
/// This object represents the constants of the VhrProviders table.
/// </summary>
public class @VhrProvidersTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "VhrProviders";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @VhrProviderIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "VhrProviderId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @NameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Name";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @IsVhrColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "IsVhr";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ArchivedColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Archived";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
}
/// <summary>
/// This object represents the constants of the VitalsDataSource table.
/// </summary>
public class @VitalsDataSourceTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "VitalsDataSource";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @IdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Id";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @NameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Name";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @IsAutoSyncEnabledColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "IsAutoSyncEnabled";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LastSyncTimeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LastSyncTime";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @IsEnrollableColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "IsEnrollable";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @AllowsMultipleEnrollmentsColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "AllowsMultipleEnrollments";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @DisplayOrderColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "DisplayOrder";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ConnectCredentialsFormPathColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ConnectCredentialsFormPath";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 200;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @InternalIdentifierColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "InternalIdentifier";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @VitalsRecordOrderDescriptionColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "VitalsRecordOrderDescription";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 50;
}
}
/// <summary>
/// This object represents the constants of the VitalsEnrollment table.
/// </summary>
public class @VitalsEnrollmentTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "VitalsEnrollment";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @IdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Id";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @DataSourceIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "DataSourceId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EncKVColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EncKV";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 10;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EncIVColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EncIV";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 100;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @PatientUsernameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "PatientUsername";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 256;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EnrollmentNameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EnrollmentName";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 80;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @CredentialsColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Credentials";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1000;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @DataSourceUniqueIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "DataSourceUniqueId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 256;
}
}
/// <summary>
/// This object represents the constants of the VitalsEnrollmentEvents table.
/// </summary>
public class @VitalsEnrollmentEventsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "VitalsEnrollmentEvents";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @VitalsEnrollmentEventIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "VitalsEnrollmentEventId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @VitalsDataSourceIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "VitalsDataSourceId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @EnrolledDateTimeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "EnrolledDateTime";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UnenrolledDateTimeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UnenrolledDateTime";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
}
/// <summary>
/// This object represents the constants of the Workgroup table.
/// </summary>
public class @WorkgroupTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "Workgroup";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @WorkGroupIDColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "WorkGroupID";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @NameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Name";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 100;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LastUpdatedColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LastUpdated";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @CreatedColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Created";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 8;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @HealthPlanIDColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "HealthPlanID";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ConsentLevelColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ConsentLevel";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @HiddenColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "Hidden";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 1;
}
}
/// <summary>
/// This object represents the constants of the WorkgroupLocations table.
/// </summary>
public class @WorkgroupLocationsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "WorkgroupLocations";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @WorkgroupLocationIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "WorkgroupLocationId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @WorkgroupIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "WorkgroupId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @LocationNameColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "LocationName";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 250;
}
}
/// <summary>
/// This object represents the constants of the ZipCodesToDeploymentCoordinators table.
/// </summary>
public class @ZipCodesToDeploymentCoordinatorsTable {
/// <summary>
/// The name of this table.
/// </summary>
public const string Name = "ZipCodesToDeploymentCoordinators";
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @UserIdColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "UserId";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 4;
}
/// <summary>
/// Contains schema information about this column.
/// </summary>
public class @ZipCodeColumn {
/// <summary>
/// The name of this column.
/// </summary>
public const string Name = "ZipCode";
/// <summary>
/// The size of this column. For varchars, this is the length of the biggest string that can be stored in this column.
/// </summary>
public const int Size = 20;
}
}
}


namespace ExampleNamespace.DataAccess.CommandConditions {
public interface AdministratorsTableCondition: TableCondition {}
public static class @AdministratorsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AdministratorId: AdministratorsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AdministratorId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "AdministratorId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: AdministratorsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PhoneNumber: AdministratorsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PhoneNumber( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PhoneNumber", new DbParameterValue( value, "VarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PhotoFileCollectionId: AdministratorsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PhotoFileCollectionId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PhotoFileCollectionId", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @AdministratorsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AdministratorId: AdministratorsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @AdministratorId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "AdministratorId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: AdministratorsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UserId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PhoneNumber: AdministratorsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PhoneNumber( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PhoneNumber", new DbParameterValue( value, "VarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PhotoFileCollectionId: AdministratorsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PhotoFileCollectionId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PhotoFileCollectionId", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @AdministratorsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AdministratorId: AdministratorsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AdministratorId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "AdministratorId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: AdministratorsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UserId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PhoneNumber: AdministratorsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PhoneNumber( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PhoneNumber", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PhotoFileCollectionId: AdministratorsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PhotoFileCollectionId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PhotoFileCollectionId", subQuery ); } }
}
}
public static class @AdministratorsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AdministratorId: AdministratorsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AdministratorId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "AdministratorId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: AdministratorsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UserId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PhoneNumber: AdministratorsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PhoneNumber( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PhoneNumber", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PhotoFileCollectionId: AdministratorsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PhotoFileCollectionId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PhotoFileCollectionId", value ); } }
}
}
public interface AdvancedDirectivesHistoryTableCondition: TableCondition {}
public static class @AdvancedDirectivesHistoryTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AdvancedDirectivesHistoryId: AdvancedDirectivesHistoryTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AdvancedDirectivesHistoryId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "AdvancedDirectivesHistoryId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DateAndTime: AdvancedDirectivesHistoryTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DateAndTime( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "DateAndTime", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Iv: AdvancedDirectivesHistoryTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Iv( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Iv", new DbParameterValue( value, "Binary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: AdvancedDirectivesHistoryTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "Binary" ) ) ); } }
}
}
public static class @AdvancedDirectivesHistoryTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AdvancedDirectivesHistoryId: AdvancedDirectivesHistoryTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @AdvancedDirectivesHistoryId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "AdvancedDirectivesHistoryId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DateAndTime: AdvancedDirectivesHistoryTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @DateAndTime( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "DateAndTime", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Iv: AdvancedDirectivesHistoryTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Iv( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Iv", new DbParameterValue( value, "Binary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: AdvancedDirectivesHistoryTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UserId( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "Binary" ) ) ); } }
}
}
public static class @AdvancedDirectivesHistoryTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AdvancedDirectivesHistoryId: AdvancedDirectivesHistoryTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AdvancedDirectivesHistoryId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "AdvancedDirectivesHistoryId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DateAndTime: AdvancedDirectivesHistoryTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DateAndTime( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "DateAndTime", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Iv: AdvancedDirectivesHistoryTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Iv( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Iv", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: AdvancedDirectivesHistoryTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UserId", subQuery ); } }
}
}
public static class @AdvancedDirectivesHistoryTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AdvancedDirectivesHistoryId: AdvancedDirectivesHistoryTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AdvancedDirectivesHistoryId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "AdvancedDirectivesHistoryId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DateAndTime: AdvancedDirectivesHistoryTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DateAndTime( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "DateAndTime", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Iv: AdvancedDirectivesHistoryTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Iv( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Iv", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: AdvancedDirectivesHistoryTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UserId", value ); } }
}
}
public interface AppContentTableCondition: TableCondition {}
public static class @AppContentTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: AppContentTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @_Value: AppContentTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @_Value( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Value", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Instructions: AppContentTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Instructions( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Instructions", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ShowInGeneralList: AppContentTableCondition {
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ShowInGeneralList( System.Boolean value ) {
this.value = value;
}
internal System.Boolean Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ShowInGeneralList", new DbParameterValue( value, "Bit" ) ) ); } }
}
}
public static class @AppContentTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: AppContentTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Name( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @_Value: AppContentTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @_Value( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Value", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Instructions: AppContentTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Instructions( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Instructions", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ShowInGeneralList: AppContentTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ShowInGeneralList( InequalityCondition.Operator op, System.Boolean value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ShowInGeneralList", new DbParameterValue( value, "Bit" ) ) ); } }
}
}
public static class @AppContentTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: AppContentTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Name", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @_Value: AppContentTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @_Value( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Value", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Instructions: AppContentTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Instructions( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Instructions", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ShowInGeneralList: AppContentTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ShowInGeneralList( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ShowInGeneralList", subQuery ); } }
}
}
public static class @AppContentTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: AppContentTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Name", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @_Value: AppContentTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @_Value( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Value", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Instructions: AppContentTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Instructions( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Instructions", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ShowInGeneralList: AppContentTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ShowInGeneralList( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ShowInGeneralList", value ); } }
}
}
public interface AppEnumsTableCondition: TableCondition {}
public static class @AppEnumsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Category: AppEnumsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Category( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Category", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ParamName: AppEnumsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ParamName( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ParamName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ParamValue: AppEnumsTableCondition {
private readonly System.Int32? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ParamValue( System.Int32? value ) {
this.value = value;
}
internal System.Int32? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ParamValue", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @AppEnumsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Category: AppEnumsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Category( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Category", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ParamName: AppEnumsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ParamName( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ParamName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ParamValue: AppEnumsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Int32? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ParamValue( InequalityCondition.Operator op, System.Int32? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ParamValue", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @AppEnumsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Category: AppEnumsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Category( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Category", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ParamName: AppEnumsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ParamName( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ParamName", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ParamValue: AppEnumsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ParamValue( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ParamValue", subQuery ); } }
}
}
public static class @AppEnumsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Category: AppEnumsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Category( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Category", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ParamName: AppEnumsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ParamName( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ParamName", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ParamValue: AppEnumsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ParamValue( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ParamValue", value ); } }
}
}
public interface aspnet_ApplicationsTableCondition: TableCondition {}
public static class @aspnet_ApplicationsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ApplicationName: aspnet_ApplicationsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ApplicationName( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ApplicationName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LoweredApplicationName: aspnet_ApplicationsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LoweredApplicationName( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LoweredApplicationName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ApplicationId: aspnet_ApplicationsTableCondition {
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ApplicationId( System.Guid value ) {
this.value = value;
}
internal System.Guid Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ApplicationId", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Description: aspnet_ApplicationsTableCondition {
private readonly System.String value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Description( System.String value ) {
this.value = value;
}
internal System.String Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Description", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @aspnet_ApplicationsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ApplicationName: aspnet_ApplicationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ApplicationName( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ApplicationName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LoweredApplicationName: aspnet_ApplicationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LoweredApplicationName( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LoweredApplicationName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ApplicationId: aspnet_ApplicationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ApplicationId( InequalityCondition.Operator op, System.Guid value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ApplicationId", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Description: aspnet_ApplicationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.String value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Description( InequalityCondition.Operator op, System.String value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Description", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @aspnet_ApplicationsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ApplicationName: aspnet_ApplicationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ApplicationName( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ApplicationName", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LoweredApplicationName: aspnet_ApplicationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LoweredApplicationName( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LoweredApplicationName", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ApplicationId: aspnet_ApplicationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ApplicationId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ApplicationId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Description: aspnet_ApplicationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Description( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Description", subQuery ); } }
}
}
public static class @aspnet_ApplicationsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ApplicationName: aspnet_ApplicationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ApplicationName( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ApplicationName", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LoweredApplicationName: aspnet_ApplicationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LoweredApplicationName( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LoweredApplicationName", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ApplicationId: aspnet_ApplicationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ApplicationId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ApplicationId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Description: aspnet_ApplicationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Description( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Description", value ); } }
}
}
public interface aspnet_MembershipTableCondition: TableCondition {}
public static class @aspnet_MembershipTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ApplicationId: aspnet_MembershipTableCondition {
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ApplicationId( System.Guid value ) {
this.value = value;
}
internal System.Guid Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ApplicationId", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: aspnet_MembershipTableCondition {
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( System.Guid value ) {
this.value = value;
}
internal System.Guid Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Password: aspnet_MembershipTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Password( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Password", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PasswordFormat: aspnet_MembershipTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PasswordFormat( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PasswordFormat", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PasswordSalt: aspnet_MembershipTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PasswordSalt( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PasswordSalt", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MobilePIN: aspnet_MembershipTableCondition {
private readonly System.String value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MobilePIN( System.String value ) {
this.value = value;
}
internal System.String Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "MobilePIN", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Email: aspnet_MembershipTableCondition {
private readonly System.String value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Email( System.String value ) {
this.value = value;
}
internal System.String Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Email", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LoweredEmail: aspnet_MembershipTableCondition {
private readonly System.String value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LoweredEmail( System.String value ) {
this.value = value;
}
internal System.String Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LoweredEmail", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PasswordQuestion: aspnet_MembershipTableCondition {
private readonly System.String value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PasswordQuestion( System.String value ) {
this.value = value;
}
internal System.String Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PasswordQuestion", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PasswordAnswer: aspnet_MembershipTableCondition {
private readonly System.String value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PasswordAnswer( System.String value ) {
this.value = value;
}
internal System.String Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PasswordAnswer", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsApproved: aspnet_MembershipTableCondition {
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsApproved( System.Boolean value ) {
this.value = value;
}
internal System.Boolean Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "IsApproved", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsLockedOut: aspnet_MembershipTableCondition {
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsLockedOut( System.Boolean value ) {
this.value = value;
}
internal System.Boolean Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "IsLockedOut", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CreateDate: aspnet_MembershipTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @CreateDate( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "CreateDate", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastLoginDate: aspnet_MembershipTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastLoginDate( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LastLoginDate", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastPasswordChangedDate: aspnet_MembershipTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastPasswordChangedDate( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LastPasswordChangedDate", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastLockoutDate: aspnet_MembershipTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastLockoutDate( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LastLockoutDate", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FailedPasswordAttemptCount: aspnet_MembershipTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FailedPasswordAttemptCount( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "FailedPasswordAttemptCount", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FailedPasswordAttemptWindowStart: aspnet_MembershipTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FailedPasswordAttemptWindowStart( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "FailedPasswordAttemptWindowStart", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FailedPasswordAnswerAttemptCount: aspnet_MembershipTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FailedPasswordAnswerAttemptCount( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "FailedPasswordAnswerAttemptCount", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FailedPasswordAnswerAttemptWindowStart: aspnet_MembershipTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FailedPasswordAnswerAttemptWindowStart( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "FailedPasswordAnswerAttemptWindowStart", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Comment: aspnet_MembershipTableCondition {
private readonly System.String value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Comment( System.String value ) {
this.value = value;
}
internal System.String Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Comment", new DbParameterValue( value, "NText" ) ) ); } }
}
}
public static class @aspnet_MembershipTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ApplicationId: aspnet_MembershipTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ApplicationId( InequalityCondition.Operator op, System.Guid value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ApplicationId", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: aspnet_MembershipTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UserId( InequalityCondition.Operator op, System.Guid value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Password: aspnet_MembershipTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Password( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Password", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PasswordFormat: aspnet_MembershipTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PasswordFormat( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PasswordFormat", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PasswordSalt: aspnet_MembershipTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PasswordSalt( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PasswordSalt", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MobilePIN: aspnet_MembershipTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.String value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @MobilePIN( InequalityCondition.Operator op, System.String value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "MobilePIN", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Email: aspnet_MembershipTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.String value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Email( InequalityCondition.Operator op, System.String value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Email", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LoweredEmail: aspnet_MembershipTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.String value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LoweredEmail( InequalityCondition.Operator op, System.String value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LoweredEmail", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PasswordQuestion: aspnet_MembershipTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.String value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PasswordQuestion( InequalityCondition.Operator op, System.String value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PasswordQuestion", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PasswordAnswer: aspnet_MembershipTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.String value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PasswordAnswer( InequalityCondition.Operator op, System.String value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PasswordAnswer", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsApproved: aspnet_MembershipTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @IsApproved( InequalityCondition.Operator op, System.Boolean value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "IsApproved", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsLockedOut: aspnet_MembershipTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @IsLockedOut( InequalityCondition.Operator op, System.Boolean value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "IsLockedOut", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CreateDate: aspnet_MembershipTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @CreateDate( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "CreateDate", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastLoginDate: aspnet_MembershipTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LastLoginDate( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LastLoginDate", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastPasswordChangedDate: aspnet_MembershipTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LastPasswordChangedDate( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LastPasswordChangedDate", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastLockoutDate: aspnet_MembershipTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LastLockoutDate( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LastLockoutDate", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FailedPasswordAttemptCount: aspnet_MembershipTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @FailedPasswordAttemptCount( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "FailedPasswordAttemptCount", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FailedPasswordAttemptWindowStart: aspnet_MembershipTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @FailedPasswordAttemptWindowStart( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "FailedPasswordAttemptWindowStart", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FailedPasswordAnswerAttemptCount: aspnet_MembershipTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @FailedPasswordAnswerAttemptCount( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "FailedPasswordAnswerAttemptCount", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FailedPasswordAnswerAttemptWindowStart: aspnet_MembershipTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @FailedPasswordAnswerAttemptWindowStart( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "FailedPasswordAnswerAttemptWindowStart", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Comment: aspnet_MembershipTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.String value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Comment( InequalityCondition.Operator op, System.String value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Comment", new DbParameterValue( value, "NText" ) ) ); } }
}
}
public static class @aspnet_MembershipTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ApplicationId: aspnet_MembershipTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ApplicationId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ApplicationId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: aspnet_MembershipTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UserId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Password: aspnet_MembershipTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Password( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Password", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PasswordFormat: aspnet_MembershipTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PasswordFormat( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PasswordFormat", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PasswordSalt: aspnet_MembershipTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PasswordSalt( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PasswordSalt", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MobilePIN: aspnet_MembershipTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MobilePIN( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "MobilePIN", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Email: aspnet_MembershipTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Email( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Email", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LoweredEmail: aspnet_MembershipTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LoweredEmail( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LoweredEmail", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PasswordQuestion: aspnet_MembershipTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PasswordQuestion( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PasswordQuestion", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PasswordAnswer: aspnet_MembershipTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PasswordAnswer( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PasswordAnswer", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsApproved: aspnet_MembershipTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsApproved( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "IsApproved", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsLockedOut: aspnet_MembershipTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsLockedOut( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "IsLockedOut", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CreateDate: aspnet_MembershipTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @CreateDate( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "CreateDate", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastLoginDate: aspnet_MembershipTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastLoginDate( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LastLoginDate", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastPasswordChangedDate: aspnet_MembershipTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastPasswordChangedDate( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LastPasswordChangedDate", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastLockoutDate: aspnet_MembershipTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastLockoutDate( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LastLockoutDate", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FailedPasswordAttemptCount: aspnet_MembershipTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FailedPasswordAttemptCount( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "FailedPasswordAttemptCount", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FailedPasswordAttemptWindowStart: aspnet_MembershipTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FailedPasswordAttemptWindowStart( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "FailedPasswordAttemptWindowStart", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FailedPasswordAnswerAttemptCount: aspnet_MembershipTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FailedPasswordAnswerAttemptCount( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "FailedPasswordAnswerAttemptCount", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FailedPasswordAnswerAttemptWindowStart: aspnet_MembershipTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FailedPasswordAnswerAttemptWindowStart( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "FailedPasswordAnswerAttemptWindowStart", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Comment: aspnet_MembershipTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Comment( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Comment", subQuery ); } }
}
}
public static class @aspnet_MembershipTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ApplicationId: aspnet_MembershipTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ApplicationId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ApplicationId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: aspnet_MembershipTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UserId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Password: aspnet_MembershipTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Password( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Password", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PasswordFormat: aspnet_MembershipTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PasswordFormat( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PasswordFormat", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PasswordSalt: aspnet_MembershipTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PasswordSalt( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PasswordSalt", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MobilePIN: aspnet_MembershipTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MobilePIN( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "MobilePIN", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Email: aspnet_MembershipTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Email( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Email", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LoweredEmail: aspnet_MembershipTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LoweredEmail( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LoweredEmail", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PasswordQuestion: aspnet_MembershipTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PasswordQuestion( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PasswordQuestion", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PasswordAnswer: aspnet_MembershipTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PasswordAnswer( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PasswordAnswer", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsApproved: aspnet_MembershipTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsApproved( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "IsApproved", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsLockedOut: aspnet_MembershipTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsLockedOut( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "IsLockedOut", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CreateDate: aspnet_MembershipTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @CreateDate( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "CreateDate", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastLoginDate: aspnet_MembershipTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastLoginDate( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LastLoginDate", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastPasswordChangedDate: aspnet_MembershipTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastPasswordChangedDate( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LastPasswordChangedDate", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastLockoutDate: aspnet_MembershipTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastLockoutDate( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LastLockoutDate", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FailedPasswordAttemptCount: aspnet_MembershipTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FailedPasswordAttemptCount( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "FailedPasswordAttemptCount", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FailedPasswordAttemptWindowStart: aspnet_MembershipTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FailedPasswordAttemptWindowStart( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "FailedPasswordAttemptWindowStart", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FailedPasswordAnswerAttemptCount: aspnet_MembershipTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FailedPasswordAnswerAttemptCount( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "FailedPasswordAnswerAttemptCount", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FailedPasswordAnswerAttemptWindowStart: aspnet_MembershipTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FailedPasswordAnswerAttemptWindowStart( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "FailedPasswordAnswerAttemptWindowStart", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Comment: aspnet_MembershipTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Comment( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Comment", value ); } }
}
}
public interface aspnet_PathsTableCondition: TableCondition {}
public static class @aspnet_PathsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ApplicationId: aspnet_PathsTableCondition {
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ApplicationId( System.Guid value ) {
this.value = value;
}
internal System.Guid Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ApplicationId", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PathId: aspnet_PathsTableCondition {
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PathId( System.Guid value ) {
this.value = value;
}
internal System.Guid Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PathId", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Path: aspnet_PathsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Path( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Path", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LoweredPath: aspnet_PathsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LoweredPath( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LoweredPath", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @aspnet_PathsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ApplicationId: aspnet_PathsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ApplicationId( InequalityCondition.Operator op, System.Guid value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ApplicationId", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PathId: aspnet_PathsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PathId( InequalityCondition.Operator op, System.Guid value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PathId", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Path: aspnet_PathsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Path( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Path", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LoweredPath: aspnet_PathsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LoweredPath( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LoweredPath", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @aspnet_PathsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ApplicationId: aspnet_PathsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ApplicationId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ApplicationId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PathId: aspnet_PathsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PathId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PathId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Path: aspnet_PathsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Path( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Path", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LoweredPath: aspnet_PathsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LoweredPath( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LoweredPath", subQuery ); } }
}
}
public static class @aspnet_PathsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ApplicationId: aspnet_PathsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ApplicationId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ApplicationId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PathId: aspnet_PathsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PathId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PathId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Path: aspnet_PathsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Path( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Path", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LoweredPath: aspnet_PathsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LoweredPath( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LoweredPath", value ); } }
}
}
public interface aspnet_PersonalizationAllUsersTableCondition: TableCondition {}
public static class @aspnet_PersonalizationAllUsersTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PathId: aspnet_PersonalizationAllUsersTableCondition {
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PathId( System.Guid value ) {
this.value = value;
}
internal System.Guid Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PathId", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PageSettings: aspnet_PersonalizationAllUsersTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PageSettings( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PageSettings", new DbParameterValue( value, "Image" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastUpdatedDate: aspnet_PersonalizationAllUsersTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastUpdatedDate( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LastUpdatedDate", new DbParameterValue( value, "DateTime" ) ) ); } }
}
}
public static class @aspnet_PersonalizationAllUsersTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PathId: aspnet_PersonalizationAllUsersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PathId( InequalityCondition.Operator op, System.Guid value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PathId", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PageSettings: aspnet_PersonalizationAllUsersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PageSettings( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PageSettings", new DbParameterValue( value, "Image" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastUpdatedDate: aspnet_PersonalizationAllUsersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LastUpdatedDate( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LastUpdatedDate", new DbParameterValue( value, "DateTime" ) ) ); } }
}
}
public static class @aspnet_PersonalizationAllUsersTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PathId: aspnet_PersonalizationAllUsersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PathId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PathId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PageSettings: aspnet_PersonalizationAllUsersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PageSettings( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PageSettings", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastUpdatedDate: aspnet_PersonalizationAllUsersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastUpdatedDate( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LastUpdatedDate", subQuery ); } }
}
}
public static class @aspnet_PersonalizationAllUsersTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PathId: aspnet_PersonalizationAllUsersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PathId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PathId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PageSettings: aspnet_PersonalizationAllUsersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PageSettings( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PageSettings", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastUpdatedDate: aspnet_PersonalizationAllUsersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastUpdatedDate( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LastUpdatedDate", value ); } }
}
}
public interface aspnet_PersonalizationPerUserTableCondition: TableCondition {}
public static class @aspnet_PersonalizationPerUserTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Id: aspnet_PersonalizationPerUserTableCondition {
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Id( System.Guid value ) {
this.value = value;
}
internal System.Guid Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Id", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PathId: aspnet_PersonalizationPerUserTableCondition {
private readonly System.Guid? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PathId( System.Guid? value ) {
this.value = value;
}
internal System.Guid? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PathId", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: aspnet_PersonalizationPerUserTableCondition {
private readonly System.Guid? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( System.Guid? value ) {
this.value = value;
}
internal System.Guid? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PageSettings: aspnet_PersonalizationPerUserTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PageSettings( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PageSettings", new DbParameterValue( value, "Image" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastUpdatedDate: aspnet_PersonalizationPerUserTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastUpdatedDate( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LastUpdatedDate", new DbParameterValue( value, "DateTime" ) ) ); } }
}
}
public static class @aspnet_PersonalizationPerUserTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Id: aspnet_PersonalizationPerUserTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Id( InequalityCondition.Operator op, System.Guid value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Id", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PathId: aspnet_PersonalizationPerUserTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Guid? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PathId( InequalityCondition.Operator op, System.Guid? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PathId", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: aspnet_PersonalizationPerUserTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Guid? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UserId( InequalityCondition.Operator op, System.Guid? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PageSettings: aspnet_PersonalizationPerUserTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PageSettings( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PageSettings", new DbParameterValue( value, "Image" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastUpdatedDate: aspnet_PersonalizationPerUserTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LastUpdatedDate( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LastUpdatedDate", new DbParameterValue( value, "DateTime" ) ) ); } }
}
}
public static class @aspnet_PersonalizationPerUserTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Id: aspnet_PersonalizationPerUserTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Id( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Id", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PathId: aspnet_PersonalizationPerUserTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PathId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PathId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: aspnet_PersonalizationPerUserTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UserId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PageSettings: aspnet_PersonalizationPerUserTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PageSettings( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PageSettings", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastUpdatedDate: aspnet_PersonalizationPerUserTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastUpdatedDate( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LastUpdatedDate", subQuery ); } }
}
}
public static class @aspnet_PersonalizationPerUserTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Id: aspnet_PersonalizationPerUserTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Id( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Id", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PathId: aspnet_PersonalizationPerUserTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PathId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PathId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: aspnet_PersonalizationPerUserTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UserId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PageSettings: aspnet_PersonalizationPerUserTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PageSettings( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PageSettings", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastUpdatedDate: aspnet_PersonalizationPerUserTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastUpdatedDate( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LastUpdatedDate", value ); } }
}
}
public interface aspnet_ProfileTableCondition: TableCondition {}
public static class @aspnet_ProfileTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: aspnet_ProfileTableCondition {
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( System.Guid value ) {
this.value = value;
}
internal System.Guid Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PropertyNames: aspnet_ProfileTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PropertyNames( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PropertyNames", new DbParameterValue( value, "NText" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PropertyValuesString: aspnet_ProfileTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PropertyValuesString( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PropertyValuesString", new DbParameterValue( value, "NText" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PropertyValuesBinary: aspnet_ProfileTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PropertyValuesBinary( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PropertyValuesBinary", new DbParameterValue( value, "Image" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastUpdatedDate: aspnet_ProfileTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastUpdatedDate( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LastUpdatedDate", new DbParameterValue( value, "DateTime" ) ) ); } }
}
}
public static class @aspnet_ProfileTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: aspnet_ProfileTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UserId( InequalityCondition.Operator op, System.Guid value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PropertyNames: aspnet_ProfileTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PropertyNames( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PropertyNames", new DbParameterValue( value, "NText" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PropertyValuesString: aspnet_ProfileTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PropertyValuesString( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PropertyValuesString", new DbParameterValue( value, "NText" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PropertyValuesBinary: aspnet_ProfileTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PropertyValuesBinary( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PropertyValuesBinary", new DbParameterValue( value, "Image" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastUpdatedDate: aspnet_ProfileTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LastUpdatedDate( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LastUpdatedDate", new DbParameterValue( value, "DateTime" ) ) ); } }
}
}
public static class @aspnet_ProfileTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: aspnet_ProfileTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UserId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PropertyNames: aspnet_ProfileTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PropertyNames( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PropertyNames", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PropertyValuesString: aspnet_ProfileTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PropertyValuesString( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PropertyValuesString", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PropertyValuesBinary: aspnet_ProfileTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PropertyValuesBinary( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PropertyValuesBinary", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastUpdatedDate: aspnet_ProfileTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastUpdatedDate( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LastUpdatedDate", subQuery ); } }
}
}
public static class @aspnet_ProfileTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: aspnet_ProfileTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UserId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PropertyNames: aspnet_ProfileTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PropertyNames( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PropertyNames", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PropertyValuesString: aspnet_ProfileTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PropertyValuesString( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PropertyValuesString", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PropertyValuesBinary: aspnet_ProfileTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PropertyValuesBinary( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PropertyValuesBinary", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastUpdatedDate: aspnet_ProfileTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastUpdatedDate( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LastUpdatedDate", value ); } }
}
}
public interface aspnet_RolesTableCondition: TableCondition {}
public static class @aspnet_RolesTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ApplicationId: aspnet_RolesTableCondition {
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ApplicationId( System.Guid value ) {
this.value = value;
}
internal System.Guid Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ApplicationId", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RoleId: aspnet_RolesTableCondition {
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @RoleId( System.Guid value ) {
this.value = value;
}
internal System.Guid Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "RoleId", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RoleName: aspnet_RolesTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @RoleName( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "RoleName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LoweredRoleName: aspnet_RolesTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LoweredRoleName( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LoweredRoleName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Description: aspnet_RolesTableCondition {
private readonly System.String value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Description( System.String value ) {
this.value = value;
}
internal System.String Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Description", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @aspnet_RolesTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ApplicationId: aspnet_RolesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ApplicationId( InequalityCondition.Operator op, System.Guid value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ApplicationId", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RoleId: aspnet_RolesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @RoleId( InequalityCondition.Operator op, System.Guid value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "RoleId", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RoleName: aspnet_RolesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @RoleName( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "RoleName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LoweredRoleName: aspnet_RolesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LoweredRoleName( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LoweredRoleName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Description: aspnet_RolesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.String value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Description( InequalityCondition.Operator op, System.String value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Description", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @aspnet_RolesTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ApplicationId: aspnet_RolesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ApplicationId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ApplicationId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RoleId: aspnet_RolesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @RoleId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "RoleId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RoleName: aspnet_RolesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @RoleName( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "RoleName", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LoweredRoleName: aspnet_RolesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LoweredRoleName( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LoweredRoleName", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Description: aspnet_RolesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Description( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Description", subQuery ); } }
}
}
public static class @aspnet_RolesTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ApplicationId: aspnet_RolesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ApplicationId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ApplicationId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RoleId: aspnet_RolesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @RoleId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "RoleId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RoleName: aspnet_RolesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @RoleName( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "RoleName", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LoweredRoleName: aspnet_RolesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LoweredRoleName( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LoweredRoleName", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Description: aspnet_RolesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Description( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Description", value ); } }
}
}
public interface aspnet_SchemaVersionsTableCondition: TableCondition {}
public static class @aspnet_SchemaVersionsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Feature: aspnet_SchemaVersionsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Feature( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Feature", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CompatibleSchemaVersion: aspnet_SchemaVersionsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @CompatibleSchemaVersion( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "CompatibleSchemaVersion", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsCurrentVersion: aspnet_SchemaVersionsTableCondition {
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsCurrentVersion( System.Boolean value ) {
this.value = value;
}
internal System.Boolean Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "IsCurrentVersion", new DbParameterValue( value, "Bit" ) ) ); } }
}
}
public static class @aspnet_SchemaVersionsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Feature: aspnet_SchemaVersionsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Feature( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Feature", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CompatibleSchemaVersion: aspnet_SchemaVersionsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @CompatibleSchemaVersion( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "CompatibleSchemaVersion", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsCurrentVersion: aspnet_SchemaVersionsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @IsCurrentVersion( InequalityCondition.Operator op, System.Boolean value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "IsCurrentVersion", new DbParameterValue( value, "Bit" ) ) ); } }
}
}
public static class @aspnet_SchemaVersionsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Feature: aspnet_SchemaVersionsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Feature( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Feature", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CompatibleSchemaVersion: aspnet_SchemaVersionsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @CompatibleSchemaVersion( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "CompatibleSchemaVersion", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsCurrentVersion: aspnet_SchemaVersionsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsCurrentVersion( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "IsCurrentVersion", subQuery ); } }
}
}
public static class @aspnet_SchemaVersionsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Feature: aspnet_SchemaVersionsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Feature( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Feature", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CompatibleSchemaVersion: aspnet_SchemaVersionsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @CompatibleSchemaVersion( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "CompatibleSchemaVersion", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsCurrentVersion: aspnet_SchemaVersionsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsCurrentVersion( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "IsCurrentVersion", value ); } }
}
}
public interface aspnet_UsersTableCondition: TableCondition {}
public static class @aspnet_UsersTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ApplicationId: aspnet_UsersTableCondition {
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ApplicationId( System.Guid value ) {
this.value = value;
}
internal System.Guid Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ApplicationId", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: aspnet_UsersTableCondition {
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( System.Guid value ) {
this.value = value;
}
internal System.Guid Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserName: aspnet_UsersTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserName( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UserName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LoweredUserName: aspnet_UsersTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LoweredUserName( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LoweredUserName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MobileAlias: aspnet_UsersTableCondition {
private readonly System.String value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MobileAlias( System.String value ) {
this.value = value;
}
internal System.String Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "MobileAlias", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsAnonymous: aspnet_UsersTableCondition {
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsAnonymous( System.Boolean value ) {
this.value = value;
}
internal System.Boolean Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "IsAnonymous", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastActivityDate: aspnet_UsersTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastActivityDate( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LastActivityDate", new DbParameterValue( value, "DateTime" ) ) ); } }
}
}
public static class @aspnet_UsersTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ApplicationId: aspnet_UsersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ApplicationId( InequalityCondition.Operator op, System.Guid value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ApplicationId", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: aspnet_UsersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UserId( InequalityCondition.Operator op, System.Guid value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserName: aspnet_UsersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UserName( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UserName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LoweredUserName: aspnet_UsersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LoweredUserName( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LoweredUserName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MobileAlias: aspnet_UsersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.String value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @MobileAlias( InequalityCondition.Operator op, System.String value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "MobileAlias", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsAnonymous: aspnet_UsersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @IsAnonymous( InequalityCondition.Operator op, System.Boolean value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "IsAnonymous", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastActivityDate: aspnet_UsersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LastActivityDate( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LastActivityDate", new DbParameterValue( value, "DateTime" ) ) ); } }
}
}
public static class @aspnet_UsersTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ApplicationId: aspnet_UsersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ApplicationId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ApplicationId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: aspnet_UsersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UserId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserName: aspnet_UsersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserName( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UserName", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LoweredUserName: aspnet_UsersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LoweredUserName( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LoweredUserName", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MobileAlias: aspnet_UsersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MobileAlias( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "MobileAlias", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsAnonymous: aspnet_UsersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsAnonymous( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "IsAnonymous", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastActivityDate: aspnet_UsersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastActivityDate( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LastActivityDate", subQuery ); } }
}
}
public static class @aspnet_UsersTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ApplicationId: aspnet_UsersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ApplicationId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ApplicationId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: aspnet_UsersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UserId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserName: aspnet_UsersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserName( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UserName", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LoweredUserName: aspnet_UsersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LoweredUserName( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LoweredUserName", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MobileAlias: aspnet_UsersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MobileAlias( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "MobileAlias", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsAnonymous: aspnet_UsersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsAnonymous( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "IsAnonymous", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastActivityDate: aspnet_UsersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastActivityDate( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LastActivityDate", value ); } }
}
}
public interface aspnet_UsersInRolesTableCondition: TableCondition {}
public static class @aspnet_UsersInRolesTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: aspnet_UsersInRolesTableCondition {
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( System.Guid value ) {
this.value = value;
}
internal System.Guid Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RoleId: aspnet_UsersInRolesTableCondition {
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @RoleId( System.Guid value ) {
this.value = value;
}
internal System.Guid Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "RoleId", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
}
public static class @aspnet_UsersInRolesTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: aspnet_UsersInRolesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UserId( InequalityCondition.Operator op, System.Guid value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RoleId: aspnet_UsersInRolesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @RoleId( InequalityCondition.Operator op, System.Guid value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "RoleId", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
}
public static class @aspnet_UsersInRolesTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: aspnet_UsersInRolesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UserId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RoleId: aspnet_UsersInRolesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @RoleId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "RoleId", subQuery ); } }
}
}
public static class @aspnet_UsersInRolesTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: aspnet_UsersInRolesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UserId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RoleId: aspnet_UsersInRolesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @RoleId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "RoleId", value ); } }
}
}
public interface aspnet_WebEvent_EventsTableCondition: TableCondition {}
public static class @aspnet_WebEvent_EventsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventId: aspnet_WebEvent_EventsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventId( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EventId", new DbParameterValue( value, "Char" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventTimeUtc: aspnet_WebEvent_EventsTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventTimeUtc( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EventTimeUtc", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventTime: aspnet_WebEvent_EventsTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventTime( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EventTime", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventType: aspnet_WebEvent_EventsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventType( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EventType", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventSequence: aspnet_WebEvent_EventsTableCondition {
private readonly decimal value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventSequence( decimal value ) {
this.value = value;
}
internal decimal Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EventSequence", new DbParameterValue( value, "Decimal" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventOccurrence: aspnet_WebEvent_EventsTableCondition {
private readonly decimal value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventOccurrence( decimal value ) {
this.value = value;
}
internal decimal Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EventOccurrence", new DbParameterValue( value, "Decimal" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventCode: aspnet_WebEvent_EventsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventCode( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EventCode", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventDetailCode: aspnet_WebEvent_EventsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventDetailCode( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EventDetailCode", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Message: aspnet_WebEvent_EventsTableCondition {
private readonly System.String value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Message( System.String value ) {
this.value = value;
}
internal System.String Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Message", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ApplicationPath: aspnet_WebEvent_EventsTableCondition {
private readonly System.String value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ApplicationPath( System.String value ) {
this.value = value;
}
internal System.String Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ApplicationPath", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ApplicationVirtualPath: aspnet_WebEvent_EventsTableCondition {
private readonly System.String value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ApplicationVirtualPath( System.String value ) {
this.value = value;
}
internal System.String Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ApplicationVirtualPath", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MachineName: aspnet_WebEvent_EventsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MachineName( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "MachineName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RequestUrl: aspnet_WebEvent_EventsTableCondition {
private readonly System.String value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @RequestUrl( System.String value ) {
this.value = value;
}
internal System.String Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "RequestUrl", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ExceptionType: aspnet_WebEvent_EventsTableCondition {
private readonly System.String value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ExceptionType( System.String value ) {
this.value = value;
}
internal System.String Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ExceptionType", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Details: aspnet_WebEvent_EventsTableCondition {
private readonly System.String value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Details( System.String value ) {
this.value = value;
}
internal System.String Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Details", new DbParameterValue( value, "NText" ) ) ); } }
}
}
public static class @aspnet_WebEvent_EventsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventId: aspnet_WebEvent_EventsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EventId( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EventId", new DbParameterValue( value, "Char" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventTimeUtc: aspnet_WebEvent_EventsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EventTimeUtc( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EventTimeUtc", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventTime: aspnet_WebEvent_EventsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EventTime( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EventTime", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventType: aspnet_WebEvent_EventsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EventType( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EventType", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventSequence: aspnet_WebEvent_EventsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly decimal value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EventSequence( InequalityCondition.Operator op, decimal value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EventSequence", new DbParameterValue( value, "Decimal" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventOccurrence: aspnet_WebEvent_EventsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly decimal value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EventOccurrence( InequalityCondition.Operator op, decimal value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EventOccurrence", new DbParameterValue( value, "Decimal" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventCode: aspnet_WebEvent_EventsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EventCode( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EventCode", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventDetailCode: aspnet_WebEvent_EventsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EventDetailCode( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EventDetailCode", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Message: aspnet_WebEvent_EventsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.String value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Message( InequalityCondition.Operator op, System.String value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Message", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ApplicationPath: aspnet_WebEvent_EventsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.String value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ApplicationPath( InequalityCondition.Operator op, System.String value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ApplicationPath", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ApplicationVirtualPath: aspnet_WebEvent_EventsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.String value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ApplicationVirtualPath( InequalityCondition.Operator op, System.String value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ApplicationVirtualPath", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MachineName: aspnet_WebEvent_EventsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @MachineName( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "MachineName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RequestUrl: aspnet_WebEvent_EventsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.String value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @RequestUrl( InequalityCondition.Operator op, System.String value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "RequestUrl", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ExceptionType: aspnet_WebEvent_EventsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.String value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ExceptionType( InequalityCondition.Operator op, System.String value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ExceptionType", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Details: aspnet_WebEvent_EventsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.String value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Details( InequalityCondition.Operator op, System.String value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Details", new DbParameterValue( value, "NText" ) ) ); } }
}
}
public static class @aspnet_WebEvent_EventsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventId: aspnet_WebEvent_EventsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EventId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventTimeUtc: aspnet_WebEvent_EventsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventTimeUtc( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EventTimeUtc", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventTime: aspnet_WebEvent_EventsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventTime( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EventTime", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventType: aspnet_WebEvent_EventsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventType( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EventType", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventSequence: aspnet_WebEvent_EventsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventSequence( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EventSequence", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventOccurrence: aspnet_WebEvent_EventsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventOccurrence( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EventOccurrence", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventCode: aspnet_WebEvent_EventsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventCode( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EventCode", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventDetailCode: aspnet_WebEvent_EventsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventDetailCode( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EventDetailCode", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Message: aspnet_WebEvent_EventsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Message( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Message", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ApplicationPath: aspnet_WebEvent_EventsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ApplicationPath( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ApplicationPath", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ApplicationVirtualPath: aspnet_WebEvent_EventsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ApplicationVirtualPath( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ApplicationVirtualPath", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MachineName: aspnet_WebEvent_EventsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MachineName( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "MachineName", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RequestUrl: aspnet_WebEvent_EventsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @RequestUrl( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "RequestUrl", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ExceptionType: aspnet_WebEvent_EventsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ExceptionType( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ExceptionType", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Details: aspnet_WebEvent_EventsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Details( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Details", subQuery ); } }
}
}
public static class @aspnet_WebEvent_EventsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventId: aspnet_WebEvent_EventsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EventId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventTimeUtc: aspnet_WebEvent_EventsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventTimeUtc( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EventTimeUtc", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventTime: aspnet_WebEvent_EventsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventTime( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EventTime", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventType: aspnet_WebEvent_EventsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventType( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EventType", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventSequence: aspnet_WebEvent_EventsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventSequence( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EventSequence", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventOccurrence: aspnet_WebEvent_EventsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventOccurrence( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EventOccurrence", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventCode: aspnet_WebEvent_EventsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventCode( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EventCode", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventDetailCode: aspnet_WebEvent_EventsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventDetailCode( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EventDetailCode", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Message: aspnet_WebEvent_EventsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Message( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Message", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ApplicationPath: aspnet_WebEvent_EventsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ApplicationPath( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ApplicationPath", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ApplicationVirtualPath: aspnet_WebEvent_EventsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ApplicationVirtualPath( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ApplicationVirtualPath", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MachineName: aspnet_WebEvent_EventsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MachineName( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "MachineName", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RequestUrl: aspnet_WebEvent_EventsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @RequestUrl( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "RequestUrl", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ExceptionType: aspnet_WebEvent_EventsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ExceptionType( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ExceptionType", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Details: aspnet_WebEvent_EventsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Details( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Details", value ); } }
}
}
public interface BackgroundNotifierLogsTableCondition: TableCondition {}
public static class @BackgroundNotifierLogsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @BackgroundNotifierLogId: BackgroundNotifierLogsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @BackgroundNotifierLogId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "BackgroundNotifierLogId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: BackgroundNotifierLogsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsError: BackgroundNotifierLogsTableCondition {
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsError( System.Boolean value ) {
this.value = value;
}
internal System.Boolean Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "IsError", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Details: BackgroundNotifierLogsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Details( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Details", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SentDateTimeUtc: BackgroundNotifierLogsTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SentDateTimeUtc( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "SentDateTimeUtc", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
}
public static class @BackgroundNotifierLogsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @BackgroundNotifierLogId: BackgroundNotifierLogsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @BackgroundNotifierLogId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "BackgroundNotifierLogId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: BackgroundNotifierLogsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UserId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsError: BackgroundNotifierLogsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @IsError( InequalityCondition.Operator op, System.Boolean value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "IsError", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Details: BackgroundNotifierLogsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Details( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Details", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SentDateTimeUtc: BackgroundNotifierLogsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @SentDateTimeUtc( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "SentDateTimeUtc", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
}
public static class @BackgroundNotifierLogsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @BackgroundNotifierLogId: BackgroundNotifierLogsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @BackgroundNotifierLogId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "BackgroundNotifierLogId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: BackgroundNotifierLogsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UserId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsError: BackgroundNotifierLogsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsError( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "IsError", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Details: BackgroundNotifierLogsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Details( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Details", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SentDateTimeUtc: BackgroundNotifierLogsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SentDateTimeUtc( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "SentDateTimeUtc", subQuery ); } }
}
}
public static class @BackgroundNotifierLogsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @BackgroundNotifierLogId: BackgroundNotifierLogsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @BackgroundNotifierLogId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "BackgroundNotifierLogId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: BackgroundNotifierLogsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UserId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsError: BackgroundNotifierLogsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsError( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "IsError", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Details: BackgroundNotifierLogsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Details( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Details", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SentDateTimeUtc: BackgroundNotifierLogsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SentDateTimeUtc( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "SentDateTimeUtc", value ); } }
}
}
public interface CareZonesTableCondition: TableCondition {}
public static class @CareZonesTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CareZoneId: CareZonesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @CareZoneId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "CareZoneId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: CareZonesTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @CareZonesTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CareZoneId: CareZonesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @CareZoneId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "CareZoneId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: CareZonesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Name( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @CareZonesTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CareZoneId: CareZonesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @CareZoneId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "CareZoneId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: CareZonesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Name", subQuery ); } }
}
}
public static class @CareZonesTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CareZoneId: CareZonesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @CareZoneId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "CareZoneId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: CareZonesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Name", value ); } }
}
}
public interface CareZonesToWorkGroupsTableCondition: TableCondition {}
public static class @CareZonesToWorkGroupsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CareZoneToWorkGroupId: CareZonesToWorkGroupsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @CareZoneToWorkGroupId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "CareZoneToWorkGroupId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CareZoneId: CareZonesToWorkGroupsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @CareZoneId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "CareZoneId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkGroupId: CareZonesToWorkGroupsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @WorkGroupId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "WorkGroupId", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @CareZonesToWorkGroupsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CareZoneToWorkGroupId: CareZonesToWorkGroupsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @CareZoneToWorkGroupId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "CareZoneToWorkGroupId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CareZoneId: CareZonesToWorkGroupsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @CareZoneId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "CareZoneId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkGroupId: CareZonesToWorkGroupsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @WorkGroupId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "WorkGroupId", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @CareZonesToWorkGroupsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CareZoneToWorkGroupId: CareZonesToWorkGroupsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @CareZoneToWorkGroupId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "CareZoneToWorkGroupId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CareZoneId: CareZonesToWorkGroupsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @CareZoneId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "CareZoneId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkGroupId: CareZonesToWorkGroupsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @WorkGroupId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "WorkGroupId", subQuery ); } }
}
}
public static class @CareZonesToWorkGroupsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CareZoneToWorkGroupId: CareZonesToWorkGroupsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @CareZoneToWorkGroupId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "CareZoneToWorkGroupId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CareZoneId: CareZonesToWorkGroupsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @CareZoneId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "CareZoneId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkGroupId: CareZonesToWorkGroupsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @WorkGroupId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "WorkGroupId", value ); } }
}
}
public interface ClinicianPatientsTableCondition: TableCondition {}
public static class @ClinicianPatientsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ClinicianPatientId: ClinicianPatientsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ClinicianPatientId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ClinicianPatientId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncryptionKeyVersion: ClinicianPatientsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncryptionKeyVersion( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EncryptionKeyVersion", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncryptionIv: ClinicianPatientsTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncryptionIv( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EncryptionIv", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ClinicianId: ClinicianPatientsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ClinicianId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ClinicianId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientInfoId: ClinicianPatientsTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PatientInfoId( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PatientInfoId", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
}
public static class @ClinicianPatientsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ClinicianPatientId: ClinicianPatientsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ClinicianPatientId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ClinicianPatientId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncryptionKeyVersion: ClinicianPatientsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EncryptionKeyVersion( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EncryptionKeyVersion", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncryptionIv: ClinicianPatientsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EncryptionIv( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EncryptionIv", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ClinicianId: ClinicianPatientsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ClinicianId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ClinicianId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientInfoId: ClinicianPatientsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PatientInfoId( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PatientInfoId", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
}
public static class @ClinicianPatientsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ClinicianPatientId: ClinicianPatientsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ClinicianPatientId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ClinicianPatientId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncryptionKeyVersion: ClinicianPatientsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncryptionKeyVersion( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EncryptionKeyVersion", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncryptionIv: ClinicianPatientsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncryptionIv( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EncryptionIv", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ClinicianId: ClinicianPatientsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ClinicianId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ClinicianId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientInfoId: ClinicianPatientsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PatientInfoId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PatientInfoId", subQuery ); } }
}
}
public static class @ClinicianPatientsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ClinicianPatientId: ClinicianPatientsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ClinicianPatientId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ClinicianPatientId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncryptionKeyVersion: ClinicianPatientsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncryptionKeyVersion( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EncryptionKeyVersion", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncryptionIv: ClinicianPatientsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncryptionIv( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EncryptionIv", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ClinicianId: ClinicianPatientsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ClinicianId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ClinicianId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientInfoId: ClinicianPatientsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PatientInfoId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PatientInfoId", value ); } }
}
}
public interface CliniciansTableCondition: TableCondition {}
public static class @CliniciansTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ClinicianId: CliniciansTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ClinicianId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ClinicianId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FirstName: CliniciansTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FirstName( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "FirstName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastName: CliniciansTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastName( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LastName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkGroupId: CliniciansTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @WorkGroupId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "WorkGroupId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: CliniciansTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @CliniciansTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ClinicianId: CliniciansTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ClinicianId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ClinicianId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FirstName: CliniciansTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @FirstName( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "FirstName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastName: CliniciansTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LastName( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LastName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkGroupId: CliniciansTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @WorkGroupId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "WorkGroupId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: CliniciansTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UserId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @CliniciansTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ClinicianId: CliniciansTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ClinicianId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ClinicianId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FirstName: CliniciansTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FirstName( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "FirstName", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastName: CliniciansTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastName( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LastName", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkGroupId: CliniciansTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @WorkGroupId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "WorkGroupId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: CliniciansTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UserId", subQuery ); } }
}
}
public static class @CliniciansTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ClinicianId: CliniciansTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ClinicianId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ClinicianId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FirstName: CliniciansTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FirstName( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "FirstName", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastName: CliniciansTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastName( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LastName", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkGroupId: CliniciansTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @WorkGroupId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "WorkGroupId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: CliniciansTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UserId", value ); } }
}
}
public interface CompletedCoursesTableCondition: TableCondition {}
public static class @CompletedCoursesTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CompletedCourseId: CompletedCoursesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @CompletedCourseId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "CompletedCourseId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TrainingCourseId: CompletedCoursesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TrainingCourseId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "TrainingCourseId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @StartDateTime: CompletedCoursesTableCondition {
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @StartDateTime( System.DateTime? value ) {
this.value = value;
}
internal System.DateTime? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "StartDateTime", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FinishedDateTime: CompletedCoursesTableCondition {
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FinishedDateTime( System.DateTime? value ) {
this.value = value;
}
internal System.DateTime? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "FinishedDateTime", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: CompletedCoursesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @CompletedCoursesTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CompletedCourseId: CompletedCoursesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @CompletedCourseId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "CompletedCourseId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TrainingCourseId: CompletedCoursesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @TrainingCourseId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "TrainingCourseId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @StartDateTime: CompletedCoursesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @StartDateTime( InequalityCondition.Operator op, System.DateTime? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "StartDateTime", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FinishedDateTime: CompletedCoursesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @FinishedDateTime( InequalityCondition.Operator op, System.DateTime? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "FinishedDateTime", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: CompletedCoursesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UserId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @CompletedCoursesTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CompletedCourseId: CompletedCoursesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @CompletedCourseId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "CompletedCourseId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TrainingCourseId: CompletedCoursesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TrainingCourseId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "TrainingCourseId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @StartDateTime: CompletedCoursesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @StartDateTime( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "StartDateTime", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FinishedDateTime: CompletedCoursesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FinishedDateTime( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "FinishedDateTime", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: CompletedCoursesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UserId", subQuery ); } }
}
}
public static class @CompletedCoursesTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CompletedCourseId: CompletedCoursesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @CompletedCourseId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "CompletedCourseId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TrainingCourseId: CompletedCoursesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TrainingCourseId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "TrainingCourseId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @StartDateTime: CompletedCoursesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @StartDateTime( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "StartDateTime", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FinishedDateTime: CompletedCoursesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FinishedDateTime( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "FinishedDateTime", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: CompletedCoursesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UserId", value ); } }
}
}
public interface ConsentTypesTableCondition: TableCondition {}
public static class @ConsentTypesTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ConsentTypeId: ConsentTypesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ConsentTypeId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ConsentTypeId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: ConsentTypesTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "VarChar" ) ) ); } }
}
}
public static class @ConsentTypesTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ConsentTypeId: ConsentTypesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ConsentTypeId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ConsentTypeId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: ConsentTypesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Name( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "VarChar" ) ) ); } }
}
}
public static class @ConsentTypesTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ConsentTypeId: ConsentTypesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ConsentTypeId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ConsentTypeId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: ConsentTypesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Name", subQuery ); } }
}
}
public static class @ConsentTypesTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ConsentTypeId: ConsentTypesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ConsentTypeId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ConsentTypeId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: ConsentTypesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Name", value ); } }
}
}
public interface ContentTableCondition: TableCondition {}
public static class @ContentTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ContentId: ContentTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ContentId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ContentId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Text: ContentTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Text( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Text", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HtmlBlockId: ContentTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @HtmlBlockId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "HtmlBlockId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @OrderRankId: ContentTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @OrderRankId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "OrderRankId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ContentTabId: ContentTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ContentTabId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ContentTabId", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @ContentTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ContentId: ContentTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ContentId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ContentId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Text: ContentTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Text( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Text", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HtmlBlockId: ContentTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @HtmlBlockId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "HtmlBlockId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @OrderRankId: ContentTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @OrderRankId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "OrderRankId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ContentTabId: ContentTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ContentTabId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ContentTabId", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @ContentTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ContentId: ContentTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ContentId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ContentId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Text: ContentTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Text( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Text", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HtmlBlockId: ContentTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @HtmlBlockId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "HtmlBlockId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @OrderRankId: ContentTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @OrderRankId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "OrderRankId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ContentTabId: ContentTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ContentTabId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ContentTabId", subQuery ); } }
}
}
public static class @ContentTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ContentId: ContentTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ContentId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ContentId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Text: ContentTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Text( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Text", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HtmlBlockId: ContentTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @HtmlBlockId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "HtmlBlockId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @OrderRankId: ContentTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @OrderRankId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "OrderRankId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ContentTabId: ContentTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ContentTabId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ContentTabId", value ); } }
}
}
public interface ContentTabsTableCondition: TableCondition {}
public static class @ContentTabsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ContentTabId: ContentTabsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ContentTabId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ContentTabId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: ContentTabsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "VarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HasProviderPortalTab: ContentTabsTableCondition {
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @HasProviderPortalTab( System.Boolean value ) {
this.value = value;
}
internal System.Boolean Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "HasProviderPortalTab", new DbParameterValue( value, "Bit" ) ) ); } }
}
}
public static class @ContentTabsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ContentTabId: ContentTabsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ContentTabId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ContentTabId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: ContentTabsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Name( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "VarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HasProviderPortalTab: ContentTabsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @HasProviderPortalTab( InequalityCondition.Operator op, System.Boolean value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "HasProviderPortalTab", new DbParameterValue( value, "Bit" ) ) ); } }
}
}
public static class @ContentTabsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ContentTabId: ContentTabsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ContentTabId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ContentTabId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: ContentTabsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Name", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HasProviderPortalTab: ContentTabsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @HasProviderPortalTab( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "HasProviderPortalTab", subQuery ); } }
}
}
public static class @ContentTabsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ContentTabId: ContentTabsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ContentTabId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ContentTabId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: ContentTabsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Name", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HasProviderPortalTab: ContentTabsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @HasProviderPortalTab( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "HasProviderPortalTab", value ); } }
}
}
public interface DirectAccessLogsTableCondition: TableCondition {}
public static class @DirectAccessLogsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DirectAccessLogs: DirectAccessLogsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DirectAccessLogs( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "DirectAccessLogs", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: DirectAccessLogsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DateTimeUtc: DirectAccessLogsTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DateTimeUtc( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "DateTimeUtc", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
}
public static class @DirectAccessLogsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DirectAccessLogs: DirectAccessLogsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @DirectAccessLogs( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "DirectAccessLogs", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: DirectAccessLogsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UserId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DateTimeUtc: DirectAccessLogsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @DateTimeUtc( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "DateTimeUtc", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
}
public static class @DirectAccessLogsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DirectAccessLogs: DirectAccessLogsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DirectAccessLogs( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "DirectAccessLogs", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: DirectAccessLogsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UserId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DateTimeUtc: DirectAccessLogsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DateTimeUtc( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "DateTimeUtc", subQuery ); } }
}
}
public static class @DirectAccessLogsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DirectAccessLogs: DirectAccessLogsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DirectAccessLogs( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "DirectAccessLogs", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: DirectAccessLogsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UserId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DateTimeUtc: DirectAccessLogsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DateTimeUtc( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "DateTimeUtc", value ); } }
}
}
public interface EmailTemplatesTableCondition: TableCondition {}
public static class @EmailTemplatesTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EmailTemplateId: EmailTemplatesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EmailTemplateId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EmailTemplateId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: EmailTemplatesTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Subject: EmailTemplatesTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Subject( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Subject", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HtmlBlockId: EmailTemplatesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @HtmlBlockId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "HtmlBlockId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RoleId: EmailTemplatesTableCondition {
private readonly System.Int32? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @RoleId( System.Int32? value ) {
this.value = value;
}
internal System.Int32? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "RoleId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EmailTemplateTypeId: EmailTemplatesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EmailTemplateTypeId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EmailTemplateTypeId", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @EmailTemplatesTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EmailTemplateId: EmailTemplatesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EmailTemplateId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EmailTemplateId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: EmailTemplatesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Name( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Subject: EmailTemplatesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Subject( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Subject", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HtmlBlockId: EmailTemplatesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @HtmlBlockId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "HtmlBlockId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RoleId: EmailTemplatesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Int32? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @RoleId( InequalityCondition.Operator op, System.Int32? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "RoleId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EmailTemplateTypeId: EmailTemplatesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EmailTemplateTypeId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EmailTemplateTypeId", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @EmailTemplatesTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EmailTemplateId: EmailTemplatesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EmailTemplateId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EmailTemplateId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: EmailTemplatesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Name", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Subject: EmailTemplatesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Subject( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Subject", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HtmlBlockId: EmailTemplatesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @HtmlBlockId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "HtmlBlockId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RoleId: EmailTemplatesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @RoleId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "RoleId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EmailTemplateTypeId: EmailTemplatesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EmailTemplateTypeId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EmailTemplateTypeId", subQuery ); } }
}
}
public static class @EmailTemplatesTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EmailTemplateId: EmailTemplatesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EmailTemplateId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EmailTemplateId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: EmailTemplatesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Name", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Subject: EmailTemplatesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Subject( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Subject", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HtmlBlockId: EmailTemplatesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @HtmlBlockId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "HtmlBlockId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RoleId: EmailTemplatesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @RoleId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "RoleId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EmailTemplateTypeId: EmailTemplatesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EmailTemplateTypeId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EmailTemplateTypeId", value ); } }
}
}
public interface EmailTemplateTypesTableCondition: TableCondition {}
public static class @EmailTemplateTypesTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EmailTemplateTypeId: EmailTemplateTypesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EmailTemplateTypeId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EmailTemplateTypeId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: EmailTemplateTypesTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @EmailTemplateTypesTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EmailTemplateTypeId: EmailTemplateTypesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EmailTemplateTypeId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EmailTemplateTypeId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: EmailTemplateTypesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Name( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @EmailTemplateTypesTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EmailTemplateTypeId: EmailTemplateTypesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EmailTemplateTypeId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EmailTemplateTypeId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: EmailTemplateTypesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Name", subQuery ); } }
}
}
public static class @EmailTemplateTypesTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EmailTemplateTypeId: EmailTemplateTypesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EmailTemplateTypeId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EmailTemplateTypeId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: EmailTemplateTypesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Name", value ); } }
}
}
public interface EventLogTableCondition: TableCondition {}
public static class @EventLogTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventID: EventLogTableCondition {
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventID( System.Guid value ) {
this.value = value;
}
internal System.Guid Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EventID", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventTime: EventLogTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventTime( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EventTime", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Category: EventLogTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Category( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Category", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SubCategory: EventLogTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SubCategory( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "SubCategory", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ErrorLevel: EventLogTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ErrorLevel( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ErrorLevel", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventCode: EventLogTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventCode( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EventCode", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncKV: EventLogTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncKV( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EncKV", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncIV: EventLogTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncIV( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EncIV", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserID: EventLogTableCondition {
private readonly System.Guid? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserID( System.Guid? value ) {
this.value = value;
}
internal System.Guid? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UserID", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserType: EventLogTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserType( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UserType", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IPAddress: EventLogTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IPAddress( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "IPAddress", new DbParameterValue( value, "VarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventSummary: EventLogTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventSummary( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EventSummary", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventURL: EventLogTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventURL( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EventURL", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AdditionalData: EventLogTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AdditionalData( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "AdditionalData", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ProtectedData: EventLogTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ProtectedData( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ProtectedData", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AccessReasonCode: EventLogTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AccessReasonCode( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "AccessReasonCode", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AccessReasonText: EventLogTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AccessReasonText( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "AccessReasonText", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AccessScope: EventLogTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AccessScope( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "AccessScope", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AccessType: EventLogTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AccessType( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "AccessType", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ReviewStatus: EventLogTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ReviewStatus( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ReviewStatus", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SuggestedAction: EventLogTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SuggestedAction( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "SuggestedAction", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ReviewedBy: EventLogTableCondition {
private readonly System.Guid? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ReviewedBy( System.Guid? value ) {
this.value = value;
}
internal System.Guid? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ReviewedBy", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ReviewDate: EventLogTableCondition {
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ReviewDate( System.DateTime? value ) {
this.value = value;
}
internal System.DateTime? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ReviewDate", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ReviewSummary: EventLogTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ReviewSummary( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ReviewSummary", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @EventLogTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventID: EventLogTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EventID( InequalityCondition.Operator op, System.Guid value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EventID", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventTime: EventLogTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EventTime( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EventTime", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Category: EventLogTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Category( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Category", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SubCategory: EventLogTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @SubCategory( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "SubCategory", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ErrorLevel: EventLogTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ErrorLevel( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ErrorLevel", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventCode: EventLogTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EventCode( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EventCode", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncKV: EventLogTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EncKV( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EncKV", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncIV: EventLogTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EncIV( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EncIV", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserID: EventLogTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Guid? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UserID( InequalityCondition.Operator op, System.Guid? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UserID", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserType: EventLogTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UserType( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UserType", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IPAddress: EventLogTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @IPAddress( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "IPAddress", new DbParameterValue( value, "VarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventSummary: EventLogTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EventSummary( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EventSummary", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventURL: EventLogTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EventURL( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EventURL", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AdditionalData: EventLogTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @AdditionalData( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "AdditionalData", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ProtectedData: EventLogTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ProtectedData( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ProtectedData", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AccessReasonCode: EventLogTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @AccessReasonCode( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "AccessReasonCode", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AccessReasonText: EventLogTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @AccessReasonText( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "AccessReasonText", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AccessScope: EventLogTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @AccessScope( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "AccessScope", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AccessType: EventLogTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @AccessType( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "AccessType", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ReviewStatus: EventLogTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ReviewStatus( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ReviewStatus", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SuggestedAction: EventLogTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @SuggestedAction( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "SuggestedAction", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ReviewedBy: EventLogTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Guid? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ReviewedBy( InequalityCondition.Operator op, System.Guid? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ReviewedBy", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ReviewDate: EventLogTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ReviewDate( InequalityCondition.Operator op, System.DateTime? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ReviewDate", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ReviewSummary: EventLogTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ReviewSummary( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ReviewSummary", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @EventLogTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventID: EventLogTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventID( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EventID", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventTime: EventLogTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventTime( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EventTime", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Category: EventLogTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Category( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Category", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SubCategory: EventLogTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SubCategory( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "SubCategory", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ErrorLevel: EventLogTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ErrorLevel( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ErrorLevel", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventCode: EventLogTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventCode( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EventCode", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncKV: EventLogTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncKV( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EncKV", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncIV: EventLogTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncIV( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EncIV", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserID: EventLogTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserID( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UserID", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserType: EventLogTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserType( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UserType", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IPAddress: EventLogTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IPAddress( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "IPAddress", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventSummary: EventLogTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventSummary( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EventSummary", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventURL: EventLogTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventURL( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EventURL", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AdditionalData: EventLogTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AdditionalData( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "AdditionalData", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ProtectedData: EventLogTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ProtectedData( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ProtectedData", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AccessReasonCode: EventLogTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AccessReasonCode( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "AccessReasonCode", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AccessReasonText: EventLogTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AccessReasonText( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "AccessReasonText", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AccessScope: EventLogTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AccessScope( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "AccessScope", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AccessType: EventLogTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AccessType( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "AccessType", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ReviewStatus: EventLogTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ReviewStatus( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ReviewStatus", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SuggestedAction: EventLogTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SuggestedAction( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "SuggestedAction", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ReviewedBy: EventLogTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ReviewedBy( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ReviewedBy", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ReviewDate: EventLogTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ReviewDate( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ReviewDate", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ReviewSummary: EventLogTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ReviewSummary( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ReviewSummary", subQuery ); } }
}
}
public static class @EventLogTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventID: EventLogTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventID( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EventID", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventTime: EventLogTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventTime( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EventTime", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Category: EventLogTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Category( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Category", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SubCategory: EventLogTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SubCategory( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "SubCategory", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ErrorLevel: EventLogTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ErrorLevel( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ErrorLevel", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventCode: EventLogTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventCode( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EventCode", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncKV: EventLogTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncKV( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EncKV", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncIV: EventLogTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncIV( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EncIV", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserID: EventLogTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserID( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UserID", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserType: EventLogTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserType( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UserType", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IPAddress: EventLogTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IPAddress( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "IPAddress", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventSummary: EventLogTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventSummary( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EventSummary", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventURL: EventLogTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventURL( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EventURL", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AdditionalData: EventLogTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AdditionalData( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "AdditionalData", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ProtectedData: EventLogTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ProtectedData( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ProtectedData", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AccessReasonCode: EventLogTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AccessReasonCode( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "AccessReasonCode", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AccessReasonText: EventLogTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AccessReasonText( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "AccessReasonText", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AccessScope: EventLogTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AccessScope( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "AccessScope", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AccessType: EventLogTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AccessType( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "AccessType", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ReviewStatus: EventLogTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ReviewStatus( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ReviewStatus", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SuggestedAction: EventLogTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SuggestedAction( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "SuggestedAction", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ReviewedBy: EventLogTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ReviewedBy( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ReviewedBy", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ReviewDate: EventLogTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ReviewDate( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ReviewDate", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ReviewSummary: EventLogTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ReviewSummary( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ReviewSummary", value ); } }
}
}
public interface FileCollectionsTableCondition: TableCondition {}
public static class @FileCollectionsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileCollectionId: FileCollectionsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FileCollectionId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "FileCollectionId", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @FileCollectionsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileCollectionId: FileCollectionsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @FileCollectionId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "FileCollectionId", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @FileCollectionsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileCollectionId: FileCollectionsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FileCollectionId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "FileCollectionId", subQuery ); } }
}
}
public static class @FileCollectionsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileCollectionId: FileCollectionsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FileCollectionId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "FileCollectionId", value ); } }
}
}
public interface FilesTableCondition: TableCondition {}
public static class @FilesTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileId: FilesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FileId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "FileId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileCollectionId: FilesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FileCollectionId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "FileCollectionId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileName: FilesTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FileName( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "FileName", new DbParameterValue( value, "VarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ContentType: FilesTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ContentType( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ContentType", new DbParameterValue( value, "VarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Contents: FilesTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Contents( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Contents", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UploadedDate: FilesTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UploadedDate( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UploadedDate", new DbParameterValue( value, "SmallDateTime" ) ) ); } }
}
}
public static class @FilesTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileId: FilesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @FileId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "FileId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileCollectionId: FilesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @FileCollectionId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "FileCollectionId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileName: FilesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @FileName( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "FileName", new DbParameterValue( value, "VarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ContentType: FilesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ContentType( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ContentType", new DbParameterValue( value, "VarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Contents: FilesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Contents( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Contents", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UploadedDate: FilesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UploadedDate( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UploadedDate", new DbParameterValue( value, "SmallDateTime" ) ) ); } }
}
}
public static class @FilesTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileId: FilesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FileId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "FileId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileCollectionId: FilesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FileCollectionId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "FileCollectionId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileName: FilesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FileName( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "FileName", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ContentType: FilesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ContentType( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ContentType", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Contents: FilesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Contents( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Contents", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UploadedDate: FilesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UploadedDate( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UploadedDate", subQuery ); } }
}
}
public static class @FilesTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileId: FilesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FileId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "FileId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileCollectionId: FilesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FileCollectionId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "FileCollectionId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileName: FilesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FileName( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "FileName", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ContentType: FilesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ContentType( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ContentType", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Contents: FilesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Contents( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Contents", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UploadedDate: FilesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UploadedDate( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UploadedDate", value ); } }
}
}
public interface FormInputsTableCondition: TableCondition {}
public static class @FormInputsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormInputId: FormInputsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FormInputId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "FormInputId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormId: FormInputsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FormId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "FormId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @InputName: FormInputsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @InputName( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "InputName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Label: FormInputsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Label( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Label", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @FormInputsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormInputId: FormInputsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @FormInputId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "FormInputId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormId: FormInputsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @FormId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "FormId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @InputName: FormInputsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @InputName( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "InputName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Label: FormInputsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Label( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Label", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @FormInputsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormInputId: FormInputsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FormInputId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "FormInputId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormId: FormInputsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FormId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "FormId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @InputName: FormInputsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @InputName( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "InputName", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Label: FormInputsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Label( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Label", subQuery ); } }
}
}
public static class @FormInputsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormInputId: FormInputsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FormInputId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "FormInputId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormId: FormInputsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FormId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "FormId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @InputName: FormInputsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @InputName( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "InputName", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Label: FormInputsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Label( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Label", value ); } }
}
}
public interface FormInstancesTableCondition: TableCondition {}
public static class @FormInstancesTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormInstanceId: FormInstancesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FormInstanceId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "FormInstanceId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormId: FormInstancesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FormId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "FormId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SignedByUserId: FormInstancesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SignedByUserId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "SignedByUserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SignedDateTimeUtc: FormInstancesTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SignedDateTimeUtc( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "SignedDateTimeUtc", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
}
public static class @FormInstancesTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormInstanceId: FormInstancesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @FormInstanceId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "FormInstanceId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormId: FormInstancesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @FormId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "FormId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SignedByUserId: FormInstancesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @SignedByUserId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "SignedByUserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SignedDateTimeUtc: FormInstancesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @SignedDateTimeUtc( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "SignedDateTimeUtc", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
}
public static class @FormInstancesTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormInstanceId: FormInstancesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FormInstanceId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "FormInstanceId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormId: FormInstancesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FormId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "FormId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SignedByUserId: FormInstancesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SignedByUserId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "SignedByUserId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SignedDateTimeUtc: FormInstancesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SignedDateTimeUtc( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "SignedDateTimeUtc", subQuery ); } }
}
}
public static class @FormInstancesTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormInstanceId: FormInstancesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FormInstanceId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "FormInstanceId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormId: FormInstancesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FormId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "FormId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SignedByUserId: FormInstancesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SignedByUserId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "SignedByUserId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SignedDateTimeUtc: FormInstancesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SignedDateTimeUtc( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "SignedDateTimeUtc", value ); } }
}
}
public interface FormsTableCondition: TableCondition {}
public static class @FormsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormId: FormsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FormId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "FormId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormName: FormsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FormName( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "FormName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @FormsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormId: FormsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @FormId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "FormId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormName: FormsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @FormName( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "FormName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @FormsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormId: FormsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FormId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "FormId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormName: FormsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FormName( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "FormName", subQuery ); } }
}
}
public static class @FormsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormId: FormsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FormId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "FormId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormName: FormsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FormName( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "FormName", value ); } }
}
}
public interface FormValuesTableCondition: TableCondition {}
public static class @FormValuesTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormValueId: FormValuesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FormValueId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "FormValueId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormInstanceId: FormValuesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FormInstanceId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "FormInstanceId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormInputId: FormValuesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FormInputId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "FormInputId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @InputValue: FormValuesTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @InputValue( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "InputValue", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @FormValuesTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormValueId: FormValuesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @FormValueId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "FormValueId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormInstanceId: FormValuesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @FormInstanceId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "FormInstanceId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormInputId: FormValuesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @FormInputId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "FormInputId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @InputValue: FormValuesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @InputValue( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "InputValue", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @FormValuesTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormValueId: FormValuesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FormValueId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "FormValueId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormInstanceId: FormValuesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FormInstanceId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "FormInstanceId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormInputId: FormValuesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FormInputId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "FormInputId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @InputValue: FormValuesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @InputValue( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "InputValue", subQuery ); } }
}
}
public static class @FormValuesTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormValueId: FormValuesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FormValueId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "FormValueId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormInstanceId: FormValuesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FormInstanceId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "FormInstanceId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FormInputId: FormValuesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FormInputId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "FormInputId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @InputValue: FormValuesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @InputValue( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "InputValue", value ); } }
}
}
public interface GlobalDatesTableCondition: TableCondition {}
public static class @GlobalDatesTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: GlobalDatesTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "VarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @_Value: GlobalDatesTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @_Value( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Value", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
}
public static class @GlobalDatesTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: GlobalDatesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Name( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "VarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @_Value: GlobalDatesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @_Value( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Value", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
}
public static class @GlobalDatesTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: GlobalDatesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Name", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @_Value: GlobalDatesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @_Value( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Value", subQuery ); } }
}
}
public static class @GlobalDatesTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: GlobalDatesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Name", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @_Value: GlobalDatesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @_Value( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Value", value ); } }
}
}
public interface GlobalIntsTableCondition: TableCondition {}
public static class @GlobalIntsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ParameterName: GlobalIntsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ParameterName( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ParameterName", new DbParameterValue( value, "VarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ParameterValue: GlobalIntsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ParameterValue( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ParameterValue", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @GlobalIntsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ParameterName: GlobalIntsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ParameterName( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ParameterName", new DbParameterValue( value, "VarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ParameterValue: GlobalIntsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ParameterValue( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ParameterValue", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @GlobalIntsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ParameterName: GlobalIntsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ParameterName( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ParameterName", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ParameterValue: GlobalIntsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ParameterValue( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ParameterValue", subQuery ); } }
}
}
public static class @GlobalIntsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ParameterName: GlobalIntsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ParameterName( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ParameterName", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ParameterValue: GlobalIntsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ParameterValue( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ParameterValue", value ); } }
}
}
public interface GlobalStringsTableCondition: TableCondition {}
public static class @GlobalStringsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: GlobalStringsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "VarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @_Value: GlobalStringsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @_Value( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Value", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @GlobalStringsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: GlobalStringsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Name( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "VarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @_Value: GlobalStringsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @_Value( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Value", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @GlobalStringsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: GlobalStringsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Name", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @_Value: GlobalStringsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @_Value( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Value", subQuery ); } }
}
}
public static class @GlobalStringsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: GlobalStringsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Name", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @_Value: GlobalStringsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @_Value( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Value", value ); } }
}
}
public interface HealthPlanTableCondition: TableCondition {}
public static class @HealthPlanTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HealthPlanID: HealthPlanTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @HealthPlanID( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "HealthPlanID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HealthPlanName: HealthPlanTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @HealthPlanName( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "HealthPlanName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Visible: HealthPlanTableCondition {
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Visible( System.Boolean value ) {
this.value = value;
}
internal System.Boolean Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Visible", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LogoData: HealthPlanTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LogoData( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LogoData", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LogoContentType: HealthPlanTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LogoContentType( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LogoContentType", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @HealthPlanTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HealthPlanID: HealthPlanTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @HealthPlanID( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "HealthPlanID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HealthPlanName: HealthPlanTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @HealthPlanName( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "HealthPlanName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Visible: HealthPlanTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Visible( InequalityCondition.Operator op, System.Boolean value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Visible", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LogoData: HealthPlanTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LogoData( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LogoData", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LogoContentType: HealthPlanTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LogoContentType( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LogoContentType", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @HealthPlanTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HealthPlanID: HealthPlanTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @HealthPlanID( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "HealthPlanID", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HealthPlanName: HealthPlanTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @HealthPlanName( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "HealthPlanName", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Visible: HealthPlanTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Visible( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Visible", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LogoData: HealthPlanTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LogoData( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LogoData", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LogoContentType: HealthPlanTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LogoContentType( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LogoContentType", subQuery ); } }
}
}
public static class @HealthPlanTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HealthPlanID: HealthPlanTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @HealthPlanID( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "HealthPlanID", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HealthPlanName: HealthPlanTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @HealthPlanName( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "HealthPlanName", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Visible: HealthPlanTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Visible( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Visible", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LogoData: HealthPlanTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LogoData( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LogoData", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LogoContentType: HealthPlanTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LogoContentType( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LogoContentType", value ); } }
}
}
public interface HtmlBlocksTableCondition: TableCondition {}
public static class @HtmlBlocksTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HtmlBlockId: HtmlBlocksTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @HtmlBlockId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "HtmlBlockId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Html: HtmlBlocksTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Html( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Html", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @HtmlBlocksTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HtmlBlockId: HtmlBlocksTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @HtmlBlockId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "HtmlBlockId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Html: HtmlBlocksTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Html( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Html", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @HtmlBlocksTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HtmlBlockId: HtmlBlocksTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @HtmlBlockId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "HtmlBlockId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Html: HtmlBlocksTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Html( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Html", subQuery ); } }
}
}
public static class @HtmlBlocksTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HtmlBlockId: HtmlBlocksTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @HtmlBlockId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "HtmlBlockId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Html: HtmlBlocksTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Html( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Html", value ); } }
}
}
public interface MainSequenceTableCondition: TableCondition {}
public static class @MainSequenceTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MainSequenceId: MainSequenceTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MainSequenceId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "MainSequenceId", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @MainSequenceTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MainSequenceId: MainSequenceTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @MainSequenceId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "MainSequenceId", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @MainSequenceTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MainSequenceId: MainSequenceTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MainSequenceId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "MainSequenceId", subQuery ); } }
}
}
public static class @MainSequenceTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MainSequenceId: MainSequenceTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MainSequenceId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "MainSequenceId", value ); } }
}
}
public interface MaintenanceWindowDaysTableCondition: TableCondition {}
public static class @MaintenanceWindowDaysTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MaintenanceWindowDayId: MaintenanceWindowDaysTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MaintenanceWindowDayId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "MaintenanceWindowDayId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Day: MaintenanceWindowDaysTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Day( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Day", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @MaintenanceWindowDaysTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MaintenanceWindowDayId: MaintenanceWindowDaysTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @MaintenanceWindowDayId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "MaintenanceWindowDayId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Day: MaintenanceWindowDaysTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Day( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Day", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @MaintenanceWindowDaysTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MaintenanceWindowDayId: MaintenanceWindowDaysTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MaintenanceWindowDayId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "MaintenanceWindowDayId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Day: MaintenanceWindowDaysTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Day( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Day", subQuery ); } }
}
}
public static class @MaintenanceWindowDaysTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MaintenanceWindowDayId: MaintenanceWindowDaysTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MaintenanceWindowDayId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "MaintenanceWindowDayId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Day: MaintenanceWindowDaysTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Day( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Day", value ); } }
}
}
public interface MaintenanceWindowsTableCondition: TableCondition {}
public static class @MaintenanceWindowsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MaintenanceWindowId: MaintenanceWindowsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MaintenanceWindowId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "MaintenanceWindowId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Enabled: MaintenanceWindowsTableCondition {
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Enabled( System.Boolean value ) {
this.value = value;
}
internal System.Boolean Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Enabled", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MaintenanceWindowDayId: MaintenanceWindowsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MaintenanceWindowDayId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "MaintenanceWindowDayId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @StartTime: MaintenanceWindowsTableCondition {
private readonly System.TimeSpan value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @StartTime( System.TimeSpan value ) {
this.value = value;
}
internal System.TimeSpan Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "StartTime", new DbParameterValue( value, "Time" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DurationHours: MaintenanceWindowsTableCondition {
private readonly decimal value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DurationHours( decimal value ) {
this.value = value;
}
internal decimal Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "DurationHours", new DbParameterValue( value, "Decimal" ) ) ); } }
}
}
public static class @MaintenanceWindowsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MaintenanceWindowId: MaintenanceWindowsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @MaintenanceWindowId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "MaintenanceWindowId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Enabled: MaintenanceWindowsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Enabled( InequalityCondition.Operator op, System.Boolean value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Enabled", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MaintenanceWindowDayId: MaintenanceWindowsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @MaintenanceWindowDayId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "MaintenanceWindowDayId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @StartTime: MaintenanceWindowsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.TimeSpan value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @StartTime( InequalityCondition.Operator op, System.TimeSpan value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "StartTime", new DbParameterValue( value, "Time" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DurationHours: MaintenanceWindowsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly decimal value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @DurationHours( InequalityCondition.Operator op, decimal value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "DurationHours", new DbParameterValue( value, "Decimal" ) ) ); } }
}
}
public static class @MaintenanceWindowsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MaintenanceWindowId: MaintenanceWindowsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MaintenanceWindowId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "MaintenanceWindowId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Enabled: MaintenanceWindowsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Enabled( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Enabled", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MaintenanceWindowDayId: MaintenanceWindowsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MaintenanceWindowDayId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "MaintenanceWindowDayId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @StartTime: MaintenanceWindowsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @StartTime( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "StartTime", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DurationHours: MaintenanceWindowsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DurationHours( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "DurationHours", subQuery ); } }
}
}
public static class @MaintenanceWindowsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MaintenanceWindowId: MaintenanceWindowsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MaintenanceWindowId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "MaintenanceWindowId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Enabled: MaintenanceWindowsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Enabled( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Enabled", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MaintenanceWindowDayId: MaintenanceWindowsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MaintenanceWindowDayId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "MaintenanceWindowDayId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @StartTime: MaintenanceWindowsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @StartTime( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "StartTime", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DurationHours: MaintenanceWindowsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DurationHours( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "DurationHours", value ); } }
}
}
public interface MediaFilesTableCondition: TableCondition {}
public static class @MediaFilesTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MediaFileId: MediaFilesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MediaFileId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "MediaFileId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileId: MediaFilesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FileId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "FileId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MediaFolderId: MediaFilesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MediaFolderId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "MediaFolderId", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @MediaFilesTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MediaFileId: MediaFilesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @MediaFileId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "MediaFileId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileId: MediaFilesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @FileId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "FileId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MediaFolderId: MediaFilesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @MediaFolderId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "MediaFolderId", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @MediaFilesTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MediaFileId: MediaFilesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MediaFileId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "MediaFileId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileId: MediaFilesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FileId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "FileId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MediaFolderId: MediaFilesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MediaFolderId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "MediaFolderId", subQuery ); } }
}
}
public static class @MediaFilesTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MediaFileId: MediaFilesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MediaFileId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "MediaFileId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileId: MediaFilesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FileId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "FileId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MediaFolderId: MediaFilesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MediaFolderId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "MediaFolderId", value ); } }
}
}
public interface MediaFoldersTableCondition: TableCondition {}
public static class @MediaFoldersTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MediaFolderId: MediaFoldersTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MediaFolderId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "MediaFolderId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: MediaFoldersTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @MediaFoldersTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MediaFolderId: MediaFoldersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @MediaFolderId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "MediaFolderId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: MediaFoldersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Name( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @MediaFoldersTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MediaFolderId: MediaFoldersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MediaFolderId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "MediaFolderId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: MediaFoldersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Name", subQuery ); } }
}
}
public static class @MediaFoldersTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MediaFolderId: MediaFoldersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MediaFolderId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "MediaFolderId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: MediaFoldersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Name", value ); } }
}
}
public interface NotificationTableCondition: TableCondition {}
public static class @NotificationTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @NotificationID: NotificationTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @NotificationID( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "NotificationID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TypeName: NotificationTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TypeName( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "TypeName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FromUser: NotificationTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FromUser( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "FromUser", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ToUser: NotificationTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ToUser( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ToUser", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EmailBody: NotificationTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EmailBody( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EmailBody", new DbParameterValue( value, "NText" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EmailSubject: NotificationTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EmailSubject( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EmailSubject", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Success: NotificationTableCondition {
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Success( System.Boolean value ) {
this.value = value;
}
internal System.Boolean Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Success", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: NotificationTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Created( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Created", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FailureMsg: NotificationTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FailureMsg( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "FailureMsg", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @NotificationTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @NotificationID: NotificationTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @NotificationID( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "NotificationID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TypeName: NotificationTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @TypeName( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "TypeName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FromUser: NotificationTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @FromUser( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "FromUser", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ToUser: NotificationTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ToUser( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ToUser", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EmailBody: NotificationTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EmailBody( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EmailBody", new DbParameterValue( value, "NText" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EmailSubject: NotificationTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EmailSubject( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EmailSubject", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Success: NotificationTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Success( InequalityCondition.Operator op, System.Boolean value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Success", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: NotificationTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Created( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Created", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FailureMsg: NotificationTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @FailureMsg( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "FailureMsg", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @NotificationTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @NotificationID: NotificationTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @NotificationID( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "NotificationID", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TypeName: NotificationTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TypeName( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "TypeName", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FromUser: NotificationTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FromUser( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "FromUser", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ToUser: NotificationTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ToUser( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ToUser", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EmailBody: NotificationTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EmailBody( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EmailBody", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EmailSubject: NotificationTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EmailSubject( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EmailSubject", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Success: NotificationTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Success( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Success", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: NotificationTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Created( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Created", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FailureMsg: NotificationTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FailureMsg( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "FailureMsg", subQuery ); } }
}
}
public static class @NotificationTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @NotificationID: NotificationTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @NotificationID( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "NotificationID", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TypeName: NotificationTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TypeName( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "TypeName", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FromUser: NotificationTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FromUser( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "FromUser", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ToUser: NotificationTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ToUser( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ToUser", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EmailBody: NotificationTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EmailBody( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EmailBody", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EmailSubject: NotificationTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EmailSubject( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EmailSubject", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Success: NotificationTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Success( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Success", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: NotificationTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Created( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Created", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FailureMsg: NotificationTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FailureMsg( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "FailureMsg", value ); } }
}
}
public interface NotificationParameterTableCondition: TableCondition {}
public static class @NotificationParameterTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ParameterID: NotificationParameterTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ParameterID( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ParameterID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: NotificationParameterTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DataType: NotificationParameterTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DataType( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "DataType", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Protocol: NotificationParameterTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Protocol( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Protocol", new DbParameterValue( value, "NChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DefaultValue: NotificationParameterTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DefaultValue( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "DefaultValue", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @NotificationParameterTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ParameterID: NotificationParameterTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ParameterID( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ParameterID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: NotificationParameterTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Name( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DataType: NotificationParameterTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @DataType( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "DataType", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Protocol: NotificationParameterTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Protocol( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Protocol", new DbParameterValue( value, "NChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DefaultValue: NotificationParameterTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @DefaultValue( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "DefaultValue", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @NotificationParameterTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ParameterID: NotificationParameterTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ParameterID( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ParameterID", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: NotificationParameterTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Name", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DataType: NotificationParameterTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DataType( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "DataType", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Protocol: NotificationParameterTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Protocol( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Protocol", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DefaultValue: NotificationParameterTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DefaultValue( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "DefaultValue", subQuery ); } }
}
}
public static class @NotificationParameterTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ParameterID: NotificationParameterTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ParameterID( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ParameterID", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: NotificationParameterTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Name", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DataType: NotificationParameterTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DataType( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "DataType", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Protocol: NotificationParameterTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Protocol( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Protocol", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DefaultValue: NotificationParameterTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DefaultValue( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "DefaultValue", value ); } }
}
}
public interface NotificationTypeTableCondition: TableCondition {}
public static class @NotificationTypeTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TypeID: NotificationTypeTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TypeID( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "TypeID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: NotificationTypeTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastModified: NotificationTypeTableCondition {
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastModified( System.DateTime? value ) {
this.value = value;
}
internal System.DateTime? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LastModified", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: NotificationTypeTableCondition {
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Created( System.DateTime? value ) {
this.value = value;
}
internal System.DateTime? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Created", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FromCode: NotificationTypeTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FromCode( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "FromCode", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ToCode: NotificationTypeTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ToCode( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ToCode", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Protocol: NotificationTypeTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Protocol( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Protocol", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Subject: NotificationTypeTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Subject( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Subject", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Body: NotificationTypeTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Body( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Body", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HtmlBody: NotificationTypeTableCondition {
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @HtmlBody( System.Boolean value ) {
this.value = value;
}
internal System.Boolean Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "HtmlBody", new DbParameterValue( value, "Bit" ) ) ); } }
}
}
public static class @NotificationTypeTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TypeID: NotificationTypeTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @TypeID( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "TypeID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: NotificationTypeTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Name( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastModified: NotificationTypeTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LastModified( InequalityCondition.Operator op, System.DateTime? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LastModified", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: NotificationTypeTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Created( InequalityCondition.Operator op, System.DateTime? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Created", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FromCode: NotificationTypeTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @FromCode( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "FromCode", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ToCode: NotificationTypeTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ToCode( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ToCode", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Protocol: NotificationTypeTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Protocol( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Protocol", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Subject: NotificationTypeTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Subject( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Subject", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Body: NotificationTypeTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Body( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Body", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HtmlBody: NotificationTypeTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @HtmlBody( InequalityCondition.Operator op, System.Boolean value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "HtmlBody", new DbParameterValue( value, "Bit" ) ) ); } }
}
}
public static class @NotificationTypeTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TypeID: NotificationTypeTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TypeID( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "TypeID", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: NotificationTypeTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Name", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastModified: NotificationTypeTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastModified( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LastModified", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: NotificationTypeTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Created( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Created", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FromCode: NotificationTypeTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FromCode( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "FromCode", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ToCode: NotificationTypeTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ToCode( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ToCode", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Protocol: NotificationTypeTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Protocol( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Protocol", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Subject: NotificationTypeTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Subject( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Subject", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Body: NotificationTypeTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Body( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Body", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HtmlBody: NotificationTypeTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @HtmlBody( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "HtmlBody", subQuery ); } }
}
}
public static class @NotificationTypeTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TypeID: NotificationTypeTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TypeID( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "TypeID", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: NotificationTypeTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Name", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastModified: NotificationTypeTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastModified( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LastModified", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: NotificationTypeTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Created( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Created", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FromCode: NotificationTypeTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FromCode( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "FromCode", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ToCode: NotificationTypeTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ToCode( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ToCode", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Protocol: NotificationTypeTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Protocol( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Protocol", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Subject: NotificationTypeTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Subject( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Subject", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Body: NotificationTypeTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Body( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Body", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HtmlBody: NotificationTypeTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @HtmlBody( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "HtmlBody", value ); } }
}
}
public interface OrderRanksTableCondition: TableCondition {}
public static class @OrderRanksTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @OrderRankId: OrderRanksTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @OrderRankId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "OrderRankId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Rank: OrderRanksTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Rank( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Rank", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @OrderRanksTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @OrderRankId: OrderRanksTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @OrderRankId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "OrderRankId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Rank: OrderRanksTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Rank( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Rank", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @OrderRanksTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @OrderRankId: OrderRanksTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @OrderRankId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "OrderRankId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Rank: OrderRanksTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Rank( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Rank", subQuery ); } }
}
}
public static class @OrderRanksTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @OrderRankId: OrderRanksTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @OrderRankId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "OrderRankId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Rank: OrderRanksTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Rank( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Rank", value ); } }
}
}
public interface OrganizationsTableCondition: TableCondition {}
public static class @OrganizationsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @OrganizationId: OrganizationsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @OrganizationId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "OrganizationId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: OrganizationsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DisabledEndDate: OrganizationsTableCondition {
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DisabledEndDate( System.DateTime? value ) {
this.value = value;
}
internal System.DateTime? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "DisabledEndDate", new DbParameterValue( value, "Date" ) ) ); } }
}
}
public static class @OrganizationsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @OrganizationId: OrganizationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @OrganizationId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "OrganizationId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: OrganizationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Name( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DisabledEndDate: OrganizationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @DisabledEndDate( InequalityCondition.Operator op, System.DateTime? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "DisabledEndDate", new DbParameterValue( value, "Date" ) ) ); } }
}
}
public static class @OrganizationsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @OrganizationId: OrganizationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @OrganizationId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "OrganizationId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: OrganizationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Name", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DisabledEndDate: OrganizationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DisabledEndDate( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "DisabledEndDate", subQuery ); } }
}
}
public static class @OrganizationsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @OrganizationId: OrganizationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @OrganizationId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "OrganizationId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: OrganizationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Name", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DisabledEndDate: OrganizationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DisabledEndDate( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "DisabledEndDate", value ); } }
}
}
public interface PasswordResetQuestionsTableCondition: TableCondition {}
public static class @PasswordResetQuestionsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PasswordResetQuestionId: PasswordResetQuestionsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PasswordResetQuestionId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PasswordResetQuestionId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Question: PasswordResetQuestionsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Question( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Question", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @PasswordResetQuestionsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PasswordResetQuestionId: PasswordResetQuestionsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PasswordResetQuestionId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PasswordResetQuestionId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Question: PasswordResetQuestionsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Question( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Question", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @PasswordResetQuestionsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PasswordResetQuestionId: PasswordResetQuestionsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PasswordResetQuestionId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PasswordResetQuestionId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Question: PasswordResetQuestionsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Question( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Question", subQuery ); } }
}
}
public static class @PasswordResetQuestionsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PasswordResetQuestionId: PasswordResetQuestionsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PasswordResetQuestionId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PasswordResetQuestionId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Question: PasswordResetQuestionsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Question( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Question", value ); } }
}
}
public interface PatientAuditRequestTableCondition: TableCondition {}
public static class @PatientAuditRequestTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientAuditID: PatientAuditRequestTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PatientAuditID( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PatientAuditID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncKV: PatientAuditRequestTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncKV( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EncKV", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncIV: PatientAuditRequestTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncIV( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EncIV", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DateRequested: PatientAuditRequestTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DateRequested( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "DateRequested", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AuditStatus: PatientAuditRequestTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AuditStatus( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "AuditStatus", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastModifiedDate: PatientAuditRequestTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastModifiedDate( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LastModifiedDate", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastModifiedUser: PatientAuditRequestTableCondition {
private readonly System.Guid? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastModifiedUser( System.Guid? value ) {
this.value = value;
}
internal System.Guid? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LastModifiedUser", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientUserID: PatientAuditRequestTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PatientUserID( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PatientUserID", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ElysiumID: PatientAuditRequestTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ElysiumID( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ElysiumID", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @BillableAmount: PatientAuditRequestTableCondition {
private readonly decimal value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @BillableAmount( decimal value ) {
this.value = value;
}
internal decimal Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "BillableAmount", new DbParameterValue( value, "Decimal" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PaymentConfirmed: PatientAuditRequestTableCondition {
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PaymentConfirmed( System.DateTime? value ) {
this.value = value;
}
internal System.DateTime? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PaymentConfirmed", new DbParameterValue( value, "DateTime" ) ) ); } }
}
}
public static class @PatientAuditRequestTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientAuditID: PatientAuditRequestTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PatientAuditID( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PatientAuditID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncKV: PatientAuditRequestTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EncKV( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EncKV", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncIV: PatientAuditRequestTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EncIV( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EncIV", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DateRequested: PatientAuditRequestTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @DateRequested( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "DateRequested", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AuditStatus: PatientAuditRequestTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @AuditStatus( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "AuditStatus", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastModifiedDate: PatientAuditRequestTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LastModifiedDate( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LastModifiedDate", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastModifiedUser: PatientAuditRequestTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Guid? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LastModifiedUser( InequalityCondition.Operator op, System.Guid? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LastModifiedUser", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientUserID: PatientAuditRequestTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PatientUserID( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PatientUserID", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ElysiumID: PatientAuditRequestTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ElysiumID( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ElysiumID", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @BillableAmount: PatientAuditRequestTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly decimal value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @BillableAmount( InequalityCondition.Operator op, decimal value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "BillableAmount", new DbParameterValue( value, "Decimal" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PaymentConfirmed: PatientAuditRequestTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PaymentConfirmed( InequalityCondition.Operator op, System.DateTime? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PaymentConfirmed", new DbParameterValue( value, "DateTime" ) ) ); } }
}
}
public static class @PatientAuditRequestTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientAuditID: PatientAuditRequestTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PatientAuditID( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PatientAuditID", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncKV: PatientAuditRequestTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncKV( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EncKV", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncIV: PatientAuditRequestTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncIV( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EncIV", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DateRequested: PatientAuditRequestTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DateRequested( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "DateRequested", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AuditStatus: PatientAuditRequestTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AuditStatus( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "AuditStatus", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastModifiedDate: PatientAuditRequestTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastModifiedDate( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LastModifiedDate", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastModifiedUser: PatientAuditRequestTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastModifiedUser( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LastModifiedUser", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientUserID: PatientAuditRequestTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PatientUserID( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PatientUserID", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ElysiumID: PatientAuditRequestTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ElysiumID( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ElysiumID", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @BillableAmount: PatientAuditRequestTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @BillableAmount( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "BillableAmount", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PaymentConfirmed: PatientAuditRequestTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PaymentConfirmed( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PaymentConfirmed", subQuery ); } }
}
}
public static class @PatientAuditRequestTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientAuditID: PatientAuditRequestTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PatientAuditID( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PatientAuditID", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncKV: PatientAuditRequestTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncKV( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EncKV", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncIV: PatientAuditRequestTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncIV( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EncIV", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DateRequested: PatientAuditRequestTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DateRequested( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "DateRequested", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AuditStatus: PatientAuditRequestTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AuditStatus( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "AuditStatus", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastModifiedDate: PatientAuditRequestTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastModifiedDate( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LastModifiedDate", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastModifiedUser: PatientAuditRequestTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastModifiedUser( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LastModifiedUser", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientUserID: PatientAuditRequestTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PatientUserID( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PatientUserID", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ElysiumID: PatientAuditRequestTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ElysiumID( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ElysiumID", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @BillableAmount: PatientAuditRequestTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @BillableAmount( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "BillableAmount", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PaymentConfirmed: PatientAuditRequestTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PaymentConfirmed( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PaymentConfirmed", value ); } }
}
}
public interface PatientConsentServiceCacheTableCondition: TableCondition {}
public static class @PatientConsentServiceCacheTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientConsentServiceCacheId: PatientConsentServiceCacheTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PatientConsentServiceCacheId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PatientConsentServiceCacheId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Iv: PatientConsentServiceCacheTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Iv( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Iv", new DbParameterValue( value, "Binary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientConsentServiceCacheDateId: PatientConsentServiceCacheTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PatientConsentServiceCacheDateId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PatientConsentServiceCacheDateId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkgroupId: PatientConsentServiceCacheTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @WorkgroupId( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "WorkgroupId", new DbParameterValue( value, "Binary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ConsentTypeId: PatientConsentServiceCacheTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ConsentTypeId( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ConsentTypeId", new DbParameterValue( value, "Binary" ) ) ); } }
}
}
public static class @PatientConsentServiceCacheTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientConsentServiceCacheId: PatientConsentServiceCacheTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PatientConsentServiceCacheId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PatientConsentServiceCacheId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Iv: PatientConsentServiceCacheTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Iv( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Iv", new DbParameterValue( value, "Binary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientConsentServiceCacheDateId: PatientConsentServiceCacheTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PatientConsentServiceCacheDateId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PatientConsentServiceCacheDateId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkgroupId: PatientConsentServiceCacheTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @WorkgroupId( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "WorkgroupId", new DbParameterValue( value, "Binary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ConsentTypeId: PatientConsentServiceCacheTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ConsentTypeId( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ConsentTypeId", new DbParameterValue( value, "Binary" ) ) ); } }
}
}
public static class @PatientConsentServiceCacheTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientConsentServiceCacheId: PatientConsentServiceCacheTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PatientConsentServiceCacheId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PatientConsentServiceCacheId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Iv: PatientConsentServiceCacheTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Iv( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Iv", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientConsentServiceCacheDateId: PatientConsentServiceCacheTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PatientConsentServiceCacheDateId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PatientConsentServiceCacheDateId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkgroupId: PatientConsentServiceCacheTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @WorkgroupId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "WorkgroupId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ConsentTypeId: PatientConsentServiceCacheTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ConsentTypeId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ConsentTypeId", subQuery ); } }
}
}
public static class @PatientConsentServiceCacheTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientConsentServiceCacheId: PatientConsentServiceCacheTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PatientConsentServiceCacheId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PatientConsentServiceCacheId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Iv: PatientConsentServiceCacheTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Iv( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Iv", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientConsentServiceCacheDateId: PatientConsentServiceCacheTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PatientConsentServiceCacheDateId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PatientConsentServiceCacheDateId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkgroupId: PatientConsentServiceCacheTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @WorkgroupId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "WorkgroupId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ConsentTypeId: PatientConsentServiceCacheTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ConsentTypeId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ConsentTypeId", value ); } }
}
}
public interface PatientConsentServiceCacheDatesTableCondition: TableCondition {}
public static class @PatientConsentServiceCacheDatesTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientConsentServiceCacheDateId: PatientConsentServiceCacheDatesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PatientConsentServiceCacheDateId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PatientConsentServiceCacheDateId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ElysiumId: PatientConsentServiceCacheDatesTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ElysiumId( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ElysiumId", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastRequestedDate: PatientConsentServiceCacheDatesTableCondition {
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastRequestedDate( System.DateTime? value ) {
this.value = value;
}
internal System.DateTime? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LastRequestedDate", new DbParameterValue( value, "Date" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Goodfor: PatientConsentServiceCacheDatesTableCondition {
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Goodfor( System.DateTime? value ) {
this.value = value;
}
internal System.DateTime? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Goodfor", new DbParameterValue( value, "Date" ) ) ); } }
}
}
public static class @PatientConsentServiceCacheDatesTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientConsentServiceCacheDateId: PatientConsentServiceCacheDatesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PatientConsentServiceCacheDateId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PatientConsentServiceCacheDateId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ElysiumId: PatientConsentServiceCacheDatesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ElysiumId( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ElysiumId", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastRequestedDate: PatientConsentServiceCacheDatesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LastRequestedDate( InequalityCondition.Operator op, System.DateTime? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LastRequestedDate", new DbParameterValue( value, "Date" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Goodfor: PatientConsentServiceCacheDatesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Goodfor( InequalityCondition.Operator op, System.DateTime? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Goodfor", new DbParameterValue( value, "Date" ) ) ); } }
}
}
public static class @PatientConsentServiceCacheDatesTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientConsentServiceCacheDateId: PatientConsentServiceCacheDatesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PatientConsentServiceCacheDateId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PatientConsentServiceCacheDateId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ElysiumId: PatientConsentServiceCacheDatesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ElysiumId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ElysiumId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastRequestedDate: PatientConsentServiceCacheDatesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastRequestedDate( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LastRequestedDate", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Goodfor: PatientConsentServiceCacheDatesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Goodfor( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Goodfor", subQuery ); } }
}
}
public static class @PatientConsentServiceCacheDatesTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientConsentServiceCacheDateId: PatientConsentServiceCacheDatesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PatientConsentServiceCacheDateId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PatientConsentServiceCacheDateId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ElysiumId: PatientConsentServiceCacheDatesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ElysiumId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ElysiumId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastRequestedDate: PatientConsentServiceCacheDatesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastRequestedDate( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LastRequestedDate", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Goodfor: PatientConsentServiceCacheDatesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Goodfor( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Goodfor", value ); } }
}
}
public interface PatientInfoTableCondition: TableCondition {}
public static class @PatientInfoTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserID: PatientInfoTableCondition {
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserID( System.Guid value ) {
this.value = value;
}
internal System.Guid Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UserID", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncKV: PatientInfoTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncKV( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EncKV", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncIV: PatientInfoTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncIV( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EncIV", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FirstName: PatientInfoTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FirstName( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "FirstName", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MiddleName: PatientInfoTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MiddleName( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "MiddleName", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastName: PatientInfoTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastName( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LastName", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Address1: PatientInfoTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Address1( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Address1", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Address2: PatientInfoTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Address2( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Address2", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @City: PatientInfoTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @City( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "City", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @State: PatientInfoTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @State( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "State", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ZipCode: PatientInfoTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ZipCode( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ZipCode", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Email: PatientInfoTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Email( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Email", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Phone: PatientInfoTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Phone( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Phone", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Gender: PatientInfoTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Gender( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Gender", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DOB: PatientInfoTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DOB( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "DOB", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ElysiumID: PatientInfoTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ElysiumID( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ElysiumID", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PhrStatusId: PatientInfoTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PhrStatusId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PhrStatusId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SignupComplete: PatientInfoTableCondition {
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SignupComplete( System.Boolean value ) {
this.value = value;
}
internal System.Boolean Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "SignupComplete", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TfaMethodId: PatientInfoTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TfaMethodId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "TfaMethodId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ForcePasswordExpired: PatientInfoTableCondition {
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ForcePasswordExpired( System.Boolean value ) {
this.value = value;
}
internal System.Boolean Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ForcePasswordExpired", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SignupDate: PatientInfoTableCondition {
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SignupDate( System.DateTime? value ) {
this.value = value;
}
internal System.DateTime? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "SignupDate", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
}
public static class @PatientInfoTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserID: PatientInfoTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UserID( InequalityCondition.Operator op, System.Guid value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UserID", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncKV: PatientInfoTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EncKV( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EncKV", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncIV: PatientInfoTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EncIV( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EncIV", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FirstName: PatientInfoTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @FirstName( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "FirstName", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MiddleName: PatientInfoTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @MiddleName( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "MiddleName", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastName: PatientInfoTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LastName( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LastName", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Address1: PatientInfoTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Address1( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Address1", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Address2: PatientInfoTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Address2( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Address2", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @City: PatientInfoTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @City( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "City", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @State: PatientInfoTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @State( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "State", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ZipCode: PatientInfoTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ZipCode( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ZipCode", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Email: PatientInfoTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Email( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Email", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Phone: PatientInfoTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Phone( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Phone", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Gender: PatientInfoTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Gender( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Gender", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DOB: PatientInfoTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @DOB( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "DOB", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ElysiumID: PatientInfoTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ElysiumID( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ElysiumID", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PhrStatusId: PatientInfoTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PhrStatusId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PhrStatusId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SignupComplete: PatientInfoTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @SignupComplete( InequalityCondition.Operator op, System.Boolean value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "SignupComplete", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TfaMethodId: PatientInfoTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @TfaMethodId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "TfaMethodId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ForcePasswordExpired: PatientInfoTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ForcePasswordExpired( InequalityCondition.Operator op, System.Boolean value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ForcePasswordExpired", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SignupDate: PatientInfoTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @SignupDate( InequalityCondition.Operator op, System.DateTime? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "SignupDate", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
}
public static class @PatientInfoTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserID: PatientInfoTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserID( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UserID", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncKV: PatientInfoTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncKV( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EncKV", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncIV: PatientInfoTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncIV( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EncIV", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FirstName: PatientInfoTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FirstName( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "FirstName", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MiddleName: PatientInfoTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MiddleName( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "MiddleName", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastName: PatientInfoTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastName( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LastName", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Address1: PatientInfoTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Address1( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Address1", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Address2: PatientInfoTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Address2( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Address2", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @City: PatientInfoTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @City( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "City", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @State: PatientInfoTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @State( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "State", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ZipCode: PatientInfoTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ZipCode( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ZipCode", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Email: PatientInfoTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Email( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Email", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Phone: PatientInfoTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Phone( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Phone", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Gender: PatientInfoTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Gender( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Gender", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DOB: PatientInfoTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DOB( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "DOB", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ElysiumID: PatientInfoTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ElysiumID( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ElysiumID", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PhrStatusId: PatientInfoTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PhrStatusId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PhrStatusId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SignupComplete: PatientInfoTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SignupComplete( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "SignupComplete", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TfaMethodId: PatientInfoTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TfaMethodId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "TfaMethodId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ForcePasswordExpired: PatientInfoTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ForcePasswordExpired( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ForcePasswordExpired", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SignupDate: PatientInfoTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SignupDate( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "SignupDate", subQuery ); } }
}
}
public static class @PatientInfoTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserID: PatientInfoTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserID( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UserID", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncKV: PatientInfoTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncKV( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EncKV", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncIV: PatientInfoTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncIV( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EncIV", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FirstName: PatientInfoTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FirstName( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "FirstName", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MiddleName: PatientInfoTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MiddleName( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "MiddleName", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastName: PatientInfoTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastName( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LastName", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Address1: PatientInfoTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Address1( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Address1", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Address2: PatientInfoTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Address2( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Address2", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @City: PatientInfoTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @City( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "City", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @State: PatientInfoTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @State( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "State", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ZipCode: PatientInfoTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ZipCode( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ZipCode", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Email: PatientInfoTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Email( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Email", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Phone: PatientInfoTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Phone( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Phone", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Gender: PatientInfoTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Gender( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Gender", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DOB: PatientInfoTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DOB( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "DOB", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ElysiumID: PatientInfoTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ElysiumID( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ElysiumID", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PhrStatusId: PatientInfoTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PhrStatusId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PhrStatusId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SignupComplete: PatientInfoTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SignupComplete( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "SignupComplete", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TfaMethodId: PatientInfoTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TfaMethodId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "TfaMethodId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ForcePasswordExpired: PatientInfoTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ForcePasswordExpired( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ForcePasswordExpired", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SignupDate: PatientInfoTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SignupDate( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "SignupDate", value ); } }
}
}
public interface PatientPortalConsentHistoryTableCondition: TableCondition {}
public static class @PatientPortalConsentHistoryTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientPortalConsentHistoryId: PatientPortalConsentHistoryTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PatientPortalConsentHistoryId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PatientPortalConsentHistoryId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Iv: PatientPortalConsentHistoryTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Iv( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Iv", new DbParameterValue( value, "Binary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ElysiumId: PatientPortalConsentHistoryTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ElysiumId( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ElysiumId", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkgroupId: PatientPortalConsentHistoryTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @WorkgroupId( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "WorkgroupId", new DbParameterValue( value, "Binary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ConsentTypeId: PatientPortalConsentHistoryTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ConsentTypeId( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ConsentTypeId", new DbParameterValue( value, "Binary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UpdatedByPatientDateTime: PatientPortalConsentHistoryTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UpdatedByPatientDateTime( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UpdatedByPatientDateTime", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
}
public static class @PatientPortalConsentHistoryTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientPortalConsentHistoryId: PatientPortalConsentHistoryTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PatientPortalConsentHistoryId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PatientPortalConsentHistoryId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Iv: PatientPortalConsentHistoryTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Iv( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Iv", new DbParameterValue( value, "Binary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ElysiumId: PatientPortalConsentHistoryTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ElysiumId( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ElysiumId", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkgroupId: PatientPortalConsentHistoryTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @WorkgroupId( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "WorkgroupId", new DbParameterValue( value, "Binary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ConsentTypeId: PatientPortalConsentHistoryTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ConsentTypeId( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ConsentTypeId", new DbParameterValue( value, "Binary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UpdatedByPatientDateTime: PatientPortalConsentHistoryTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UpdatedByPatientDateTime( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UpdatedByPatientDateTime", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
}
public static class @PatientPortalConsentHistoryTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientPortalConsentHistoryId: PatientPortalConsentHistoryTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PatientPortalConsentHistoryId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PatientPortalConsentHistoryId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Iv: PatientPortalConsentHistoryTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Iv( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Iv", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ElysiumId: PatientPortalConsentHistoryTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ElysiumId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ElysiumId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkgroupId: PatientPortalConsentHistoryTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @WorkgroupId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "WorkgroupId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ConsentTypeId: PatientPortalConsentHistoryTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ConsentTypeId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ConsentTypeId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UpdatedByPatientDateTime: PatientPortalConsentHistoryTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UpdatedByPatientDateTime( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UpdatedByPatientDateTime", subQuery ); } }
}
}
public static class @PatientPortalConsentHistoryTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientPortalConsentHistoryId: PatientPortalConsentHistoryTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PatientPortalConsentHistoryId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PatientPortalConsentHistoryId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Iv: PatientPortalConsentHistoryTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Iv( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Iv", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ElysiumId: PatientPortalConsentHistoryTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ElysiumId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ElysiumId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkgroupId: PatientPortalConsentHistoryTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @WorkgroupId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "WorkgroupId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ConsentTypeId: PatientPortalConsentHistoryTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ConsentTypeId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ConsentTypeId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UpdatedByPatientDateTime: PatientPortalConsentHistoryTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UpdatedByPatientDateTime( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UpdatedByPatientDateTime", value ); } }
}
}
public interface PaymentTableCondition: TableCondition {}
public static class @PaymentTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PaymentID: PaymentTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PaymentID( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PaymentID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserID: PaymentTableCondition {
private readonly System.Guid? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserID( System.Guid? value ) {
this.value = value;
}
internal System.Guid? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UserID", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PaymentTypeID: PaymentTableCondition {
private readonly System.Int32? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PaymentTypeID( System.Int32? value ) {
this.value = value;
}
internal System.Int32? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PaymentTypeID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PaymentMethodID: PaymentTableCondition {
private readonly System.Int32? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PaymentMethodID( System.Int32? value ) {
this.value = value;
}
internal System.Int32? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PaymentMethodID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Total: PaymentTableCondition {
private readonly System.Single? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Total( System.Single? value ) {
this.value = value;
}
internal System.Single? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Total", new DbParameterValue( value, "Real" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: PaymentTableCondition {
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Created( System.DateTime? value ) {
this.value = value;
}
internal System.DateTime? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Created", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastModified: PaymentTableCondition {
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastModified( System.DateTime? value ) {
this.value = value;
}
internal System.DateTime? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LastModified", new DbParameterValue( value, "DateTime" ) ) ); } }
}
}
public static class @PaymentTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PaymentID: PaymentTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PaymentID( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PaymentID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserID: PaymentTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Guid? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UserID( InequalityCondition.Operator op, System.Guid? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UserID", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PaymentTypeID: PaymentTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Int32? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PaymentTypeID( InequalityCondition.Operator op, System.Int32? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PaymentTypeID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PaymentMethodID: PaymentTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Int32? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PaymentMethodID( InequalityCondition.Operator op, System.Int32? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PaymentMethodID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Total: PaymentTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Single? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Total( InequalityCondition.Operator op, System.Single? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Total", new DbParameterValue( value, "Real" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: PaymentTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Created( InequalityCondition.Operator op, System.DateTime? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Created", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastModified: PaymentTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LastModified( InequalityCondition.Operator op, System.DateTime? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LastModified", new DbParameterValue( value, "DateTime" ) ) ); } }
}
}
public static class @PaymentTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PaymentID: PaymentTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PaymentID( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PaymentID", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserID: PaymentTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserID( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UserID", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PaymentTypeID: PaymentTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PaymentTypeID( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PaymentTypeID", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PaymentMethodID: PaymentTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PaymentMethodID( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PaymentMethodID", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Total: PaymentTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Total( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Total", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: PaymentTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Created( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Created", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastModified: PaymentTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastModified( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LastModified", subQuery ); } }
}
}
public static class @PaymentTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PaymentID: PaymentTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PaymentID( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PaymentID", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserID: PaymentTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserID( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UserID", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PaymentTypeID: PaymentTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PaymentTypeID( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PaymentTypeID", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PaymentMethodID: PaymentTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PaymentMethodID( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PaymentMethodID", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Total: PaymentTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Total( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Total", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: PaymentTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Created( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Created", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastModified: PaymentTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastModified( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LastModified", value ); } }
}
}
public interface PaymentMethodTableCondition: TableCondition {}
public static class @PaymentMethodTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MethodID: PaymentMethodTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MethodID( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "MethodID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: PaymentMethodTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Enabled: PaymentMethodTableCondition {
private readonly System.Boolean? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Enabled( System.Boolean? value ) {
this.value = value;
}
internal System.Boolean? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Enabled", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: PaymentMethodTableCondition {
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Created( System.DateTime? value ) {
this.value = value;
}
internal System.DateTime? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Created", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastModified: PaymentMethodTableCondition {
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastModified( System.DateTime? value ) {
this.value = value;
}
internal System.DateTime? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LastModified", new DbParameterValue( value, "DateTime" ) ) ); } }
}
}
public static class @PaymentMethodTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MethodID: PaymentMethodTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @MethodID( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "MethodID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: PaymentMethodTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Name( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Enabled: PaymentMethodTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Boolean? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Enabled( InequalityCondition.Operator op, System.Boolean? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Enabled", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: PaymentMethodTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Created( InequalityCondition.Operator op, System.DateTime? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Created", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastModified: PaymentMethodTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LastModified( InequalityCondition.Operator op, System.DateTime? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LastModified", new DbParameterValue( value, "DateTime" ) ) ); } }
}
}
public static class @PaymentMethodTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MethodID: PaymentMethodTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MethodID( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "MethodID", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: PaymentMethodTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Name", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Enabled: PaymentMethodTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Enabled( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Enabled", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: PaymentMethodTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Created( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Created", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastModified: PaymentMethodTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastModified( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LastModified", subQuery ); } }
}
}
public static class @PaymentMethodTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MethodID: PaymentMethodTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MethodID( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "MethodID", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: PaymentMethodTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Name", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Enabled: PaymentMethodTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Enabled( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Enabled", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: PaymentMethodTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Created( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Created", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastModified: PaymentMethodTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastModified( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LastModified", value ); } }
}
}
public interface PaymentTypeTableCondition: TableCondition {}
public static class @PaymentTypeTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TypeID: PaymentTypeTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TypeID( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "TypeID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: PaymentTypeTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Price: PaymentTypeTableCondition {
private readonly System.Single? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Price( System.Single? value ) {
this.value = value;
}
internal System.Single? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Price", new DbParameterValue( value, "Real" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: PaymentTypeTableCondition {
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Created( System.DateTime? value ) {
this.value = value;
}
internal System.DateTime? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Created", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastUpdated: PaymentTypeTableCondition {
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastUpdated( System.DateTime? value ) {
this.value = value;
}
internal System.DateTime? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LastUpdated", new DbParameterValue( value, "DateTime" ) ) ); } }
}
}
public static class @PaymentTypeTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TypeID: PaymentTypeTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @TypeID( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "TypeID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: PaymentTypeTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Name( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Price: PaymentTypeTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Single? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Price( InequalityCondition.Operator op, System.Single? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Price", new DbParameterValue( value, "Real" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: PaymentTypeTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Created( InequalityCondition.Operator op, System.DateTime? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Created", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastUpdated: PaymentTypeTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LastUpdated( InequalityCondition.Operator op, System.DateTime? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LastUpdated", new DbParameterValue( value, "DateTime" ) ) ); } }
}
}
public static class @PaymentTypeTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TypeID: PaymentTypeTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TypeID( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "TypeID", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: PaymentTypeTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Name", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Price: PaymentTypeTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Price( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Price", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: PaymentTypeTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Created( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Created", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastUpdated: PaymentTypeTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastUpdated( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LastUpdated", subQuery ); } }
}
}
public static class @PaymentTypeTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TypeID: PaymentTypeTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TypeID( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "TypeID", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: PaymentTypeTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Name", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Price: PaymentTypeTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Price( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Price", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: PaymentTypeTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Created( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Created", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastUpdated: PaymentTypeTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastUpdated( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LastUpdated", value ); } }
}
}
public interface PerfLogTableCondition: TableCondition {}
public static class @PerfLogTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PerfLogID: PerfLogTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PerfLogID( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PerfLogID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TStamp: PerfLogTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TStamp( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "TStamp", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Category: PerfLogTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Category( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Category", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Code: PerfLogTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Code( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Code", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ElapsedTime: PerfLogTableCondition {
private readonly decimal value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ElapsedTime( decimal value ) {
this.value = value;
}
internal decimal Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ElapsedTime", new DbParameterValue( value, "Decimal" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Units: PerfLogTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Units( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Units", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsTest: PerfLogTableCondition {
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsTest( System.Boolean value ) {
this.value = value;
}
internal System.Boolean Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "IsTest", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Factor1: PerfLogTableCondition {
private readonly System.Decimal? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Factor1( System.Decimal? value ) {
this.value = value;
}
internal System.Decimal? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Factor1", new DbParameterValue( value, "Decimal" ) ) ); } }
}
}
public static class @PerfLogTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PerfLogID: PerfLogTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PerfLogID( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PerfLogID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TStamp: PerfLogTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @TStamp( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "TStamp", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Category: PerfLogTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Category( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Category", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Code: PerfLogTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Code( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Code", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ElapsedTime: PerfLogTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly decimal value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ElapsedTime( InequalityCondition.Operator op, decimal value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ElapsedTime", new DbParameterValue( value, "Decimal" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Units: PerfLogTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Units( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Units", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsTest: PerfLogTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @IsTest( InequalityCondition.Operator op, System.Boolean value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "IsTest", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Factor1: PerfLogTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Decimal? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Factor1( InequalityCondition.Operator op, System.Decimal? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Factor1", new DbParameterValue( value, "Decimal" ) ) ); } }
}
}
public static class @PerfLogTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PerfLogID: PerfLogTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PerfLogID( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PerfLogID", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TStamp: PerfLogTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TStamp( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "TStamp", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Category: PerfLogTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Category( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Category", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Code: PerfLogTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Code( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Code", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ElapsedTime: PerfLogTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ElapsedTime( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ElapsedTime", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Units: PerfLogTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Units( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Units", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsTest: PerfLogTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsTest( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "IsTest", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Factor1: PerfLogTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Factor1( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Factor1", subQuery ); } }
}
}
public static class @PerfLogTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PerfLogID: PerfLogTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PerfLogID( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PerfLogID", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TStamp: PerfLogTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TStamp( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "TStamp", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Category: PerfLogTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Category( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Category", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Code: PerfLogTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Code( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Code", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ElapsedTime: PerfLogTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ElapsedTime( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ElapsedTime", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Units: PerfLogTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Units( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Units", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsTest: PerfLogTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsTest( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "IsTest", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Factor1: PerfLogTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Factor1( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Factor1", value ); } }
}
}
public interface PhrStatusesTableCondition: TableCondition {}
public static class @PhrStatusesTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PhrStatusId: PhrStatusesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PhrStatusId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PhrStatusId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PhrStatus: PhrStatusesTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PhrStatus( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PhrStatus", new DbParameterValue( value, "VarChar" ) ) ); } }
}
}
public static class @PhrStatusesTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PhrStatusId: PhrStatusesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PhrStatusId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PhrStatusId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PhrStatus: PhrStatusesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PhrStatus( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PhrStatus", new DbParameterValue( value, "VarChar" ) ) ); } }
}
}
public static class @PhrStatusesTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PhrStatusId: PhrStatusesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PhrStatusId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PhrStatusId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PhrStatus: PhrStatusesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PhrStatus( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PhrStatus", subQuery ); } }
}
}
public static class @PhrStatusesTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PhrStatusId: PhrStatusesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PhrStatusId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PhrStatusId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PhrStatus: PhrStatusesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PhrStatus( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PhrStatus", value ); } }
}
}
public interface PhysicianTableCondition: TableCondition {}
public static class @PhysicianTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PhysicianID: PhysicianTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PhysicianID( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PhysicianID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ExternalID: PhysicianTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ExternalID( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ExternalID", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SpecialtyID: PhysicianTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SpecialtyID( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "SpecialtyID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkGroupID: PhysicianTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @WorkGroupID( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "WorkGroupID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FirstName: PhysicianTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FirstName( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "FirstName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastName: PhysicianTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastName( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LastName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MiddleInitial: PhysicianTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MiddleInitial( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "MiddleInitial", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Company: PhysicianTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Company( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Company", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Address: PhysicianTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Address( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Address", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @City: PhysicianTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @City( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "City", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @State: PhysicianTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @State( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "State", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Zip: PhysicianTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Zip( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Zip", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Phone: PhysicianTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Phone( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Phone", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastUpdated: PhysicianTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastUpdated( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LastUpdated", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: PhysicianTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Created( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Created", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Hidden: PhysicianTableCondition {
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Hidden( System.Boolean value ) {
this.value = value;
}
internal System.Boolean Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Hidden", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ProviderNPI: PhysicianTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ProviderNPI( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ProviderNPI", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkgroupLocationId: PhysicianTableCondition {
private readonly System.Int32? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @WorkgroupLocationId( System.Int32? value ) {
this.value = value;
}
internal System.Int32? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "WorkgroupLocationId", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @PhysicianTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PhysicianID: PhysicianTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PhysicianID( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PhysicianID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ExternalID: PhysicianTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ExternalID( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ExternalID", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SpecialtyID: PhysicianTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @SpecialtyID( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "SpecialtyID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkGroupID: PhysicianTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @WorkGroupID( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "WorkGroupID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FirstName: PhysicianTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @FirstName( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "FirstName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastName: PhysicianTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LastName( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LastName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MiddleInitial: PhysicianTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @MiddleInitial( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "MiddleInitial", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Company: PhysicianTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Company( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Company", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Address: PhysicianTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Address( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Address", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @City: PhysicianTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @City( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "City", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @State: PhysicianTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @State( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "State", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Zip: PhysicianTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Zip( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Zip", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Phone: PhysicianTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Phone( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Phone", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastUpdated: PhysicianTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LastUpdated( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LastUpdated", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: PhysicianTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Created( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Created", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Hidden: PhysicianTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Hidden( InequalityCondition.Operator op, System.Boolean value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Hidden", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ProviderNPI: PhysicianTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ProviderNPI( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ProviderNPI", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkgroupLocationId: PhysicianTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Int32? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @WorkgroupLocationId( InequalityCondition.Operator op, System.Int32? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "WorkgroupLocationId", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @PhysicianTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PhysicianID: PhysicianTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PhysicianID( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PhysicianID", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ExternalID: PhysicianTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ExternalID( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ExternalID", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SpecialtyID: PhysicianTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SpecialtyID( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "SpecialtyID", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkGroupID: PhysicianTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @WorkGroupID( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "WorkGroupID", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FirstName: PhysicianTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FirstName( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "FirstName", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastName: PhysicianTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastName( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LastName", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MiddleInitial: PhysicianTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MiddleInitial( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "MiddleInitial", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Company: PhysicianTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Company( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Company", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Address: PhysicianTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Address( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Address", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @City: PhysicianTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @City( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "City", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @State: PhysicianTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @State( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "State", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Zip: PhysicianTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Zip( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Zip", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Phone: PhysicianTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Phone( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Phone", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastUpdated: PhysicianTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastUpdated( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LastUpdated", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: PhysicianTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Created( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Created", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Hidden: PhysicianTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Hidden( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Hidden", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ProviderNPI: PhysicianTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ProviderNPI( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ProviderNPI", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkgroupLocationId: PhysicianTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @WorkgroupLocationId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "WorkgroupLocationId", subQuery ); } }
}
}
public static class @PhysicianTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PhysicianID: PhysicianTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PhysicianID( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PhysicianID", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ExternalID: PhysicianTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ExternalID( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ExternalID", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SpecialtyID: PhysicianTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SpecialtyID( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "SpecialtyID", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkGroupID: PhysicianTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @WorkGroupID( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "WorkGroupID", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FirstName: PhysicianTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FirstName( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "FirstName", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastName: PhysicianTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastName( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LastName", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MiddleInitial: PhysicianTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MiddleInitial( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "MiddleInitial", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Company: PhysicianTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Company( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Company", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Address: PhysicianTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Address( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Address", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @City: PhysicianTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @City( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "City", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @State: PhysicianTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @State( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "State", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Zip: PhysicianTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Zip( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Zip", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Phone: PhysicianTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Phone( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Phone", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastUpdated: PhysicianTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastUpdated( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LastUpdated", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: PhysicianTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Created( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Created", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Hidden: PhysicianTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Hidden( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Hidden", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ProviderNPI: PhysicianTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ProviderNPI( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ProviderNPI", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkgroupLocationId: PhysicianTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @WorkgroupLocationId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "WorkgroupLocationId", value ); } }
}
}
public interface PreviousPasswordsTableCondition: TableCondition {}
public static class @PreviousPasswordsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PreviousPasswordId: PreviousPasswordsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PreviousPasswordId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PreviousPasswordId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: PreviousPasswordsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Salt: PreviousPasswordsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Salt( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Salt", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Password: PreviousPasswordsTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Password( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Password", new DbParameterValue( value, "Binary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Date: PreviousPasswordsTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Date( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Date", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
}
public static class @PreviousPasswordsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PreviousPasswordId: PreviousPasswordsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PreviousPasswordId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PreviousPasswordId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: PreviousPasswordsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UserId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Salt: PreviousPasswordsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Salt( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Salt", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Password: PreviousPasswordsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Password( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Password", new DbParameterValue( value, "Binary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Date: PreviousPasswordsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Date( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Date", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
}
public static class @PreviousPasswordsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PreviousPasswordId: PreviousPasswordsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PreviousPasswordId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PreviousPasswordId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: PreviousPasswordsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UserId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Salt: PreviousPasswordsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Salt( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Salt", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Password: PreviousPasswordsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Password( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Password", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Date: PreviousPasswordsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Date( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Date", subQuery ); } }
}
}
public static class @PreviousPasswordsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PreviousPasswordId: PreviousPasswordsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PreviousPasswordId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PreviousPasswordId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: PreviousPasswordsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UserId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Salt: PreviousPasswordsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Salt( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Salt", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Password: PreviousPasswordsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Password( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Password", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Date: PreviousPasswordsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Date( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Date", value ); } }
}
}
public interface ProviderTableCondition: TableCondition {}
public static class @ProviderTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ProviderID: ProviderTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ProviderID( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ProviderID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TypeID: ProviderTableCondition {
private readonly System.Int32? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TypeID( System.Int32? value ) {
this.value = value;
}
internal System.Int32? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "TypeID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: ProviderTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Namespace: ProviderTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Namespace( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Namespace", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsEnabled: ProviderTableCondition {
private readonly System.Boolean? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsEnabled( System.Boolean? value ) {
this.value = value;
}
internal System.Boolean? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "IsEnabled", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsCurrent: ProviderTableCondition {
private readonly System.Boolean? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsCurrent( System.Boolean? value ) {
this.value = value;
}
internal System.Boolean? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "IsCurrent", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastModified: ProviderTableCondition {
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastModified( System.DateTime? value ) {
this.value = value;
}
internal System.DateTime? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LastModified", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: ProviderTableCondition {
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Created( System.DateTime? value ) {
this.value = value;
}
internal System.DateTime? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Created", new DbParameterValue( value, "DateTime" ) ) ); } }
}
}
public static class @ProviderTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ProviderID: ProviderTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ProviderID( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ProviderID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TypeID: ProviderTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Int32? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @TypeID( InequalityCondition.Operator op, System.Int32? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "TypeID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: ProviderTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Name( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Namespace: ProviderTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Namespace( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Namespace", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsEnabled: ProviderTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Boolean? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @IsEnabled( InequalityCondition.Operator op, System.Boolean? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "IsEnabled", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsCurrent: ProviderTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Boolean? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @IsCurrent( InequalityCondition.Operator op, System.Boolean? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "IsCurrent", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastModified: ProviderTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LastModified( InequalityCondition.Operator op, System.DateTime? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LastModified", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: ProviderTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Created( InequalityCondition.Operator op, System.DateTime? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Created", new DbParameterValue( value, "DateTime" ) ) ); } }
}
}
public static class @ProviderTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ProviderID: ProviderTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ProviderID( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ProviderID", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TypeID: ProviderTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TypeID( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "TypeID", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: ProviderTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Name", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Namespace: ProviderTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Namespace( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Namespace", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsEnabled: ProviderTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsEnabled( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "IsEnabled", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsCurrent: ProviderTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsCurrent( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "IsCurrent", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastModified: ProviderTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastModified( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LastModified", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: ProviderTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Created( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Created", subQuery ); } }
}
}
public static class @ProviderTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ProviderID: ProviderTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ProviderID( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ProviderID", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TypeID: ProviderTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TypeID( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "TypeID", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: ProviderTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Name", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Namespace: ProviderTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Namespace( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Namespace", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsEnabled: ProviderTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsEnabled( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "IsEnabled", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsCurrent: ProviderTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsCurrent( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "IsCurrent", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastModified: ProviderTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastModified( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LastModified", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: ProviderTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Created( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Created", value ); } }
}
}
public interface ProviderPortalUsersTableCondition: TableCondition {}
public static class @ProviderPortalUsersTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ProviderPortalUserId: ProviderPortalUsersTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ProviderPortalUserId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ProviderPortalUserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RhioUserName: ProviderPortalUsersTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @RhioUserName( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "RhioUserName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: ProviderPortalUsersTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @NationalProviderIdentifier: ProviderPortalUsersTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @NationalProviderIdentifier( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "NationalProviderIdentifier", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @ProviderPortalUsersTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ProviderPortalUserId: ProviderPortalUsersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ProviderPortalUserId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ProviderPortalUserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RhioUserName: ProviderPortalUsersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @RhioUserName( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "RhioUserName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: ProviderPortalUsersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UserId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @NationalProviderIdentifier: ProviderPortalUsersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @NationalProviderIdentifier( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "NationalProviderIdentifier", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @ProviderPortalUsersTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ProviderPortalUserId: ProviderPortalUsersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ProviderPortalUserId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ProviderPortalUserId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RhioUserName: ProviderPortalUsersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @RhioUserName( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "RhioUserName", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: ProviderPortalUsersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UserId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @NationalProviderIdentifier: ProviderPortalUsersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @NationalProviderIdentifier( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "NationalProviderIdentifier", subQuery ); } }
}
}
public static class @ProviderPortalUsersTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ProviderPortalUserId: ProviderPortalUsersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ProviderPortalUserId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ProviderPortalUserId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RhioUserName: ProviderPortalUsersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @RhioUserName( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "RhioUserName", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: ProviderPortalUsersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UserId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @NationalProviderIdentifier: ProviderPortalUsersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @NationalProviderIdentifier( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "NationalProviderIdentifier", value ); } }
}
}
public interface ProviderPortalUsersToCareZonesTableCondition: TableCondition {}
public static class @ProviderPortalUsersToCareZonesTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ProviderPortalUsersToCareZonesId: ProviderPortalUsersToCareZonesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ProviderPortalUsersToCareZonesId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ProviderPortalUsersToCareZonesId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ProviderPortalUserId: ProviderPortalUsersToCareZonesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ProviderPortalUserId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ProviderPortalUserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CareZoneId: ProviderPortalUsersToCareZonesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @CareZoneId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "CareZoneId", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @ProviderPortalUsersToCareZonesTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ProviderPortalUsersToCareZonesId: ProviderPortalUsersToCareZonesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ProviderPortalUsersToCareZonesId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ProviderPortalUsersToCareZonesId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ProviderPortalUserId: ProviderPortalUsersToCareZonesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ProviderPortalUserId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ProviderPortalUserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CareZoneId: ProviderPortalUsersToCareZonesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @CareZoneId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "CareZoneId", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @ProviderPortalUsersToCareZonesTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ProviderPortalUsersToCareZonesId: ProviderPortalUsersToCareZonesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ProviderPortalUsersToCareZonesId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ProviderPortalUsersToCareZonesId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ProviderPortalUserId: ProviderPortalUsersToCareZonesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ProviderPortalUserId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ProviderPortalUserId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CareZoneId: ProviderPortalUsersToCareZonesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @CareZoneId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "CareZoneId", subQuery ); } }
}
}
public static class @ProviderPortalUsersToCareZonesTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ProviderPortalUsersToCareZonesId: ProviderPortalUsersToCareZonesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ProviderPortalUsersToCareZonesId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ProviderPortalUsersToCareZonesId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ProviderPortalUserId: ProviderPortalUsersToCareZonesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ProviderPortalUserId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ProviderPortalUserId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CareZoneId: ProviderPortalUsersToCareZonesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @CareZoneId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "CareZoneId", value ); } }
}
}
public interface ProviderPortalUsersToNewCareZonesTableCondition: TableCondition {}
public static class @ProviderPortalUsersToNewCareZonesTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ProviderPortalUserId: ProviderPortalUsersToNewCareZonesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ProviderPortalUserId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ProviderPortalUserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CareZoneId: ProviderPortalUsersToNewCareZonesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @CareZoneId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "CareZoneId", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @ProviderPortalUsersToNewCareZonesTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ProviderPortalUserId: ProviderPortalUsersToNewCareZonesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ProviderPortalUserId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ProviderPortalUserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CareZoneId: ProviderPortalUsersToNewCareZonesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @CareZoneId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "CareZoneId", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @ProviderPortalUsersToNewCareZonesTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ProviderPortalUserId: ProviderPortalUsersToNewCareZonesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ProviderPortalUserId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ProviderPortalUserId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CareZoneId: ProviderPortalUsersToNewCareZonesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @CareZoneId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "CareZoneId", subQuery ); } }
}
}
public static class @ProviderPortalUsersToNewCareZonesTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ProviderPortalUserId: ProviderPortalUsersToNewCareZonesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ProviderPortalUserId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ProviderPortalUserId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CareZoneId: ProviderPortalUsersToNewCareZonesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @CareZoneId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "CareZoneId", value ); } }
}
}
public interface ProviderTypeTableCondition: TableCondition {}
public static class @ProviderTypeTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TypeID: ProviderTypeTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TypeID( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "TypeID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: ProviderTypeTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastModified: ProviderTypeTableCondition {
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastModified( System.DateTime? value ) {
this.value = value;
}
internal System.DateTime? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LastModified", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: ProviderTypeTableCondition {
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Created( System.DateTime? value ) {
this.value = value;
}
internal System.DateTime? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Created", new DbParameterValue( value, "DateTime" ) ) ); } }
}
}
public static class @ProviderTypeTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TypeID: ProviderTypeTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @TypeID( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "TypeID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: ProviderTypeTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Name( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastModified: ProviderTypeTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LastModified( InequalityCondition.Operator op, System.DateTime? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LastModified", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: ProviderTypeTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Created( InequalityCondition.Operator op, System.DateTime? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Created", new DbParameterValue( value, "DateTime" ) ) ); } }
}
}
public static class @ProviderTypeTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TypeID: ProviderTypeTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TypeID( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "TypeID", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: ProviderTypeTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Name", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastModified: ProviderTypeTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastModified( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LastModified", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: ProviderTypeTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Created( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Created", subQuery ); } }
}
}
public static class @ProviderTypeTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TypeID: ProviderTypeTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TypeID( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "TypeID", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: ProviderTypeTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Name", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastModified: ProviderTypeTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastModified( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LastModified", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: ProviderTypeTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Created( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Created", value ); } }
}
}
public interface RolesTableCondition: TableCondition {}
public static class @RolesTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RoleId: RolesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @RoleId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "RoleId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RoleName: RolesTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @RoleName( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "RoleName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @RolesTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RoleId: RolesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @RoleId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "RoleId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RoleName: RolesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @RoleName( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "RoleName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @RolesTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RoleId: RolesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @RoleId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "RoleId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RoleName: RolesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @RoleName( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "RoleName", subQuery ); } }
}
}
public static class @RolesTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RoleId: RolesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @RoleId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "RoleId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RoleName: RolesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @RoleName( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "RoleName", value ); } }
}
}
public interface SalesforceContactsTableCondition: TableCondition {}
public static class @SalesforceContactsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SalesforceContactId: SalesforceContactsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SalesforceContactId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "SalesforceContactId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PersonalDirectAddress: SalesforceContactsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PersonalDirectAddress( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PersonalDirectAddress", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Title: SalesforceContactsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Title( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Title", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FirstName: SalesforceContactsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FirstName( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "FirstName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastName: SalesforceContactsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastName( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LastName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PhoneNumber: SalesforceContactsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PhoneNumber( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PhoneNumber", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SalesforceOrganizationId: SalesforceContactsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SalesforceOrganizationId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "SalesforceOrganizationId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsVhrUser: SalesforceContactsTableCondition {
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsVhrUser( System.Boolean value ) {
this.value = value;
}
internal System.Boolean Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "IsVhrUser", new DbParameterValue( value, "Bit" ) ) ); } }
}
}
public static class @SalesforceContactsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SalesforceContactId: SalesforceContactsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @SalesforceContactId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "SalesforceContactId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PersonalDirectAddress: SalesforceContactsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PersonalDirectAddress( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PersonalDirectAddress", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Title: SalesforceContactsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Title( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Title", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FirstName: SalesforceContactsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @FirstName( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "FirstName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastName: SalesforceContactsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LastName( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LastName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PhoneNumber: SalesforceContactsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PhoneNumber( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PhoneNumber", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SalesforceOrganizationId: SalesforceContactsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @SalesforceOrganizationId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "SalesforceOrganizationId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsVhrUser: SalesforceContactsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @IsVhrUser( InequalityCondition.Operator op, System.Boolean value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "IsVhrUser", new DbParameterValue( value, "Bit" ) ) ); } }
}
}
public static class @SalesforceContactsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SalesforceContactId: SalesforceContactsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SalesforceContactId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "SalesforceContactId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PersonalDirectAddress: SalesforceContactsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PersonalDirectAddress( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PersonalDirectAddress", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Title: SalesforceContactsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Title( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Title", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FirstName: SalesforceContactsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FirstName( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "FirstName", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastName: SalesforceContactsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastName( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LastName", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PhoneNumber: SalesforceContactsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PhoneNumber( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PhoneNumber", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SalesforceOrganizationId: SalesforceContactsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SalesforceOrganizationId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "SalesforceOrganizationId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsVhrUser: SalesforceContactsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsVhrUser( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "IsVhrUser", subQuery ); } }
}
}
public static class @SalesforceContactsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SalesforceContactId: SalesforceContactsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SalesforceContactId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "SalesforceContactId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PersonalDirectAddress: SalesforceContactsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PersonalDirectAddress( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PersonalDirectAddress", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Title: SalesforceContactsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Title( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Title", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FirstName: SalesforceContactsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FirstName( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "FirstName", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastName: SalesforceContactsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastName( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LastName", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PhoneNumber: SalesforceContactsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PhoneNumber( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PhoneNumber", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SalesforceOrganizationId: SalesforceContactsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SalesforceOrganizationId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "SalesforceOrganizationId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsVhrUser: SalesforceContactsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsVhrUser( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "IsVhrUser", value ); } }
}
}
public interface SalesforceOrganizationsTableCondition: TableCondition {}
public static class @SalesforceOrganizationsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SalesforceOrganizationId: SalesforceOrganizationsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SalesforceOrganizationId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "SalesforceOrganizationId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @OrganizationName: SalesforceOrganizationsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @OrganizationName( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "OrganizationName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ParentOrganizationId: SalesforceOrganizationsTableCondition {
private readonly System.Int32? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ParentOrganizationId( System.Int32? value ) {
this.value = value;
}
internal System.Int32? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ParentOrganizationId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DirectAddress: SalesforceOrganizationsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DirectAddress( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "DirectAddress", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PhoneNumber: SalesforceOrganizationsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PhoneNumber( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PhoneNumber", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Street: SalesforceOrganizationsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Street( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Street", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Street2: SalesforceOrganizationsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Street2( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Street2", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @City: SalesforceOrganizationsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @City( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "City", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @StateId: SalesforceOrganizationsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @StateId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "StateId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ZipCode: SalesforceOrganizationsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ZipCode( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ZipCode", new DbParameterValue( value, "VarChar" ) ) ); } }
}
}
public static class @SalesforceOrganizationsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SalesforceOrganizationId: SalesforceOrganizationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @SalesforceOrganizationId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "SalesforceOrganizationId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @OrganizationName: SalesforceOrganizationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @OrganizationName( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "OrganizationName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ParentOrganizationId: SalesforceOrganizationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Int32? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ParentOrganizationId( InequalityCondition.Operator op, System.Int32? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ParentOrganizationId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DirectAddress: SalesforceOrganizationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @DirectAddress( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "DirectAddress", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PhoneNumber: SalesforceOrganizationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PhoneNumber( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PhoneNumber", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Street: SalesforceOrganizationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Street( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Street", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Street2: SalesforceOrganizationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Street2( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Street2", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @City: SalesforceOrganizationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @City( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "City", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @StateId: SalesforceOrganizationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @StateId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "StateId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ZipCode: SalesforceOrganizationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ZipCode( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ZipCode", new DbParameterValue( value, "VarChar" ) ) ); } }
}
}
public static class @SalesforceOrganizationsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SalesforceOrganizationId: SalesforceOrganizationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SalesforceOrganizationId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "SalesforceOrganizationId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @OrganizationName: SalesforceOrganizationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @OrganizationName( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "OrganizationName", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ParentOrganizationId: SalesforceOrganizationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ParentOrganizationId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ParentOrganizationId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DirectAddress: SalesforceOrganizationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DirectAddress( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "DirectAddress", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PhoneNumber: SalesforceOrganizationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PhoneNumber( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PhoneNumber", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Street: SalesforceOrganizationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Street( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Street", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Street2: SalesforceOrganizationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Street2( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Street2", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @City: SalesforceOrganizationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @City( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "City", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @StateId: SalesforceOrganizationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @StateId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "StateId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ZipCode: SalesforceOrganizationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ZipCode( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ZipCode", subQuery ); } }
}
}
public static class @SalesforceOrganizationsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SalesforceOrganizationId: SalesforceOrganizationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SalesforceOrganizationId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "SalesforceOrganizationId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @OrganizationName: SalesforceOrganizationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @OrganizationName( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "OrganizationName", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ParentOrganizationId: SalesforceOrganizationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ParentOrganizationId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ParentOrganizationId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DirectAddress: SalesforceOrganizationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DirectAddress( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "DirectAddress", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PhoneNumber: SalesforceOrganizationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PhoneNumber( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PhoneNumber", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Street: SalesforceOrganizationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Street( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Street", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Street2: SalesforceOrganizationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Street2( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Street2", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @City: SalesforceOrganizationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @City( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "City", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @StateId: SalesforceOrganizationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @StateId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "StateId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ZipCode: SalesforceOrganizationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ZipCode( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ZipCode", value ); } }
}
}
public interface ScanAttachFileTableCondition: TableCondition {}
public static class @ScanAttachFileTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileID: ScanAttachFileTableCondition {
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FileID( System.Guid value ) {
this.value = value;
}
internal System.Guid Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "FileID", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncKV: ScanAttachFileTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncKV( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EncKV", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncIV: ScanAttachFileTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncIV( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EncIV", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ElysiumID: ScanAttachFileTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ElysiumID( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ElysiumID", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Category: ScanAttachFileTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Category( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Category", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileStatus: ScanAttachFileTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FileStatus( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "FileStatus", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DateUploaded: ScanAttachFileTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DateUploaded( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "DateUploaded", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DateUpdated: ScanAttachFileTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DateUpdated( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "DateUpdated", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SuggestedFileName: ScanAttachFileTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SuggestedFileName( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "SuggestedFileName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileMimeType: ScanAttachFileTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FileMimeType( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "FileMimeType", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileBytesEncrypted: ScanAttachFileTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FileBytesEncrypted( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "FileBytesEncrypted", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientUserID: ScanAttachFileTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PatientUserID( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PatientUserID", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
}
public static class @ScanAttachFileTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileID: ScanAttachFileTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @FileID( InequalityCondition.Operator op, System.Guid value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "FileID", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncKV: ScanAttachFileTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EncKV( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EncKV", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncIV: ScanAttachFileTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EncIV( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EncIV", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ElysiumID: ScanAttachFileTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ElysiumID( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ElysiumID", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Category: ScanAttachFileTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Category( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Category", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileStatus: ScanAttachFileTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @FileStatus( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "FileStatus", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DateUploaded: ScanAttachFileTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @DateUploaded( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "DateUploaded", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DateUpdated: ScanAttachFileTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @DateUpdated( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "DateUpdated", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SuggestedFileName: ScanAttachFileTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @SuggestedFileName( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "SuggestedFileName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileMimeType: ScanAttachFileTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @FileMimeType( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "FileMimeType", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileBytesEncrypted: ScanAttachFileTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @FileBytesEncrypted( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "FileBytesEncrypted", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientUserID: ScanAttachFileTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PatientUserID( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PatientUserID", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
}
public static class @ScanAttachFileTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileID: ScanAttachFileTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FileID( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "FileID", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncKV: ScanAttachFileTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncKV( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EncKV", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncIV: ScanAttachFileTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncIV( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EncIV", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ElysiumID: ScanAttachFileTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ElysiumID( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ElysiumID", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Category: ScanAttachFileTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Category( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Category", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileStatus: ScanAttachFileTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FileStatus( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "FileStatus", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DateUploaded: ScanAttachFileTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DateUploaded( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "DateUploaded", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DateUpdated: ScanAttachFileTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DateUpdated( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "DateUpdated", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SuggestedFileName: ScanAttachFileTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SuggestedFileName( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "SuggestedFileName", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileMimeType: ScanAttachFileTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FileMimeType( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "FileMimeType", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileBytesEncrypted: ScanAttachFileTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FileBytesEncrypted( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "FileBytesEncrypted", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientUserID: ScanAttachFileTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PatientUserID( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PatientUserID", subQuery ); } }
}
}
public static class @ScanAttachFileTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileID: ScanAttachFileTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FileID( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "FileID", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncKV: ScanAttachFileTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncKV( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EncKV", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncIV: ScanAttachFileTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncIV( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EncIV", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ElysiumID: ScanAttachFileTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ElysiumID( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ElysiumID", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Category: ScanAttachFileTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Category( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Category", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileStatus: ScanAttachFileTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FileStatus( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "FileStatus", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DateUploaded: ScanAttachFileTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DateUploaded( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "DateUploaded", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DateUpdated: ScanAttachFileTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DateUpdated( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "DateUpdated", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SuggestedFileName: ScanAttachFileTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SuggestedFileName( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "SuggestedFileName", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileMimeType: ScanAttachFileTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FileMimeType( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "FileMimeType", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FileBytesEncrypted: ScanAttachFileTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FileBytesEncrypted( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "FileBytesEncrypted", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientUserID: ScanAttachFileTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PatientUserID( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PatientUserID", value ); } }
}
}
public interface SpecialtyTableCondition: TableCondition {}
public static class @SpecialtyTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SpecialtyID: SpecialtyTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SpecialtyID( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "SpecialtyID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: SpecialtyTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastModified: SpecialtyTableCondition {
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastModified( System.DateTime? value ) {
this.value = value;
}
internal System.DateTime? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LastModified", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: SpecialtyTableCondition {
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Created( System.DateTime? value ) {
this.value = value;
}
internal System.DateTime? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Created", new DbParameterValue( value, "DateTime" ) ) ); } }
}
}
public static class @SpecialtyTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SpecialtyID: SpecialtyTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @SpecialtyID( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "SpecialtyID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: SpecialtyTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Name( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastModified: SpecialtyTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LastModified( InequalityCondition.Operator op, System.DateTime? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LastModified", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: SpecialtyTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Created( InequalityCondition.Operator op, System.DateTime? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Created", new DbParameterValue( value, "DateTime" ) ) ); } }
}
}
public static class @SpecialtyTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SpecialtyID: SpecialtyTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SpecialtyID( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "SpecialtyID", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: SpecialtyTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Name", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastModified: SpecialtyTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastModified( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LastModified", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: SpecialtyTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Created( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Created", subQuery ); } }
}
}
public static class @SpecialtyTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SpecialtyID: SpecialtyTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SpecialtyID( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "SpecialtyID", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: SpecialtyTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Name", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastModified: SpecialtyTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastModified( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LastModified", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: SpecialtyTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Created( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Created", value ); } }
}
}
public interface StatesTableCondition: TableCondition {}
public static class @StatesTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @StateId: StatesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @StateId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "StateId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: StatesTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Abbreviation: StatesTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Abbreviation( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Abbreviation", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @StatesTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @StateId: StatesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @StateId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "StateId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: StatesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Name( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Abbreviation: StatesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Abbreviation( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Abbreviation", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @StatesTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @StateId: StatesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @StateId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "StateId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: StatesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Name", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Abbreviation: StatesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Abbreviation( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Abbreviation", subQuery ); } }
}
}
public static class @StatesTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @StateId: StatesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @StateId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "StateId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: StatesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Name", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Abbreviation: StatesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Abbreviation( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Abbreviation", value ); } }
}
}
public interface sysdiagramsTableCondition: TableCondition {}
public static class @sysdiagramsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @name: sysdiagramsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @name( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @principal_id: sysdiagramsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @principal_id( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "principal_id", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @diagram_id: sysdiagramsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @diagram_id( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "diagram_id", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @version: sysdiagramsTableCondition {
private readonly System.Int32? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @version( System.Int32? value ) {
this.value = value;
}
internal System.Int32? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "version", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @definition: sysdiagramsTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @definition( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "definition", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
}
public static class @sysdiagramsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @name: sysdiagramsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @name( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @principal_id: sysdiagramsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @principal_id( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "principal_id", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @diagram_id: sysdiagramsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @diagram_id( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "diagram_id", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @version: sysdiagramsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Int32? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @version( InequalityCondition.Operator op, System.Int32? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "version", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @definition: sysdiagramsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @definition( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "definition", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
}
public static class @sysdiagramsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @name: sysdiagramsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @name( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "name", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @principal_id: sysdiagramsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @principal_id( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "principal_id", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @diagram_id: sysdiagramsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @diagram_id( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "diagram_id", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @version: sysdiagramsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @version( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "version", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @definition: sysdiagramsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @definition( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "definition", subQuery ); } }
}
}
public static class @sysdiagramsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @name: sysdiagramsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @name( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "name", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @principal_id: sysdiagramsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @principal_id( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "principal_id", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @diagram_id: sysdiagramsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @diagram_id( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "diagram_id", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @version: sysdiagramsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @version( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "version", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @definition: sysdiagramsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @definition( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "definition", value ); } }
}
}
public interface TempPreDertEventLogsTableCondition: TableCondition {}
public static class @TempPreDertEventLogsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TempPreDertEventLogId: TempPreDertEventLogsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TempPreDertEventLogId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "TempPreDertEventLogId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventDate: TempPreDertEventLogsTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventDate( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EventDate", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AdministratorUserId: TempPreDertEventLogsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AdministratorUserId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "AdministratorUserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AffectedUserId: TempPreDertEventLogsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AffectedUserId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "AffectedUserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventCode: TempPreDertEventLogsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventCode( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EventCode", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LogMessage: TempPreDertEventLogsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LogMessage( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LogMessage", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @TempPreDertEventLogsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TempPreDertEventLogId: TempPreDertEventLogsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @TempPreDertEventLogId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "TempPreDertEventLogId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventDate: TempPreDertEventLogsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EventDate( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EventDate", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AdministratorUserId: TempPreDertEventLogsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @AdministratorUserId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "AdministratorUserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AffectedUserId: TempPreDertEventLogsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @AffectedUserId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "AffectedUserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventCode: TempPreDertEventLogsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EventCode( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EventCode", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LogMessage: TempPreDertEventLogsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LogMessage( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LogMessage", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @TempPreDertEventLogsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TempPreDertEventLogId: TempPreDertEventLogsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TempPreDertEventLogId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "TempPreDertEventLogId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventDate: TempPreDertEventLogsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventDate( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EventDate", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AdministratorUserId: TempPreDertEventLogsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AdministratorUserId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "AdministratorUserId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AffectedUserId: TempPreDertEventLogsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AffectedUserId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "AffectedUserId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventCode: TempPreDertEventLogsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventCode( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EventCode", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LogMessage: TempPreDertEventLogsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LogMessage( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LogMessage", subQuery ); } }
}
}
public static class @TempPreDertEventLogsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TempPreDertEventLogId: TempPreDertEventLogsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TempPreDertEventLogId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "TempPreDertEventLogId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventDate: TempPreDertEventLogsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventDate( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EventDate", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AdministratorUserId: TempPreDertEventLogsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AdministratorUserId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "AdministratorUserId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AffectedUserId: TempPreDertEventLogsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AffectedUserId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "AffectedUserId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EventCode: TempPreDertEventLogsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EventCode( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EventCode", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LogMessage: TempPreDertEventLogsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LogMessage( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LogMessage", value ); } }
}
}
public interface TfaMethodsTableCondition: TableCondition {}
public static class @TfaMethodsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TfaMethodId: TfaMethodsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TfaMethodId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "TfaMethodId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Method: TfaMethodsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Method( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Method", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @TfaMethodsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TfaMethodId: TfaMethodsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @TfaMethodId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "TfaMethodId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Method: TfaMethodsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Method( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Method", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @TfaMethodsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TfaMethodId: TfaMethodsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TfaMethodId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "TfaMethodId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Method: TfaMethodsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Method( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Method", subQuery ); } }
}
}
public static class @TfaMethodsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TfaMethodId: TfaMethodsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TfaMethodId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "TfaMethodId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Method: TfaMethodsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Method( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Method", value ); } }
}
}
public interface TrainingContentTableCondition: TableCondition {}
public static class @TrainingContentTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TrainingContentId: TrainingContentTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TrainingContentId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "TrainingContentId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Text: TrainingContentTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Text( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Text", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HtmlBlockId: TrainingContentTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @HtmlBlockId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "HtmlBlockId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @OrderRankId: TrainingContentTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @OrderRankId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "OrderRankId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TrainingCourseTypeId: TrainingContentTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TrainingCourseTypeId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "TrainingCourseTypeId", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @TrainingContentTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TrainingContentId: TrainingContentTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @TrainingContentId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "TrainingContentId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Text: TrainingContentTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Text( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Text", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HtmlBlockId: TrainingContentTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @HtmlBlockId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "HtmlBlockId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @OrderRankId: TrainingContentTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @OrderRankId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "OrderRankId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TrainingCourseTypeId: TrainingContentTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @TrainingCourseTypeId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "TrainingCourseTypeId", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @TrainingContentTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TrainingContentId: TrainingContentTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TrainingContentId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "TrainingContentId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Text: TrainingContentTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Text( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Text", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HtmlBlockId: TrainingContentTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @HtmlBlockId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "HtmlBlockId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @OrderRankId: TrainingContentTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @OrderRankId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "OrderRankId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TrainingCourseTypeId: TrainingContentTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TrainingCourseTypeId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "TrainingCourseTypeId", subQuery ); } }
}
}
public static class @TrainingContentTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TrainingContentId: TrainingContentTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TrainingContentId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "TrainingContentId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Text: TrainingContentTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Text( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Text", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HtmlBlockId: TrainingContentTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @HtmlBlockId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "HtmlBlockId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @OrderRankId: TrainingContentTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @OrderRankId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "OrderRankId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TrainingCourseTypeId: TrainingContentTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TrainingCourseTypeId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "TrainingCourseTypeId", value ); } }
}
}
public interface TrainingCoursesTableCondition: TableCondition {}
public static class @TrainingCoursesTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TrainingCourseId: TrainingCoursesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TrainingCourseId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "TrainingCourseId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: TrainingCoursesTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DestinationUrl: TrainingCoursesTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DestinationUrl( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "DestinationUrl", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsPerpetual: TrainingCoursesTableCondition {
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsPerpetual( System.Boolean value ) {
this.value = value;
}
internal System.Boolean Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "IsPerpetual", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsArchived: TrainingCoursesTableCondition {
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsArchived( System.Boolean value ) {
this.value = value;
}
internal System.Boolean Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "IsArchived", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TrainingCourseTypeId: TrainingCoursesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TrainingCourseTypeId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "TrainingCourseTypeId", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @TrainingCoursesTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TrainingCourseId: TrainingCoursesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @TrainingCourseId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "TrainingCourseId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: TrainingCoursesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Name( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DestinationUrl: TrainingCoursesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @DestinationUrl( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "DestinationUrl", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsPerpetual: TrainingCoursesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @IsPerpetual( InequalityCondition.Operator op, System.Boolean value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "IsPerpetual", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsArchived: TrainingCoursesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @IsArchived( InequalityCondition.Operator op, System.Boolean value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "IsArchived", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TrainingCourseTypeId: TrainingCoursesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @TrainingCourseTypeId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "TrainingCourseTypeId", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @TrainingCoursesTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TrainingCourseId: TrainingCoursesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TrainingCourseId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "TrainingCourseId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: TrainingCoursesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Name", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DestinationUrl: TrainingCoursesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DestinationUrl( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "DestinationUrl", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsPerpetual: TrainingCoursesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsPerpetual( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "IsPerpetual", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsArchived: TrainingCoursesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsArchived( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "IsArchived", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TrainingCourseTypeId: TrainingCoursesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TrainingCourseTypeId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "TrainingCourseTypeId", subQuery ); } }
}
}
public static class @TrainingCoursesTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TrainingCourseId: TrainingCoursesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TrainingCourseId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "TrainingCourseId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: TrainingCoursesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Name", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DestinationUrl: TrainingCoursesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DestinationUrl( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "DestinationUrl", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsPerpetual: TrainingCoursesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsPerpetual( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "IsPerpetual", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsArchived: TrainingCoursesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsArchived( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "IsArchived", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TrainingCourseTypeId: TrainingCoursesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TrainingCourseTypeId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "TrainingCourseTypeId", value ); } }
}
}
public interface TrainingCourseTypesTableCondition: TableCondition {}
public static class @TrainingCourseTypesTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TrainingCourseTypeId: TrainingCourseTypesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TrainingCourseTypeId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "TrainingCourseTypeId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: TrainingCourseTypesTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @TrainingCourseTypesTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TrainingCourseTypeId: TrainingCourseTypesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @TrainingCourseTypeId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "TrainingCourseTypeId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: TrainingCourseTypesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Name( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @TrainingCourseTypesTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TrainingCourseTypeId: TrainingCourseTypesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TrainingCourseTypeId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "TrainingCourseTypeId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: TrainingCourseTypesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Name", subQuery ); } }
}
}
public static class @TrainingCourseTypesTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TrainingCourseTypeId: TrainingCourseTypesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TrainingCourseTypeId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "TrainingCourseTypeId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: TrainingCourseTypesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Name", value ); } }
}
}
public interface UserLoginLogsTableCondition: TableCondition {}
public static class @UserLoginLogsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserLoginLogId: UserLoginLogsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserLoginLogId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UserLoginLogId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: UserLoginLogsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DateTimeUtc: UserLoginLogsTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DateTimeUtc( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "DateTimeUtc", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
}
public static class @UserLoginLogsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserLoginLogId: UserLoginLogsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UserLoginLogId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UserLoginLogId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: UserLoginLogsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UserId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DateTimeUtc: UserLoginLogsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @DateTimeUtc( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "DateTimeUtc", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
}
public static class @UserLoginLogsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserLoginLogId: UserLoginLogsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserLoginLogId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UserLoginLogId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: UserLoginLogsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UserId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DateTimeUtc: UserLoginLogsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DateTimeUtc( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "DateTimeUtc", subQuery ); } }
}
}
public static class @UserLoginLogsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserLoginLogId: UserLoginLogsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserLoginLogId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UserLoginLogId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: UserLoginLogsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UserId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DateTimeUtc: UserLoginLogsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DateTimeUtc( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "DateTimeUtc", value ); } }
}
}
public interface UserLogMessagesTableCondition: TableCondition {}
public static class @UserLogMessagesTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserLogMessageId: UserLogMessagesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserLogMessageId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UserLogMessageId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: UserLogMessagesTableCondition {
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( System.Guid value ) {
this.value = value;
}
internal System.Guid Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DateAndTime: UserLogMessagesTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DateAndTime( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "DateAndTime", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Iv: UserLogMessagesTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Iv( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Iv", new DbParameterValue( value, "Binary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Message: UserLogMessagesTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Message( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Message", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
}
public static class @UserLogMessagesTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserLogMessageId: UserLogMessagesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UserLogMessageId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UserLogMessageId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: UserLogMessagesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Guid value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UserId( InequalityCondition.Operator op, System.Guid value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "UniqueIdentifier" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DateAndTime: UserLogMessagesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @DateAndTime( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "DateAndTime", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Iv: UserLogMessagesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Iv( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Iv", new DbParameterValue( value, "Binary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Message: UserLogMessagesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Message( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Message", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
}
public static class @UserLogMessagesTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserLogMessageId: UserLogMessagesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserLogMessageId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UserLogMessageId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: UserLogMessagesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UserId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DateAndTime: UserLogMessagesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DateAndTime( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "DateAndTime", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Iv: UserLogMessagesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Iv( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Iv", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Message: UserLogMessagesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Message( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Message", subQuery ); } }
}
}
public static class @UserLogMessagesTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserLogMessageId: UserLogMessagesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserLogMessageId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UserLogMessageId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: UserLogMessagesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UserId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DateAndTime: UserLogMessagesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DateAndTime( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "DateAndTime", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Iv: UserLogMessagesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Iv( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Iv", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Message: UserLogMessagesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Message( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Message", value ); } }
}
}
public interface UsersTableCondition: TableCondition {}
public static class @UsersTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: UsersTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EmailAddress: UsersTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EmailAddress( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EmailAddress", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RoleId: UsersTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @RoleId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "RoleId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Salt: UsersTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Salt( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Salt", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Password: UsersTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Password( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Password", new DbParameterValue( value, "Binary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastRequestDateTime: UsersTableCondition {
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastRequestDateTime( System.DateTime? value ) {
this.value = value;
}
internal System.DateTime? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LastRequestDateTime", new DbParameterValue( value, "SmallDateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MustChangePassword: UsersTableCondition {
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MustChangePassword( System.Boolean value ) {
this.value = value;
}
internal System.Boolean Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "MustChangePassword", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Disabled: UsersTableCondition {
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Disabled( System.Boolean value ) {
this.value = value;
}
internal System.Boolean Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Disabled", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @InvalidPasswordAttempts: UsersTableCondition {
private readonly System.Byte value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @InvalidPasswordAttempts( System.Byte value ) {
this.value = value;
}
internal System.Byte Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "InvalidPasswordAttempts", new DbParameterValue( value, "TinyInt" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastPasswordChangeDate: UsersTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastPasswordChangeDate( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LastPasswordChangeDate", new DbParameterValue( value, "SmallDateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FirstName: UsersTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FirstName( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "FirstName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastName: UsersTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastName( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LastName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastAlertEmailSentDateTime: UsersTableCondition {
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastAlertEmailSentDateTime( System.DateTime? value ) {
this.value = value;
}
internal System.DateTime? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LastAlertEmailSentDateTime", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CreatedDateTime: UsersTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @CreatedDateTime( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "CreatedDateTime", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EmailVerificationCode: UsersTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EmailVerificationCode( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EmailVerificationCode", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EmailVerifiedDateUtc: UsersTableCondition {
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EmailVerifiedDateUtc( System.DateTime? value ) {
this.value = value;
}
internal System.DateTime? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EmailVerifiedDateUtc", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Deleted: UsersTableCondition {
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Deleted( System.Boolean value ) {
this.value = value;
}
internal System.Boolean Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Deleted", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Random2: UsersTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Random2( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Random2", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @UsersTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: UsersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UserId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EmailAddress: UsersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EmailAddress( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EmailAddress", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RoleId: UsersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @RoleId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "RoleId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Salt: UsersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Salt( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Salt", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Password: UsersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Password( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Password", new DbParameterValue( value, "Binary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastRequestDateTime: UsersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LastRequestDateTime( InequalityCondition.Operator op, System.DateTime? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LastRequestDateTime", new DbParameterValue( value, "SmallDateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MustChangePassword: UsersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @MustChangePassword( InequalityCondition.Operator op, System.Boolean value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "MustChangePassword", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Disabled: UsersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Disabled( InequalityCondition.Operator op, System.Boolean value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Disabled", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @InvalidPasswordAttempts: UsersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @InvalidPasswordAttempts( InequalityCondition.Operator op, System.Byte value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "InvalidPasswordAttempts", new DbParameterValue( value, "TinyInt" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastPasswordChangeDate: UsersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LastPasswordChangeDate( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LastPasswordChangeDate", new DbParameterValue( value, "SmallDateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FirstName: UsersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @FirstName( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "FirstName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastName: UsersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LastName( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LastName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastAlertEmailSentDateTime: UsersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LastAlertEmailSentDateTime( InequalityCondition.Operator op, System.DateTime? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LastAlertEmailSentDateTime", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CreatedDateTime: UsersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @CreatedDateTime( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "CreatedDateTime", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EmailVerificationCode: UsersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EmailVerificationCode( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EmailVerificationCode", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EmailVerifiedDateUtc: UsersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EmailVerifiedDateUtc( InequalityCondition.Operator op, System.DateTime? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EmailVerifiedDateUtc", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Deleted: UsersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Deleted( InequalityCondition.Operator op, System.Boolean value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Deleted", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Random2: UsersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Random2( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Random2", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @UsersTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: UsersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UserId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EmailAddress: UsersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EmailAddress( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EmailAddress", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RoleId: UsersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @RoleId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "RoleId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Salt: UsersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Salt( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Salt", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Password: UsersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Password( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Password", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastRequestDateTime: UsersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastRequestDateTime( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LastRequestDateTime", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MustChangePassword: UsersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MustChangePassword( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "MustChangePassword", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Disabled: UsersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Disabled( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Disabled", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @InvalidPasswordAttempts: UsersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @InvalidPasswordAttempts( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "InvalidPasswordAttempts", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastPasswordChangeDate: UsersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastPasswordChangeDate( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LastPasswordChangeDate", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FirstName: UsersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FirstName( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "FirstName", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastName: UsersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastName( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LastName", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastAlertEmailSentDateTime: UsersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastAlertEmailSentDateTime( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LastAlertEmailSentDateTime", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CreatedDateTime: UsersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @CreatedDateTime( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "CreatedDateTime", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EmailVerificationCode: UsersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EmailVerificationCode( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EmailVerificationCode", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EmailVerifiedDateUtc: UsersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EmailVerifiedDateUtc( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EmailVerifiedDateUtc", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Deleted: UsersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Deleted( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Deleted", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Random2: UsersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Random2( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Random2", subQuery ); } }
}
}
public static class @UsersTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: UsersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UserId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EmailAddress: UsersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EmailAddress( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EmailAddress", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RoleId: UsersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @RoleId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "RoleId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Salt: UsersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Salt( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Salt", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Password: UsersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Password( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Password", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastRequestDateTime: UsersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastRequestDateTime( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LastRequestDateTime", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @MustChangePassword: UsersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @MustChangePassword( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "MustChangePassword", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Disabled: UsersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Disabled( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Disabled", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @InvalidPasswordAttempts: UsersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @InvalidPasswordAttempts( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "InvalidPasswordAttempts", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastPasswordChangeDate: UsersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastPasswordChangeDate( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LastPasswordChangeDate", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @FirstName: UsersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @FirstName( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "FirstName", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastName: UsersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastName( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LastName", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastAlertEmailSentDateTime: UsersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastAlertEmailSentDateTime( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LastAlertEmailSentDateTime", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @CreatedDateTime: UsersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @CreatedDateTime( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "CreatedDateTime", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EmailVerificationCode: UsersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EmailVerificationCode( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EmailVerificationCode", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EmailVerifiedDateUtc: UsersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EmailVerifiedDateUtc( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EmailVerifiedDateUtc", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Deleted: UsersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Deleted( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Deleted", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Random2: UsersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Random2( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Random2", value ); } }
}
}
public interface UsersToHiddenTrainingCourseTypesTableCondition: TableCondition {}
public static class @UsersToHiddenTrainingCourseTypesTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: UsersToHiddenTrainingCourseTypesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TrainingCourseTypeId: UsersToHiddenTrainingCourseTypesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TrainingCourseTypeId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "TrainingCourseTypeId", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @UsersToHiddenTrainingCourseTypesTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: UsersToHiddenTrainingCourseTypesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UserId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TrainingCourseTypeId: UsersToHiddenTrainingCourseTypesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @TrainingCourseTypeId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "TrainingCourseTypeId", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @UsersToHiddenTrainingCourseTypesTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: UsersToHiddenTrainingCourseTypesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UserId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TrainingCourseTypeId: UsersToHiddenTrainingCourseTypesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TrainingCourseTypeId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "TrainingCourseTypeId", subQuery ); } }
}
}
public static class @UsersToHiddenTrainingCourseTypesTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: UsersToHiddenTrainingCourseTypesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UserId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @TrainingCourseTypeId: UsersToHiddenTrainingCourseTypesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @TrainingCourseTypeId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "TrainingCourseTypeId", value ); } }
}
}
public interface UsersToOrganizationsTableCondition: TableCondition {}
public static class @UsersToOrganizationsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UsersToOrganizationId: UsersToOrganizationsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UsersToOrganizationId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UsersToOrganizationId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: UsersToOrganizationsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @OrganizationId: UsersToOrganizationsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @OrganizationId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "OrganizationId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @StartDate: UsersToOrganizationsTableCondition {
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @StartDate( System.DateTime? value ) {
this.value = value;
}
internal System.DateTime? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "StartDate", new DbParameterValue( value, "Date" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EndDate: UsersToOrganizationsTableCondition {
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EndDate( System.DateTime? value ) {
this.value = value;
}
internal System.DateTime? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EndDate", new DbParameterValue( value, "Date" ) ) ); } }
}
}
public static class @UsersToOrganizationsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UsersToOrganizationId: UsersToOrganizationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UsersToOrganizationId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UsersToOrganizationId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: UsersToOrganizationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UserId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @OrganizationId: UsersToOrganizationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @OrganizationId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "OrganizationId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @StartDate: UsersToOrganizationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @StartDate( InequalityCondition.Operator op, System.DateTime? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "StartDate", new DbParameterValue( value, "Date" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EndDate: UsersToOrganizationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EndDate( InequalityCondition.Operator op, System.DateTime? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EndDate", new DbParameterValue( value, "Date" ) ) ); } }
}
}
public static class @UsersToOrganizationsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UsersToOrganizationId: UsersToOrganizationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UsersToOrganizationId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UsersToOrganizationId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: UsersToOrganizationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UserId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @OrganizationId: UsersToOrganizationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @OrganizationId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "OrganizationId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @StartDate: UsersToOrganizationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @StartDate( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "StartDate", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EndDate: UsersToOrganizationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EndDate( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EndDate", subQuery ); } }
}
}
public static class @UsersToOrganizationsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UsersToOrganizationId: UsersToOrganizationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UsersToOrganizationId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UsersToOrganizationId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: UsersToOrganizationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UserId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @OrganizationId: UsersToOrganizationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @OrganizationId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "OrganizationId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @StartDate: UsersToOrganizationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @StartDate( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "StartDate", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EndDate: UsersToOrganizationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EndDate( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EndDate", value ); } }
}
}
public interface UsersToPasswordResetQuestionsTableCondition: TableCondition {}
public static class @UsersToPasswordResetQuestionsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UsersToPasswordResetQuestionId: UsersToPasswordResetQuestionsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UsersToPasswordResetQuestionId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UsersToPasswordResetQuestionId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: UsersToPasswordResetQuestionsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PasswordResetQuestionId: UsersToPasswordResetQuestionsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PasswordResetQuestionId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PasswordResetQuestionId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Iv: UsersToPasswordResetQuestionsTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Iv( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Iv", new DbParameterValue( value, "Binary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Answer: UsersToPasswordResetQuestionsTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Answer( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Answer", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
}
public static class @UsersToPasswordResetQuestionsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UsersToPasswordResetQuestionId: UsersToPasswordResetQuestionsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UsersToPasswordResetQuestionId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UsersToPasswordResetQuestionId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: UsersToPasswordResetQuestionsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UserId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PasswordResetQuestionId: UsersToPasswordResetQuestionsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PasswordResetQuestionId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PasswordResetQuestionId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Iv: UsersToPasswordResetQuestionsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Iv( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Iv", new DbParameterValue( value, "Binary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Answer: UsersToPasswordResetQuestionsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Answer( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Answer", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
}
public static class @UsersToPasswordResetQuestionsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UsersToPasswordResetQuestionId: UsersToPasswordResetQuestionsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UsersToPasswordResetQuestionId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UsersToPasswordResetQuestionId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: UsersToPasswordResetQuestionsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UserId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PasswordResetQuestionId: UsersToPasswordResetQuestionsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PasswordResetQuestionId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PasswordResetQuestionId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Iv: UsersToPasswordResetQuestionsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Iv( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Iv", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Answer: UsersToPasswordResetQuestionsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Answer( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Answer", subQuery ); } }
}
}
public static class @UsersToPasswordResetQuestionsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UsersToPasswordResetQuestionId: UsersToPasswordResetQuestionsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UsersToPasswordResetQuestionId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UsersToPasswordResetQuestionId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: UsersToPasswordResetQuestionsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UserId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PasswordResetQuestionId: UsersToPasswordResetQuestionsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PasswordResetQuestionId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PasswordResetQuestionId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Iv: UsersToPasswordResetQuestionsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Iv( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Iv", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Answer: UsersToPasswordResetQuestionsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Answer( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Answer", value ); } }
}
}
public interface VhrAccessLogsTableCondition: TableCondition {}
public static class @VhrAccessLogsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrAccessLogId: VhrAccessLogsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VhrAccessLogId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "VhrAccessLogId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrProfileId: VhrAccessLogsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VhrProfileId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "VhrProfileId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DateTimeUtc: VhrAccessLogsTableCondition {
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DateTimeUtc( DateTime value ) {
this.value = value;
}
internal DateTime Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "DateTimeUtc", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
}
public static class @VhrAccessLogsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrAccessLogId: VhrAccessLogsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @VhrAccessLogId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "VhrAccessLogId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrProfileId: VhrAccessLogsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @VhrProfileId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "VhrProfileId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DateTimeUtc: VhrAccessLogsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly DateTime value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @DateTimeUtc( InequalityCondition.Operator op, DateTime value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "DateTimeUtc", new DbParameterValue( value, "DateTime2" ) ) ); } }
}
}
public static class @VhrAccessLogsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrAccessLogId: VhrAccessLogsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VhrAccessLogId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "VhrAccessLogId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrProfileId: VhrAccessLogsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VhrProfileId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "VhrProfileId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DateTimeUtc: VhrAccessLogsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DateTimeUtc( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "DateTimeUtc", subQuery ); } }
}
}
public static class @VhrAccessLogsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrAccessLogId: VhrAccessLogsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VhrAccessLogId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "VhrAccessLogId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrProfileId: VhrAccessLogsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VhrProfileId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "VhrProfileId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DateTimeUtc: VhrAccessLogsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DateTimeUtc( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "DateTimeUtc", value ); } }
}
}
public interface VhrEnvironmentConfigurationsTableCondition: TableCondition {}
public static class @VhrEnvironmentConfigurationsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrProviderId: VhrEnvironmentConfigurationsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VhrProviderId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "VhrProviderId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrEnvironmentId: VhrEnvironmentConfigurationsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VhrEnvironmentId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "VhrEnvironmentId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EndpointUrl: VhrEnvironmentConfigurationsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EndpointUrl( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EndpointUrl", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SsoSiteId: VhrEnvironmentConfigurationsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SsoSiteId( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "SsoSiteId", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SsoCertificate: VhrEnvironmentConfigurationsTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SsoCertificate( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "SsoCertificate", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SsoPassword: VhrEnvironmentConfigurationsTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SsoPassword( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "SsoPassword", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SsoIv: VhrEnvironmentConfigurationsTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SsoIv( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "SsoIv", new DbParameterValue( value, "Binary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ClientCertificate: VhrEnvironmentConfigurationsTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ClientCertificate( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ClientCertificate", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ClientPassword: VhrEnvironmentConfigurationsTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ClientPassword( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ClientPassword", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ClientIv: VhrEnvironmentConfigurationsTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ClientIv( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ClientIv", new DbParameterValue( value, "Binary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SsoSendingParty: VhrEnvironmentConfigurationsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SsoSendingParty( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "SsoSendingParty", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RedirectToUrl: VhrEnvironmentConfigurationsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @RedirectToUrl( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "RedirectToUrl", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @VhrEnvironmentConfigurationsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrProviderId: VhrEnvironmentConfigurationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @VhrProviderId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "VhrProviderId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrEnvironmentId: VhrEnvironmentConfigurationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @VhrEnvironmentId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "VhrEnvironmentId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EndpointUrl: VhrEnvironmentConfigurationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EndpointUrl( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EndpointUrl", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SsoSiteId: VhrEnvironmentConfigurationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @SsoSiteId( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "SsoSiteId", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SsoCertificate: VhrEnvironmentConfigurationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @SsoCertificate( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "SsoCertificate", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SsoPassword: VhrEnvironmentConfigurationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @SsoPassword( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "SsoPassword", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SsoIv: VhrEnvironmentConfigurationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @SsoIv( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "SsoIv", new DbParameterValue( value, "Binary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ClientCertificate: VhrEnvironmentConfigurationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ClientCertificate( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ClientCertificate", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ClientPassword: VhrEnvironmentConfigurationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ClientPassword( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ClientPassword", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ClientIv: VhrEnvironmentConfigurationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ClientIv( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ClientIv", new DbParameterValue( value, "Binary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SsoSendingParty: VhrEnvironmentConfigurationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @SsoSendingParty( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "SsoSendingParty", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RedirectToUrl: VhrEnvironmentConfigurationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @RedirectToUrl( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "RedirectToUrl", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @VhrEnvironmentConfigurationsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrProviderId: VhrEnvironmentConfigurationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VhrProviderId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "VhrProviderId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrEnvironmentId: VhrEnvironmentConfigurationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VhrEnvironmentId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "VhrEnvironmentId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EndpointUrl: VhrEnvironmentConfigurationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EndpointUrl( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EndpointUrl", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SsoSiteId: VhrEnvironmentConfigurationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SsoSiteId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "SsoSiteId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SsoCertificate: VhrEnvironmentConfigurationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SsoCertificate( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "SsoCertificate", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SsoPassword: VhrEnvironmentConfigurationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SsoPassword( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "SsoPassword", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SsoIv: VhrEnvironmentConfigurationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SsoIv( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "SsoIv", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ClientCertificate: VhrEnvironmentConfigurationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ClientCertificate( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ClientCertificate", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ClientPassword: VhrEnvironmentConfigurationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ClientPassword( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ClientPassword", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ClientIv: VhrEnvironmentConfigurationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ClientIv( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ClientIv", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SsoSendingParty: VhrEnvironmentConfigurationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SsoSendingParty( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "SsoSendingParty", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RedirectToUrl: VhrEnvironmentConfigurationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @RedirectToUrl( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "RedirectToUrl", subQuery ); } }
}
}
public static class @VhrEnvironmentConfigurationsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrProviderId: VhrEnvironmentConfigurationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VhrProviderId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "VhrProviderId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrEnvironmentId: VhrEnvironmentConfigurationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VhrEnvironmentId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "VhrEnvironmentId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EndpointUrl: VhrEnvironmentConfigurationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EndpointUrl( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EndpointUrl", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SsoSiteId: VhrEnvironmentConfigurationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SsoSiteId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "SsoSiteId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SsoCertificate: VhrEnvironmentConfigurationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SsoCertificate( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "SsoCertificate", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SsoPassword: VhrEnvironmentConfigurationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SsoPassword( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "SsoPassword", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SsoIv: VhrEnvironmentConfigurationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SsoIv( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "SsoIv", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ClientCertificate: VhrEnvironmentConfigurationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ClientCertificate( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ClientCertificate", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ClientPassword: VhrEnvironmentConfigurationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ClientPassword( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ClientPassword", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ClientIv: VhrEnvironmentConfigurationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ClientIv( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ClientIv", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @SsoSendingParty: VhrEnvironmentConfigurationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @SsoSendingParty( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "SsoSendingParty", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @RedirectToUrl: VhrEnvironmentConfigurationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @RedirectToUrl( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "RedirectToUrl", value ); } }
}
}
public interface VhrEnvironmentsTableCondition: TableCondition {}
public static class @VhrEnvironmentsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrEnvironmentId: VhrEnvironmentsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VhrEnvironmentId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "VhrEnvironmentId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: VhrEnvironmentsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @VhrEnvironmentsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrEnvironmentId: VhrEnvironmentsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @VhrEnvironmentId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "VhrEnvironmentId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: VhrEnvironmentsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Name( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @VhrEnvironmentsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrEnvironmentId: VhrEnvironmentsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VhrEnvironmentId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "VhrEnvironmentId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: VhrEnvironmentsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Name", subQuery ); } }
}
}
public static class @VhrEnvironmentsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrEnvironmentId: VhrEnvironmentsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VhrEnvironmentId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "VhrEnvironmentId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: VhrEnvironmentsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Name", value ); } }
}
}
public interface VhrProfilesTableCondition: TableCondition {}
public static class @VhrProfilesTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrProfileId: VhrProfilesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VhrProfileId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "VhrProfileId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrUserName: VhrProfilesTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VhrUserName( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "VhrUserName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Description: VhrProfilesTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Description( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Description", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Deleted: VhrProfilesTableCondition {
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Deleted( System.Boolean value ) {
this.value = value;
}
internal System.Boolean Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Deleted", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrProviderId: VhrProfilesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VhrProviderId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "VhrProviderId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Disabled: VhrProfilesTableCondition {
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Disabled( System.Boolean value ) {
this.value = value;
}
internal System.Boolean Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Disabled", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: VhrProfilesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrEnvironmentId: VhrProfilesTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VhrEnvironmentId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "VhrEnvironmentId", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @VhrProfilesTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrProfileId: VhrProfilesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @VhrProfileId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "VhrProfileId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrUserName: VhrProfilesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @VhrUserName( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "VhrUserName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Description: VhrProfilesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Description( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Description", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Deleted: VhrProfilesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Deleted( InequalityCondition.Operator op, System.Boolean value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Deleted", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrProviderId: VhrProfilesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @VhrProviderId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "VhrProviderId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Disabled: VhrProfilesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Disabled( InequalityCondition.Operator op, System.Boolean value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Disabled", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: VhrProfilesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UserId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrEnvironmentId: VhrProfilesTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @VhrEnvironmentId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "VhrEnvironmentId", new DbParameterValue( value, "Int" ) ) ); } }
}
}
public static class @VhrProfilesTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrProfileId: VhrProfilesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VhrProfileId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "VhrProfileId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrUserName: VhrProfilesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VhrUserName( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "VhrUserName", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Description: VhrProfilesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Description( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Description", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Deleted: VhrProfilesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Deleted( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Deleted", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrProviderId: VhrProfilesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VhrProviderId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "VhrProviderId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Disabled: VhrProfilesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Disabled( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Disabled", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: VhrProfilesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UserId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrEnvironmentId: VhrProfilesTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VhrEnvironmentId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "VhrEnvironmentId", subQuery ); } }
}
}
public static class @VhrProfilesTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrProfileId: VhrProfilesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VhrProfileId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "VhrProfileId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrUserName: VhrProfilesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VhrUserName( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "VhrUserName", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Description: VhrProfilesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Description( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Description", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Deleted: VhrProfilesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Deleted( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Deleted", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrProviderId: VhrProfilesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VhrProviderId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "VhrProviderId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Disabled: VhrProfilesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Disabled( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Disabled", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: VhrProfilesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UserId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrEnvironmentId: VhrProfilesTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VhrEnvironmentId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "VhrEnvironmentId", value ); } }
}
}
public interface VhrProvidersTableCondition: TableCondition {}
public static class @VhrProvidersTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrProviderId: VhrProvidersTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VhrProviderId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "VhrProviderId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: VhrProvidersTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "VarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsVhr: VhrProvidersTableCondition {
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsVhr( System.Boolean value ) {
this.value = value;
}
internal System.Boolean Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "IsVhr", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Archived: VhrProvidersTableCondition {
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Archived( System.Boolean value ) {
this.value = value;
}
internal System.Boolean Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Archived", new DbParameterValue( value, "Bit" ) ) ); } }
}
}
public static class @VhrProvidersTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrProviderId: VhrProvidersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @VhrProviderId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "VhrProviderId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: VhrProvidersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Name( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "VarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsVhr: VhrProvidersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @IsVhr( InequalityCondition.Operator op, System.Boolean value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "IsVhr", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Archived: VhrProvidersTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Archived( InequalityCondition.Operator op, System.Boolean value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Archived", new DbParameterValue( value, "Bit" ) ) ); } }
}
}
public static class @VhrProvidersTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrProviderId: VhrProvidersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VhrProviderId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "VhrProviderId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: VhrProvidersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Name", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsVhr: VhrProvidersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsVhr( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "IsVhr", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Archived: VhrProvidersTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Archived( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Archived", subQuery ); } }
}
}
public static class @VhrProvidersTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VhrProviderId: VhrProvidersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VhrProviderId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "VhrProviderId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: VhrProvidersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Name", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsVhr: VhrProvidersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsVhr( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "IsVhr", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Archived: VhrProvidersTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Archived( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Archived", value ); } }
}
}
public interface VitalsDataSourceTableCondition: TableCondition {}
public static class @VitalsDataSourceTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Id: VitalsDataSourceTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Id( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Id", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: VitalsDataSourceTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsAutoSyncEnabled: VitalsDataSourceTableCondition {
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsAutoSyncEnabled( System.Boolean value ) {
this.value = value;
}
internal System.Boolean Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "IsAutoSyncEnabled", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastSyncTime: VitalsDataSourceTableCondition {
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastSyncTime( System.DateTime? value ) {
this.value = value;
}
internal System.DateTime? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LastSyncTime", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsEnrollable: VitalsDataSourceTableCondition {
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsEnrollable( System.Boolean value ) {
this.value = value;
}
internal System.Boolean Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "IsEnrollable", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AllowsMultipleEnrollments: VitalsDataSourceTableCondition {
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AllowsMultipleEnrollments( System.Boolean value ) {
this.value = value;
}
internal System.Boolean Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "AllowsMultipleEnrollments", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DisplayOrder: VitalsDataSourceTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DisplayOrder( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "DisplayOrder", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ConnectCredentialsFormPath: VitalsDataSourceTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ConnectCredentialsFormPath( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ConnectCredentialsFormPath", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @InternalIdentifier: VitalsDataSourceTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @InternalIdentifier( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "InternalIdentifier", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VitalsRecordOrderDescription: VitalsDataSourceTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VitalsRecordOrderDescription( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "VitalsRecordOrderDescription", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @VitalsDataSourceTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Id: VitalsDataSourceTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Id( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Id", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: VitalsDataSourceTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Name( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsAutoSyncEnabled: VitalsDataSourceTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @IsAutoSyncEnabled( InequalityCondition.Operator op, System.Boolean value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "IsAutoSyncEnabled", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastSyncTime: VitalsDataSourceTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LastSyncTime( InequalityCondition.Operator op, System.DateTime? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LastSyncTime", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsEnrollable: VitalsDataSourceTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @IsEnrollable( InequalityCondition.Operator op, System.Boolean value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "IsEnrollable", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AllowsMultipleEnrollments: VitalsDataSourceTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @AllowsMultipleEnrollments( InequalityCondition.Operator op, System.Boolean value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "AllowsMultipleEnrollments", new DbParameterValue( value, "Bit" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DisplayOrder: VitalsDataSourceTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @DisplayOrder( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "DisplayOrder", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ConnectCredentialsFormPath: VitalsDataSourceTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ConnectCredentialsFormPath( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ConnectCredentialsFormPath", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @InternalIdentifier: VitalsDataSourceTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @InternalIdentifier( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "InternalIdentifier", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VitalsRecordOrderDescription: VitalsDataSourceTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @VitalsRecordOrderDescription( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "VitalsRecordOrderDescription", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @VitalsDataSourceTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Id: VitalsDataSourceTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Id( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Id", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: VitalsDataSourceTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Name", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsAutoSyncEnabled: VitalsDataSourceTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsAutoSyncEnabled( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "IsAutoSyncEnabled", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastSyncTime: VitalsDataSourceTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastSyncTime( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LastSyncTime", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsEnrollable: VitalsDataSourceTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsEnrollable( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "IsEnrollable", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AllowsMultipleEnrollments: VitalsDataSourceTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AllowsMultipleEnrollments( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "AllowsMultipleEnrollments", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DisplayOrder: VitalsDataSourceTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DisplayOrder( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "DisplayOrder", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ConnectCredentialsFormPath: VitalsDataSourceTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ConnectCredentialsFormPath( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ConnectCredentialsFormPath", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @InternalIdentifier: VitalsDataSourceTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @InternalIdentifier( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "InternalIdentifier", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VitalsRecordOrderDescription: VitalsDataSourceTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VitalsRecordOrderDescription( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "VitalsRecordOrderDescription", subQuery ); } }
}
}
public static class @VitalsDataSourceTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Id: VitalsDataSourceTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Id( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Id", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: VitalsDataSourceTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Name", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsAutoSyncEnabled: VitalsDataSourceTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsAutoSyncEnabled( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "IsAutoSyncEnabled", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastSyncTime: VitalsDataSourceTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastSyncTime( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LastSyncTime", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @IsEnrollable: VitalsDataSourceTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @IsEnrollable( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "IsEnrollable", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @AllowsMultipleEnrollments: VitalsDataSourceTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @AllowsMultipleEnrollments( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "AllowsMultipleEnrollments", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DisplayOrder: VitalsDataSourceTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DisplayOrder( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "DisplayOrder", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ConnectCredentialsFormPath: VitalsDataSourceTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ConnectCredentialsFormPath( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ConnectCredentialsFormPath", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @InternalIdentifier: VitalsDataSourceTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @InternalIdentifier( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "InternalIdentifier", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VitalsRecordOrderDescription: VitalsDataSourceTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VitalsRecordOrderDescription( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "VitalsRecordOrderDescription", value ); } }
}
}
public interface VitalsEnrollmentTableCondition: TableCondition {}
public static class @VitalsEnrollmentTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Id: VitalsEnrollmentTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Id( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Id", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DataSourceId: VitalsEnrollmentTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DataSourceId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "DataSourceId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncKV: VitalsEnrollmentTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncKV( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EncKV", new DbParameterValue( value, "VarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncIV: VitalsEnrollmentTableCondition {
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncIV( System.Byte[] value ) {
this.value = value;
}
internal System.Byte[] Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EncIV", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientUsername: VitalsEnrollmentTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PatientUsername( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "PatientUsername", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EnrollmentName: VitalsEnrollmentTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EnrollmentName( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EnrollmentName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Credentials: VitalsEnrollmentTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Credentials( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Credentials", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DataSourceUniqueId: VitalsEnrollmentTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DataSourceUniqueId( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "DataSourceUniqueId", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @VitalsEnrollmentTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Id: VitalsEnrollmentTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Id( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Id", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DataSourceId: VitalsEnrollmentTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @DataSourceId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "DataSourceId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncKV: VitalsEnrollmentTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EncKV( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EncKV", new DbParameterValue( value, "VarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncIV: VitalsEnrollmentTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Byte[] value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EncIV( InequalityCondition.Operator op, System.Byte[] value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EncIV", new DbParameterValue( value, "VarBinary" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientUsername: VitalsEnrollmentTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @PatientUsername( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "PatientUsername", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EnrollmentName: VitalsEnrollmentTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EnrollmentName( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EnrollmentName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Credentials: VitalsEnrollmentTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Credentials( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Credentials", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DataSourceUniqueId: VitalsEnrollmentTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @DataSourceUniqueId( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "DataSourceUniqueId", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @VitalsEnrollmentTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Id: VitalsEnrollmentTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Id( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Id", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DataSourceId: VitalsEnrollmentTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DataSourceId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "DataSourceId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncKV: VitalsEnrollmentTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncKV( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EncKV", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncIV: VitalsEnrollmentTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncIV( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EncIV", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientUsername: VitalsEnrollmentTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PatientUsername( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "PatientUsername", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EnrollmentName: VitalsEnrollmentTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EnrollmentName( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EnrollmentName", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Credentials: VitalsEnrollmentTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Credentials( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Credentials", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DataSourceUniqueId: VitalsEnrollmentTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DataSourceUniqueId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "DataSourceUniqueId", subQuery ); } }
}
}
public static class @VitalsEnrollmentTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Id: VitalsEnrollmentTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Id( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Id", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DataSourceId: VitalsEnrollmentTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DataSourceId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "DataSourceId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncKV: VitalsEnrollmentTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncKV( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EncKV", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EncIV: VitalsEnrollmentTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EncIV( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EncIV", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @PatientUsername: VitalsEnrollmentTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @PatientUsername( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "PatientUsername", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EnrollmentName: VitalsEnrollmentTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EnrollmentName( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EnrollmentName", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Credentials: VitalsEnrollmentTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Credentials( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Credentials", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @DataSourceUniqueId: VitalsEnrollmentTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @DataSourceUniqueId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "DataSourceUniqueId", value ); } }
}
}
public interface VitalsEnrollmentEventsTableCondition: TableCondition {}
public static class @VitalsEnrollmentEventsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VitalsEnrollmentEventId: VitalsEnrollmentEventsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VitalsEnrollmentEventId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "VitalsEnrollmentEventId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VitalsDataSourceId: VitalsEnrollmentEventsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VitalsDataSourceId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "VitalsDataSourceId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EnrolledDateTime: VitalsEnrollmentEventsTableCondition {
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EnrolledDateTime( System.DateTime? value ) {
this.value = value;
}
internal System.DateTime? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "EnrolledDateTime", new DbParameterValue( value, "SmallDateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UnenrolledDateTime: VitalsEnrollmentEventsTableCondition {
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UnenrolledDateTime( System.DateTime? value ) {
this.value = value;
}
internal System.DateTime? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UnenrolledDateTime", new DbParameterValue( value, "SmallDateTime" ) ) ); } }
}
}
public static class @VitalsEnrollmentEventsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VitalsEnrollmentEventId: VitalsEnrollmentEventsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @VitalsEnrollmentEventId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "VitalsEnrollmentEventId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VitalsDataSourceId: VitalsEnrollmentEventsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @VitalsDataSourceId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "VitalsDataSourceId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EnrolledDateTime: VitalsEnrollmentEventsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @EnrolledDateTime( InequalityCondition.Operator op, System.DateTime? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "EnrolledDateTime", new DbParameterValue( value, "SmallDateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UnenrolledDateTime: VitalsEnrollmentEventsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UnenrolledDateTime( InequalityCondition.Operator op, System.DateTime? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UnenrolledDateTime", new DbParameterValue( value, "SmallDateTime" ) ) ); } }
}
}
public static class @VitalsEnrollmentEventsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VitalsEnrollmentEventId: VitalsEnrollmentEventsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VitalsEnrollmentEventId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "VitalsEnrollmentEventId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VitalsDataSourceId: VitalsEnrollmentEventsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VitalsDataSourceId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "VitalsDataSourceId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EnrolledDateTime: VitalsEnrollmentEventsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EnrolledDateTime( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "EnrolledDateTime", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UnenrolledDateTime: VitalsEnrollmentEventsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UnenrolledDateTime( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UnenrolledDateTime", subQuery ); } }
}
}
public static class @VitalsEnrollmentEventsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VitalsEnrollmentEventId: VitalsEnrollmentEventsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VitalsEnrollmentEventId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "VitalsEnrollmentEventId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @VitalsDataSourceId: VitalsEnrollmentEventsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @VitalsDataSourceId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "VitalsDataSourceId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @EnrolledDateTime: VitalsEnrollmentEventsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @EnrolledDateTime( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "EnrolledDateTime", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UnenrolledDateTime: VitalsEnrollmentEventsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UnenrolledDateTime( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UnenrolledDateTime", value ); } }
}
}
public interface WorkgroupTableCondition: TableCondition {}
public static class @WorkgroupTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkGroupID: WorkgroupTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @WorkGroupID( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "WorkGroupID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: WorkgroupTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastUpdated: WorkgroupTableCondition {
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastUpdated( System.DateTime? value ) {
this.value = value;
}
internal System.DateTime? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LastUpdated", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: WorkgroupTableCondition {
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Created( System.DateTime? value ) {
this.value = value;
}
internal System.DateTime? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Created", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HealthPlanID: WorkgroupTableCondition {
private readonly System.Int32? value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @HealthPlanID( System.Int32? value ) {
this.value = value;
}
internal System.Int32? Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "HealthPlanID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ConsentLevel: WorkgroupTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ConsentLevel( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ConsentLevel", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Hidden: WorkgroupTableCondition {
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Hidden( System.Boolean value ) {
this.value = value;
}
internal System.Boolean Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "Hidden", new DbParameterValue( value, "Bit" ) ) ); } }
}
}
public static class @WorkgroupTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkGroupID: WorkgroupTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @WorkGroupID( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "WorkGroupID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: WorkgroupTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Name( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Name", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastUpdated: WorkgroupTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LastUpdated( InequalityCondition.Operator op, System.DateTime? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LastUpdated", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: WorkgroupTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.DateTime? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Created( InequalityCondition.Operator op, System.DateTime? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Created", new DbParameterValue( value, "DateTime" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HealthPlanID: WorkgroupTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Int32? value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @HealthPlanID( InequalityCondition.Operator op, System.Int32? value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "HealthPlanID", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ConsentLevel: WorkgroupTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ConsentLevel( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ConsentLevel", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Hidden: WorkgroupTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly System.Boolean value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @Hidden( InequalityCondition.Operator op, System.Boolean value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "Hidden", new DbParameterValue( value, "Bit" ) ) ); } }
}
}
public static class @WorkgroupTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkGroupID: WorkgroupTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @WorkGroupID( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "WorkGroupID", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: WorkgroupTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Name", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastUpdated: WorkgroupTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastUpdated( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LastUpdated", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: WorkgroupTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Created( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Created", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HealthPlanID: WorkgroupTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @HealthPlanID( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "HealthPlanID", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ConsentLevel: WorkgroupTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ConsentLevel( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ConsentLevel", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Hidden: WorkgroupTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Hidden( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "Hidden", subQuery ); } }
}
}
public static class @WorkgroupTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkGroupID: WorkgroupTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @WorkGroupID( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "WorkGroupID", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Name: WorkgroupTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Name( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Name", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LastUpdated: WorkgroupTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LastUpdated( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LastUpdated", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Created: WorkgroupTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Created( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Created", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @HealthPlanID: WorkgroupTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @HealthPlanID( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "HealthPlanID", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ConsentLevel: WorkgroupTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ConsentLevel( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ConsentLevel", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @Hidden: WorkgroupTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @Hidden( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "Hidden", value ); } }
}
}
public interface WorkgroupLocationsTableCondition: TableCondition {}
public static class @WorkgroupLocationsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkgroupLocationId: WorkgroupLocationsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @WorkgroupLocationId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "WorkgroupLocationId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkgroupId: WorkgroupLocationsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @WorkgroupId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "WorkgroupId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LocationName: WorkgroupLocationsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LocationName( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "LocationName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @WorkgroupLocationsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkgroupLocationId: WorkgroupLocationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @WorkgroupLocationId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "WorkgroupLocationId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkgroupId: WorkgroupLocationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @WorkgroupId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "WorkgroupId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LocationName: WorkgroupLocationsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @LocationName( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "LocationName", new DbParameterValue( value, "NVarChar" ) ) ); } }
}
}
public static class @WorkgroupLocationsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkgroupLocationId: WorkgroupLocationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @WorkgroupLocationId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "WorkgroupLocationId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkgroupId: WorkgroupLocationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @WorkgroupId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "WorkgroupId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LocationName: WorkgroupLocationsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LocationName( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "LocationName", subQuery ); } }
}
}
public static class @WorkgroupLocationsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkgroupLocationId: WorkgroupLocationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @WorkgroupLocationId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "WorkgroupLocationId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @WorkgroupId: WorkgroupLocationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @WorkgroupId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "WorkgroupId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @LocationName: WorkgroupLocationsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @LocationName( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "LocationName", value ); } }
}
}
public interface ZipCodesToDeploymentCoordinatorsTableCondition: TableCondition {}
public static class @ZipCodesToDeploymentCoordinatorsTableEqualityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: ZipCodesToDeploymentCoordinatorsTableCondition {
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( int value ) {
this.value = value;
}
internal int Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ZipCode: ZipCodesToDeploymentCoordinatorsTableCondition {
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ZipCode( string value ) {
this.value = value;
}
internal string Value { get { return value; } }
InlineDbCommandCondition TableCondition.CommandCondition { get { return new EqualityCondition( new InlineDbCommandColumnValue( "ZipCode", new DbParameterValue( value, "VarChar" ) ) ); } }
}
}
public static class @ZipCodesToDeploymentCoordinatorsTableInequalityConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: ZipCodesToDeploymentCoordinatorsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly int value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @UserId( InequalityCondition.Operator op, int value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "UserId", new DbParameterValue( value, "Int" ) ) ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ZipCode: ZipCodesToDeploymentCoordinatorsTableCondition {
private readonly InequalityCondition.Operator op; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command. Expression will read 'valueInDatabase op yourValue'. So new InequalityCondition( Operator.GreaterThan, value ) will turn into 'columnName > @value'.
/// </summary>
public @ZipCode( InequalityCondition.Operator op, string value ) {
this.op = op;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InequalityCondition( op, new InlineDbCommandColumnValue( "ZipCode", new DbParameterValue( value, "VarChar" ) ) ); } }
}
}
public static class @ZipCodesToDeploymentCoordinatorsTableInConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: ZipCodesToDeploymentCoordinatorsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "UserId", subQuery ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ZipCode: ZipCodesToDeploymentCoordinatorsTableCondition {
private readonly string subQuery;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ZipCode( string subQuery ) {
this.subQuery = subQuery;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new InCondition( "ZipCode", subQuery ); } }
}
}
public static class @ZipCodesToDeploymentCoordinatorsTableLikeConditions {
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @UserId: ZipCodesToDeploymentCoordinatorsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @UserId( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "UserId", value ); } }
}
/// <summary>
/// A condition that narrows the scope of a command.
/// </summary>
public class @ZipCode: ZipCodesToDeploymentCoordinatorsTableCondition {
private readonly LikeCondition.Behavior behavior; 
private readonly string value;
/// <summary>
/// Creates a condition to narrow the scope of a command.
/// </summary>
public @ZipCode( LikeCondition.Behavior behavior, string value ) {
this.behavior = behavior;
this.value = value;
}
InlineDbCommandCondition TableCondition.CommandCondition { get { return new LikeCondition( behavior, "ZipCode", value ); } }
}
}
}

namespace ExampleNamespace.DataAccess.TableRetrieval {
/// <summary>
/// Contains logic that retrieves rows from the Administrators table.
/// </summary>
public static partial class @AdministratorsTableRetrieval {
internal class BasicRow {
private readonly int @__administratorId;
private readonly int @__userId;
private readonly string @__phoneNumber;
private readonly int @__photoFileCollectionId;
internal BasicRow( DbDataReader reader ) {
@__administratorId = (System.Int32)reader.GetValue( 0 );
@__userId = (System.Int32)reader.GetValue( 1 );
@__phoneNumber = (System.String)reader.GetValue( 2 );
@__photoFileCollectionId = (System.Int32)reader.GetValue( 3 );
}
internal int @AdministratorId { get { return @__administratorId; } }
internal int @UserId { get { return @__userId; } }
internal string @PhoneNumber { get { return @__phoneNumber; } }
internal int @PhotoFileCollectionId { get { return @__photoFileCollectionId; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @AdministratorId { get { return __basicRow.@AdministratorId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @UserId { get { return __basicRow.@UserId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @PhoneNumber { get { return __basicRow.@PhoneNumber; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @PhotoFileCollectionId { get { return __basicRow.@PhotoFileCollectionId; } }
public override int GetHashCode() { 
return @AdministratorId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @AdministratorId == other.@AdministratorId && @UserId == other.@UserId && @PhoneNumber == other.@PhoneNumber && @PhotoFileCollectionId == other.@PhotoFileCollectionId;
}
public Modification.@AdministratorsModification ToModification() {
return Modification.@AdministratorsModification.CreateForSingleRowUpdate( @AdministratorId, @UserId, @PhoneNumber, @PhotoFileCollectionId );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "AdministratorsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.AdministratorsTableCondition[] conditions ) {
var administratorIdCondition = conditions.OfType<CommandConditions.@AdministratorsTableEqualityConditions.@AdministratorId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = administratorIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( administratorIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM Administrators", !isPkQuery, orderByClause: "ORDER BY AdministratorId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@AdministratorId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@AdministratorsTableEqualityConditions.@AdministratorId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@AdministratorId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the AdvancedDirectivesHistory table.
/// </summary>
public static partial class @AdvancedDirectivesHistoryTableRetrieval {
internal class BasicRow {
private readonly int @__advancedDirectivesHistoryId;
private readonly DateTime @__dateAndTime;
private readonly System.Byte[] @__iv;
private readonly System.Byte[] @__userId;
internal BasicRow( DbDataReader reader ) {
@__advancedDirectivesHistoryId = (System.Int32)reader.GetValue( 0 );
@__dateAndTime = (System.DateTime)reader.GetValue( 1 );
@__iv = (System.Byte[])reader.GetValue( 2 );
@__userId = (System.Byte[])reader.GetValue( 3 );
}
internal int @AdvancedDirectivesHistoryId { get { return @__advancedDirectivesHistoryId; } }
internal DateTime @DateAndTime { get { return @__dateAndTime; } }
internal System.Byte[] @Iv { get { return @__iv; } }
internal System.Byte[] @UserId { get { return @__userId; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @AdvancedDirectivesHistoryId { get { return __basicRow.@AdvancedDirectivesHistoryId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @DateAndTime { get { return __basicRow.@DateAndTime; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @Iv { get { return __basicRow.@Iv; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @UserId { get { return __basicRow.@UserId; } }
public override int GetHashCode() { 
return @AdvancedDirectivesHistoryId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @AdvancedDirectivesHistoryId == other.@AdvancedDirectivesHistoryId && @DateAndTime == other.@DateAndTime;
}
public Modification.@AdvancedDirectivesHistoryModification ToModification() {
return Modification.@AdvancedDirectivesHistoryModification.CreateForSingleRowUpdate( @AdvancedDirectivesHistoryId, @DateAndTime, @Iv, @UserId );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "AdvancedDirectivesHistoryTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.AdvancedDirectivesHistoryTableCondition[] conditions ) {
var advancedDirectivesHistoryIdCondition = conditions.OfType<CommandConditions.@AdvancedDirectivesHistoryTableEqualityConditions.@AdvancedDirectivesHistoryId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = advancedDirectivesHistoryIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( advancedDirectivesHistoryIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM AdvancedDirectivesHistory", !isPkQuery, orderByClause: "ORDER BY AdvancedDirectivesHistoryId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@AdvancedDirectivesHistoryId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@AdvancedDirectivesHistoryTableEqualityConditions.@AdvancedDirectivesHistoryId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@AdvancedDirectivesHistoryId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the AppContent table.
/// </summary>
public static partial class @AppContentTableRetrieval {
internal class BasicRow {
private readonly string @__name;
private readonly string @__value;
private readonly string @__instructions;
private readonly System.Boolean @__showInGeneralList;
internal BasicRow( DbDataReader reader ) {
@__name = (System.String)reader.GetValue( 0 );
@__value = (System.String)reader.GetValue( 1 );
@__instructions = (System.String)reader.GetValue( 2 );
@__showInGeneralList = (System.Boolean)reader.GetValue( 3 );
}
internal string @Name { get { return @__name; } }
internal string @Value { get { return @__value; } }
internal string @Instructions { get { return @__instructions; } }
internal System.Boolean @ShowInGeneralList { get { return @__showInGeneralList; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public string @Name { get { return __basicRow.@Name; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Value { get { return __basicRow.@Value; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Instructions { get { return __basicRow.@Instructions; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Boolean @ShowInGeneralList { get { return __basicRow.@ShowInGeneralList; } }
public override int GetHashCode() { 
return @Name.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @Name == other.@Name && @Value == other.@Value && @Instructions == other.@Instructions && @ShowInGeneralList == other.@ShowInGeneralList;
}
public Modification.@AppContentModification ToModification() {
return Modification.@AppContentModification.CreateForSingleRowUpdate( @Name, @Value, @Instructions, @ShowInGeneralList );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "AppContentTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<string>, Row> rowsByPk = new Dictionary<Tuple<string>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<string>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.AppContentTableCondition[] conditions ) {
var nameCondition = conditions.OfType<CommandConditions.@AppContentTableEqualityConditions.@Name>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = nameCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( nameCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM AppContent", !isPkQuery, orderByClause: "ORDER BY Name" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@Name ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingPk( string name, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@AppContentTableEqualityConditions.@Name( name ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
}
/// <summary>
/// Contains logic that retrieves rows from the AppEnums table.
/// </summary>
public static partial class @AppEnumsTableRetrieval {
internal class BasicRow {
private readonly string @__category;
private readonly string @__paramName;
private readonly System.Int32? @__paramValue;
internal BasicRow( DbDataReader reader ) {
@__category = (System.String)reader.GetValue( 0 );
@__paramName = (System.String)reader.GetValue( 1 );
@__paramValue = reader.IsDBNull( 2 ) ? (System.Int32?)null : (System.Int32)reader.GetValue( 2 );
}
internal string @Category { get { return @__category; } }
internal string @ParamName { get { return @__paramName; } }
internal System.Int32? @ParamValue { get { return @__paramValue; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public string @Category { get { return __basicRow.@Category; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @ParamName { get { return __basicRow.@ParamName; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.Int32? @ParamValue { get { return __basicRow.@ParamValue; } }
public override int GetHashCode() { 
return @Category.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @Category == other.@Category && @ParamName == other.@ParamName && @ParamValue == other.@ParamValue;
}
public Modification.@AppEnumsModification ToModification() {
return Modification.@AppEnumsModification.CreateForSingleRowUpdate( @Category, @ParamName, @ParamValue );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "AppEnumsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<string, string>, Row> rowsByPk = new Dictionary<Tuple<string, string>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<string, string>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.AppEnumsTableCondition[] conditions ) {
var categoryCondition = conditions.OfType<CommandConditions.@AppEnumsTableEqualityConditions.@Category>().FirstOrDefault();
var paramNameCondition = conditions.OfType<CommandConditions.@AppEnumsTableEqualityConditions.@ParamName>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = categoryCondition != null && paramNameCondition != null && conditions.Count() == 2;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( categoryCondition.Value, paramNameCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM AppEnums", !isPkQuery, orderByClause: "ORDER BY Category, ParamName" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@Category, i.@ParamName ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingPk( string category, string paramName, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@AppEnumsTableEqualityConditions.@Category( category ), new CommandConditions.@AppEnumsTableEqualityConditions.@ParamName( paramName ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
}
/// <summary>
/// Contains logic that retrieves rows from the aspnet_Applications table.
/// </summary>
public static partial class @aspnet_ApplicationsTableRetrieval {
internal class BasicRow {
private readonly string @__applicationName;
private readonly string @__loweredApplicationName;
private readonly System.Guid @__applicationId;
private readonly System.String @__description;
internal BasicRow( DbDataReader reader ) {
@__applicationName = (System.String)reader.GetValue( 0 );
@__loweredApplicationName = (System.String)reader.GetValue( 1 );
@__applicationId = (System.Guid)reader.GetValue( 2 );
@__description = reader.IsDBNull( 3 ) ? (System.String)null : (System.String)reader.GetValue( 3 );
}
internal string @ApplicationName { get { return @__applicationName; } }
internal string @LoweredApplicationName { get { return @__loweredApplicationName; } }
internal System.Guid @ApplicationId { get { return @__applicationId; } }
internal System.String @Description { get { return @__description; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public string @ApplicationName { get { return __basicRow.@ApplicationName; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @LoweredApplicationName { get { return __basicRow.@LoweredApplicationName; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Guid @ApplicationId { get { return __basicRow.@ApplicationId; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.String @Description { get { return __basicRow.@Description; } }
public override int GetHashCode() { 
return @ApplicationName.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @ApplicationName == other.@ApplicationName && @LoweredApplicationName == other.@LoweredApplicationName && @ApplicationId == other.@ApplicationId && @Description == other.@Description;
}
public Modification.@aspnet_ApplicationsModification ToModification() {
return Modification.@aspnet_ApplicationsModification.CreateForSingleRowUpdate( @ApplicationName, @LoweredApplicationName, @ApplicationId, @Description );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "aspnet_ApplicationsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<System.Guid>, Row> rowsByPk = new Dictionary<Tuple<System.Guid>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<System.Guid>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.aspnet_ApplicationsTableCondition[] conditions ) {
var applicationIdCondition = conditions.OfType<CommandConditions.@aspnet_ApplicationsTableEqualityConditions.@ApplicationId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = applicationIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( applicationIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM aspnet_Applications", !isPkQuery, orderByClause: "ORDER BY ApplicationId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@ApplicationId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( System.Guid id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@aspnet_ApplicationsTableEqualityConditions.@ApplicationId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<System.Guid, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@ApplicationId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the aspnet_Membership table.
/// </summary>
public static partial class @aspnet_MembershipTableRetrieval {
internal class BasicRow {
private readonly System.Guid @__applicationId;
private readonly System.Guid @__userId;
private readonly string @__password;
private readonly int @__passwordFormat;
private readonly string @__passwordSalt;
private readonly System.String @__mobilePIN;
private readonly System.String @__email;
private readonly System.String @__loweredEmail;
private readonly System.String @__passwordQuestion;
private readonly System.String @__passwordAnswer;
private readonly System.Boolean @__isApproved;
private readonly System.Boolean @__isLockedOut;
private readonly DateTime @__createDate;
private readonly DateTime @__lastLoginDate;
private readonly DateTime @__lastPasswordChangedDate;
private readonly DateTime @__lastLockoutDate;
private readonly int @__failedPasswordAttemptCount;
private readonly DateTime @__failedPasswordAttemptWindowStart;
private readonly int @__failedPasswordAnswerAttemptCount;
private readonly DateTime @__failedPasswordAnswerAttemptWindowStart;
private readonly System.String @__comment;
internal BasicRow( DbDataReader reader ) {
@__applicationId = (System.Guid)reader.GetValue( 0 );
@__userId = (System.Guid)reader.GetValue( 1 );
@__password = (System.String)reader.GetValue( 2 );
@__passwordFormat = (System.Int32)reader.GetValue( 3 );
@__passwordSalt = (System.String)reader.GetValue( 4 );
@__mobilePIN = reader.IsDBNull( 5 ) ? (System.String)null : (System.String)reader.GetValue( 5 );
@__email = reader.IsDBNull( 6 ) ? (System.String)null : (System.String)reader.GetValue( 6 );
@__loweredEmail = reader.IsDBNull( 7 ) ? (System.String)null : (System.String)reader.GetValue( 7 );
@__passwordQuestion = reader.IsDBNull( 8 ) ? (System.String)null : (System.String)reader.GetValue( 8 );
@__passwordAnswer = reader.IsDBNull( 9 ) ? (System.String)null : (System.String)reader.GetValue( 9 );
@__isApproved = (System.Boolean)reader.GetValue( 10 );
@__isLockedOut = (System.Boolean)reader.GetValue( 11 );
@__createDate = (System.DateTime)reader.GetValue( 12 );
@__lastLoginDate = (System.DateTime)reader.GetValue( 13 );
@__lastPasswordChangedDate = (System.DateTime)reader.GetValue( 14 );
@__lastLockoutDate = (System.DateTime)reader.GetValue( 15 );
@__failedPasswordAttemptCount = (System.Int32)reader.GetValue( 16 );
@__failedPasswordAttemptWindowStart = (System.DateTime)reader.GetValue( 17 );
@__failedPasswordAnswerAttemptCount = (System.Int32)reader.GetValue( 18 );
@__failedPasswordAnswerAttemptWindowStart = (System.DateTime)reader.GetValue( 19 );
@__comment = reader.IsDBNull( 20 ) ? (System.String)null : (System.String)reader.GetValue( 20 );
}
internal System.Guid @ApplicationId { get { return @__applicationId; } }
internal System.Guid @UserId { get { return @__userId; } }
internal string @Password { get { return @__password; } }
internal int @PasswordFormat { get { return @__passwordFormat; } }
internal string @PasswordSalt { get { return @__passwordSalt; } }
internal System.String @MobilePIN { get { return @__mobilePIN; } }
internal System.String @Email { get { return @__email; } }
internal System.String @LoweredEmail { get { return @__loweredEmail; } }
internal System.String @PasswordQuestion { get { return @__passwordQuestion; } }
internal System.String @PasswordAnswer { get { return @__passwordAnswer; } }
internal System.Boolean @IsApproved { get { return @__isApproved; } }
internal System.Boolean @IsLockedOut { get { return @__isLockedOut; } }
internal DateTime @CreateDate { get { return @__createDate; } }
internal DateTime @LastLoginDate { get { return @__lastLoginDate; } }
internal DateTime @LastPasswordChangedDate { get { return @__lastPasswordChangedDate; } }
internal DateTime @LastLockoutDate { get { return @__lastLockoutDate; } }
internal int @FailedPasswordAttemptCount { get { return @__failedPasswordAttemptCount; } }
internal DateTime @FailedPasswordAttemptWindowStart { get { return @__failedPasswordAttemptWindowStart; } }
internal int @FailedPasswordAnswerAttemptCount { get { return @__failedPasswordAnswerAttemptCount; } }
internal DateTime @FailedPasswordAnswerAttemptWindowStart { get { return @__failedPasswordAnswerAttemptWindowStart; } }
internal System.String @Comment { get { return @__comment; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public System.Guid @ApplicationId { get { return __basicRow.@ApplicationId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Guid @UserId { get { return __basicRow.@UserId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Password { get { return __basicRow.@Password; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @PasswordFormat { get { return __basicRow.@PasswordFormat; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @PasswordSalt { get { return __basicRow.@PasswordSalt; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.String @MobilePIN { get { return __basicRow.@MobilePIN; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.String @Email { get { return __basicRow.@Email; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.String @LoweredEmail { get { return __basicRow.@LoweredEmail; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.String @PasswordQuestion { get { return __basicRow.@PasswordQuestion; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.String @PasswordAnswer { get { return __basicRow.@PasswordAnswer; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Boolean @IsApproved { get { return __basicRow.@IsApproved; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Boolean @IsLockedOut { get { return __basicRow.@IsLockedOut; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @CreateDate { get { return __basicRow.@CreateDate; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @LastLoginDate { get { return __basicRow.@LastLoginDate; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @LastPasswordChangedDate { get { return __basicRow.@LastPasswordChangedDate; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @LastLockoutDate { get { return __basicRow.@LastLockoutDate; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @FailedPasswordAttemptCount { get { return __basicRow.@FailedPasswordAttemptCount; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @FailedPasswordAttemptWindowStart { get { return __basicRow.@FailedPasswordAttemptWindowStart; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @FailedPasswordAnswerAttemptCount { get { return __basicRow.@FailedPasswordAnswerAttemptCount; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @FailedPasswordAnswerAttemptWindowStart { get { return __basicRow.@FailedPasswordAnswerAttemptWindowStart; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.String @Comment { get { return __basicRow.@Comment; } }
public override int GetHashCode() { 
return @ApplicationId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @ApplicationId == other.@ApplicationId && @UserId == other.@UserId && @Password == other.@Password && @PasswordFormat == other.@PasswordFormat && @PasswordSalt == other.@PasswordSalt && @MobilePIN == other.@MobilePIN && @Email == other.@Email && @LoweredEmail == other.@LoweredEmail && @PasswordQuestion == other.@PasswordQuestion && @PasswordAnswer == other.@PasswordAnswer && @IsApproved == other.@IsApproved && @IsLockedOut == other.@IsLockedOut && @CreateDate == other.@CreateDate && @LastLoginDate == other.@LastLoginDate && @LastPasswordChangedDate == other.@LastPasswordChangedDate && @LastLockoutDate == other.@LastLockoutDate && @FailedPasswordAttemptCount == other.@FailedPasswordAttemptCount && @FailedPasswordAttemptWindowStart == other.@FailedPasswordAttemptWindowStart && @FailedPasswordAnswerAttemptCount == other.@FailedPasswordAnswerAttemptCount && @FailedPasswordAnswerAttemptWindowStart == other.@FailedPasswordAnswerAttemptWindowStart && @Comment == other.@Comment;
}
public Modification.@aspnet_MembershipModification ToModification() {
return Modification.@aspnet_MembershipModification.CreateForSingleRowUpdate( @ApplicationId, @UserId, @Password, @PasswordFormat, @PasswordSalt, @MobilePIN, @Email, @LoweredEmail, @PasswordQuestion, @PasswordAnswer, @IsApproved, @IsLockedOut, @CreateDate, @LastLoginDate, @LastPasswordChangedDate, @LastLockoutDate, @FailedPasswordAttemptCount, @FailedPasswordAttemptWindowStart, @FailedPasswordAnswerAttemptCount, @FailedPasswordAnswerAttemptWindowStart, @Comment );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "aspnet_MembershipTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<System.Guid>, Row> rowsByPk = new Dictionary<Tuple<System.Guid>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<System.Guid>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.aspnet_MembershipTableCondition[] conditions ) {
var userIdCondition = conditions.OfType<CommandConditions.@aspnet_MembershipTableEqualityConditions.@UserId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = userIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( userIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM aspnet_Membership", !isPkQuery, orderByClause: "ORDER BY UserId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@UserId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( System.Guid id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@aspnet_MembershipTableEqualityConditions.@UserId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<System.Guid, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@UserId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the aspnet_Paths table.
/// </summary>
public static partial class @aspnet_PathsTableRetrieval {
internal class BasicRow {
private readonly System.Guid @__applicationId;
private readonly System.Guid @__pathId;
private readonly string @__path;
private readonly string @__loweredPath;
internal BasicRow( DbDataReader reader ) {
@__applicationId = (System.Guid)reader.GetValue( 0 );
@__pathId = (System.Guid)reader.GetValue( 1 );
@__path = (System.String)reader.GetValue( 2 );
@__loweredPath = (System.String)reader.GetValue( 3 );
}
internal System.Guid @ApplicationId { get { return @__applicationId; } }
internal System.Guid @PathId { get { return @__pathId; } }
internal string @Path { get { return @__path; } }
internal string @LoweredPath { get { return @__loweredPath; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public System.Guid @ApplicationId { get { return __basicRow.@ApplicationId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Guid @PathId { get { return __basicRow.@PathId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Path { get { return __basicRow.@Path; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @LoweredPath { get { return __basicRow.@LoweredPath; } }
public override int GetHashCode() { 
return @ApplicationId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @ApplicationId == other.@ApplicationId && @PathId == other.@PathId && @Path == other.@Path && @LoweredPath == other.@LoweredPath;
}
public Modification.@aspnet_PathsModification ToModification() {
return Modification.@aspnet_PathsModification.CreateForSingleRowUpdate( @ApplicationId, @PathId, @Path, @LoweredPath );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "aspnet_PathsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<System.Guid, string>, Row> rowsByPk = new Dictionary<Tuple<System.Guid, string>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<System.Guid, string>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.aspnet_PathsTableCondition[] conditions ) {
var applicationIdCondition = conditions.OfType<CommandConditions.@aspnet_PathsTableEqualityConditions.@ApplicationId>().FirstOrDefault();
var loweredPathCondition = conditions.OfType<CommandConditions.@aspnet_PathsTableEqualityConditions.@LoweredPath>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = applicationIdCondition != null && loweredPathCondition != null && conditions.Count() == 2;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( applicationIdCondition.Value, loweredPathCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM aspnet_Paths", !isPkQuery, orderByClause: "ORDER BY ApplicationId, LoweredPath" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@ApplicationId, i.@LoweredPath ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingPk( System.Guid applicationId, string loweredPath, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@aspnet_PathsTableEqualityConditions.@ApplicationId( applicationId ), new CommandConditions.@aspnet_PathsTableEqualityConditions.@LoweredPath( loweredPath ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
}
/// <summary>
/// Contains logic that retrieves rows from the aspnet_PersonalizationAllUsers table.
/// </summary>
public static partial class @aspnet_PersonalizationAllUsersTableRetrieval {
internal class BasicRow {
private readonly System.Guid @__pathId;
private readonly System.Byte[] @__pageSettings;
private readonly DateTime @__lastUpdatedDate;
internal BasicRow( DbDataReader reader ) {
@__pathId = (System.Guid)reader.GetValue( 0 );
@__pageSettings = (System.Byte[])reader.GetValue( 1 );
@__lastUpdatedDate = (System.DateTime)reader.GetValue( 2 );
}
internal System.Guid @PathId { get { return @__pathId; } }
internal System.Byte[] @PageSettings { get { return @__pageSettings; } }
internal DateTime @LastUpdatedDate { get { return @__lastUpdatedDate; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public System.Guid @PathId { get { return __basicRow.@PathId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @PageSettings { get { return __basicRow.@PageSettings; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @LastUpdatedDate { get { return __basicRow.@LastUpdatedDate; } }
public override int GetHashCode() { 
return @PathId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @PathId == other.@PathId && @LastUpdatedDate == other.@LastUpdatedDate;
}
public Modification.@aspnet_PersonalizationAllUsersModification ToModification() {
return Modification.@aspnet_PersonalizationAllUsersModification.CreateForSingleRowUpdate( @PathId, @PageSettings, @LastUpdatedDate );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "aspnet_PersonalizationAllUsersTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<System.Guid>, Row> rowsByPk = new Dictionary<Tuple<System.Guid>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<System.Guid>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.aspnet_PersonalizationAllUsersTableCondition[] conditions ) {
var pathIdCondition = conditions.OfType<CommandConditions.@aspnet_PersonalizationAllUsersTableEqualityConditions.@PathId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = pathIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( pathIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM aspnet_PersonalizationAllUsers", !isPkQuery, orderByClause: "ORDER BY PathId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@PathId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( System.Guid id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@aspnet_PersonalizationAllUsersTableEqualityConditions.@PathId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<System.Guid, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@PathId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the aspnet_PersonalizationPerUser table.
/// </summary>
public static partial class @aspnet_PersonalizationPerUserTableRetrieval {
internal class BasicRow {
private readonly System.Guid @__id;
private readonly System.Guid? @__pathId;
private readonly System.Guid? @__userId;
private readonly System.Byte[] @__pageSettings;
private readonly DateTime @__lastUpdatedDate;
internal BasicRow( DbDataReader reader ) {
@__id = (System.Guid)reader.GetValue( 0 );
@__pathId = reader.IsDBNull( 1 ) ? (System.Guid?)null : (System.Guid)reader.GetValue( 1 );
@__userId = reader.IsDBNull( 2 ) ? (System.Guid?)null : (System.Guid)reader.GetValue( 2 );
@__pageSettings = (System.Byte[])reader.GetValue( 3 );
@__lastUpdatedDate = (System.DateTime)reader.GetValue( 4 );
}
internal System.Guid @Id { get { return @__id; } }
internal System.Guid? @PathId { get { return @__pathId; } }
internal System.Guid? @UserId { get { return @__userId; } }
internal System.Byte[] @PageSettings { get { return @__pageSettings; } }
internal DateTime @LastUpdatedDate { get { return @__lastUpdatedDate; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public System.Guid @Id { get { return __basicRow.@Id; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.Guid? @PathId { get { return __basicRow.@PathId; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.Guid? @UserId { get { return __basicRow.@UserId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @PageSettings { get { return __basicRow.@PageSettings; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @LastUpdatedDate { get { return __basicRow.@LastUpdatedDate; } }
public override int GetHashCode() { 
return @Id.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @Id == other.@Id && @PathId == other.@PathId && @UserId == other.@UserId && @LastUpdatedDate == other.@LastUpdatedDate;
}
public Modification.@aspnet_PersonalizationPerUserModification ToModification() {
return Modification.@aspnet_PersonalizationPerUserModification.CreateForSingleRowUpdate( @Id, @PathId, @UserId, @PageSettings, @LastUpdatedDate );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "aspnet_PersonalizationPerUserTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<System.Guid?, System.Guid?>, Row> rowsByPk = new Dictionary<Tuple<System.Guid?, System.Guid?>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<System.Guid?, System.Guid?>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.aspnet_PersonalizationPerUserTableCondition[] conditions ) {
var pathIdCondition = conditions.OfType<CommandConditions.@aspnet_PersonalizationPerUserTableEqualityConditions.@PathId>().FirstOrDefault();
var userIdCondition = conditions.OfType<CommandConditions.@aspnet_PersonalizationPerUserTableEqualityConditions.@UserId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = pathIdCondition != null && userIdCondition != null && conditions.Count() == 2;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( pathIdCondition.Value, userIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM aspnet_PersonalizationPerUser", !isPkQuery, orderByClause: "ORDER BY PathId, UserId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@PathId, i.@UserId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingPk( System.Guid? pathId, System.Guid? userId, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@aspnet_PersonalizationPerUserTableEqualityConditions.@PathId( pathId ), new CommandConditions.@aspnet_PersonalizationPerUserTableEqualityConditions.@UserId( userId ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
}
/// <summary>
/// Contains logic that retrieves rows from the aspnet_Profile table.
/// </summary>
public static partial class @aspnet_ProfileTableRetrieval {
internal class BasicRow {
private readonly System.Guid @__userId;
private readonly string @__propertyNames;
private readonly string @__propertyValuesString;
private readonly System.Byte[] @__propertyValuesBinary;
private readonly DateTime @__lastUpdatedDate;
internal BasicRow( DbDataReader reader ) {
@__userId = (System.Guid)reader.GetValue( 0 );
@__propertyNames = (System.String)reader.GetValue( 1 );
@__propertyValuesString = (System.String)reader.GetValue( 2 );
@__propertyValuesBinary = (System.Byte[])reader.GetValue( 3 );
@__lastUpdatedDate = (System.DateTime)reader.GetValue( 4 );
}
internal System.Guid @UserId { get { return @__userId; } }
internal string @PropertyNames { get { return @__propertyNames; } }
internal string @PropertyValuesString { get { return @__propertyValuesString; } }
internal System.Byte[] @PropertyValuesBinary { get { return @__propertyValuesBinary; } }
internal DateTime @LastUpdatedDate { get { return @__lastUpdatedDate; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public System.Guid @UserId { get { return __basicRow.@UserId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @PropertyNames { get { return __basicRow.@PropertyNames; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @PropertyValuesString { get { return __basicRow.@PropertyValuesString; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @PropertyValuesBinary { get { return __basicRow.@PropertyValuesBinary; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @LastUpdatedDate { get { return __basicRow.@LastUpdatedDate; } }
public override int GetHashCode() { 
return @UserId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @UserId == other.@UserId && @PropertyNames == other.@PropertyNames && @PropertyValuesString == other.@PropertyValuesString && @LastUpdatedDate == other.@LastUpdatedDate;
}
public Modification.@aspnet_ProfileModification ToModification() {
return Modification.@aspnet_ProfileModification.CreateForSingleRowUpdate( @UserId, @PropertyNames, @PropertyValuesString, @PropertyValuesBinary, @LastUpdatedDate );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "aspnet_ProfileTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<System.Guid>, Row> rowsByPk = new Dictionary<Tuple<System.Guid>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<System.Guid>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.aspnet_ProfileTableCondition[] conditions ) {
var userIdCondition = conditions.OfType<CommandConditions.@aspnet_ProfileTableEqualityConditions.@UserId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = userIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( userIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM aspnet_Profile", !isPkQuery, orderByClause: "ORDER BY UserId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@UserId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( System.Guid id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@aspnet_ProfileTableEqualityConditions.@UserId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<System.Guid, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@UserId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the aspnet_Roles table.
/// </summary>
public static partial class @aspnet_RolesTableRetrieval {
internal class BasicRow {
private readonly System.Guid @__applicationId;
private readonly System.Guid @__roleId;
private readonly string @__roleName;
private readonly string @__loweredRoleName;
private readonly System.String @__description;
internal BasicRow( DbDataReader reader ) {
@__applicationId = (System.Guid)reader.GetValue( 0 );
@__roleId = (System.Guid)reader.GetValue( 1 );
@__roleName = (System.String)reader.GetValue( 2 );
@__loweredRoleName = (System.String)reader.GetValue( 3 );
@__description = reader.IsDBNull( 4 ) ? (System.String)null : (System.String)reader.GetValue( 4 );
}
internal System.Guid @ApplicationId { get { return @__applicationId; } }
internal System.Guid @RoleId { get { return @__roleId; } }
internal string @RoleName { get { return @__roleName; } }
internal string @LoweredRoleName { get { return @__loweredRoleName; } }
internal System.String @Description { get { return @__description; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public System.Guid @ApplicationId { get { return __basicRow.@ApplicationId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Guid @RoleId { get { return __basicRow.@RoleId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @RoleName { get { return __basicRow.@RoleName; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @LoweredRoleName { get { return __basicRow.@LoweredRoleName; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.String @Description { get { return __basicRow.@Description; } }
public override int GetHashCode() { 
return @ApplicationId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @ApplicationId == other.@ApplicationId && @RoleId == other.@RoleId && @RoleName == other.@RoleName && @LoweredRoleName == other.@LoweredRoleName && @Description == other.@Description;
}
public Modification.@aspnet_RolesModification ToModification() {
return Modification.@aspnet_RolesModification.CreateForSingleRowUpdate( @ApplicationId, @RoleId, @RoleName, @LoweredRoleName, @Description );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "aspnet_RolesTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<System.Guid, string>, Row> rowsByPk = new Dictionary<Tuple<System.Guid, string>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<System.Guid, string>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.aspnet_RolesTableCondition[] conditions ) {
var applicationIdCondition = conditions.OfType<CommandConditions.@aspnet_RolesTableEqualityConditions.@ApplicationId>().FirstOrDefault();
var loweredRoleNameCondition = conditions.OfType<CommandConditions.@aspnet_RolesTableEqualityConditions.@LoweredRoleName>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = applicationIdCondition != null && loweredRoleNameCondition != null && conditions.Count() == 2;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( applicationIdCondition.Value, loweredRoleNameCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM aspnet_Roles", !isPkQuery, orderByClause: "ORDER BY ApplicationId, LoweredRoleName" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@ApplicationId, i.@LoweredRoleName ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingPk( System.Guid applicationId, string loweredRoleName, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@aspnet_RolesTableEqualityConditions.@ApplicationId( applicationId ), new CommandConditions.@aspnet_RolesTableEqualityConditions.@LoweredRoleName( loweredRoleName ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
}
/// <summary>
/// Contains logic that retrieves rows from the aspnet_SchemaVersions table.
/// </summary>
public static partial class @aspnet_SchemaVersionsTableRetrieval {
internal class BasicRow {
private readonly string @__feature;
private readonly string @__compatibleSchemaVersion;
private readonly System.Boolean @__isCurrentVersion;
internal BasicRow( DbDataReader reader ) {
@__feature = (System.String)reader.GetValue( 0 );
@__compatibleSchemaVersion = (System.String)reader.GetValue( 1 );
@__isCurrentVersion = (System.Boolean)reader.GetValue( 2 );
}
internal string @Feature { get { return @__feature; } }
internal string @CompatibleSchemaVersion { get { return @__compatibleSchemaVersion; } }
internal System.Boolean @IsCurrentVersion { get { return @__isCurrentVersion; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public string @Feature { get { return __basicRow.@Feature; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @CompatibleSchemaVersion { get { return __basicRow.@CompatibleSchemaVersion; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Boolean @IsCurrentVersion { get { return __basicRow.@IsCurrentVersion; } }
public override int GetHashCode() { 
return @Feature.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @Feature == other.@Feature && @CompatibleSchemaVersion == other.@CompatibleSchemaVersion && @IsCurrentVersion == other.@IsCurrentVersion;
}
public Modification.@aspnet_SchemaVersionsModification ToModification() {
return Modification.@aspnet_SchemaVersionsModification.CreateForSingleRowUpdate( @Feature, @CompatibleSchemaVersion, @IsCurrentVersion );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "aspnet_SchemaVersionsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<string, string>, Row> rowsByPk = new Dictionary<Tuple<string, string>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<string, string>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.aspnet_SchemaVersionsTableCondition[] conditions ) {
var featureCondition = conditions.OfType<CommandConditions.@aspnet_SchemaVersionsTableEqualityConditions.@Feature>().FirstOrDefault();
var compatibleSchemaVersionCondition = conditions.OfType<CommandConditions.@aspnet_SchemaVersionsTableEqualityConditions.@CompatibleSchemaVersion>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = featureCondition != null && compatibleSchemaVersionCondition != null && conditions.Count() == 2;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( featureCondition.Value, compatibleSchemaVersionCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM aspnet_SchemaVersions", !isPkQuery, orderByClause: "ORDER BY Feature, CompatibleSchemaVersion" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@Feature, i.@CompatibleSchemaVersion ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingPk( string feature, string compatibleSchemaVersion, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@aspnet_SchemaVersionsTableEqualityConditions.@Feature( feature ), new CommandConditions.@aspnet_SchemaVersionsTableEqualityConditions.@CompatibleSchemaVersion( compatibleSchemaVersion ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
}
/// <summary>
/// Contains logic that retrieves rows from the aspnet_Users table.
/// </summary>
public static partial class @aspnet_UsersTableRetrieval {
internal class BasicRow {
private readonly System.Guid @__applicationId;
private readonly System.Guid @__userId;
private readonly string @__userName;
private readonly string @__loweredUserName;
private readonly System.String @__mobileAlias;
private readonly System.Boolean @__isAnonymous;
private readonly DateTime @__lastActivityDate;
internal BasicRow( DbDataReader reader ) {
@__applicationId = (System.Guid)reader.GetValue( 0 );
@__userId = (System.Guid)reader.GetValue( 1 );
@__userName = (System.String)reader.GetValue( 2 );
@__loweredUserName = (System.String)reader.GetValue( 3 );
@__mobileAlias = reader.IsDBNull( 4 ) ? (System.String)null : (System.String)reader.GetValue( 4 );
@__isAnonymous = (System.Boolean)reader.GetValue( 5 );
@__lastActivityDate = (System.DateTime)reader.GetValue( 6 );
}
internal System.Guid @ApplicationId { get { return @__applicationId; } }
internal System.Guid @UserId { get { return @__userId; } }
internal string @UserName { get { return @__userName; } }
internal string @LoweredUserName { get { return @__loweredUserName; } }
internal System.String @MobileAlias { get { return @__mobileAlias; } }
internal System.Boolean @IsAnonymous { get { return @__isAnonymous; } }
internal DateTime @LastActivityDate { get { return @__lastActivityDate; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public System.Guid @ApplicationId { get { return __basicRow.@ApplicationId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Guid @UserId { get { return __basicRow.@UserId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @UserName { get { return __basicRow.@UserName; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @LoweredUserName { get { return __basicRow.@LoweredUserName; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.String @MobileAlias { get { return __basicRow.@MobileAlias; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Boolean @IsAnonymous { get { return __basicRow.@IsAnonymous; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @LastActivityDate { get { return __basicRow.@LastActivityDate; } }
public override int GetHashCode() { 
return @ApplicationId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @ApplicationId == other.@ApplicationId && @UserId == other.@UserId && @UserName == other.@UserName && @LoweredUserName == other.@LoweredUserName && @MobileAlias == other.@MobileAlias && @IsAnonymous == other.@IsAnonymous && @LastActivityDate == other.@LastActivityDate;
}
public Modification.@aspnet_UsersModification ToModification() {
return Modification.@aspnet_UsersModification.CreateForSingleRowUpdate( @ApplicationId, @UserId, @UserName, @LoweredUserName, @MobileAlias, @IsAnonymous, @LastActivityDate );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "aspnet_UsersTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<System.Guid, string>, Row> rowsByPk = new Dictionary<Tuple<System.Guid, string>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<System.Guid, string>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.aspnet_UsersTableCondition[] conditions ) {
var applicationIdCondition = conditions.OfType<CommandConditions.@aspnet_UsersTableEqualityConditions.@ApplicationId>().FirstOrDefault();
var loweredUserNameCondition = conditions.OfType<CommandConditions.@aspnet_UsersTableEqualityConditions.@LoweredUserName>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = applicationIdCondition != null && loweredUserNameCondition != null && conditions.Count() == 2;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( applicationIdCondition.Value, loweredUserNameCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM aspnet_Users", !isPkQuery, orderByClause: "ORDER BY ApplicationId, LoweredUserName" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@ApplicationId, i.@LoweredUserName ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingPk( System.Guid applicationId, string loweredUserName, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@aspnet_UsersTableEqualityConditions.@ApplicationId( applicationId ), new CommandConditions.@aspnet_UsersTableEqualityConditions.@LoweredUserName( loweredUserName ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
}
/// <summary>
/// Contains logic that retrieves rows from the aspnet_UsersInRoles table.
/// </summary>
public static partial class @aspnet_UsersInRolesTableRetrieval {
internal class BasicRow {
private readonly System.Guid @__userId;
private readonly System.Guid @__roleId;
internal BasicRow( DbDataReader reader ) {
@__userId = (System.Guid)reader.GetValue( 0 );
@__roleId = (System.Guid)reader.GetValue( 1 );
}
internal System.Guid @UserId { get { return @__userId; } }
internal System.Guid @RoleId { get { return @__roleId; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public System.Guid @UserId { get { return __basicRow.@UserId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Guid @RoleId { get { return __basicRow.@RoleId; } }
public override int GetHashCode() { 
return @UserId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @UserId == other.@UserId && @RoleId == other.@RoleId;
}
public Modification.@aspnet_UsersInRolesModification ToModification() {
return Modification.@aspnet_UsersInRolesModification.CreateForSingleRowUpdate( @UserId, @RoleId );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "aspnet_UsersInRolesTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<System.Guid, System.Guid>, Row> rowsByPk = new Dictionary<Tuple<System.Guid, System.Guid>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<System.Guid, System.Guid>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.aspnet_UsersInRolesTableCondition[] conditions ) {
var userIdCondition = conditions.OfType<CommandConditions.@aspnet_UsersInRolesTableEqualityConditions.@UserId>().FirstOrDefault();
var roleIdCondition = conditions.OfType<CommandConditions.@aspnet_UsersInRolesTableEqualityConditions.@RoleId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = userIdCondition != null && roleIdCondition != null && conditions.Count() == 2;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( userIdCondition.Value, roleIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM aspnet_UsersInRoles", !isPkQuery, orderByClause: "ORDER BY UserId, RoleId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@UserId, i.@RoleId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingPk( System.Guid userId, System.Guid roleId, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@aspnet_UsersInRolesTableEqualityConditions.@UserId( userId ), new CommandConditions.@aspnet_UsersInRolesTableEqualityConditions.@RoleId( roleId ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
}
/// <summary>
/// Contains logic that retrieves rows from the aspnet_WebEvent_Events table.
/// </summary>
public static partial class @aspnet_WebEvent_EventsTableRetrieval {
internal class BasicRow {
private readonly string @__eventId;
private readonly DateTime @__eventTimeUtc;
private readonly DateTime @__eventTime;
private readonly string @__eventType;
private readonly decimal @__eventSequence;
private readonly decimal @__eventOccurrence;
private readonly int @__eventCode;
private readonly int @__eventDetailCode;
private readonly System.String @__message;
private readonly System.String @__applicationPath;
private readonly System.String @__applicationVirtualPath;
private readonly string @__machineName;
private readonly System.String @__requestUrl;
private readonly System.String @__exceptionType;
private readonly System.String @__details;
internal BasicRow( DbDataReader reader ) {
@__eventId = (System.String)reader.GetValue( 0 );
@__eventTimeUtc = (System.DateTime)reader.GetValue( 1 );
@__eventTime = (System.DateTime)reader.GetValue( 2 );
@__eventType = (System.String)reader.GetValue( 3 );
@__eventSequence = (System.Decimal)reader.GetValue( 4 );
@__eventOccurrence = (System.Decimal)reader.GetValue( 5 );
@__eventCode = (System.Int32)reader.GetValue( 6 );
@__eventDetailCode = (System.Int32)reader.GetValue( 7 );
@__message = reader.IsDBNull( 8 ) ? (System.String)null : (System.String)reader.GetValue( 8 );
@__applicationPath = reader.IsDBNull( 9 ) ? (System.String)null : (System.String)reader.GetValue( 9 );
@__applicationVirtualPath = reader.IsDBNull( 10 ) ? (System.String)null : (System.String)reader.GetValue( 10 );
@__machineName = (System.String)reader.GetValue( 11 );
@__requestUrl = reader.IsDBNull( 12 ) ? (System.String)null : (System.String)reader.GetValue( 12 );
@__exceptionType = reader.IsDBNull( 13 ) ? (System.String)null : (System.String)reader.GetValue( 13 );
@__details = reader.IsDBNull( 14 ) ? (System.String)null : (System.String)reader.GetValue( 14 );
}
internal string @EventId { get { return @__eventId; } }
internal DateTime @EventTimeUtc { get { return @__eventTimeUtc; } }
internal DateTime @EventTime { get { return @__eventTime; } }
internal string @EventType { get { return @__eventType; } }
internal decimal @EventSequence { get { return @__eventSequence; } }
internal decimal @EventOccurrence { get { return @__eventOccurrence; } }
internal int @EventCode { get { return @__eventCode; } }
internal int @EventDetailCode { get { return @__eventDetailCode; } }
internal System.String @Message { get { return @__message; } }
internal System.String @ApplicationPath { get { return @__applicationPath; } }
internal System.String @ApplicationVirtualPath { get { return @__applicationVirtualPath; } }
internal string @MachineName { get { return @__machineName; } }
internal System.String @RequestUrl { get { return @__requestUrl; } }
internal System.String @ExceptionType { get { return @__exceptionType; } }
internal System.String @Details { get { return @__details; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public string @EventId { get { return __basicRow.@EventId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @EventTimeUtc { get { return __basicRow.@EventTimeUtc; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @EventTime { get { return __basicRow.@EventTime; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @EventType { get { return __basicRow.@EventType; } }
/// <summary>
/// This object will never be null.
/// </summary>
public decimal @EventSequence { get { return __basicRow.@EventSequence; } }
/// <summary>
/// This object will never be null.
/// </summary>
public decimal @EventOccurrence { get { return __basicRow.@EventOccurrence; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @EventCode { get { return __basicRow.@EventCode; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @EventDetailCode { get { return __basicRow.@EventDetailCode; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.String @Message { get { return __basicRow.@Message; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.String @ApplicationPath { get { return __basicRow.@ApplicationPath; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.String @ApplicationVirtualPath { get { return __basicRow.@ApplicationVirtualPath; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @MachineName { get { return __basicRow.@MachineName; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.String @RequestUrl { get { return __basicRow.@RequestUrl; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.String @ExceptionType { get { return __basicRow.@ExceptionType; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.String @Details { get { return __basicRow.@Details; } }
public override int GetHashCode() { 
return @EventId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @EventId == other.@EventId && @EventTimeUtc == other.@EventTimeUtc && @EventTime == other.@EventTime && @EventType == other.@EventType && @EventSequence == other.@EventSequence && @EventOccurrence == other.@EventOccurrence && @EventCode == other.@EventCode && @EventDetailCode == other.@EventDetailCode && @Message == other.@Message && @ApplicationPath == other.@ApplicationPath && @ApplicationVirtualPath == other.@ApplicationVirtualPath && @MachineName == other.@MachineName && @RequestUrl == other.@RequestUrl && @ExceptionType == other.@ExceptionType && @Details == other.@Details;
}
public Modification.@aspnet_WebEvent_EventsModification ToModification() {
return Modification.@aspnet_WebEvent_EventsModification.CreateForSingleRowUpdate( @EventId, @EventTimeUtc, @EventTime, @EventType, @EventSequence, @EventOccurrence, @EventCode, @EventDetailCode, @Message, @ApplicationPath, @ApplicationVirtualPath, @MachineName, @RequestUrl, @ExceptionType, @Details );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "aspnet_WebEvent_EventsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<string>, Row> rowsByPk = new Dictionary<Tuple<string>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<string>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.aspnet_WebEvent_EventsTableCondition[] conditions ) {
var eventIdCondition = conditions.OfType<CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@EventId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = eventIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( eventIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM aspnet_WebEvent_Events", !isPkQuery, orderByClause: "ORDER BY EventId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@EventId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( string id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@EventId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<string, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@EventId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the BackgroundNotifierLogs table.
/// </summary>
public static partial class @BackgroundNotifierLogsTableRetrieval {
internal class BasicRow {
private readonly int @__backgroundNotifierLogId;
private readonly int @__userId;
private readonly System.Boolean @__isError;
private readonly string @__details;
private readonly DateTime @__sentDateTimeUtc;
internal BasicRow( DbDataReader reader ) {
@__backgroundNotifierLogId = (System.Int32)reader.GetValue( 0 );
@__userId = (System.Int32)reader.GetValue( 1 );
@__isError = (System.Boolean)reader.GetValue( 2 );
@__details = (System.String)reader.GetValue( 3 );
@__sentDateTimeUtc = (System.DateTime)reader.GetValue( 4 );
}
internal int @BackgroundNotifierLogId { get { return @__backgroundNotifierLogId; } }
internal int @UserId { get { return @__userId; } }
internal System.Boolean @IsError { get { return @__isError; } }
internal string @Details { get { return @__details; } }
internal DateTime @SentDateTimeUtc { get { return @__sentDateTimeUtc; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @BackgroundNotifierLogId { get { return __basicRow.@BackgroundNotifierLogId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @UserId { get { return __basicRow.@UserId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Boolean @IsError { get { return __basicRow.@IsError; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Details { get { return __basicRow.@Details; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @SentDateTimeUtc { get { return __basicRow.@SentDateTimeUtc; } }
public override int GetHashCode() { 
return @BackgroundNotifierLogId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @BackgroundNotifierLogId == other.@BackgroundNotifierLogId && @UserId == other.@UserId && @IsError == other.@IsError && @Details == other.@Details && @SentDateTimeUtc == other.@SentDateTimeUtc;
}
public Modification.@BackgroundNotifierLogsModification ToModification() {
return Modification.@BackgroundNotifierLogsModification.CreateForSingleRowUpdate( @BackgroundNotifierLogId, @UserId, @IsError, @Details, @SentDateTimeUtc );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "BackgroundNotifierLogsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.BackgroundNotifierLogsTableCondition[] conditions ) {
var backgroundNotifierLogIdCondition = conditions.OfType<CommandConditions.@BackgroundNotifierLogsTableEqualityConditions.@BackgroundNotifierLogId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = backgroundNotifierLogIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( backgroundNotifierLogIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM BackgroundNotifierLogs", !isPkQuery, orderByClause: "ORDER BY BackgroundNotifierLogId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@BackgroundNotifierLogId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@BackgroundNotifierLogsTableEqualityConditions.@BackgroundNotifierLogId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@BackgroundNotifierLogId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the CareZones table.
/// </summary>
public static partial class @CareZonesTableRetrieval {
internal class BasicRow {
private readonly int @__careZoneId;
private readonly string @__name;
internal BasicRow( DbDataReader reader ) {
@__careZoneId = (System.Int32)reader.GetValue( 0 );
@__name = (System.String)reader.GetValue( 1 );
}
internal int @CareZoneId { get { return @__careZoneId; } }
internal string @Name { get { return @__name; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @CareZoneId { get { return __basicRow.@CareZoneId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Name { get { return __basicRow.@Name; } }
public override int GetHashCode() { 
return @CareZoneId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @CareZoneId == other.@CareZoneId && @Name == other.@Name;
}
public Modification.@CareZonesModification ToModification() {
return Modification.@CareZonesModification.CreateForSingleRowUpdate( @CareZoneId, @Name );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "CareZonesTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.CareZonesTableCondition[] conditions ) {
var careZoneIdCondition = conditions.OfType<CommandConditions.@CareZonesTableEqualityConditions.@CareZoneId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = careZoneIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( careZoneIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM CareZones", !isPkQuery, orderByClause: "ORDER BY CareZoneId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@CareZoneId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@CareZonesTableEqualityConditions.@CareZoneId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@CareZoneId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the CareZonesToWorkGroups table.
/// </summary>
public static partial class @CareZonesToWorkGroupsTableRetrieval {
internal class BasicRow {
private readonly int @__careZoneToWorkGroupId;
private readonly int @__careZoneId;
private readonly int @__workGroupId;
internal BasicRow( DbDataReader reader ) {
@__careZoneToWorkGroupId = (System.Int32)reader.GetValue( 0 );
@__careZoneId = (System.Int32)reader.GetValue( 1 );
@__workGroupId = (System.Int32)reader.GetValue( 2 );
}
internal int @CareZoneToWorkGroupId { get { return @__careZoneToWorkGroupId; } }
internal int @CareZoneId { get { return @__careZoneId; } }
internal int @WorkGroupId { get { return @__workGroupId; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @CareZoneToWorkGroupId { get { return __basicRow.@CareZoneToWorkGroupId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @CareZoneId { get { return __basicRow.@CareZoneId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @WorkGroupId { get { return __basicRow.@WorkGroupId; } }
public override int GetHashCode() { 
return @CareZoneToWorkGroupId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @CareZoneToWorkGroupId == other.@CareZoneToWorkGroupId && @CareZoneId == other.@CareZoneId && @WorkGroupId == other.@WorkGroupId;
}
public Modification.@CareZonesToWorkGroupsModification ToModification() {
return Modification.@CareZonesToWorkGroupsModification.CreateForSingleRowUpdate( @CareZoneToWorkGroupId, @CareZoneId, @WorkGroupId );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "CareZonesToWorkGroupsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.CareZonesToWorkGroupsTableCondition[] conditions ) {
var careZoneToWorkGroupIdCondition = conditions.OfType<CommandConditions.@CareZonesToWorkGroupsTableEqualityConditions.@CareZoneToWorkGroupId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = careZoneToWorkGroupIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( careZoneToWorkGroupIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM CareZonesToWorkGroups", !isPkQuery, orderByClause: "ORDER BY CareZoneToWorkGroupId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@CareZoneToWorkGroupId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@CareZonesToWorkGroupsTableEqualityConditions.@CareZoneToWorkGroupId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@CareZoneToWorkGroupId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the ClinicianPatients table.
/// </summary>
public static partial class @ClinicianPatientsTableRetrieval {
internal class BasicRow {
private readonly int @__clinicianPatientId;
private readonly string @__encryptionKeyVersion;
private readonly System.Byte[] @__encryptionIv;
private readonly int @__clinicianId;
private readonly System.Byte[] @__patientInfoId;
internal BasicRow( DbDataReader reader ) {
@__clinicianPatientId = (System.Int32)reader.GetValue( 0 );
@__encryptionKeyVersion = (System.String)reader.GetValue( 1 );
@__encryptionIv = (System.Byte[])reader.GetValue( 2 );
@__clinicianId = (System.Int32)reader.GetValue( 3 );
@__patientInfoId = (System.Byte[])reader.GetValue( 4 );
}
internal int @ClinicianPatientId { get { return @__clinicianPatientId; } }
internal string @EncryptionKeyVersion { get { return @__encryptionKeyVersion; } }
internal System.Byte[] @EncryptionIv { get { return @__encryptionIv; } }
internal int @ClinicianId { get { return @__clinicianId; } }
internal System.Byte[] @PatientInfoId { get { return @__patientInfoId; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @ClinicianPatientId { get { return __basicRow.@ClinicianPatientId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @EncryptionKeyVersion { get { return __basicRow.@EncryptionKeyVersion; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @EncryptionIv { get { return __basicRow.@EncryptionIv; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @ClinicianId { get { return __basicRow.@ClinicianId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @PatientInfoId { get { return __basicRow.@PatientInfoId; } }
public override int GetHashCode() { 
return @ClinicianPatientId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @ClinicianPatientId == other.@ClinicianPatientId && @EncryptionKeyVersion == other.@EncryptionKeyVersion && @ClinicianId == other.@ClinicianId;
}
public Modification.@ClinicianPatientsModification ToModification() {
return Modification.@ClinicianPatientsModification.CreateForSingleRowUpdate( @ClinicianPatientId, @EncryptionKeyVersion, @EncryptionIv, @ClinicianId, @PatientInfoId );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "ClinicianPatientsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.ClinicianPatientsTableCondition[] conditions ) {
var clinicianPatientIdCondition = conditions.OfType<CommandConditions.@ClinicianPatientsTableEqualityConditions.@ClinicianPatientId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = clinicianPatientIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( clinicianPatientIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM ClinicianPatients", !isPkQuery, orderByClause: "ORDER BY ClinicianPatientId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@ClinicianPatientId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@ClinicianPatientsTableEqualityConditions.@ClinicianPatientId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@ClinicianPatientId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the Clinicians table.
/// </summary>
public static partial class @CliniciansTableRetrieval {
internal class BasicRow {
private readonly int @__clinicianId;
private readonly string @__firstName;
private readonly string @__lastName;
private readonly int @__workGroupId;
private readonly int @__userId;
internal BasicRow( DbDataReader reader ) {
@__clinicianId = (System.Int32)reader.GetValue( 0 );
@__firstName = (System.String)reader.GetValue( 1 );
@__lastName = (System.String)reader.GetValue( 2 );
@__workGroupId = (System.Int32)reader.GetValue( 3 );
@__userId = (System.Int32)reader.GetValue( 4 );
}
internal int @ClinicianId { get { return @__clinicianId; } }
internal string @FirstName { get { return @__firstName; } }
internal string @LastName { get { return @__lastName; } }
internal int @WorkGroupId { get { return @__workGroupId; } }
internal int @UserId { get { return @__userId; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @ClinicianId { get { return __basicRow.@ClinicianId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @FirstName { get { return __basicRow.@FirstName; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @LastName { get { return __basicRow.@LastName; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @WorkGroupId { get { return __basicRow.@WorkGroupId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @UserId { get { return __basicRow.@UserId; } }
public override int GetHashCode() { 
return @ClinicianId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @ClinicianId == other.@ClinicianId && @FirstName == other.@FirstName && @LastName == other.@LastName && @WorkGroupId == other.@WorkGroupId && @UserId == other.@UserId;
}
public Modification.@CliniciansModification ToModification() {
return Modification.@CliniciansModification.CreateForSingleRowUpdate( @ClinicianId, @FirstName, @LastName, @WorkGroupId, @UserId );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "CliniciansTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.CliniciansTableCondition[] conditions ) {
var clinicianIdCondition = conditions.OfType<CommandConditions.@CliniciansTableEqualityConditions.@ClinicianId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = clinicianIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( clinicianIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM Clinicians", !isPkQuery, orderByClause: "ORDER BY ClinicianId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@ClinicianId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@CliniciansTableEqualityConditions.@ClinicianId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@ClinicianId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the CompletedCourses table.
/// </summary>
public static partial class @CompletedCoursesTableRetrieval {
internal class BasicRow {
private readonly int @__completedCourseId;
private readonly int @__trainingCourseId;
private readonly System.DateTime? @__startDateTime;
private readonly System.DateTime? @__finishedDateTime;
private readonly int @__userId;
internal BasicRow( DbDataReader reader ) {
@__completedCourseId = (System.Int32)reader.GetValue( 0 );
@__trainingCourseId = (System.Int32)reader.GetValue( 1 );
@__startDateTime = reader.IsDBNull( 2 ) ? (System.DateTime?)null : (System.DateTime)reader.GetValue( 2 );
@__finishedDateTime = reader.IsDBNull( 3 ) ? (System.DateTime?)null : (System.DateTime)reader.GetValue( 3 );
@__userId = (System.Int32)reader.GetValue( 4 );
}
internal int @CompletedCourseId { get { return @__completedCourseId; } }
internal int @TrainingCourseId { get { return @__trainingCourseId; } }
internal System.DateTime? @StartDateTime { get { return @__startDateTime; } }
internal System.DateTime? @FinishedDateTime { get { return @__finishedDateTime; } }
internal int @UserId { get { return @__userId; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @CompletedCourseId { get { return __basicRow.@CompletedCourseId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @TrainingCourseId { get { return __basicRow.@TrainingCourseId; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.DateTime? @StartDateTime { get { return __basicRow.@StartDateTime; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.DateTime? @FinishedDateTime { get { return __basicRow.@FinishedDateTime; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @UserId { get { return __basicRow.@UserId; } }
public override int GetHashCode() { 
return @CompletedCourseId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @CompletedCourseId == other.@CompletedCourseId && @TrainingCourseId == other.@TrainingCourseId && @StartDateTime == other.@StartDateTime && @FinishedDateTime == other.@FinishedDateTime && @UserId == other.@UserId;
}
public Modification.@CompletedCoursesModification ToModification() {
return Modification.@CompletedCoursesModification.CreateForSingleRowUpdate( @CompletedCourseId, @TrainingCourseId, @StartDateTime, @FinishedDateTime, @UserId );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "CompletedCoursesTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.CompletedCoursesTableCondition[] conditions ) {
var completedCourseIdCondition = conditions.OfType<CommandConditions.@CompletedCoursesTableEqualityConditions.@CompletedCourseId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = completedCourseIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( completedCourseIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM CompletedCourses", !isPkQuery, orderByClause: "ORDER BY CompletedCourseId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@CompletedCourseId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@CompletedCoursesTableEqualityConditions.@CompletedCourseId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@CompletedCourseId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the ConsentTypes table.
/// </summary>
public static partial class @ConsentTypesTableRetrieval {
internal class BasicRow {
private readonly int @__consentTypeId;
private readonly string @__name;
internal BasicRow( DbDataReader reader ) {
@__consentTypeId = (System.Int32)reader.GetValue( 0 );
@__name = (System.String)reader.GetValue( 1 );
}
internal int @ConsentTypeId { get { return @__consentTypeId; } }
internal string @Name { get { return @__name; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @ConsentTypeId { get { return __basicRow.@ConsentTypeId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Name { get { return __basicRow.@Name; } }
public override int GetHashCode() { 
return @ConsentTypeId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @ConsentTypeId == other.@ConsentTypeId && @Name == other.@Name;
}
public Modification.@ConsentTypesModification ToModification() {
return Modification.@ConsentTypesModification.CreateForSingleRowUpdate( @ConsentTypeId, @Name );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "ConsentTypesTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.ConsentTypesTableCondition[] conditions ) {
var consentTypeIdCondition = conditions.OfType<CommandConditions.@ConsentTypesTableEqualityConditions.@ConsentTypeId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = consentTypeIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( consentTypeIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM ConsentTypes", !isPkQuery, orderByClause: "ORDER BY ConsentTypeId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@ConsentTypeId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@ConsentTypesTableEqualityConditions.@ConsentTypeId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@ConsentTypeId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the Content table.
/// </summary>
public static partial class @ContentTableRetrieval {
internal class BasicRow {
private readonly int @__contentId;
private readonly string @__text;
private readonly int @__htmlBlockId;
private readonly int @__orderRankId;
private readonly int @__contentTabId;
internal BasicRow( DbDataReader reader ) {
@__contentId = (System.Int32)reader.GetValue( 0 );
@__text = (System.String)reader.GetValue( 1 );
@__htmlBlockId = (System.Int32)reader.GetValue( 2 );
@__orderRankId = (System.Int32)reader.GetValue( 3 );
@__contentTabId = (System.Int32)reader.GetValue( 4 );
}
internal int @ContentId { get { return @__contentId; } }
internal string @Text { get { return @__text; } }
internal int @HtmlBlockId { get { return @__htmlBlockId; } }
internal int @OrderRankId { get { return @__orderRankId; } }
internal int @ContentTabId { get { return @__contentTabId; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @ContentId { get { return __basicRow.@ContentId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Text { get { return __basicRow.@Text; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @HtmlBlockId { get { return __basicRow.@HtmlBlockId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @OrderRankId { get { return __basicRow.@OrderRankId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @ContentTabId { get { return __basicRow.@ContentTabId; } }
public override int GetHashCode() { 
return @ContentId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @ContentId == other.@ContentId && @Text == other.@Text && @HtmlBlockId == other.@HtmlBlockId && @OrderRankId == other.@OrderRankId && @ContentTabId == other.@ContentTabId;
}
public Modification.@ContentModification ToModification() {
return Modification.@ContentModification.CreateForSingleRowUpdate( @ContentId, @Text, @HtmlBlockId, @OrderRankId, @ContentTabId );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "ContentTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.ContentTableCondition[] conditions ) {
var contentIdCondition = conditions.OfType<CommandConditions.@ContentTableEqualityConditions.@ContentId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = contentIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( contentIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM Content", !isPkQuery, orderByClause: "ORDER BY ContentId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@ContentId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@ContentTableEqualityConditions.@ContentId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@ContentId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the ContentTabs table.
/// </summary>
public static partial class @ContentTabsTableRetrieval {
internal class BasicRow {
private readonly int @__contentTabId;
private readonly string @__name;
private readonly System.Boolean @__hasProviderPortalTab;
internal BasicRow( DbDataReader reader ) {
@__contentTabId = (System.Int32)reader.GetValue( 0 );
@__name = (System.String)reader.GetValue( 1 );
@__hasProviderPortalTab = (System.Boolean)reader.GetValue( 2 );
}
internal int @ContentTabId { get { return @__contentTabId; } }
internal string @Name { get { return @__name; } }
internal System.Boolean @HasProviderPortalTab { get { return @__hasProviderPortalTab; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @ContentTabId { get { return __basicRow.@ContentTabId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Name { get { return __basicRow.@Name; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Boolean @HasProviderPortalTab { get { return __basicRow.@HasProviderPortalTab; } }
public override int GetHashCode() { 
return @ContentTabId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @ContentTabId == other.@ContentTabId && @Name == other.@Name && @HasProviderPortalTab == other.@HasProviderPortalTab;
}
public Modification.@ContentTabsModification ToModification() {
return Modification.@ContentTabsModification.CreateForSingleRowUpdate( @ContentTabId, @Name, @HasProviderPortalTab );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "ContentTabsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.ContentTabsTableCondition[] conditions ) {
var contentTabIdCondition = conditions.OfType<CommandConditions.@ContentTabsTableEqualityConditions.@ContentTabId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = contentTabIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( contentTabIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM ContentTabs", !isPkQuery, orderByClause: "ORDER BY ContentTabId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@ContentTabId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@ContentTabsTableEqualityConditions.@ContentTabId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@ContentTabId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the DirectAccessLogs table.
/// </summary>
public static partial class @DirectAccessLogsTableRetrieval {
internal class BasicRow {
private readonly int @__directAccessLogs;
private readonly int @__userId;
private readonly DateTime @__dateTimeUtc;
internal BasicRow( DbDataReader reader ) {
@__directAccessLogs = (System.Int32)reader.GetValue( 0 );
@__userId = (System.Int32)reader.GetValue( 1 );
@__dateTimeUtc = (System.DateTime)reader.GetValue( 2 );
}
internal int @DirectAccessLogs { get { return @__directAccessLogs; } }
internal int @UserId { get { return @__userId; } }
internal DateTime @DateTimeUtc { get { return @__dateTimeUtc; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @DirectAccessLogs { get { return __basicRow.@DirectAccessLogs; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @UserId { get { return __basicRow.@UserId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @DateTimeUtc { get { return __basicRow.@DateTimeUtc; } }
public override int GetHashCode() { 
return @DirectAccessLogs.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @DirectAccessLogs == other.@DirectAccessLogs && @UserId == other.@UserId && @DateTimeUtc == other.@DateTimeUtc;
}
public Modification.@DirectAccessLogsModification ToModification() {
return Modification.@DirectAccessLogsModification.CreateForSingleRowUpdate( @DirectAccessLogs, @UserId, @DateTimeUtc );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "DirectAccessLogsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.DirectAccessLogsTableCondition[] conditions ) {
var directAccessLogsCondition = conditions.OfType<CommandConditions.@DirectAccessLogsTableEqualityConditions.@DirectAccessLogs>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = directAccessLogsCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( directAccessLogsCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM DirectAccessLogs", !isPkQuery, orderByClause: "ORDER BY DirectAccessLogs" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@DirectAccessLogs ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingPk( int directAccessLogs, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@DirectAccessLogsTableEqualityConditions.@DirectAccessLogs( directAccessLogs ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
}
/// <summary>
/// Contains logic that retrieves rows from the EmailTemplates table.
/// </summary>
public static partial class @EmailTemplatesTableRetrieval {
internal class BasicRow {
private readonly int @__emailTemplateId;
private readonly string @__name;
private readonly string @__subject;
private readonly int @__htmlBlockId;
private readonly System.Int32? @__roleId;
private readonly int @__emailTemplateTypeId;
internal BasicRow( DbDataReader reader ) {
@__emailTemplateId = (System.Int32)reader.GetValue( 0 );
@__name = (System.String)reader.GetValue( 1 );
@__subject = (System.String)reader.GetValue( 2 );
@__htmlBlockId = (System.Int32)reader.GetValue( 3 );
@__roleId = reader.IsDBNull( 4 ) ? (System.Int32?)null : (System.Int32)reader.GetValue( 4 );
@__emailTemplateTypeId = (System.Int32)reader.GetValue( 5 );
}
internal int @EmailTemplateId { get { return @__emailTemplateId; } }
internal string @Name { get { return @__name; } }
internal string @Subject { get { return @__subject; } }
internal int @HtmlBlockId { get { return @__htmlBlockId; } }
internal System.Int32? @RoleId { get { return @__roleId; } }
internal int @EmailTemplateTypeId { get { return @__emailTemplateTypeId; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @EmailTemplateId { get { return __basicRow.@EmailTemplateId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Name { get { return __basicRow.@Name; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Subject { get { return __basicRow.@Subject; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @HtmlBlockId { get { return __basicRow.@HtmlBlockId; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.Int32? @RoleId { get { return __basicRow.@RoleId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @EmailTemplateTypeId { get { return __basicRow.@EmailTemplateTypeId; } }
public override int GetHashCode() { 
return @EmailTemplateId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @EmailTemplateId == other.@EmailTemplateId && @Name == other.@Name && @Subject == other.@Subject && @HtmlBlockId == other.@HtmlBlockId && @RoleId == other.@RoleId && @EmailTemplateTypeId == other.@EmailTemplateTypeId;
}
public Modification.@EmailTemplatesModification ToModification() {
return Modification.@EmailTemplatesModification.CreateForSingleRowUpdate( @EmailTemplateId, @Name, @Subject, @HtmlBlockId, @RoleId, @EmailTemplateTypeId );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "EmailTemplatesTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.EmailTemplatesTableCondition[] conditions ) {
var emailTemplateIdCondition = conditions.OfType<CommandConditions.@EmailTemplatesTableEqualityConditions.@EmailTemplateId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = emailTemplateIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( emailTemplateIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM EmailTemplates", !isPkQuery, orderByClause: "ORDER BY EmailTemplateId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@EmailTemplateId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@EmailTemplatesTableEqualityConditions.@EmailTemplateId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@EmailTemplateId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the EmailTemplateTypes table.
/// </summary>
public static partial class @EmailTemplateTypesTableRetrieval {
internal class BasicRow {
private readonly int @__emailTemplateTypeId;
private readonly string @__name;
internal BasicRow( DbDataReader reader ) {
@__emailTemplateTypeId = (System.Int32)reader.GetValue( 0 );
@__name = (System.String)reader.GetValue( 1 );
}
internal int @EmailTemplateTypeId { get { return @__emailTemplateTypeId; } }
internal string @Name { get { return @__name; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @EmailTemplateTypeId { get { return __basicRow.@EmailTemplateTypeId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Name { get { return __basicRow.@Name; } }
public override int GetHashCode() { 
return @EmailTemplateTypeId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @EmailTemplateTypeId == other.@EmailTemplateTypeId && @Name == other.@Name;
}
public Modification.@EmailTemplateTypesModification ToModification() {
return Modification.@EmailTemplateTypesModification.CreateForSingleRowUpdate( @EmailTemplateTypeId, @Name );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "EmailTemplateTypesTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.EmailTemplateTypesTableCondition[] conditions ) {
var emailTemplateTypeIdCondition = conditions.OfType<CommandConditions.@EmailTemplateTypesTableEqualityConditions.@EmailTemplateTypeId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = emailTemplateTypeIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( emailTemplateTypeIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM EmailTemplateTypes", !isPkQuery, orderByClause: "ORDER BY EmailTemplateTypeId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@EmailTemplateTypeId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@EmailTemplateTypesTableEqualityConditions.@EmailTemplateTypeId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@EmailTemplateTypeId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the EventLog table.
/// </summary>
public static partial class @EventLogTableRetrieval {
internal class BasicRow {
private readonly System.Guid @__eventID;
private readonly DateTime @__eventTime;
private readonly string @__category;
private readonly string @__subCategory;
private readonly int @__errorLevel;
private readonly string @__eventCode;
private readonly string @__encKV;
private readonly System.Byte[] @__encIV;
private readonly System.Guid? @__userID;
private readonly string @__userType;
private readonly string @__iPAddress;
private readonly string @__eventSummary;
private readonly string @__eventURL;
private readonly string @__additionalData;
private readonly System.Byte[] @__protectedData;
private readonly string @__accessReasonCode;
private readonly string @__accessReasonText;
private readonly string @__accessScope;
private readonly int @__accessType;
private readonly string @__reviewStatus;
private readonly string @__suggestedAction;
private readonly System.Guid? @__reviewedBy;
private readonly System.DateTime? @__reviewDate;
private readonly string @__reviewSummary;
internal BasicRow( DbDataReader reader ) {
@__eventID = (System.Guid)reader.GetValue( 0 );
@__eventTime = (System.DateTime)reader.GetValue( 1 );
@__category = (System.String)reader.GetValue( 2 );
@__subCategory = (System.String)reader.GetValue( 3 );
@__errorLevel = (System.Int32)reader.GetValue( 4 );
@__eventCode = (System.String)reader.GetValue( 5 );
@__encKV = (System.String)reader.GetValue( 6 );
@__encIV = reader.IsDBNull( 7 ) ? (System.Byte[])null : (System.Byte[])reader.GetValue( 7 );
@__userID = reader.IsDBNull( 8 ) ? (System.Guid?)null : (System.Guid)reader.GetValue( 8 );
@__userType = (System.String)reader.GetValue( 9 );
@__iPAddress = (System.String)reader.GetValue( 10 );
@__eventSummary = (System.String)reader.GetValue( 11 );
@__eventURL = (System.String)reader.GetValue( 12 );
@__additionalData = (System.String)reader.GetValue( 13 );
@__protectedData = reader.IsDBNull( 14 ) ? (System.Byte[])null : (System.Byte[])reader.GetValue( 14 );
@__accessReasonCode = (System.String)reader.GetValue( 15 );
@__accessReasonText = (System.String)reader.GetValue( 16 );
@__accessScope = (System.String)reader.GetValue( 17 );
@__accessType = (System.Int32)reader.GetValue( 18 );
@__reviewStatus = (System.String)reader.GetValue( 19 );
@__suggestedAction = (System.String)reader.GetValue( 20 );
@__reviewedBy = reader.IsDBNull( 21 ) ? (System.Guid?)null : (System.Guid)reader.GetValue( 21 );
@__reviewDate = reader.IsDBNull( 22 ) ? (System.DateTime?)null : (System.DateTime)reader.GetValue( 22 );
@__reviewSummary = (System.String)reader.GetValue( 23 );
}
internal System.Guid @EventID { get { return @__eventID; } }
internal DateTime @EventTime { get { return @__eventTime; } }
internal string @Category { get { return @__category; } }
internal string @SubCategory { get { return @__subCategory; } }
internal int @ErrorLevel { get { return @__errorLevel; } }
internal string @EventCode { get { return @__eventCode; } }
internal string @EncKV { get { return @__encKV; } }
internal System.Byte[] @EncIV { get { return @__encIV; } }
internal System.Guid? @UserID { get { return @__userID; } }
internal string @UserType { get { return @__userType; } }
internal string @IPAddress { get { return @__iPAddress; } }
internal string @EventSummary { get { return @__eventSummary; } }
internal string @EventURL { get { return @__eventURL; } }
internal string @AdditionalData { get { return @__additionalData; } }
internal System.Byte[] @ProtectedData { get { return @__protectedData; } }
internal string @AccessReasonCode { get { return @__accessReasonCode; } }
internal string @AccessReasonText { get { return @__accessReasonText; } }
internal string @AccessScope { get { return @__accessScope; } }
internal int @AccessType { get { return @__accessType; } }
internal string @ReviewStatus { get { return @__reviewStatus; } }
internal string @SuggestedAction { get { return @__suggestedAction; } }
internal System.Guid? @ReviewedBy { get { return @__reviewedBy; } }
internal System.DateTime? @ReviewDate { get { return @__reviewDate; } }
internal string @ReviewSummary { get { return @__reviewSummary; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public System.Guid @EventID { get { return __basicRow.@EventID; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @EventTime { get { return __basicRow.@EventTime; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Category { get { return __basicRow.@Category; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @SubCategory { get { return __basicRow.@SubCategory; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @ErrorLevel { get { return __basicRow.@ErrorLevel; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @EventCode { get { return __basicRow.@EventCode; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @EncKV { get { return __basicRow.@EncKV; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.Byte[] @EncIV { get { return __basicRow.@EncIV; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.Guid? @UserID { get { return __basicRow.@UserID; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @UserType { get { return __basicRow.@UserType; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @IPAddress { get { return __basicRow.@IPAddress; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @EventSummary { get { return __basicRow.@EventSummary; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @EventURL { get { return __basicRow.@EventURL; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @AdditionalData { get { return __basicRow.@AdditionalData; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.Byte[] @ProtectedData { get { return __basicRow.@ProtectedData; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @AccessReasonCode { get { return __basicRow.@AccessReasonCode; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @AccessReasonText { get { return __basicRow.@AccessReasonText; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @AccessScope { get { return __basicRow.@AccessScope; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @AccessType { get { return __basicRow.@AccessType; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @ReviewStatus { get { return __basicRow.@ReviewStatus; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @SuggestedAction { get { return __basicRow.@SuggestedAction; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.Guid? @ReviewedBy { get { return __basicRow.@ReviewedBy; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.DateTime? @ReviewDate { get { return __basicRow.@ReviewDate; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @ReviewSummary { get { return __basicRow.@ReviewSummary; } }
public override int GetHashCode() { 
return @EventID.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @EventID == other.@EventID && @EventTime == other.@EventTime && @Category == other.@Category && @SubCategory == other.@SubCategory && @ErrorLevel == other.@ErrorLevel && @EventCode == other.@EventCode && @EncKV == other.@EncKV && @UserID == other.@UserID && @UserType == other.@UserType && @IPAddress == other.@IPAddress && @EventSummary == other.@EventSummary && @EventURL == other.@EventURL && @AdditionalData == other.@AdditionalData && @AccessReasonCode == other.@AccessReasonCode && @AccessReasonText == other.@AccessReasonText && @AccessScope == other.@AccessScope && @AccessType == other.@AccessType && @ReviewStatus == other.@ReviewStatus && @SuggestedAction == other.@SuggestedAction && @ReviewedBy == other.@ReviewedBy && @ReviewDate == other.@ReviewDate && @ReviewSummary == other.@ReviewSummary;
}
public Modification.@EventLogModification ToModification() {
return Modification.@EventLogModification.CreateForSingleRowUpdate( @EventID, @EventTime, @Category, @SubCategory, @ErrorLevel, @EventCode, @EncKV, @EncIV, @UserID, @UserType, @IPAddress, @EventSummary, @EventURL, @AdditionalData, @ProtectedData, @AccessReasonCode, @AccessReasonText, @AccessScope, @AccessType, @ReviewStatus, @SuggestedAction, @ReviewedBy, @ReviewDate, @ReviewSummary );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "EventLogTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<System.Guid, DateTime, string, string>, Row> rowsByPk = new Dictionary<Tuple<System.Guid, DateTime, string, string>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<System.Guid, DateTime, string, string>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.EventLogTableCondition[] conditions ) {
var eventIDCondition = conditions.OfType<CommandConditions.@EventLogTableEqualityConditions.@EventID>().FirstOrDefault();
var eventTimeCondition = conditions.OfType<CommandConditions.@EventLogTableEqualityConditions.@EventTime>().FirstOrDefault();
var categoryCondition = conditions.OfType<CommandConditions.@EventLogTableEqualityConditions.@Category>().FirstOrDefault();
var subCategoryCondition = conditions.OfType<CommandConditions.@EventLogTableEqualityConditions.@SubCategory>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = eventIDCondition != null && eventTimeCondition != null && categoryCondition != null && subCategoryCondition != null && conditions.Count() == 4;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( eventIDCondition.Value, eventTimeCondition.Value, categoryCondition.Value, subCategoryCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM EventLog", !isPkQuery, orderByClause: "ORDER BY EventID, EventTime, Category, SubCategory" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@EventID, i.@EventTime, i.@Category, i.@SubCategory ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingPk( System.Guid eventID, DateTime eventTime, string category, string subCategory, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@EventLogTableEqualityConditions.@EventID( eventID ), new CommandConditions.@EventLogTableEqualityConditions.@EventTime( eventTime ), new CommandConditions.@EventLogTableEqualityConditions.@Category( category ), new CommandConditions.@EventLogTableEqualityConditions.@SubCategory( subCategory ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
}
/// <summary>
/// Contains logic that retrieves rows from the FileCollections table.
/// </summary>
public static partial class @FileCollectionsTableRetrieval {
internal class BasicRow {
private readonly int @__fileCollectionId;
internal BasicRow( DbDataReader reader ) {
@__fileCollectionId = (System.Int32)reader.GetValue( 0 );
}
internal int @FileCollectionId { get { return @__fileCollectionId; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @FileCollectionId { get { return __basicRow.@FileCollectionId; } }
public override int GetHashCode() { 
return @FileCollectionId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @FileCollectionId == other.@FileCollectionId;
}
public Modification.@FileCollectionsModification ToModification() {
return Modification.@FileCollectionsModification.CreateForSingleRowUpdate( @FileCollectionId );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "FileCollectionsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.FileCollectionsTableCondition[] conditions ) {
var fileCollectionIdCondition = conditions.OfType<CommandConditions.@FileCollectionsTableEqualityConditions.@FileCollectionId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = fileCollectionIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( fileCollectionIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM FileCollections", !isPkQuery, orderByClause: "ORDER BY FileCollectionId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@FileCollectionId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@FileCollectionsTableEqualityConditions.@FileCollectionId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@FileCollectionId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the Files table.
/// </summary>
public static partial class @FilesTableRetrieval {
internal class BasicRow {
private readonly int @__fileId;
private readonly int @__fileCollectionId;
private readonly string @__fileName;
private readonly string @__contentType;
private readonly System.Byte[] @__contents;
private readonly DateTime @__uploadedDate;
internal BasicRow( DbDataReader reader ) {
@__fileId = (System.Int32)reader.GetValue( 0 );
@__fileCollectionId = (System.Int32)reader.GetValue( 1 );
@__fileName = (System.String)reader.GetValue( 2 );
@__contentType = (System.String)reader.GetValue( 3 );
@__contents = (System.Byte[])reader.GetValue( 4 );
@__uploadedDate = (System.DateTime)reader.GetValue( 5 );
}
internal int @FileId { get { return @__fileId; } }
internal int @FileCollectionId { get { return @__fileCollectionId; } }
internal string @FileName { get { return @__fileName; } }
internal string @ContentType { get { return @__contentType; } }
internal System.Byte[] @Contents { get { return @__contents; } }
internal DateTime @UploadedDate { get { return @__uploadedDate; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @FileId { get { return __basicRow.@FileId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @FileCollectionId { get { return __basicRow.@FileCollectionId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @FileName { get { return __basicRow.@FileName; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @ContentType { get { return __basicRow.@ContentType; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @Contents { get { return __basicRow.@Contents; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @UploadedDate { get { return __basicRow.@UploadedDate; } }
public override int GetHashCode() { 
return @FileId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @FileId == other.@FileId && @FileCollectionId == other.@FileCollectionId && @FileName == other.@FileName && @ContentType == other.@ContentType && @UploadedDate == other.@UploadedDate;
}
public Modification.@FilesModification ToModification() {
return Modification.@FilesModification.CreateForSingleRowUpdate( @FileId, @FileCollectionId, @FileName, @ContentType, @Contents, @UploadedDate );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "FilesTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.FilesTableCondition[] conditions ) {
var fileIdCondition = conditions.OfType<CommandConditions.@FilesTableEqualityConditions.@FileId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = fileIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( fileIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM Files", !isPkQuery, orderByClause: "ORDER BY FileId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@FileId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@FilesTableEqualityConditions.@FileId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@FileId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the FormInputs table.
/// </summary>
public static partial class @FormInputsTableRetrieval {
internal class BasicRow {
private readonly int @__formInputId;
private readonly int @__formId;
private readonly string @__inputName;
private readonly string @__label;
internal BasicRow( DbDataReader reader ) {
@__formInputId = (System.Int32)reader.GetValue( 0 );
@__formId = (System.Int32)reader.GetValue( 1 );
@__inputName = (System.String)reader.GetValue( 2 );
@__label = (System.String)reader.GetValue( 3 );
}
internal int @FormInputId { get { return @__formInputId; } }
internal int @FormId { get { return @__formId; } }
internal string @InputName { get { return @__inputName; } }
internal string @Label { get { return @__label; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @FormInputId { get { return __basicRow.@FormInputId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @FormId { get { return __basicRow.@FormId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @InputName { get { return __basicRow.@InputName; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Label { get { return __basicRow.@Label; } }
public override int GetHashCode() { 
return @FormInputId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @FormInputId == other.@FormInputId && @FormId == other.@FormId && @InputName == other.@InputName && @Label == other.@Label;
}
public Modification.@FormInputsModification ToModification() {
return Modification.@FormInputsModification.CreateForSingleRowUpdate( @FormInputId, @FormId, @InputName, @Label );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "FormInputsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.FormInputsTableCondition[] conditions ) {
var formInputIdCondition = conditions.OfType<CommandConditions.@FormInputsTableEqualityConditions.@FormInputId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = formInputIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( formInputIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM FormInputs", !isPkQuery, orderByClause: "ORDER BY FormInputId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@FormInputId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@FormInputsTableEqualityConditions.@FormInputId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@FormInputId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the FormInstances table.
/// </summary>
public static partial class @FormInstancesTableRetrieval {
internal class BasicRow {
private readonly int @__formInstanceId;
private readonly int @__formId;
private readonly int @__signedByUserId;
private readonly DateTime @__signedDateTimeUtc;
internal BasicRow( DbDataReader reader ) {
@__formInstanceId = (System.Int32)reader.GetValue( 0 );
@__formId = (System.Int32)reader.GetValue( 1 );
@__signedByUserId = (System.Int32)reader.GetValue( 2 );
@__signedDateTimeUtc = (System.DateTime)reader.GetValue( 3 );
}
internal int @FormInstanceId { get { return @__formInstanceId; } }
internal int @FormId { get { return @__formId; } }
internal int @SignedByUserId { get { return @__signedByUserId; } }
internal DateTime @SignedDateTimeUtc { get { return @__signedDateTimeUtc; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @FormInstanceId { get { return __basicRow.@FormInstanceId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @FormId { get { return __basicRow.@FormId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @SignedByUserId { get { return __basicRow.@SignedByUserId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @SignedDateTimeUtc { get { return __basicRow.@SignedDateTimeUtc; } }
public override int GetHashCode() { 
return @FormInstanceId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @FormInstanceId == other.@FormInstanceId && @FormId == other.@FormId && @SignedByUserId == other.@SignedByUserId && @SignedDateTimeUtc == other.@SignedDateTimeUtc;
}
public Modification.@FormInstancesModification ToModification() {
return Modification.@FormInstancesModification.CreateForSingleRowUpdate( @FormInstanceId, @FormId, @SignedByUserId, @SignedDateTimeUtc );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "FormInstancesTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.FormInstancesTableCondition[] conditions ) {
var formInstanceIdCondition = conditions.OfType<CommandConditions.@FormInstancesTableEqualityConditions.@FormInstanceId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = formInstanceIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( formInstanceIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM FormInstances", !isPkQuery, orderByClause: "ORDER BY FormInstanceId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@FormInstanceId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@FormInstancesTableEqualityConditions.@FormInstanceId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@FormInstanceId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the Forms table.
/// </summary>
public static partial class @FormsTableRetrieval {
internal class BasicRow {
private readonly int @__formId;
private readonly string @__formName;
internal BasicRow( DbDataReader reader ) {
@__formId = (System.Int32)reader.GetValue( 0 );
@__formName = (System.String)reader.GetValue( 1 );
}
internal int @FormId { get { return @__formId; } }
internal string @FormName { get { return @__formName; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @FormId { get { return __basicRow.@FormId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @FormName { get { return __basicRow.@FormName; } }
public override int GetHashCode() { 
return @FormId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @FormId == other.@FormId && @FormName == other.@FormName;
}
public Modification.@FormsModification ToModification() {
return Modification.@FormsModification.CreateForSingleRowUpdate( @FormId, @FormName );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "FormsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.FormsTableCondition[] conditions ) {
var formIdCondition = conditions.OfType<CommandConditions.@FormsTableEqualityConditions.@FormId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = formIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( formIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM Forms", !isPkQuery, orderByClause: "ORDER BY FormId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@FormId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@FormsTableEqualityConditions.@FormId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@FormId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the FormValues table.
/// </summary>
public static partial class @FormValuesTableRetrieval {
internal class BasicRow {
private readonly int @__formValueId;
private readonly int @__formInstanceId;
private readonly int @__formInputId;
private readonly string @__inputValue;
internal BasicRow( DbDataReader reader ) {
@__formValueId = (System.Int32)reader.GetValue( 0 );
@__formInstanceId = (System.Int32)reader.GetValue( 1 );
@__formInputId = (System.Int32)reader.GetValue( 2 );
@__inputValue = (System.String)reader.GetValue( 3 );
}
internal int @FormValueId { get { return @__formValueId; } }
internal int @FormInstanceId { get { return @__formInstanceId; } }
internal int @FormInputId { get { return @__formInputId; } }
internal string @InputValue { get { return @__inputValue; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @FormValueId { get { return __basicRow.@FormValueId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @FormInstanceId { get { return __basicRow.@FormInstanceId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @FormInputId { get { return __basicRow.@FormInputId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @InputValue { get { return __basicRow.@InputValue; } }
public override int GetHashCode() { 
return @FormValueId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @FormValueId == other.@FormValueId && @FormInstanceId == other.@FormInstanceId && @FormInputId == other.@FormInputId && @InputValue == other.@InputValue;
}
public Modification.@FormValuesModification ToModification() {
return Modification.@FormValuesModification.CreateForSingleRowUpdate( @FormValueId, @FormInstanceId, @FormInputId, @InputValue );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "FormValuesTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.FormValuesTableCondition[] conditions ) {
var formValueIdCondition = conditions.OfType<CommandConditions.@FormValuesTableEqualityConditions.@FormValueId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = formValueIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( formValueIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM FormValues", !isPkQuery, orderByClause: "ORDER BY FormValueId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@FormValueId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@FormValuesTableEqualityConditions.@FormValueId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@FormValueId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the GlobalDates table.
/// </summary>
public static partial class @GlobalDatesTableRetrieval {
internal class BasicRow {
private readonly string @__name;
private readonly DateTime @__value;
internal BasicRow( DbDataReader reader ) {
@__name = (System.String)reader.GetValue( 0 );
@__value = (System.DateTime)reader.GetValue( 1 );
}
internal string @Name { get { return @__name; } }
internal DateTime @Value { get { return @__value; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public string @Name { get { return __basicRow.@Name; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @Value { get { return __basicRow.@Value; } }
public override int GetHashCode() { 
return @Name.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @Name == other.@Name && @Value == other.@Value;
}
public Modification.@GlobalDatesModification ToModification() {
return Modification.@GlobalDatesModification.CreateForSingleRowUpdate( @Name, @Value );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "GlobalDatesTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<string>, Row> rowsByPk = new Dictionary<Tuple<string>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<string>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.GlobalDatesTableCondition[] conditions ) {
var nameCondition = conditions.OfType<CommandConditions.@GlobalDatesTableEqualityConditions.@Name>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = nameCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( nameCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM GlobalDates", !isPkQuery, orderByClause: "ORDER BY Name" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@Name ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingPk( string name, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@GlobalDatesTableEqualityConditions.@Name( name ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
}
/// <summary>
/// Contains logic that retrieves rows from the GlobalInts table.
/// </summary>
public static partial class @GlobalIntsTableRetrieval {
internal class BasicRow {
private readonly string @__parameterName;
private readonly int @__parameterValue;
internal BasicRow( DbDataReader reader ) {
@__parameterName = (System.String)reader.GetValue( 0 );
@__parameterValue = (System.Int32)reader.GetValue( 1 );
}
internal string @ParameterName { get { return @__parameterName; } }
internal int @ParameterValue { get { return @__parameterValue; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public string @ParameterName { get { return __basicRow.@ParameterName; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @ParameterValue { get { return __basicRow.@ParameterValue; } }
public override int GetHashCode() { 
return @ParameterName.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @ParameterName == other.@ParameterName && @ParameterValue == other.@ParameterValue;
}
public Modification.@GlobalIntsModification ToModification() {
return Modification.@GlobalIntsModification.CreateForSingleRowUpdate( @ParameterName, @ParameterValue );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "GlobalIntsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<string>, Row> rowsByPk = new Dictionary<Tuple<string>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<string>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.GlobalIntsTableCondition[] conditions ) {
var parameterNameCondition = conditions.OfType<CommandConditions.@GlobalIntsTableEqualityConditions.@ParameterName>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = parameterNameCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( parameterNameCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM GlobalInts", !isPkQuery, orderByClause: "ORDER BY ParameterName" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@ParameterName ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingPk( string parameterName, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@GlobalIntsTableEqualityConditions.@ParameterName( parameterName ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
}
/// <summary>
/// Contains logic that retrieves rows from the GlobalStrings table.
/// </summary>
public static partial class @GlobalStringsTableRetrieval {
internal class BasicRow {
private readonly string @__name;
private readonly string @__value;
internal BasicRow( DbDataReader reader ) {
@__name = (System.String)reader.GetValue( 0 );
@__value = (System.String)reader.GetValue( 1 );
}
internal string @Name { get { return @__name; } }
internal string @Value { get { return @__value; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public string @Name { get { return __basicRow.@Name; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Value { get { return __basicRow.@Value; } }
public override int GetHashCode() { 
return @Name.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @Name == other.@Name && @Value == other.@Value;
}
public Modification.@GlobalStringsModification ToModification() {
return Modification.@GlobalStringsModification.CreateForSingleRowUpdate( @Name, @Value );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "GlobalStringsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<string>, Row> rowsByPk = new Dictionary<Tuple<string>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<string>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.GlobalStringsTableCondition[] conditions ) {
var nameCondition = conditions.OfType<CommandConditions.@GlobalStringsTableEqualityConditions.@Name>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = nameCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( nameCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM GlobalStrings", !isPkQuery, orderByClause: "ORDER BY Name" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@Name ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingPk( string name, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@GlobalStringsTableEqualityConditions.@Name( name ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
}
/// <summary>
/// Contains logic that retrieves rows from the HealthPlan table.
/// </summary>
public static partial class @HealthPlanTableRetrieval {
internal class BasicRow {
private readonly int @__healthPlanID;
private readonly string @__healthPlanName;
private readonly System.Boolean @__visible;
private readonly System.Byte[] @__logoData;
private readonly string @__logoContentType;
internal BasicRow( DbDataReader reader ) {
@__healthPlanID = (System.Int32)reader.GetValue( 0 );
@__healthPlanName = (System.String)reader.GetValue( 1 );
@__visible = (System.Boolean)reader.GetValue( 2 );
@__logoData = reader.IsDBNull( 3 ) ? (System.Byte[])null : (System.Byte[])reader.GetValue( 3 );
@__logoContentType = (System.String)reader.GetValue( 4 );
}
internal int @HealthPlanID { get { return @__healthPlanID; } }
internal string @HealthPlanName { get { return @__healthPlanName; } }
internal System.Boolean @Visible { get { return @__visible; } }
internal System.Byte[] @LogoData { get { return @__logoData; } }
internal string @LogoContentType { get { return @__logoContentType; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @HealthPlanID { get { return __basicRow.@HealthPlanID; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @HealthPlanName { get { return __basicRow.@HealthPlanName; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Boolean @Visible { get { return __basicRow.@Visible; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.Byte[] @LogoData { get { return __basicRow.@LogoData; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @LogoContentType { get { return __basicRow.@LogoContentType; } }
public override int GetHashCode() { 
return @HealthPlanID.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @HealthPlanID == other.@HealthPlanID && @HealthPlanName == other.@HealthPlanName && @Visible == other.@Visible && @LogoContentType == other.@LogoContentType;
}
public Modification.@HealthPlanModification ToModification() {
return Modification.@HealthPlanModification.CreateForSingleRowUpdate( @HealthPlanID, @HealthPlanName, @Visible, @LogoData, @LogoContentType );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "HealthPlanTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.HealthPlanTableCondition[] conditions ) {
var healthPlanIDCondition = conditions.OfType<CommandConditions.@HealthPlanTableEqualityConditions.@HealthPlanID>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = healthPlanIDCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( healthPlanIDCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM HealthPlan", !isPkQuery, orderByClause: "ORDER BY HealthPlanID" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@HealthPlanID ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@HealthPlanTableEqualityConditions.@HealthPlanID( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@HealthPlanID );
}
}
/// <summary>
/// Contains logic that retrieves rows from the HtmlBlocks table.
/// </summary>
public static partial class @HtmlBlocksTableRetrieval {
internal class BasicRow {
private readonly int @__htmlBlockId;
private readonly string @__html;
internal BasicRow( DbDataReader reader ) {
@__htmlBlockId = (System.Int32)reader.GetValue( 0 );
@__html = (System.String)reader.GetValue( 1 );
}
internal int @HtmlBlockId { get { return @__htmlBlockId; } }
internal string @Html { get { return @__html; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @HtmlBlockId { get { return __basicRow.@HtmlBlockId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Html { get { return __basicRow.@Html; } }
public override int GetHashCode() { 
return @HtmlBlockId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @HtmlBlockId == other.@HtmlBlockId && @Html == other.@Html;
}
public Modification.@HtmlBlocksModification ToModification() {
return Modification.@HtmlBlocksModification.CreateForSingleRowUpdate( @HtmlBlockId, @Html );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "HtmlBlocksTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.HtmlBlocksTableCondition[] conditions ) {
var htmlBlockIdCondition = conditions.OfType<CommandConditions.@HtmlBlocksTableEqualityConditions.@HtmlBlockId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = htmlBlockIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( htmlBlockIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM HtmlBlocks", !isPkQuery, orderByClause: "ORDER BY HtmlBlockId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@HtmlBlockId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@HtmlBlocksTableEqualityConditions.@HtmlBlockId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@HtmlBlockId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the MainSequence table.
/// </summary>
public static partial class @MainSequenceTableRetrieval {
internal class BasicRow {
private readonly int @__mainSequenceId;
internal BasicRow( DbDataReader reader ) {
@__mainSequenceId = (System.Int32)reader.GetValue( 0 );
}
internal int @MainSequenceId { get { return @__mainSequenceId; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @MainSequenceId { get { return __basicRow.@MainSequenceId; } }
public override int GetHashCode() { 
return @MainSequenceId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @MainSequenceId == other.@MainSequenceId;
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "MainSequenceTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.MainSequenceTableCondition[] conditions ) {
var mainSequenceIdCondition = conditions.OfType<CommandConditions.@MainSequenceTableEqualityConditions.@MainSequenceId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = mainSequenceIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( mainSequenceIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM MainSequence", !isPkQuery, orderByClause: "ORDER BY MainSequenceId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@MainSequenceId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@MainSequenceTableEqualityConditions.@MainSequenceId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@MainSequenceId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the MaintenanceWindowDays table.
/// </summary>
public static partial class @MaintenanceWindowDaysTableRetrieval {
internal class BasicRow {
private readonly int @__maintenanceWindowDayId;
private readonly string @__day;
internal BasicRow( DbDataReader reader ) {
@__maintenanceWindowDayId = (System.Int32)reader.GetValue( 0 );
@__day = (System.String)reader.GetValue( 1 );
}
internal int @MaintenanceWindowDayId { get { return @__maintenanceWindowDayId; } }
internal string @Day { get { return @__day; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @MaintenanceWindowDayId { get { return __basicRow.@MaintenanceWindowDayId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Day { get { return __basicRow.@Day; } }
public override int GetHashCode() { 
return @MaintenanceWindowDayId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @MaintenanceWindowDayId == other.@MaintenanceWindowDayId && @Day == other.@Day;
}
public Modification.@MaintenanceWindowDaysModification ToModification() {
return Modification.@MaintenanceWindowDaysModification.CreateForSingleRowUpdate( @MaintenanceWindowDayId, @Day );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "MaintenanceWindowDaysTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.MaintenanceWindowDaysTableCondition[] conditions ) {
var maintenanceWindowDayIdCondition = conditions.OfType<CommandConditions.@MaintenanceWindowDaysTableEqualityConditions.@MaintenanceWindowDayId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = maintenanceWindowDayIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( maintenanceWindowDayIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM MaintenanceWindowDays", !isPkQuery, orderByClause: "ORDER BY MaintenanceWindowDayId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@MaintenanceWindowDayId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@MaintenanceWindowDaysTableEqualityConditions.@MaintenanceWindowDayId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@MaintenanceWindowDayId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the MaintenanceWindows table.
/// </summary>
public static partial class @MaintenanceWindowsTableRetrieval {
internal class BasicRow {
private readonly int @__maintenanceWindowId;
private readonly System.Boolean @__enabled;
private readonly int @__maintenanceWindowDayId;
private readonly System.TimeSpan @__startTime;
private readonly decimal @__durationHours;
internal BasicRow( DbDataReader reader ) {
@__maintenanceWindowId = (System.Int32)reader.GetValue( 0 );
@__enabled = (System.Boolean)reader.GetValue( 1 );
@__maintenanceWindowDayId = (System.Int32)reader.GetValue( 2 );
@__startTime = (System.TimeSpan)reader.GetValue( 3 );
@__durationHours = (System.Decimal)reader.GetValue( 4 );
}
internal int @MaintenanceWindowId { get { return @__maintenanceWindowId; } }
internal System.Boolean @Enabled { get { return @__enabled; } }
internal int @MaintenanceWindowDayId { get { return @__maintenanceWindowDayId; } }
internal System.TimeSpan @StartTime { get { return @__startTime; } }
internal decimal @DurationHours { get { return @__durationHours; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @MaintenanceWindowId { get { return __basicRow.@MaintenanceWindowId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Boolean @Enabled { get { return __basicRow.@Enabled; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @MaintenanceWindowDayId { get { return __basicRow.@MaintenanceWindowDayId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.TimeSpan @StartTime { get { return __basicRow.@StartTime; } }
/// <summary>
/// This object will never be null.
/// </summary>
public decimal @DurationHours { get { return __basicRow.@DurationHours; } }
public override int GetHashCode() { 
return @MaintenanceWindowId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @MaintenanceWindowId == other.@MaintenanceWindowId && @Enabled == other.@Enabled && @MaintenanceWindowDayId == other.@MaintenanceWindowDayId && @StartTime == other.@StartTime && @DurationHours == other.@DurationHours;
}
public Modification.@MaintenanceWindowsModification ToModification() {
return Modification.@MaintenanceWindowsModification.CreateForSingleRowUpdate( @MaintenanceWindowId, @Enabled, @MaintenanceWindowDayId, @StartTime, @DurationHours );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "MaintenanceWindowsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.MaintenanceWindowsTableCondition[] conditions ) {
var maintenanceWindowIdCondition = conditions.OfType<CommandConditions.@MaintenanceWindowsTableEqualityConditions.@MaintenanceWindowId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = maintenanceWindowIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( maintenanceWindowIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM MaintenanceWindows", !isPkQuery, orderByClause: "ORDER BY MaintenanceWindowId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@MaintenanceWindowId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@MaintenanceWindowsTableEqualityConditions.@MaintenanceWindowId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@MaintenanceWindowId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the MediaFiles table.
/// </summary>
public static partial class @MediaFilesTableRetrieval {
internal class BasicRow {
private readonly int @__mediaFileId;
private readonly int @__fileId;
private readonly int @__mediaFolderId;
internal BasicRow( DbDataReader reader ) {
@__mediaFileId = (System.Int32)reader.GetValue( 0 );
@__fileId = (System.Int32)reader.GetValue( 1 );
@__mediaFolderId = (System.Int32)reader.GetValue( 2 );
}
internal int @MediaFileId { get { return @__mediaFileId; } }
internal int @FileId { get { return @__fileId; } }
internal int @MediaFolderId { get { return @__mediaFolderId; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @MediaFileId { get { return __basicRow.@MediaFileId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @FileId { get { return __basicRow.@FileId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @MediaFolderId { get { return __basicRow.@MediaFolderId; } }
public override int GetHashCode() { 
return @MediaFileId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @MediaFileId == other.@MediaFileId && @FileId == other.@FileId && @MediaFolderId == other.@MediaFolderId;
}
public Modification.@MediaFilesModification ToModification() {
return Modification.@MediaFilesModification.CreateForSingleRowUpdate( @MediaFileId, @FileId, @MediaFolderId );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "MediaFilesTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.MediaFilesTableCondition[] conditions ) {
var mediaFileIdCondition = conditions.OfType<CommandConditions.@MediaFilesTableEqualityConditions.@MediaFileId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = mediaFileIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( mediaFileIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM MediaFiles", !isPkQuery, orderByClause: "ORDER BY MediaFileId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@MediaFileId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@MediaFilesTableEqualityConditions.@MediaFileId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@MediaFileId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the MediaFolders table.
/// </summary>
public static partial class @MediaFoldersTableRetrieval {
internal class BasicRow {
private readonly int @__mediaFolderId;
private readonly string @__name;
internal BasicRow( DbDataReader reader ) {
@__mediaFolderId = (System.Int32)reader.GetValue( 0 );
@__name = (System.String)reader.GetValue( 1 );
}
internal int @MediaFolderId { get { return @__mediaFolderId; } }
internal string @Name { get { return @__name; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @MediaFolderId { get { return __basicRow.@MediaFolderId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Name { get { return __basicRow.@Name; } }
public override int GetHashCode() { 
return @MediaFolderId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @MediaFolderId == other.@MediaFolderId && @Name == other.@Name;
}
public Modification.@MediaFoldersModification ToModification() {
return Modification.@MediaFoldersModification.CreateForSingleRowUpdate( @MediaFolderId, @Name );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "MediaFoldersTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.MediaFoldersTableCondition[] conditions ) {
var mediaFolderIdCondition = conditions.OfType<CommandConditions.@MediaFoldersTableEqualityConditions.@MediaFolderId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = mediaFolderIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( mediaFolderIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM MediaFolders", !isPkQuery, orderByClause: "ORDER BY MediaFolderId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@MediaFolderId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@MediaFoldersTableEqualityConditions.@MediaFolderId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@MediaFolderId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the Notification table.
/// </summary>
public static partial class @NotificationTableRetrieval {
internal class BasicRow {
private readonly int @__notificationID;
private readonly string @__typeName;
private readonly string @__fromUser;
private readonly string @__toUser;
private readonly string @__emailBody;
private readonly string @__emailSubject;
private readonly System.Boolean @__success;
private readonly DateTime @__created;
private readonly string @__failureMsg;
internal BasicRow( DbDataReader reader ) {
@__notificationID = (System.Int32)reader.GetValue( 0 );
@__typeName = (System.String)reader.GetValue( 1 );
@__fromUser = (System.String)reader.GetValue( 2 );
@__toUser = (System.String)reader.GetValue( 3 );
@__emailBody = (System.String)reader.GetValue( 4 );
@__emailSubject = (System.String)reader.GetValue( 5 );
@__success = (System.Boolean)reader.GetValue( 6 );
@__created = (System.DateTime)reader.GetValue( 7 );
@__failureMsg = (System.String)reader.GetValue( 8 );
}
internal int @NotificationID { get { return @__notificationID; } }
internal string @TypeName { get { return @__typeName; } }
internal string @FromUser { get { return @__fromUser; } }
internal string @ToUser { get { return @__toUser; } }
internal string @EmailBody { get { return @__emailBody; } }
internal string @EmailSubject { get { return @__emailSubject; } }
internal System.Boolean @Success { get { return @__success; } }
internal DateTime @Created { get { return @__created; } }
internal string @FailureMsg { get { return @__failureMsg; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @NotificationID { get { return __basicRow.@NotificationID; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @TypeName { get { return __basicRow.@TypeName; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @FromUser { get { return __basicRow.@FromUser; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @ToUser { get { return __basicRow.@ToUser; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @EmailBody { get { return __basicRow.@EmailBody; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @EmailSubject { get { return __basicRow.@EmailSubject; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Boolean @Success { get { return __basicRow.@Success; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @Created { get { return __basicRow.@Created; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @FailureMsg { get { return __basicRow.@FailureMsg; } }
public override int GetHashCode() { 
return @NotificationID.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @NotificationID == other.@NotificationID && @TypeName == other.@TypeName && @FromUser == other.@FromUser && @ToUser == other.@ToUser && @EmailBody == other.@EmailBody && @EmailSubject == other.@EmailSubject && @Success == other.@Success && @Created == other.@Created && @FailureMsg == other.@FailureMsg;
}
public Modification.@NotificationModification ToModification() {
return Modification.@NotificationModification.CreateForSingleRowUpdate( @NotificationID, @TypeName, @FromUser, @ToUser, @EmailBody, @EmailSubject, @Success, @Created, @FailureMsg );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "NotificationTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.NotificationTableCondition[] conditions ) {
var notificationIDCondition = conditions.OfType<CommandConditions.@NotificationTableEqualityConditions.@NotificationID>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = notificationIDCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( notificationIDCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM Notification", !isPkQuery, orderByClause: "ORDER BY NotificationID" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@NotificationID ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@NotificationTableEqualityConditions.@NotificationID( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@NotificationID );
}
}
/// <summary>
/// Contains logic that retrieves rows from the NotificationParameter table.
/// </summary>
public static partial class @NotificationParameterTableRetrieval {
internal class BasicRow {
private readonly int @__parameterID;
private readonly string @__name;
private readonly string @__dataType;
private readonly string @__protocol;
private readonly string @__defaultValue;
internal BasicRow( DbDataReader reader ) {
@__parameterID = (System.Int32)reader.GetValue( 0 );
@__name = (System.String)reader.GetValue( 1 );
@__dataType = (System.String)reader.GetValue( 2 );
@__protocol = (System.String)reader.GetValue( 3 );
@__defaultValue = (System.String)reader.GetValue( 4 );
}
internal int @ParameterID { get { return @__parameterID; } }
internal string @Name { get { return @__name; } }
internal string @DataType { get { return @__dataType; } }
internal string @Protocol { get { return @__protocol; } }
internal string @DefaultValue { get { return @__defaultValue; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @ParameterID { get { return __basicRow.@ParameterID; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Name { get { return __basicRow.@Name; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @DataType { get { return __basicRow.@DataType; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Protocol { get { return __basicRow.@Protocol; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @DefaultValue { get { return __basicRow.@DefaultValue; } }
public override int GetHashCode() { 
return @ParameterID.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @ParameterID == other.@ParameterID && @Name == other.@Name && @DataType == other.@DataType && @Protocol == other.@Protocol && @DefaultValue == other.@DefaultValue;
}
public Modification.@NotificationParameterModification ToModification() {
return Modification.@NotificationParameterModification.CreateForSingleRowUpdate( @ParameterID, @Name, @DataType, @Protocol, @DefaultValue );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "NotificationParameterTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.NotificationParameterTableCondition[] conditions ) {
var parameterIDCondition = conditions.OfType<CommandConditions.@NotificationParameterTableEqualityConditions.@ParameterID>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = parameterIDCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( parameterIDCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM NotificationParameter", !isPkQuery, orderByClause: "ORDER BY ParameterID" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@ParameterID ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@NotificationParameterTableEqualityConditions.@ParameterID( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@ParameterID );
}
}
/// <summary>
/// Contains logic that retrieves rows from the NotificationType table.
/// </summary>
public static partial class @NotificationTypeTableRetrieval {
internal class BasicRow {
private readonly int @__typeID;
private readonly string @__name;
private readonly System.DateTime? @__lastModified;
private readonly System.DateTime? @__created;
private readonly string @__fromCode;
private readonly string @__toCode;
private readonly string @__protocol;
private readonly string @__subject;
private readonly string @__body;
private readonly System.Boolean @__htmlBody;
internal BasicRow( DbDataReader reader ) {
@__typeID = (System.Int32)reader.GetValue( 0 );
@__name = (System.String)reader.GetValue( 1 );
@__lastModified = reader.IsDBNull( 2 ) ? (System.DateTime?)null : (System.DateTime)reader.GetValue( 2 );
@__created = reader.IsDBNull( 3 ) ? (System.DateTime?)null : (System.DateTime)reader.GetValue( 3 );
@__fromCode = (System.String)reader.GetValue( 4 );
@__toCode = (System.String)reader.GetValue( 5 );
@__protocol = (System.String)reader.GetValue( 6 );
@__subject = (System.String)reader.GetValue( 7 );
@__body = (System.String)reader.GetValue( 8 );
@__htmlBody = (System.Boolean)reader.GetValue( 9 );
}
internal int @TypeID { get { return @__typeID; } }
internal string @Name { get { return @__name; } }
internal System.DateTime? @LastModified { get { return @__lastModified; } }
internal System.DateTime? @Created { get { return @__created; } }
internal string @FromCode { get { return @__fromCode; } }
internal string @ToCode { get { return @__toCode; } }
internal string @Protocol { get { return @__protocol; } }
internal string @Subject { get { return @__subject; } }
internal string @Body { get { return @__body; } }
internal System.Boolean @HtmlBody { get { return @__htmlBody; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @TypeID { get { return __basicRow.@TypeID; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Name { get { return __basicRow.@Name; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.DateTime? @LastModified { get { return __basicRow.@LastModified; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.DateTime? @Created { get { return __basicRow.@Created; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @FromCode { get { return __basicRow.@FromCode; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @ToCode { get { return __basicRow.@ToCode; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Protocol { get { return __basicRow.@Protocol; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Subject { get { return __basicRow.@Subject; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Body { get { return __basicRow.@Body; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Boolean @HtmlBody { get { return __basicRow.@HtmlBody; } }
public override int GetHashCode() { 
return @TypeID.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @TypeID == other.@TypeID && @Name == other.@Name && @LastModified == other.@LastModified && @Created == other.@Created && @FromCode == other.@FromCode && @ToCode == other.@ToCode && @Protocol == other.@Protocol && @Subject == other.@Subject && @Body == other.@Body && @HtmlBody == other.@HtmlBody;
}
public Modification.@NotificationTypeModification ToModification() {
return Modification.@NotificationTypeModification.CreateForSingleRowUpdate( @TypeID, @Name, @LastModified, @Created, @FromCode, @ToCode, @Protocol, @Subject, @Body, @HtmlBody );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "NotificationTypeTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.NotificationTypeTableCondition[] conditions ) {
var typeIDCondition = conditions.OfType<CommandConditions.@NotificationTypeTableEqualityConditions.@TypeID>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = typeIDCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( typeIDCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM NotificationType", !isPkQuery, orderByClause: "ORDER BY TypeID" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@TypeID ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@NotificationTypeTableEqualityConditions.@TypeID( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@TypeID );
}
}
/// <summary>
/// Contains logic that retrieves rows from the OrderRanks table.
/// </summary>
public static partial class @OrderRanksTableRetrieval {
internal class BasicRow {
private readonly int @__orderRankId;
private readonly int @__rank;
internal BasicRow( DbDataReader reader ) {
@__orderRankId = (System.Int32)reader.GetValue( 0 );
@__rank = (System.Int32)reader.GetValue( 1 );
}
internal int @OrderRankId { get { return @__orderRankId; } }
internal int @Rank { get { return @__rank; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @OrderRankId { get { return __basicRow.@OrderRankId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @Rank { get { return __basicRow.@Rank; } }
public override int GetHashCode() { 
return @OrderRankId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @OrderRankId == other.@OrderRankId && @Rank == other.@Rank;
}
public Modification.@OrderRanksModification ToModification() {
return Modification.@OrderRanksModification.CreateForSingleRowUpdate( @OrderRankId, @Rank );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "OrderRanksTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.OrderRanksTableCondition[] conditions ) {
var orderRankIdCondition = conditions.OfType<CommandConditions.@OrderRanksTableEqualityConditions.@OrderRankId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = orderRankIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( orderRankIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM OrderRanks", !isPkQuery, orderByClause: "ORDER BY OrderRankId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@OrderRankId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@OrderRanksTableEqualityConditions.@OrderRankId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@OrderRankId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the Organizations table.
/// </summary>
public static partial class @OrganizationsTableRetrieval {
internal class BasicRow {
private readonly int @__organizationId;
private readonly string @__name;
private readonly System.DateTime? @__disabledEndDate;
internal BasicRow( DbDataReader reader ) {
@__organizationId = (System.Int32)reader.GetValue( 0 );
@__name = (System.String)reader.GetValue( 1 );
@__disabledEndDate = reader.IsDBNull( 2 ) ? (System.DateTime?)null : (System.DateTime)reader.GetValue( 2 );
}
internal int @OrganizationId { get { return @__organizationId; } }
internal string @Name { get { return @__name; } }
internal System.DateTime? @DisabledEndDate { get { return @__disabledEndDate; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @OrganizationId { get { return __basicRow.@OrganizationId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Name { get { return __basicRow.@Name; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.DateTime? @DisabledEndDate { get { return __basicRow.@DisabledEndDate; } }
public override int GetHashCode() { 
return @OrganizationId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @OrganizationId == other.@OrganizationId && @Name == other.@Name && @DisabledEndDate == other.@DisabledEndDate;
}
public Modification.@OrganizationsModification ToModification() {
return Modification.@OrganizationsModification.CreateForSingleRowUpdate( @OrganizationId, @Name, @DisabledEndDate );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "OrganizationsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.OrganizationsTableCondition[] conditions ) {
var organizationIdCondition = conditions.OfType<CommandConditions.@OrganizationsTableEqualityConditions.@OrganizationId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = organizationIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( organizationIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM Organizations", !isPkQuery, orderByClause: "ORDER BY OrganizationId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@OrganizationId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@OrganizationsTableEqualityConditions.@OrganizationId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@OrganizationId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the PasswordResetQuestions table.
/// </summary>
public static partial class @PasswordResetQuestionsTableRetrieval {
internal class BasicRow {
private readonly int @__passwordResetQuestionId;
private readonly string @__question;
internal BasicRow( DbDataReader reader ) {
@__passwordResetQuestionId = (System.Int32)reader.GetValue( 0 );
@__question = (System.String)reader.GetValue( 1 );
}
internal int @PasswordResetQuestionId { get { return @__passwordResetQuestionId; } }
internal string @Question { get { return @__question; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @PasswordResetQuestionId { get { return __basicRow.@PasswordResetQuestionId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Question { get { return __basicRow.@Question; } }
public override int GetHashCode() { 
return @PasswordResetQuestionId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @PasswordResetQuestionId == other.@PasswordResetQuestionId && @Question == other.@Question;
}
public Modification.@PasswordResetQuestionsModification ToModification() {
return Modification.@PasswordResetQuestionsModification.CreateForSingleRowUpdate( @PasswordResetQuestionId, @Question );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "PasswordResetQuestionsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.PasswordResetQuestionsTableCondition[] conditions ) {
var passwordResetQuestionIdCondition = conditions.OfType<CommandConditions.@PasswordResetQuestionsTableEqualityConditions.@PasswordResetQuestionId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = passwordResetQuestionIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( passwordResetQuestionIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM PasswordResetQuestions", !isPkQuery, orderByClause: "ORDER BY PasswordResetQuestionId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@PasswordResetQuestionId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@PasswordResetQuestionsTableEqualityConditions.@PasswordResetQuestionId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@PasswordResetQuestionId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the PatientAuditRequest table.
/// </summary>
public static partial class @PatientAuditRequestTableRetrieval {
internal class BasicRow {
private readonly int @__patientAuditID;
private readonly string @__encKV;
private readonly System.Byte[] @__encIV;
private readonly DateTime @__dateRequested;
private readonly string @__auditStatus;
private readonly DateTime @__lastModifiedDate;
private readonly System.Guid? @__lastModifiedUser;
private readonly System.Byte[] @__patientUserID;
private readonly string @__elysiumID;
private readonly decimal @__billableAmount;
private readonly System.DateTime? @__paymentConfirmed;
internal BasicRow( DbDataReader reader ) {
@__patientAuditID = (System.Int32)reader.GetValue( 0 );
@__encKV = (System.String)reader.GetValue( 1 );
@__encIV = (System.Byte[])reader.GetValue( 2 );
@__dateRequested = (System.DateTime)reader.GetValue( 3 );
@__auditStatus = (System.String)reader.GetValue( 4 );
@__lastModifiedDate = (System.DateTime)reader.GetValue( 5 );
@__lastModifiedUser = reader.IsDBNull( 6 ) ? (System.Guid?)null : (System.Guid)reader.GetValue( 6 );
@__patientUserID = (System.Byte[])reader.GetValue( 7 );
@__elysiumID = (System.String)reader.GetValue( 8 );
@__billableAmount = (System.Decimal)reader.GetValue( 9 );
@__paymentConfirmed = reader.IsDBNull( 10 ) ? (System.DateTime?)null : (System.DateTime)reader.GetValue( 10 );
}
internal int @PatientAuditID { get { return @__patientAuditID; } }
internal string @EncKV { get { return @__encKV; } }
internal System.Byte[] @EncIV { get { return @__encIV; } }
internal DateTime @DateRequested { get { return @__dateRequested; } }
internal string @AuditStatus { get { return @__auditStatus; } }
internal DateTime @LastModifiedDate { get { return @__lastModifiedDate; } }
internal System.Guid? @LastModifiedUser { get { return @__lastModifiedUser; } }
internal System.Byte[] @PatientUserID { get { return @__patientUserID; } }
internal string @ElysiumID { get { return @__elysiumID; } }
internal decimal @BillableAmount { get { return @__billableAmount; } }
internal System.DateTime? @PaymentConfirmed { get { return @__paymentConfirmed; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @PatientAuditID { get { return __basicRow.@PatientAuditID; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @EncKV { get { return __basicRow.@EncKV; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @EncIV { get { return __basicRow.@EncIV; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @DateRequested { get { return __basicRow.@DateRequested; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @AuditStatus { get { return __basicRow.@AuditStatus; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @LastModifiedDate { get { return __basicRow.@LastModifiedDate; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.Guid? @LastModifiedUser { get { return __basicRow.@LastModifiedUser; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @PatientUserID { get { return __basicRow.@PatientUserID; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @ElysiumID { get { return __basicRow.@ElysiumID; } }
/// <summary>
/// This object will never be null.
/// </summary>
public decimal @BillableAmount { get { return __basicRow.@BillableAmount; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.DateTime? @PaymentConfirmed { get { return __basicRow.@PaymentConfirmed; } }
public override int GetHashCode() { 
return @PatientAuditID.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @PatientAuditID == other.@PatientAuditID && @EncKV == other.@EncKV && @DateRequested == other.@DateRequested && @AuditStatus == other.@AuditStatus && @LastModifiedDate == other.@LastModifiedDate && @LastModifiedUser == other.@LastModifiedUser && @ElysiumID == other.@ElysiumID && @BillableAmount == other.@BillableAmount && @PaymentConfirmed == other.@PaymentConfirmed;
}
public Modification.@PatientAuditRequestModification ToModification() {
return Modification.@PatientAuditRequestModification.CreateForSingleRowUpdate( @PatientAuditID, @EncKV, @EncIV, @DateRequested, @AuditStatus, @LastModifiedDate, @LastModifiedUser, @PatientUserID, @ElysiumID, @BillableAmount, @PaymentConfirmed );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "PatientAuditRequestTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.PatientAuditRequestTableCondition[] conditions ) {
var patientAuditIDCondition = conditions.OfType<CommandConditions.@PatientAuditRequestTableEqualityConditions.@PatientAuditID>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = patientAuditIDCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( patientAuditIDCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM PatientAuditRequest", !isPkQuery, orderByClause: "ORDER BY PatientAuditID" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@PatientAuditID ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@PatientAuditRequestTableEqualityConditions.@PatientAuditID( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@PatientAuditID );
}
}
/// <summary>
/// Contains logic that retrieves rows from the PatientConsentServiceCache table.
/// </summary>
public static partial class @PatientConsentServiceCacheTableRetrieval {
internal class BasicRow {
private readonly int @__patientConsentServiceCacheId;
private readonly System.Byte[] @__iv;
private readonly int @__patientConsentServiceCacheDateId;
private readonly System.Byte[] @__workgroupId;
private readonly System.Byte[] @__consentTypeId;
internal BasicRow( DbDataReader reader ) {
@__patientConsentServiceCacheId = (System.Int32)reader.GetValue( 0 );
@__iv = (System.Byte[])reader.GetValue( 1 );
@__patientConsentServiceCacheDateId = (System.Int32)reader.GetValue( 2 );
@__workgroupId = (System.Byte[])reader.GetValue( 3 );
@__consentTypeId = (System.Byte[])reader.GetValue( 4 );
}
internal int @PatientConsentServiceCacheId { get { return @__patientConsentServiceCacheId; } }
internal System.Byte[] @Iv { get { return @__iv; } }
internal int @PatientConsentServiceCacheDateId { get { return @__patientConsentServiceCacheDateId; } }
internal System.Byte[] @WorkgroupId { get { return @__workgroupId; } }
internal System.Byte[] @ConsentTypeId { get { return @__consentTypeId; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @PatientConsentServiceCacheId { get { return __basicRow.@PatientConsentServiceCacheId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @Iv { get { return __basicRow.@Iv; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @PatientConsentServiceCacheDateId { get { return __basicRow.@PatientConsentServiceCacheDateId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @WorkgroupId { get { return __basicRow.@WorkgroupId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @ConsentTypeId { get { return __basicRow.@ConsentTypeId; } }
public override int GetHashCode() { 
return @PatientConsentServiceCacheId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @PatientConsentServiceCacheId == other.@PatientConsentServiceCacheId && @PatientConsentServiceCacheDateId == other.@PatientConsentServiceCacheDateId;
}
public Modification.@PatientConsentServiceCacheModification ToModification() {
return Modification.@PatientConsentServiceCacheModification.CreateForSingleRowUpdate( @PatientConsentServiceCacheId, @Iv, @PatientConsentServiceCacheDateId, @WorkgroupId, @ConsentTypeId );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "PatientConsentServiceCacheTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.PatientConsentServiceCacheTableCondition[] conditions ) {
var patientConsentServiceCacheIdCondition = conditions.OfType<CommandConditions.@PatientConsentServiceCacheTableEqualityConditions.@PatientConsentServiceCacheId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = patientConsentServiceCacheIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( patientConsentServiceCacheIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM PatientConsentServiceCache", !isPkQuery, orderByClause: "ORDER BY PatientConsentServiceCacheId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@PatientConsentServiceCacheId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@PatientConsentServiceCacheTableEqualityConditions.@PatientConsentServiceCacheId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@PatientConsentServiceCacheId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the PatientConsentServiceCacheDates table.
/// </summary>
public static partial class @PatientConsentServiceCacheDatesTableRetrieval {
internal class BasicRow {
private readonly int @__patientConsentServiceCacheDateId;
private readonly string @__elysiumId;
private readonly System.DateTime? @__lastRequestedDate;
private readonly System.DateTime? @__goodfor;
internal BasicRow( DbDataReader reader ) {
@__patientConsentServiceCacheDateId = (System.Int32)reader.GetValue( 0 );
@__elysiumId = (System.String)reader.GetValue( 1 );
@__lastRequestedDate = reader.IsDBNull( 2 ) ? (System.DateTime?)null : (System.DateTime)reader.GetValue( 2 );
@__goodfor = reader.IsDBNull( 3 ) ? (System.DateTime?)null : (System.DateTime)reader.GetValue( 3 );
}
internal int @PatientConsentServiceCacheDateId { get { return @__patientConsentServiceCacheDateId; } }
internal string @ElysiumId { get { return @__elysiumId; } }
internal System.DateTime? @LastRequestedDate { get { return @__lastRequestedDate; } }
internal System.DateTime? @Goodfor { get { return @__goodfor; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @PatientConsentServiceCacheDateId { get { return __basicRow.@PatientConsentServiceCacheDateId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @ElysiumId { get { return __basicRow.@ElysiumId; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.DateTime? @LastRequestedDate { get { return __basicRow.@LastRequestedDate; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.DateTime? @Goodfor { get { return __basicRow.@Goodfor; } }
public override int GetHashCode() { 
return @PatientConsentServiceCacheDateId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @PatientConsentServiceCacheDateId == other.@PatientConsentServiceCacheDateId && @ElysiumId == other.@ElysiumId && @LastRequestedDate == other.@LastRequestedDate && @Goodfor == other.@Goodfor;
}
public Modification.@PatientConsentServiceCacheDatesModification ToModification() {
return Modification.@PatientConsentServiceCacheDatesModification.CreateForSingleRowUpdate( @PatientConsentServiceCacheDateId, @ElysiumId, @LastRequestedDate, @Goodfor );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "PatientConsentServiceCacheDatesTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.PatientConsentServiceCacheDatesTableCondition[] conditions ) {
var patientConsentServiceCacheDateIdCondition = conditions.OfType<CommandConditions.@PatientConsentServiceCacheDatesTableEqualityConditions.@PatientConsentServiceCacheDateId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = patientConsentServiceCacheDateIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( patientConsentServiceCacheDateIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM PatientConsentServiceCacheDates", !isPkQuery, orderByClause: "ORDER BY PatientConsentServiceCacheDateId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@PatientConsentServiceCacheDateId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@PatientConsentServiceCacheDatesTableEqualityConditions.@PatientConsentServiceCacheDateId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@PatientConsentServiceCacheDateId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the PatientInfo table.
/// </summary>
public static partial class @PatientInfoTableRetrieval {
internal class BasicRow {
private readonly System.Guid @__userID;
private readonly string @__encKV;
private readonly System.Byte[] @__encIV;
private readonly System.Byte[] @__firstName;
private readonly System.Byte[] @__middleName;
private readonly System.Byte[] @__lastName;
private readonly System.Byte[] @__address1;
private readonly System.Byte[] @__address2;
private readonly System.Byte[] @__city;
private readonly System.Byte[] @__state;
private readonly System.Byte[] @__zipCode;
private readonly System.Byte[] @__email;
private readonly System.Byte[] @__phone;
private readonly System.Byte[] @__gender;
private readonly System.Byte[] @__dOB;
private readonly System.Byte[] @__elysiumID;
private readonly int @__phrStatusId;
private readonly System.Boolean @__signupComplete;
private readonly int @__tfaMethodId;
private readonly System.Boolean @__forcePasswordExpired;
private readonly System.DateTime? @__signupDate;
internal BasicRow( DbDataReader reader ) {
@__userID = (System.Guid)reader.GetValue( 0 );
@__encKV = (System.String)reader.GetValue( 1 );
@__encIV = (System.Byte[])reader.GetValue( 2 );
@__firstName = (System.Byte[])reader.GetValue( 3 );
@__middleName = (System.Byte[])reader.GetValue( 4 );
@__lastName = (System.Byte[])reader.GetValue( 5 );
@__address1 = (System.Byte[])reader.GetValue( 6 );
@__address2 = (System.Byte[])reader.GetValue( 7 );
@__city = (System.Byte[])reader.GetValue( 8 );
@__state = (System.Byte[])reader.GetValue( 9 );
@__zipCode = (System.Byte[])reader.GetValue( 10 );
@__email = (System.Byte[])reader.GetValue( 11 );
@__phone = (System.Byte[])reader.GetValue( 12 );
@__gender = (System.Byte[])reader.GetValue( 13 );
@__dOB = (System.Byte[])reader.GetValue( 14 );
@__elysiumID = (System.Byte[])reader.GetValue( 15 );
@__phrStatusId = (System.Int32)reader.GetValue( 16 );
@__signupComplete = (System.Boolean)reader.GetValue( 17 );
@__tfaMethodId = (System.Int32)reader.GetValue( 18 );
@__forcePasswordExpired = (System.Boolean)reader.GetValue( 19 );
@__signupDate = reader.IsDBNull( 20 ) ? (System.DateTime?)null : (System.DateTime)reader.GetValue( 20 );
}
internal System.Guid @UserID { get { return @__userID; } }
internal string @EncKV { get { return @__encKV; } }
internal System.Byte[] @EncIV { get { return @__encIV; } }
internal System.Byte[] @FirstName { get { return @__firstName; } }
internal System.Byte[] @MiddleName { get { return @__middleName; } }
internal System.Byte[] @LastName { get { return @__lastName; } }
internal System.Byte[] @Address1 { get { return @__address1; } }
internal System.Byte[] @Address2 { get { return @__address2; } }
internal System.Byte[] @City { get { return @__city; } }
internal System.Byte[] @State { get { return @__state; } }
internal System.Byte[] @ZipCode { get { return @__zipCode; } }
internal System.Byte[] @Email { get { return @__email; } }
internal System.Byte[] @Phone { get { return @__phone; } }
internal System.Byte[] @Gender { get { return @__gender; } }
internal System.Byte[] @DOB { get { return @__dOB; } }
internal System.Byte[] @ElysiumID { get { return @__elysiumID; } }
internal int @PhrStatusId { get { return @__phrStatusId; } }
internal System.Boolean @SignupComplete { get { return @__signupComplete; } }
internal int @TfaMethodId { get { return @__tfaMethodId; } }
internal System.Boolean @ForcePasswordExpired { get { return @__forcePasswordExpired; } }
internal System.DateTime? @SignupDate { get { return @__signupDate; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public System.Guid @UserID { get { return __basicRow.@UserID; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @EncKV { get { return __basicRow.@EncKV; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @EncIV { get { return __basicRow.@EncIV; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @FirstName { get { return __basicRow.@FirstName; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @MiddleName { get { return __basicRow.@MiddleName; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @LastName { get { return __basicRow.@LastName; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @Address1 { get { return __basicRow.@Address1; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @Address2 { get { return __basicRow.@Address2; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @City { get { return __basicRow.@City; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @State { get { return __basicRow.@State; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @ZipCode { get { return __basicRow.@ZipCode; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @Email { get { return __basicRow.@Email; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @Phone { get { return __basicRow.@Phone; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @Gender { get { return __basicRow.@Gender; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @DOB { get { return __basicRow.@DOB; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @ElysiumID { get { return __basicRow.@ElysiumID; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @PhrStatusId { get { return __basicRow.@PhrStatusId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Boolean @SignupComplete { get { return __basicRow.@SignupComplete; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @TfaMethodId { get { return __basicRow.@TfaMethodId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Boolean @ForcePasswordExpired { get { return __basicRow.@ForcePasswordExpired; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.DateTime? @SignupDate { get { return __basicRow.@SignupDate; } }
public override int GetHashCode() { 
return @UserID.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @UserID == other.@UserID && @EncKV == other.@EncKV && @PhrStatusId == other.@PhrStatusId && @SignupComplete == other.@SignupComplete && @TfaMethodId == other.@TfaMethodId && @ForcePasswordExpired == other.@ForcePasswordExpired && @SignupDate == other.@SignupDate;
}
public Modification.@PatientInfoModification ToModification() {
return Modification.@PatientInfoModification.CreateForSingleRowUpdate( @UserID, @EncKV, @EncIV, @FirstName, @MiddleName, @LastName, @Address1, @Address2, @City, @State, @ZipCode, @Email, @Phone, @Gender, @DOB, @ElysiumID, @PhrStatusId, @SignupComplete, @TfaMethodId, @ForcePasswordExpired, @SignupDate );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "PatientInfoTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<System.Guid>, Row> rowsByPk = new Dictionary<Tuple<System.Guid>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<System.Guid>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.PatientInfoTableCondition[] conditions ) {
var userIDCondition = conditions.OfType<CommandConditions.@PatientInfoTableEqualityConditions.@UserID>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = userIDCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( userIDCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM PatientInfo", !isPkQuery, orderByClause: "ORDER BY UserID" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@UserID ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( System.Guid id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@PatientInfoTableEqualityConditions.@UserID( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<System.Guid, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@UserID );
}
}
/// <summary>
/// Contains logic that retrieves rows from the PatientPortalConsentHistory table.
/// </summary>
public static partial class @PatientPortalConsentHistoryTableRetrieval {
internal class BasicRow {
private readonly int @__patientPortalConsentHistoryId;
private readonly System.Byte[] @__iv;
private readonly string @__elysiumId;
private readonly System.Byte[] @__workgroupId;
private readonly System.Byte[] @__consentTypeId;
private readonly DateTime @__updatedByPatientDateTime;
internal BasicRow( DbDataReader reader ) {
@__patientPortalConsentHistoryId = (System.Int32)reader.GetValue( 0 );
@__iv = (System.Byte[])reader.GetValue( 1 );
@__elysiumId = (System.String)reader.GetValue( 2 );
@__workgroupId = (System.Byte[])reader.GetValue( 3 );
@__consentTypeId = (System.Byte[])reader.GetValue( 4 );
@__updatedByPatientDateTime = (System.DateTime)reader.GetValue( 5 );
}
internal int @PatientPortalConsentHistoryId { get { return @__patientPortalConsentHistoryId; } }
internal System.Byte[] @Iv { get { return @__iv; } }
internal string @ElysiumId { get { return @__elysiumId; } }
internal System.Byte[] @WorkgroupId { get { return @__workgroupId; } }
internal System.Byte[] @ConsentTypeId { get { return @__consentTypeId; } }
internal DateTime @UpdatedByPatientDateTime { get { return @__updatedByPatientDateTime; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @PatientPortalConsentHistoryId { get { return __basicRow.@PatientPortalConsentHistoryId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @Iv { get { return __basicRow.@Iv; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @ElysiumId { get { return __basicRow.@ElysiumId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @WorkgroupId { get { return __basicRow.@WorkgroupId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @ConsentTypeId { get { return __basicRow.@ConsentTypeId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @UpdatedByPatientDateTime { get { return __basicRow.@UpdatedByPatientDateTime; } }
public override int GetHashCode() { 
return @PatientPortalConsentHistoryId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @PatientPortalConsentHistoryId == other.@PatientPortalConsentHistoryId && @ElysiumId == other.@ElysiumId && @UpdatedByPatientDateTime == other.@UpdatedByPatientDateTime;
}
public Modification.@PatientPortalConsentHistoryModification ToModification() {
return Modification.@PatientPortalConsentHistoryModification.CreateForSingleRowUpdate( @PatientPortalConsentHistoryId, @Iv, @ElysiumId, @WorkgroupId, @ConsentTypeId, @UpdatedByPatientDateTime );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "PatientPortalConsentHistoryTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.PatientPortalConsentHistoryTableCondition[] conditions ) {
var patientPortalConsentHistoryIdCondition = conditions.OfType<CommandConditions.@PatientPortalConsentHistoryTableEqualityConditions.@PatientPortalConsentHistoryId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = patientPortalConsentHistoryIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( patientPortalConsentHistoryIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM PatientPortalConsentHistory", !isPkQuery, orderByClause: "ORDER BY PatientPortalConsentHistoryId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@PatientPortalConsentHistoryId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@PatientPortalConsentHistoryTableEqualityConditions.@PatientPortalConsentHistoryId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@PatientPortalConsentHistoryId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the Payment table.
/// </summary>
public static partial class @PaymentTableRetrieval {
internal class BasicRow {
private readonly int @__paymentID;
private readonly System.Guid? @__userID;
private readonly System.Int32? @__paymentTypeID;
private readonly System.Int32? @__paymentMethodID;
private readonly System.Single? @__total;
private readonly System.DateTime? @__created;
private readonly System.DateTime? @__lastModified;
internal BasicRow( DbDataReader reader ) {
@__paymentID = (System.Int32)reader.GetValue( 0 );
@__userID = reader.IsDBNull( 1 ) ? (System.Guid?)null : (System.Guid)reader.GetValue( 1 );
@__paymentTypeID = reader.IsDBNull( 2 ) ? (System.Int32?)null : (System.Int32)reader.GetValue( 2 );
@__paymentMethodID = reader.IsDBNull( 3 ) ? (System.Int32?)null : (System.Int32)reader.GetValue( 3 );
@__total = reader.IsDBNull( 4 ) ? (System.Single?)null : (System.Single)reader.GetValue( 4 );
@__created = reader.IsDBNull( 5 ) ? (System.DateTime?)null : (System.DateTime)reader.GetValue( 5 );
@__lastModified = reader.IsDBNull( 6 ) ? (System.DateTime?)null : (System.DateTime)reader.GetValue( 6 );
}
internal int @PaymentID { get { return @__paymentID; } }
internal System.Guid? @UserID { get { return @__userID; } }
internal System.Int32? @PaymentTypeID { get { return @__paymentTypeID; } }
internal System.Int32? @PaymentMethodID { get { return @__paymentMethodID; } }
internal System.Single? @Total { get { return @__total; } }
internal System.DateTime? @Created { get { return @__created; } }
internal System.DateTime? @LastModified { get { return @__lastModified; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @PaymentID { get { return __basicRow.@PaymentID; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.Guid? @UserID { get { return __basicRow.@UserID; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.Int32? @PaymentTypeID { get { return __basicRow.@PaymentTypeID; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.Int32? @PaymentMethodID { get { return __basicRow.@PaymentMethodID; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.Single? @Total { get { return __basicRow.@Total; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.DateTime? @Created { get { return __basicRow.@Created; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.DateTime? @LastModified { get { return __basicRow.@LastModified; } }
public override int GetHashCode() { 
return @PaymentID.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @PaymentID == other.@PaymentID && @UserID == other.@UserID && @PaymentTypeID == other.@PaymentTypeID && @PaymentMethodID == other.@PaymentMethodID && @Total == other.@Total && @Created == other.@Created && @LastModified == other.@LastModified;
}
public Modification.@PaymentModification ToModification() {
return Modification.@PaymentModification.CreateForSingleRowUpdate( @PaymentID, @UserID, @PaymentTypeID, @PaymentMethodID, @Total, @Created, @LastModified );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "PaymentTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.PaymentTableCondition[] conditions ) {
var paymentIDCondition = conditions.OfType<CommandConditions.@PaymentTableEqualityConditions.@PaymentID>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = paymentIDCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( paymentIDCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM Payment", !isPkQuery, orderByClause: "ORDER BY PaymentID" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@PaymentID ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@PaymentTableEqualityConditions.@PaymentID( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@PaymentID );
}
}
/// <summary>
/// Contains logic that retrieves rows from the PaymentMethod table.
/// </summary>
public static partial class @PaymentMethodTableRetrieval {
internal class BasicRow {
private readonly int @__methodID;
private readonly string @__name;
private readonly System.Boolean? @__enabled;
private readonly System.DateTime? @__created;
private readonly System.DateTime? @__lastModified;
internal BasicRow( DbDataReader reader ) {
@__methodID = (System.Int32)reader.GetValue( 0 );
@__name = (System.String)reader.GetValue( 1 );
@__enabled = reader.IsDBNull( 2 ) ? (System.Boolean?)null : (System.Boolean)reader.GetValue( 2 );
@__created = reader.IsDBNull( 3 ) ? (System.DateTime?)null : (System.DateTime)reader.GetValue( 3 );
@__lastModified = reader.IsDBNull( 4 ) ? (System.DateTime?)null : (System.DateTime)reader.GetValue( 4 );
}
internal int @MethodID { get { return @__methodID; } }
internal string @Name { get { return @__name; } }
internal System.Boolean? @Enabled { get { return @__enabled; } }
internal System.DateTime? @Created { get { return @__created; } }
internal System.DateTime? @LastModified { get { return @__lastModified; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @MethodID { get { return __basicRow.@MethodID; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Name { get { return __basicRow.@Name; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.Boolean? @Enabled { get { return __basicRow.@Enabled; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.DateTime? @Created { get { return __basicRow.@Created; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.DateTime? @LastModified { get { return __basicRow.@LastModified; } }
public override int GetHashCode() { 
return @MethodID.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @MethodID == other.@MethodID && @Name == other.@Name && @Enabled == other.@Enabled && @Created == other.@Created && @LastModified == other.@LastModified;
}
public Modification.@PaymentMethodModification ToModification() {
return Modification.@PaymentMethodModification.CreateForSingleRowUpdate( @MethodID, @Name, @Enabled, @Created, @LastModified );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "PaymentMethodTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.PaymentMethodTableCondition[] conditions ) {
var methodIDCondition = conditions.OfType<CommandConditions.@PaymentMethodTableEqualityConditions.@MethodID>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = methodIDCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( methodIDCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM PaymentMethod", !isPkQuery, orderByClause: "ORDER BY MethodID" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@MethodID ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@PaymentMethodTableEqualityConditions.@MethodID( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@MethodID );
}
}
/// <summary>
/// Contains logic that retrieves rows from the PaymentType table.
/// </summary>
public static partial class @PaymentTypeTableRetrieval {
internal class BasicRow {
private readonly int @__typeID;
private readonly string @__name;
private readonly System.Single? @__price;
private readonly System.DateTime? @__created;
private readonly System.DateTime? @__lastUpdated;
internal BasicRow( DbDataReader reader ) {
@__typeID = (System.Int32)reader.GetValue( 0 );
@__name = (System.String)reader.GetValue( 1 );
@__price = reader.IsDBNull( 2 ) ? (System.Single?)null : (System.Single)reader.GetValue( 2 );
@__created = reader.IsDBNull( 3 ) ? (System.DateTime?)null : (System.DateTime)reader.GetValue( 3 );
@__lastUpdated = reader.IsDBNull( 4 ) ? (System.DateTime?)null : (System.DateTime)reader.GetValue( 4 );
}
internal int @TypeID { get { return @__typeID; } }
internal string @Name { get { return @__name; } }
internal System.Single? @Price { get { return @__price; } }
internal System.DateTime? @Created { get { return @__created; } }
internal System.DateTime? @LastUpdated { get { return @__lastUpdated; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @TypeID { get { return __basicRow.@TypeID; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Name { get { return __basicRow.@Name; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.Single? @Price { get { return __basicRow.@Price; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.DateTime? @Created { get { return __basicRow.@Created; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.DateTime? @LastUpdated { get { return __basicRow.@LastUpdated; } }
public override int GetHashCode() { 
return @TypeID.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @TypeID == other.@TypeID && @Name == other.@Name && @Price == other.@Price && @Created == other.@Created && @LastUpdated == other.@LastUpdated;
}
public Modification.@PaymentTypeModification ToModification() {
return Modification.@PaymentTypeModification.CreateForSingleRowUpdate( @TypeID, @Name, @Price, @Created, @LastUpdated );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "PaymentTypeTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.PaymentTypeTableCondition[] conditions ) {
var typeIDCondition = conditions.OfType<CommandConditions.@PaymentTypeTableEqualityConditions.@TypeID>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = typeIDCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( typeIDCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM PaymentType", !isPkQuery, orderByClause: "ORDER BY TypeID" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@TypeID ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@PaymentTypeTableEqualityConditions.@TypeID( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@TypeID );
}
}
/// <summary>
/// Contains logic that retrieves rows from the PerfLog table.
/// </summary>
public static partial class @PerfLogTableRetrieval {
internal class BasicRow {
private readonly int @__perfLogID;
private readonly DateTime @__tStamp;
private readonly string @__category;
private readonly string @__code;
private readonly decimal @__elapsedTime;
private readonly string @__units;
private readonly System.Boolean @__isTest;
private readonly System.Decimal? @__factor1;
internal BasicRow( DbDataReader reader ) {
@__perfLogID = (System.Int32)reader.GetValue( 0 );
@__tStamp = (System.DateTime)reader.GetValue( 1 );
@__category = (System.String)reader.GetValue( 2 );
@__code = (System.String)reader.GetValue( 3 );
@__elapsedTime = (System.Decimal)reader.GetValue( 4 );
@__units = (System.String)reader.GetValue( 5 );
@__isTest = (System.Boolean)reader.GetValue( 6 );
@__factor1 = reader.IsDBNull( 7 ) ? (System.Decimal?)null : (System.Decimal)reader.GetValue( 7 );
}
internal int @PerfLogID { get { return @__perfLogID; } }
internal DateTime @TStamp { get { return @__tStamp; } }
internal string @Category { get { return @__category; } }
internal string @Code { get { return @__code; } }
internal decimal @ElapsedTime { get { return @__elapsedTime; } }
internal string @Units { get { return @__units; } }
internal System.Boolean @IsTest { get { return @__isTest; } }
internal System.Decimal? @Factor1 { get { return @__factor1; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @PerfLogID { get { return __basicRow.@PerfLogID; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @TStamp { get { return __basicRow.@TStamp; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Category { get { return __basicRow.@Category; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Code { get { return __basicRow.@Code; } }
/// <summary>
/// This object will never be null.
/// </summary>
public decimal @ElapsedTime { get { return __basicRow.@ElapsedTime; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Units { get { return __basicRow.@Units; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Boolean @IsTest { get { return __basicRow.@IsTest; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.Decimal? @Factor1 { get { return __basicRow.@Factor1; } }
public override int GetHashCode() { 
return @PerfLogID.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @PerfLogID == other.@PerfLogID && @TStamp == other.@TStamp && @Category == other.@Category && @Code == other.@Code && @ElapsedTime == other.@ElapsedTime && @Units == other.@Units && @IsTest == other.@IsTest && @Factor1 == other.@Factor1;
}
public Modification.@PerfLogModification ToModification() {
return Modification.@PerfLogModification.CreateForSingleRowUpdate( @PerfLogID, @TStamp, @Category, @Code, @ElapsedTime, @Units, @IsTest, @Factor1 );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "PerfLogTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.PerfLogTableCondition[] conditions ) {
var perfLogIDCondition = conditions.OfType<CommandConditions.@PerfLogTableEqualityConditions.@PerfLogID>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = perfLogIDCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( perfLogIDCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM PerfLog", !isPkQuery, orderByClause: "ORDER BY PerfLogID" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@PerfLogID ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@PerfLogTableEqualityConditions.@PerfLogID( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@PerfLogID );
}
}
/// <summary>
/// Contains logic that retrieves rows from the PhrStatuses table.
/// </summary>
public static partial class @PhrStatusesTableRetrieval {
internal class BasicRow {
private readonly int @__phrStatusId;
private readonly string @__phrStatus;
internal BasicRow( DbDataReader reader ) {
@__phrStatusId = (System.Int32)reader.GetValue( 0 );
@__phrStatus = (System.String)reader.GetValue( 1 );
}
internal int @PhrStatusId { get { return @__phrStatusId; } }
internal string @PhrStatus { get { return @__phrStatus; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @PhrStatusId { get { return __basicRow.@PhrStatusId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @PhrStatus { get { return __basicRow.@PhrStatus; } }
public override int GetHashCode() { 
return @PhrStatusId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @PhrStatusId == other.@PhrStatusId && @PhrStatus == other.@PhrStatus;
}
public Modification.@PhrStatusesModification ToModification() {
return Modification.@PhrStatusesModification.CreateForSingleRowUpdate( @PhrStatusId, @PhrStatus );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "PhrStatusesTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.PhrStatusesTableCondition[] conditions ) {
var phrStatusIdCondition = conditions.OfType<CommandConditions.@PhrStatusesTableEqualityConditions.@PhrStatusId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = phrStatusIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( phrStatusIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM PhrStatuses", !isPkQuery, orderByClause: "ORDER BY PhrStatusId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@PhrStatusId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@PhrStatusesTableEqualityConditions.@PhrStatusId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@PhrStatusId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the Physician table.
/// </summary>
public static partial class @PhysicianTableRetrieval {
internal class BasicRow {
private readonly int @__physicianID;
private readonly string @__externalID;
private readonly int @__specialtyID;
private readonly int @__workGroupID;
private readonly string @__firstName;
private readonly string @__lastName;
private readonly string @__middleInitial;
private readonly string @__company;
private readonly string @__address;
private readonly string @__city;
private readonly string @__state;
private readonly string @__zip;
private readonly string @__phone;
private readonly DateTime @__lastUpdated;
private readonly DateTime @__created;
private readonly System.Boolean @__hidden;
private readonly string @__providerNPI;
private readonly System.Int32? @__workgroupLocationId;
internal BasicRow( DbDataReader reader ) {
@__physicianID = (System.Int32)reader.GetValue( 0 );
@__externalID = (System.String)reader.GetValue( 1 );
@__specialtyID = (System.Int32)reader.GetValue( 2 );
@__workGroupID = (System.Int32)reader.GetValue( 3 );
@__firstName = (System.String)reader.GetValue( 4 );
@__lastName = (System.String)reader.GetValue( 5 );
@__middleInitial = (System.String)reader.GetValue( 6 );
@__company = (System.String)reader.GetValue( 7 );
@__address = (System.String)reader.GetValue( 8 );
@__city = (System.String)reader.GetValue( 9 );
@__state = (System.String)reader.GetValue( 10 );
@__zip = (System.String)reader.GetValue( 11 );
@__phone = (System.String)reader.GetValue( 12 );
@__lastUpdated = (System.DateTime)reader.GetValue( 13 );
@__created = (System.DateTime)reader.GetValue( 14 );
@__hidden = (System.Boolean)reader.GetValue( 15 );
@__providerNPI = (System.String)reader.GetValue( 16 );
@__workgroupLocationId = reader.IsDBNull( 17 ) ? (System.Int32?)null : (System.Int32)reader.GetValue( 17 );
}
internal int @PhysicianID { get { return @__physicianID; } }
internal string @ExternalID { get { return @__externalID; } }
internal int @SpecialtyID { get { return @__specialtyID; } }
internal int @WorkGroupID { get { return @__workGroupID; } }
internal string @FirstName { get { return @__firstName; } }
internal string @LastName { get { return @__lastName; } }
internal string @MiddleInitial { get { return @__middleInitial; } }
internal string @Company { get { return @__company; } }
internal string @Address { get { return @__address; } }
internal string @City { get { return @__city; } }
internal string @State { get { return @__state; } }
internal string @Zip { get { return @__zip; } }
internal string @Phone { get { return @__phone; } }
internal DateTime @LastUpdated { get { return @__lastUpdated; } }
internal DateTime @Created { get { return @__created; } }
internal System.Boolean @Hidden { get { return @__hidden; } }
internal string @ProviderNPI { get { return @__providerNPI; } }
internal System.Int32? @WorkgroupLocationId { get { return @__workgroupLocationId; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @PhysicianID { get { return __basicRow.@PhysicianID; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @ExternalID { get { return __basicRow.@ExternalID; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @SpecialtyID { get { return __basicRow.@SpecialtyID; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @WorkGroupID { get { return __basicRow.@WorkGroupID; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @FirstName { get { return __basicRow.@FirstName; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @LastName { get { return __basicRow.@LastName; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @MiddleInitial { get { return __basicRow.@MiddleInitial; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Company { get { return __basicRow.@Company; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Address { get { return __basicRow.@Address; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @City { get { return __basicRow.@City; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @State { get { return __basicRow.@State; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Zip { get { return __basicRow.@Zip; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Phone { get { return __basicRow.@Phone; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @LastUpdated { get { return __basicRow.@LastUpdated; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @Created { get { return __basicRow.@Created; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Boolean @Hidden { get { return __basicRow.@Hidden; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @ProviderNPI { get { return __basicRow.@ProviderNPI; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.Int32? @WorkgroupLocationId { get { return __basicRow.@WorkgroupLocationId; } }
public override int GetHashCode() { 
return @PhysicianID.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @PhysicianID == other.@PhysicianID && @ExternalID == other.@ExternalID && @SpecialtyID == other.@SpecialtyID && @WorkGroupID == other.@WorkGroupID && @FirstName == other.@FirstName && @LastName == other.@LastName && @MiddleInitial == other.@MiddleInitial && @Company == other.@Company && @Address == other.@Address && @City == other.@City && @State == other.@State && @Zip == other.@Zip && @Phone == other.@Phone && @LastUpdated == other.@LastUpdated && @Created == other.@Created && @Hidden == other.@Hidden && @ProviderNPI == other.@ProviderNPI && @WorkgroupLocationId == other.@WorkgroupLocationId;
}
public Modification.@PhysicianModification ToModification() {
return Modification.@PhysicianModification.CreateForSingleRowUpdate( @PhysicianID, @ExternalID, @SpecialtyID, @WorkGroupID, @FirstName, @LastName, @MiddleInitial, @Company, @Address, @City, @State, @Zip, @Phone, @LastUpdated, @Created, @Hidden, @ProviderNPI, @WorkgroupLocationId );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "PhysicianTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.PhysicianTableCondition[] conditions ) {
var physicianIDCondition = conditions.OfType<CommandConditions.@PhysicianTableEqualityConditions.@PhysicianID>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = physicianIDCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( physicianIDCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM Physician", !isPkQuery, orderByClause: "ORDER BY PhysicianID" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@PhysicianID ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@PhysicianTableEqualityConditions.@PhysicianID( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@PhysicianID );
}
}
/// <summary>
/// Contains logic that retrieves rows from the PreviousPasswords table.
/// </summary>
public static partial class @PreviousPasswordsTableRetrieval {
internal class BasicRow {
private readonly int @__previousPasswordId;
private readonly int @__userId;
private readonly int @__salt;
private readonly System.Byte[] @__password;
private readonly DateTime @__date;
internal BasicRow( DbDataReader reader ) {
@__previousPasswordId = (System.Int32)reader.GetValue( 0 );
@__userId = (System.Int32)reader.GetValue( 1 );
@__salt = (System.Int32)reader.GetValue( 2 );
@__password = (System.Byte[])reader.GetValue( 3 );
@__date = (System.DateTime)reader.GetValue( 4 );
}
internal int @PreviousPasswordId { get { return @__previousPasswordId; } }
internal int @UserId { get { return @__userId; } }
internal int @Salt { get { return @__salt; } }
internal System.Byte[] @Password { get { return @__password; } }
internal DateTime @Date { get { return @__date; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @PreviousPasswordId { get { return __basicRow.@PreviousPasswordId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @UserId { get { return __basicRow.@UserId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @Salt { get { return __basicRow.@Salt; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @Password { get { return __basicRow.@Password; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @Date { get { return __basicRow.@Date; } }
public override int GetHashCode() { 
return @PreviousPasswordId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @PreviousPasswordId == other.@PreviousPasswordId && @UserId == other.@UserId && @Salt == other.@Salt && @Date == other.@Date;
}
public Modification.@PreviousPasswordsModification ToModification() {
return Modification.@PreviousPasswordsModification.CreateForSingleRowUpdate( @PreviousPasswordId, @UserId, @Salt, @Password, @Date );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "PreviousPasswordsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.PreviousPasswordsTableCondition[] conditions ) {
var previousPasswordIdCondition = conditions.OfType<CommandConditions.@PreviousPasswordsTableEqualityConditions.@PreviousPasswordId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = previousPasswordIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( previousPasswordIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM PreviousPasswords", !isPkQuery, orderByClause: "ORDER BY PreviousPasswordId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@PreviousPasswordId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@PreviousPasswordsTableEqualityConditions.@PreviousPasswordId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@PreviousPasswordId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the Provider table.
/// </summary>
public static partial class @ProviderTableRetrieval {
internal class BasicRow {
private readonly int @__providerID;
private readonly System.Int32? @__typeID;
private readonly string @__name;
private readonly string @__namespace;
private readonly System.Boolean? @__isEnabled;
private readonly System.Boolean? @__isCurrent;
private readonly System.DateTime? @__lastModified;
private readonly System.DateTime? @__created;
internal BasicRow( DbDataReader reader ) {
@__providerID = (System.Int32)reader.GetValue( 0 );
@__typeID = reader.IsDBNull( 1 ) ? (System.Int32?)null : (System.Int32)reader.GetValue( 1 );
@__name = (System.String)reader.GetValue( 2 );
@__namespace = (System.String)reader.GetValue( 3 );
@__isEnabled = reader.IsDBNull( 4 ) ? (System.Boolean?)null : (System.Boolean)reader.GetValue( 4 );
@__isCurrent = reader.IsDBNull( 5 ) ? (System.Boolean?)null : (System.Boolean)reader.GetValue( 5 );
@__lastModified = reader.IsDBNull( 6 ) ? (System.DateTime?)null : (System.DateTime)reader.GetValue( 6 );
@__created = reader.IsDBNull( 7 ) ? (System.DateTime?)null : (System.DateTime)reader.GetValue( 7 );
}
internal int @ProviderID { get { return @__providerID; } }
internal System.Int32? @TypeID { get { return @__typeID; } }
internal string @Name { get { return @__name; } }
internal string @Namespace { get { return @__namespace; } }
internal System.Boolean? @IsEnabled { get { return @__isEnabled; } }
internal System.Boolean? @IsCurrent { get { return @__isCurrent; } }
internal System.DateTime? @LastModified { get { return @__lastModified; } }
internal System.DateTime? @Created { get { return @__created; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @ProviderID { get { return __basicRow.@ProviderID; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.Int32? @TypeID { get { return __basicRow.@TypeID; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Name { get { return __basicRow.@Name; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Namespace { get { return __basicRow.@Namespace; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.Boolean? @IsEnabled { get { return __basicRow.@IsEnabled; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.Boolean? @IsCurrent { get { return __basicRow.@IsCurrent; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.DateTime? @LastModified { get { return __basicRow.@LastModified; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.DateTime? @Created { get { return __basicRow.@Created; } }
public override int GetHashCode() { 
return @ProviderID.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @ProviderID == other.@ProviderID && @TypeID == other.@TypeID && @Name == other.@Name && @Namespace == other.@Namespace && @IsEnabled == other.@IsEnabled && @IsCurrent == other.@IsCurrent && @LastModified == other.@LastModified && @Created == other.@Created;
}
public Modification.@ProviderModification ToModification() {
return Modification.@ProviderModification.CreateForSingleRowUpdate( @ProviderID, @TypeID, @Name, @Namespace, @IsEnabled, @IsCurrent, @LastModified, @Created );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "ProviderTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.ProviderTableCondition[] conditions ) {
var providerIDCondition = conditions.OfType<CommandConditions.@ProviderTableEqualityConditions.@ProviderID>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = providerIDCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( providerIDCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM Provider", !isPkQuery, orderByClause: "ORDER BY ProviderID" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@ProviderID ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@ProviderTableEqualityConditions.@ProviderID( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@ProviderID );
}
}
/// <summary>
/// Contains logic that retrieves rows from the ProviderPortalUsers table.
/// </summary>
public static partial class @ProviderPortalUsersTableRetrieval {
internal class BasicRow {
private readonly int @__providerPortalUserId;
private readonly string @__rhioUserName;
private readonly int @__userId;
private readonly string @__nationalProviderIdentifier;
internal BasicRow( DbDataReader reader ) {
@__providerPortalUserId = (System.Int32)reader.GetValue( 0 );
@__rhioUserName = (System.String)reader.GetValue( 1 );
@__userId = (System.Int32)reader.GetValue( 2 );
@__nationalProviderIdentifier = (System.String)reader.GetValue( 3 );
}
internal int @ProviderPortalUserId { get { return @__providerPortalUserId; } }
internal string @RhioUserName { get { return @__rhioUserName; } }
internal int @UserId { get { return @__userId; } }
internal string @NationalProviderIdentifier { get { return @__nationalProviderIdentifier; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @ProviderPortalUserId { get { return __basicRow.@ProviderPortalUserId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @RhioUserName { get { return __basicRow.@RhioUserName; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @UserId { get { return __basicRow.@UserId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @NationalProviderIdentifier { get { return __basicRow.@NationalProviderIdentifier; } }
public override int GetHashCode() { 
return @ProviderPortalUserId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @ProviderPortalUserId == other.@ProviderPortalUserId && @RhioUserName == other.@RhioUserName && @UserId == other.@UserId && @NationalProviderIdentifier == other.@NationalProviderIdentifier;
}
public Modification.@ProviderPortalUsersModification ToModification() {
return Modification.@ProviderPortalUsersModification.CreateForSingleRowUpdate( @ProviderPortalUserId, @RhioUserName, @UserId, @NationalProviderIdentifier );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "ProviderPortalUsersTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.ProviderPortalUsersTableCondition[] conditions ) {
var providerPortalUserIdCondition = conditions.OfType<CommandConditions.@ProviderPortalUsersTableEqualityConditions.@ProviderPortalUserId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = providerPortalUserIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( providerPortalUserIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM ProviderPortalUsers", !isPkQuery, orderByClause: "ORDER BY ProviderPortalUserId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@ProviderPortalUserId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@ProviderPortalUsersTableEqualityConditions.@ProviderPortalUserId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@ProviderPortalUserId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the ProviderPortalUsersToCareZones table.
/// </summary>
public static partial class @ProviderPortalUsersToCareZonesTableRetrieval {
internal class BasicRow {
private readonly int @__providerPortalUsersToCareZonesId;
private readonly int @__providerPortalUserId;
private readonly int @__careZoneId;
internal BasicRow( DbDataReader reader ) {
@__providerPortalUsersToCareZonesId = (System.Int32)reader.GetValue( 0 );
@__providerPortalUserId = (System.Int32)reader.GetValue( 1 );
@__careZoneId = (System.Int32)reader.GetValue( 2 );
}
internal int @ProviderPortalUsersToCareZonesId { get { return @__providerPortalUsersToCareZonesId; } }
internal int @ProviderPortalUserId { get { return @__providerPortalUserId; } }
internal int @CareZoneId { get { return @__careZoneId; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @ProviderPortalUsersToCareZonesId { get { return __basicRow.@ProviderPortalUsersToCareZonesId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @ProviderPortalUserId { get { return __basicRow.@ProviderPortalUserId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @CareZoneId { get { return __basicRow.@CareZoneId; } }
public override int GetHashCode() { 
return @ProviderPortalUsersToCareZonesId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @ProviderPortalUsersToCareZonesId == other.@ProviderPortalUsersToCareZonesId && @ProviderPortalUserId == other.@ProviderPortalUserId && @CareZoneId == other.@CareZoneId;
}
public Modification.@ProviderPortalUsersToCareZonesModification ToModification() {
return Modification.@ProviderPortalUsersToCareZonesModification.CreateForSingleRowUpdate( @ProviderPortalUsersToCareZonesId, @ProviderPortalUserId, @CareZoneId );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "ProviderPortalUsersToCareZonesTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.ProviderPortalUsersToCareZonesTableCondition[] conditions ) {
var providerPortalUsersToCareZonesIdCondition = conditions.OfType<CommandConditions.@ProviderPortalUsersToCareZonesTableEqualityConditions.@ProviderPortalUsersToCareZonesId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = providerPortalUsersToCareZonesIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( providerPortalUsersToCareZonesIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM ProviderPortalUsersToCareZones", !isPkQuery, orderByClause: "ORDER BY ProviderPortalUsersToCareZonesId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@ProviderPortalUsersToCareZonesId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@ProviderPortalUsersToCareZonesTableEqualityConditions.@ProviderPortalUsersToCareZonesId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@ProviderPortalUsersToCareZonesId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the ProviderPortalUsersToNewCareZones table.
/// </summary>
public static partial class @ProviderPortalUsersToNewCareZonesTableRetrieval {
internal class BasicRow {
private readonly int @__providerPortalUserId;
private readonly int @__careZoneId;
internal BasicRow( DbDataReader reader ) {
@__providerPortalUserId = (System.Int32)reader.GetValue( 0 );
@__careZoneId = (System.Int32)reader.GetValue( 1 );
}
internal int @ProviderPortalUserId { get { return @__providerPortalUserId; } }
internal int @CareZoneId { get { return @__careZoneId; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @ProviderPortalUserId { get { return __basicRow.@ProviderPortalUserId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @CareZoneId { get { return __basicRow.@CareZoneId; } }
public override int GetHashCode() { 
return @ProviderPortalUserId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @ProviderPortalUserId == other.@ProviderPortalUserId && @CareZoneId == other.@CareZoneId;
}
public Modification.@ProviderPortalUsersToNewCareZonesModification ToModification() {
return Modification.@ProviderPortalUsersToNewCareZonesModification.CreateForSingleRowUpdate( @ProviderPortalUserId, @CareZoneId );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "ProviderPortalUsersToNewCareZonesTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int, int>, Row> rowsByPk = new Dictionary<Tuple<int, int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int, int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.ProviderPortalUsersToNewCareZonesTableCondition[] conditions ) {
var providerPortalUserIdCondition = conditions.OfType<CommandConditions.@ProviderPortalUsersToNewCareZonesTableEqualityConditions.@ProviderPortalUserId>().FirstOrDefault();
var careZoneIdCondition = conditions.OfType<CommandConditions.@ProviderPortalUsersToNewCareZonesTableEqualityConditions.@CareZoneId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = providerPortalUserIdCondition != null && careZoneIdCondition != null && conditions.Count() == 2;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( providerPortalUserIdCondition.Value, careZoneIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM ProviderPortalUsersToNewCareZones", !isPkQuery, orderByClause: "ORDER BY ProviderPortalUserId, CareZoneId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@ProviderPortalUserId, i.@CareZoneId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingPk( int providerPortalUserId, int careZoneId, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@ProviderPortalUsersToNewCareZonesTableEqualityConditions.@ProviderPortalUserId( providerPortalUserId ), new CommandConditions.@ProviderPortalUsersToNewCareZonesTableEqualityConditions.@CareZoneId( careZoneId ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
}
/// <summary>
/// Contains logic that retrieves rows from the ProviderType table.
/// </summary>
public static partial class @ProviderTypeTableRetrieval {
internal class BasicRow {
private readonly int @__typeID;
private readonly string @__name;
private readonly System.DateTime? @__lastModified;
private readonly System.DateTime? @__created;
internal BasicRow( DbDataReader reader ) {
@__typeID = (System.Int32)reader.GetValue( 0 );
@__name = (System.String)reader.GetValue( 1 );
@__lastModified = reader.IsDBNull( 2 ) ? (System.DateTime?)null : (System.DateTime)reader.GetValue( 2 );
@__created = reader.IsDBNull( 3 ) ? (System.DateTime?)null : (System.DateTime)reader.GetValue( 3 );
}
internal int @TypeID { get { return @__typeID; } }
internal string @Name { get { return @__name; } }
internal System.DateTime? @LastModified { get { return @__lastModified; } }
internal System.DateTime? @Created { get { return @__created; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @TypeID { get { return __basicRow.@TypeID; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Name { get { return __basicRow.@Name; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.DateTime? @LastModified { get { return __basicRow.@LastModified; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.DateTime? @Created { get { return __basicRow.@Created; } }
public override int GetHashCode() { 
return @TypeID.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @TypeID == other.@TypeID && @Name == other.@Name && @LastModified == other.@LastModified && @Created == other.@Created;
}
public Modification.@ProviderTypeModification ToModification() {
return Modification.@ProviderTypeModification.CreateForSingleRowUpdate( @TypeID, @Name, @LastModified, @Created );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "ProviderTypeTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.ProviderTypeTableCondition[] conditions ) {
var typeIDCondition = conditions.OfType<CommandConditions.@ProviderTypeTableEqualityConditions.@TypeID>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = typeIDCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( typeIDCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM ProviderType", !isPkQuery, orderByClause: "ORDER BY TypeID" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@TypeID ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@ProviderTypeTableEqualityConditions.@TypeID( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@TypeID );
}
}
/// <summary>
/// Contains logic that retrieves rows from the Roles table.
/// </summary>
public static partial class @RolesTableRetrieval {
internal class BasicRow {
private readonly int @__roleId;
private readonly string @__roleName;
internal BasicRow( DbDataReader reader ) {
@__roleId = (System.Int32)reader.GetValue( 0 );
@__roleName = (System.String)reader.GetValue( 1 );
}
internal int @RoleId { get { return @__roleId; } }
internal string @RoleName { get { return @__roleName; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @RoleId { get { return __basicRow.@RoleId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @RoleName { get { return __basicRow.@RoleName; } }
public override int GetHashCode() { 
return @RoleId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @RoleId == other.@RoleId && @RoleName == other.@RoleName;
}
public Modification.@RolesModification ToModification() {
return Modification.@RolesModification.CreateForSingleRowUpdate( @RoleId, @RoleName );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "RolesTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.RolesTableCondition[] conditions ) {
var roleIdCondition = conditions.OfType<CommandConditions.@RolesTableEqualityConditions.@RoleId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = roleIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( roleIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM Roles", !isPkQuery, orderByClause: "ORDER BY RoleId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@RoleId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@RolesTableEqualityConditions.@RoleId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@RoleId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the SalesforceContacts table.
/// </summary>
public static partial class @SalesforceContactsTableRetrieval {
internal class BasicRow {
private readonly int @__salesforceContactId;
private readonly string @__personalDirectAddress;
private readonly string @__title;
private readonly string @__firstName;
private readonly string @__lastName;
private readonly string @__phoneNumber;
private readonly int @__salesforceOrganizationId;
private readonly System.Boolean @__isVhrUser;
internal BasicRow( DbDataReader reader ) {
@__salesforceContactId = (System.Int32)reader.GetValue( 0 );
@__personalDirectAddress = (System.String)reader.GetValue( 1 );
@__title = (System.String)reader.GetValue( 2 );
@__firstName = (System.String)reader.GetValue( 3 );
@__lastName = (System.String)reader.GetValue( 4 );
@__phoneNumber = (System.String)reader.GetValue( 5 );
@__salesforceOrganizationId = (System.Int32)reader.GetValue( 6 );
@__isVhrUser = (System.Boolean)reader.GetValue( 7 );
}
internal int @SalesforceContactId { get { return @__salesforceContactId; } }
internal string @PersonalDirectAddress { get { return @__personalDirectAddress; } }
internal string @Title { get { return @__title; } }
internal string @FirstName { get { return @__firstName; } }
internal string @LastName { get { return @__lastName; } }
internal string @PhoneNumber { get { return @__phoneNumber; } }
internal int @SalesforceOrganizationId { get { return @__salesforceOrganizationId; } }
internal System.Boolean @IsVhrUser { get { return @__isVhrUser; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @SalesforceContactId { get { return __basicRow.@SalesforceContactId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @PersonalDirectAddress { get { return __basicRow.@PersonalDirectAddress; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Title { get { return __basicRow.@Title; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @FirstName { get { return __basicRow.@FirstName; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @LastName { get { return __basicRow.@LastName; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @PhoneNumber { get { return __basicRow.@PhoneNumber; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @SalesforceOrganizationId { get { return __basicRow.@SalesforceOrganizationId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Boolean @IsVhrUser { get { return __basicRow.@IsVhrUser; } }
public override int GetHashCode() { 
return @SalesforceContactId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @SalesforceContactId == other.@SalesforceContactId && @PersonalDirectAddress == other.@PersonalDirectAddress && @Title == other.@Title && @FirstName == other.@FirstName && @LastName == other.@LastName && @PhoneNumber == other.@PhoneNumber && @SalesforceOrganizationId == other.@SalesforceOrganizationId && @IsVhrUser == other.@IsVhrUser;
}
public Modification.@SalesforceContactsModification ToModification() {
return Modification.@SalesforceContactsModification.CreateForSingleRowUpdate( @SalesforceContactId, @PersonalDirectAddress, @Title, @FirstName, @LastName, @PhoneNumber, @SalesforceOrganizationId, @IsVhrUser );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "SalesforceContactsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.SalesforceContactsTableCondition[] conditions ) {
var salesforceContactIdCondition = conditions.OfType<CommandConditions.@SalesforceContactsTableEqualityConditions.@SalesforceContactId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = salesforceContactIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( salesforceContactIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM SalesforceContacts", !isPkQuery, orderByClause: "ORDER BY SalesforceContactId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@SalesforceContactId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@SalesforceContactsTableEqualityConditions.@SalesforceContactId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@SalesforceContactId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the SalesforceOrganizations table.
/// </summary>
public static partial class @SalesforceOrganizationsTableRetrieval {
internal class BasicRow {
private readonly int @__salesforceOrganizationId;
private readonly string @__organizationName;
private readonly System.Int32? @__parentOrganizationId;
private readonly string @__directAddress;
private readonly string @__phoneNumber;
private readonly string @__street;
private readonly string @__street2;
private readonly string @__city;
private readonly int @__stateId;
private readonly string @__zipCode;
internal BasicRow( DbDataReader reader ) {
@__salesforceOrganizationId = (System.Int32)reader.GetValue( 0 );
@__organizationName = (System.String)reader.GetValue( 1 );
@__parentOrganizationId = reader.IsDBNull( 2 ) ? (System.Int32?)null : (System.Int32)reader.GetValue( 2 );
@__directAddress = (System.String)reader.GetValue( 3 );
@__phoneNumber = (System.String)reader.GetValue( 4 );
@__street = (System.String)reader.GetValue( 5 );
@__street2 = (System.String)reader.GetValue( 6 );
@__city = (System.String)reader.GetValue( 7 );
@__stateId = (System.Int32)reader.GetValue( 8 );
@__zipCode = (System.String)reader.GetValue( 9 );
}
internal int @SalesforceOrganizationId { get { return @__salesforceOrganizationId; } }
internal string @OrganizationName { get { return @__organizationName; } }
internal System.Int32? @ParentOrganizationId { get { return @__parentOrganizationId; } }
internal string @DirectAddress { get { return @__directAddress; } }
internal string @PhoneNumber { get { return @__phoneNumber; } }
internal string @Street { get { return @__street; } }
internal string @Street2 { get { return @__street2; } }
internal string @City { get { return @__city; } }
internal int @StateId { get { return @__stateId; } }
internal string @ZipCode { get { return @__zipCode; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @SalesforceOrganizationId { get { return __basicRow.@SalesforceOrganizationId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @OrganizationName { get { return __basicRow.@OrganizationName; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.Int32? @ParentOrganizationId { get { return __basicRow.@ParentOrganizationId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @DirectAddress { get { return __basicRow.@DirectAddress; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @PhoneNumber { get { return __basicRow.@PhoneNumber; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Street { get { return __basicRow.@Street; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Street2 { get { return __basicRow.@Street2; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @City { get { return __basicRow.@City; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @StateId { get { return __basicRow.@StateId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @ZipCode { get { return __basicRow.@ZipCode; } }
public override int GetHashCode() { 
return @SalesforceOrganizationId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @SalesforceOrganizationId == other.@SalesforceOrganizationId && @OrganizationName == other.@OrganizationName && @ParentOrganizationId == other.@ParentOrganizationId && @DirectAddress == other.@DirectAddress && @PhoneNumber == other.@PhoneNumber && @Street == other.@Street && @Street2 == other.@Street2 && @City == other.@City && @StateId == other.@StateId && @ZipCode == other.@ZipCode;
}
public Modification.@SalesforceOrganizationsModification ToModification() {
return Modification.@SalesforceOrganizationsModification.CreateForSingleRowUpdate( @SalesforceOrganizationId, @OrganizationName, @ParentOrganizationId, @DirectAddress, @PhoneNumber, @Street, @Street2, @City, @StateId, @ZipCode );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "SalesforceOrganizationsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.SalesforceOrganizationsTableCondition[] conditions ) {
var salesforceOrganizationIdCondition = conditions.OfType<CommandConditions.@SalesforceOrganizationsTableEqualityConditions.@SalesforceOrganizationId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = salesforceOrganizationIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( salesforceOrganizationIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM SalesforceOrganizations", !isPkQuery, orderByClause: "ORDER BY SalesforceOrganizationId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@SalesforceOrganizationId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@SalesforceOrganizationsTableEqualityConditions.@SalesforceOrganizationId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@SalesforceOrganizationId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the ScanAttachFile table.
/// </summary>
public static partial class @ScanAttachFileTableRetrieval {
internal class BasicRow {
private readonly System.Guid @__fileID;
private readonly string @__encKV;
private readonly System.Byte[] @__encIV;
private readonly string @__elysiumID;
private readonly string @__category;
private readonly string @__fileStatus;
private readonly DateTime @__dateUploaded;
private readonly DateTime @__dateUpdated;
private readonly string @__suggestedFileName;
private readonly string @__fileMimeType;
private readonly System.Byte[] @__fileBytesEncrypted;
private readonly System.Byte[] @__patientUserID;
internal BasicRow( DbDataReader reader ) {
@__fileID = (System.Guid)reader.GetValue( 0 );
@__encKV = (System.String)reader.GetValue( 1 );
@__encIV = (System.Byte[])reader.GetValue( 2 );
@__elysiumID = (System.String)reader.GetValue( 3 );
@__category = (System.String)reader.GetValue( 4 );
@__fileStatus = (System.String)reader.GetValue( 5 );
@__dateUploaded = (System.DateTime)reader.GetValue( 6 );
@__dateUpdated = (System.DateTime)reader.GetValue( 7 );
@__suggestedFileName = (System.String)reader.GetValue( 8 );
@__fileMimeType = (System.String)reader.GetValue( 9 );
@__fileBytesEncrypted = reader.IsDBNull( 10 ) ? (System.Byte[])null : (System.Byte[])reader.GetValue( 10 );
@__patientUserID = (System.Byte[])reader.GetValue( 11 );
}
internal System.Guid @FileID { get { return @__fileID; } }
internal string @EncKV { get { return @__encKV; } }
internal System.Byte[] @EncIV { get { return @__encIV; } }
internal string @ElysiumID { get { return @__elysiumID; } }
internal string @Category { get { return @__category; } }
internal string @FileStatus { get { return @__fileStatus; } }
internal DateTime @DateUploaded { get { return @__dateUploaded; } }
internal DateTime @DateUpdated { get { return @__dateUpdated; } }
internal string @SuggestedFileName { get { return @__suggestedFileName; } }
internal string @FileMimeType { get { return @__fileMimeType; } }
internal System.Byte[] @FileBytesEncrypted { get { return @__fileBytesEncrypted; } }
internal System.Byte[] @PatientUserID { get { return @__patientUserID; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public System.Guid @FileID { get { return __basicRow.@FileID; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @EncKV { get { return __basicRow.@EncKV; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @EncIV { get { return __basicRow.@EncIV; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @ElysiumID { get { return __basicRow.@ElysiumID; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Category { get { return __basicRow.@Category; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @FileStatus { get { return __basicRow.@FileStatus; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @DateUploaded { get { return __basicRow.@DateUploaded; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @DateUpdated { get { return __basicRow.@DateUpdated; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @SuggestedFileName { get { return __basicRow.@SuggestedFileName; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @FileMimeType { get { return __basicRow.@FileMimeType; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.Byte[] @FileBytesEncrypted { get { return __basicRow.@FileBytesEncrypted; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @PatientUserID { get { return __basicRow.@PatientUserID; } }
public override int GetHashCode() { 
return @FileID.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @FileID == other.@FileID && @EncKV == other.@EncKV && @ElysiumID == other.@ElysiumID && @Category == other.@Category && @FileStatus == other.@FileStatus && @DateUploaded == other.@DateUploaded && @DateUpdated == other.@DateUpdated && @SuggestedFileName == other.@SuggestedFileName && @FileMimeType == other.@FileMimeType;
}
public Modification.@ScanAttachFileModification ToModification() {
return Modification.@ScanAttachFileModification.CreateForSingleRowUpdate( @FileID, @EncKV, @EncIV, @ElysiumID, @Category, @FileStatus, @DateUploaded, @DateUpdated, @SuggestedFileName, @FileMimeType, @FileBytesEncrypted, @PatientUserID );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "ScanAttachFileTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<System.Guid>, Row> rowsByPk = new Dictionary<Tuple<System.Guid>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<System.Guid>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.ScanAttachFileTableCondition[] conditions ) {
var fileIDCondition = conditions.OfType<CommandConditions.@ScanAttachFileTableEqualityConditions.@FileID>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = fileIDCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( fileIDCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM ScanAttachFile", !isPkQuery, orderByClause: "ORDER BY FileID" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@FileID ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( System.Guid id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@ScanAttachFileTableEqualityConditions.@FileID( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<System.Guid, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@FileID );
}
}
/// <summary>
/// Contains logic that retrieves rows from the Specialty table.
/// </summary>
public static partial class @SpecialtyTableRetrieval {
internal class BasicRow {
private readonly int @__specialtyID;
private readonly string @__name;
private readonly System.DateTime? @__lastModified;
private readonly System.DateTime? @__created;
internal BasicRow( DbDataReader reader ) {
@__specialtyID = (System.Int32)reader.GetValue( 0 );
@__name = (System.String)reader.GetValue( 1 );
@__lastModified = reader.IsDBNull( 2 ) ? (System.DateTime?)null : (System.DateTime)reader.GetValue( 2 );
@__created = reader.IsDBNull( 3 ) ? (System.DateTime?)null : (System.DateTime)reader.GetValue( 3 );
}
internal int @SpecialtyID { get { return @__specialtyID; } }
internal string @Name { get { return @__name; } }
internal System.DateTime? @LastModified { get { return @__lastModified; } }
internal System.DateTime? @Created { get { return @__created; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @SpecialtyID { get { return __basicRow.@SpecialtyID; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Name { get { return __basicRow.@Name; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.DateTime? @LastModified { get { return __basicRow.@LastModified; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.DateTime? @Created { get { return __basicRow.@Created; } }
public override int GetHashCode() { 
return @SpecialtyID.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @SpecialtyID == other.@SpecialtyID && @Name == other.@Name && @LastModified == other.@LastModified && @Created == other.@Created;
}
public Modification.@SpecialtyModification ToModification() {
return Modification.@SpecialtyModification.CreateForSingleRowUpdate( @SpecialtyID, @Name, @LastModified, @Created );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "SpecialtyTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.SpecialtyTableCondition[] conditions ) {
var specialtyIDCondition = conditions.OfType<CommandConditions.@SpecialtyTableEqualityConditions.@SpecialtyID>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = specialtyIDCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( specialtyIDCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM Specialty", !isPkQuery, orderByClause: "ORDER BY SpecialtyID" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@SpecialtyID ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@SpecialtyTableEqualityConditions.@SpecialtyID( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@SpecialtyID );
}
}
/// <summary>
/// Contains logic that retrieves rows from the States table.
/// </summary>
public static partial class @StatesTableRetrieval {
internal class BasicRow {
private readonly int @__stateId;
private readonly string @__name;
private readonly string @__abbreviation;
internal BasicRow( DbDataReader reader ) {
@__stateId = (System.Int32)reader.GetValue( 0 );
@__name = (System.String)reader.GetValue( 1 );
@__abbreviation = (System.String)reader.GetValue( 2 );
}
internal int @StateId { get { return @__stateId; } }
internal string @Name { get { return @__name; } }
internal string @Abbreviation { get { return @__abbreviation; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @StateId { get { return __basicRow.@StateId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Name { get { return __basicRow.@Name; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Abbreviation { get { return __basicRow.@Abbreviation; } }
public override int GetHashCode() { 
return @StateId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @StateId == other.@StateId && @Name == other.@Name && @Abbreviation == other.@Abbreviation;
}
public Modification.@StatesModification ToModification() {
return Modification.@StatesModification.CreateForSingleRowUpdate( @StateId, @Name, @Abbreviation );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "StatesTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.StatesTableCondition[] conditions ) {
var stateIdCondition = conditions.OfType<CommandConditions.@StatesTableEqualityConditions.@StateId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = stateIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( stateIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM States", !isPkQuery, orderByClause: "ORDER BY StateId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@StateId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@StatesTableEqualityConditions.@StateId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@StateId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the sysdiagrams table.
/// </summary>
public static partial class @sysdiagramsTableRetrieval {
internal class BasicRow {
private readonly string @__name;
private readonly int @__principal_id;
private readonly int @__diagram_id;
private readonly System.Int32? @__version;
private readonly System.Byte[] @__definition;
internal BasicRow( DbDataReader reader ) {
@__name = (System.String)reader.GetValue( 0 );
@__principal_id = (System.Int32)reader.GetValue( 1 );
@__diagram_id = (System.Int32)reader.GetValue( 2 );
@__version = reader.IsDBNull( 3 ) ? (System.Int32?)null : (System.Int32)reader.GetValue( 3 );
@__definition = reader.IsDBNull( 4 ) ? (System.Byte[])null : (System.Byte[])reader.GetValue( 4 );
}
internal string @name { get { return @__name; } }
internal int @principal_id { get { return @__principal_id; } }
internal int @diagram_id { get { return @__diagram_id; } }
internal System.Int32? @version { get { return @__version; } }
internal System.Byte[] @definition { get { return @__definition; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public string @name { get { return __basicRow.@name; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @principal_id { get { return __basicRow.@principal_id; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @diagram_id { get { return __basicRow.@diagram_id; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.Int32? @version { get { return __basicRow.@version; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.Byte[] @definition { get { return __basicRow.@definition; } }
public override int GetHashCode() { 
return @name.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @name == other.@name && @principal_id == other.@principal_id && @diagram_id == other.@diagram_id && @version == other.@version;
}
public Modification.@sysdiagramsModification ToModification() {
return Modification.@sysdiagramsModification.CreateForSingleRowUpdate( @name, @principal_id, @diagram_id, @version, @definition );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "sysdiagramsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.sysdiagramsTableCondition[] conditions ) {
var diagram_idCondition = conditions.OfType<CommandConditions.@sysdiagramsTableEqualityConditions.@diagram_id>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = diagram_idCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( diagram_idCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM sysdiagrams", !isPkQuery, orderByClause: "ORDER BY diagram_id" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@diagram_id ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@sysdiagramsTableEqualityConditions.@diagram_id( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@diagram_id );
}
}
/// <summary>
/// Contains logic that retrieves rows from the TempPreDertEventLogs table.
/// </summary>
public static partial class @TempPreDertEventLogsTableRetrieval {
internal class BasicRow {
private readonly int @__tempPreDertEventLogId;
private readonly DateTime @__eventDate;
private readonly int @__administratorUserId;
private readonly int @__affectedUserId;
private readonly string @__eventCode;
private readonly string @__logMessage;
internal BasicRow( DbDataReader reader ) {
@__tempPreDertEventLogId = (System.Int32)reader.GetValue( 0 );
@__eventDate = (System.DateTime)reader.GetValue( 1 );
@__administratorUserId = (System.Int32)reader.GetValue( 2 );
@__affectedUserId = (System.Int32)reader.GetValue( 3 );
@__eventCode = (System.String)reader.GetValue( 4 );
@__logMessage = (System.String)reader.GetValue( 5 );
}
internal int @TempPreDertEventLogId { get { return @__tempPreDertEventLogId; } }
internal DateTime @EventDate { get { return @__eventDate; } }
internal int @AdministratorUserId { get { return @__administratorUserId; } }
internal int @AffectedUserId { get { return @__affectedUserId; } }
internal string @EventCode { get { return @__eventCode; } }
internal string @LogMessage { get { return @__logMessage; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @TempPreDertEventLogId { get { return __basicRow.@TempPreDertEventLogId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @EventDate { get { return __basicRow.@EventDate; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @AdministratorUserId { get { return __basicRow.@AdministratorUserId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @AffectedUserId { get { return __basicRow.@AffectedUserId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @EventCode { get { return __basicRow.@EventCode; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @LogMessage { get { return __basicRow.@LogMessage; } }
public override int GetHashCode() { 
return @TempPreDertEventLogId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @TempPreDertEventLogId == other.@TempPreDertEventLogId && @EventDate == other.@EventDate && @AdministratorUserId == other.@AdministratorUserId && @AffectedUserId == other.@AffectedUserId && @EventCode == other.@EventCode && @LogMessage == other.@LogMessage;
}
public Modification.@TempPreDertEventLogsModification ToModification() {
return Modification.@TempPreDertEventLogsModification.CreateForSingleRowUpdate( @TempPreDertEventLogId, @EventDate, @AdministratorUserId, @AffectedUserId, @EventCode, @LogMessage );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "TempPreDertEventLogsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.TempPreDertEventLogsTableCondition[] conditions ) {
var tempPreDertEventLogIdCondition = conditions.OfType<CommandConditions.@TempPreDertEventLogsTableEqualityConditions.@TempPreDertEventLogId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = tempPreDertEventLogIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( tempPreDertEventLogIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM TempPreDertEventLogs", !isPkQuery, orderByClause: "ORDER BY TempPreDertEventLogId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@TempPreDertEventLogId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@TempPreDertEventLogsTableEqualityConditions.@TempPreDertEventLogId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@TempPreDertEventLogId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the TfaMethods table.
/// </summary>
public static partial class @TfaMethodsTableRetrieval {
internal class BasicRow {
private readonly int @__tfaMethodId;
private readonly string @__method;
internal BasicRow( DbDataReader reader ) {
@__tfaMethodId = (System.Int32)reader.GetValue( 0 );
@__method = (System.String)reader.GetValue( 1 );
}
internal int @TfaMethodId { get { return @__tfaMethodId; } }
internal string @Method { get { return @__method; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @TfaMethodId { get { return __basicRow.@TfaMethodId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Method { get { return __basicRow.@Method; } }
public override int GetHashCode() { 
return @TfaMethodId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @TfaMethodId == other.@TfaMethodId && @Method == other.@Method;
}
public Modification.@TfaMethodsModification ToModification() {
return Modification.@TfaMethodsModification.CreateForSingleRowUpdate( @TfaMethodId, @Method );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "TfaMethodsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.TfaMethodsTableCondition[] conditions ) {
var tfaMethodIdCondition = conditions.OfType<CommandConditions.@TfaMethodsTableEqualityConditions.@TfaMethodId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = tfaMethodIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( tfaMethodIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM TfaMethods", !isPkQuery, orderByClause: "ORDER BY TfaMethodId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@TfaMethodId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@TfaMethodsTableEqualityConditions.@TfaMethodId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@TfaMethodId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the TrainingContent table.
/// </summary>
public static partial class @TrainingContentTableRetrieval {
internal class BasicRow {
private readonly int @__trainingContentId;
private readonly string @__text;
private readonly int @__htmlBlockId;
private readonly int @__orderRankId;
private readonly int @__trainingCourseTypeId;
internal BasicRow( DbDataReader reader ) {
@__trainingContentId = (System.Int32)reader.GetValue( 0 );
@__text = (System.String)reader.GetValue( 1 );
@__htmlBlockId = (System.Int32)reader.GetValue( 2 );
@__orderRankId = (System.Int32)reader.GetValue( 3 );
@__trainingCourseTypeId = (System.Int32)reader.GetValue( 4 );
}
internal int @TrainingContentId { get { return @__trainingContentId; } }
internal string @Text { get { return @__text; } }
internal int @HtmlBlockId { get { return @__htmlBlockId; } }
internal int @OrderRankId { get { return @__orderRankId; } }
internal int @TrainingCourseTypeId { get { return @__trainingCourseTypeId; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @TrainingContentId { get { return __basicRow.@TrainingContentId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Text { get { return __basicRow.@Text; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @HtmlBlockId { get { return __basicRow.@HtmlBlockId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @OrderRankId { get { return __basicRow.@OrderRankId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @TrainingCourseTypeId { get { return __basicRow.@TrainingCourseTypeId; } }
public override int GetHashCode() { 
return @TrainingContentId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @TrainingContentId == other.@TrainingContentId && @Text == other.@Text && @HtmlBlockId == other.@HtmlBlockId && @OrderRankId == other.@OrderRankId && @TrainingCourseTypeId == other.@TrainingCourseTypeId;
}
public Modification.@TrainingContentModification ToModification() {
return Modification.@TrainingContentModification.CreateForSingleRowUpdate( @TrainingContentId, @Text, @HtmlBlockId, @OrderRankId, @TrainingCourseTypeId );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "TrainingContentTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.TrainingContentTableCondition[] conditions ) {
var trainingContentIdCondition = conditions.OfType<CommandConditions.@TrainingContentTableEqualityConditions.@TrainingContentId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = trainingContentIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( trainingContentIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM TrainingContent", !isPkQuery, orderByClause: "ORDER BY TrainingContentId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@TrainingContentId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@TrainingContentTableEqualityConditions.@TrainingContentId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@TrainingContentId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the TrainingCourses table.
/// </summary>
public static partial class @TrainingCoursesTableRetrieval {
internal class BasicRow {
private readonly int @__trainingCourseId;
private readonly string @__name;
private readonly string @__destinationUrl;
private readonly System.Boolean @__isPerpetual;
private readonly System.Boolean @__isArchived;
private readonly int @__trainingCourseTypeId;
internal BasicRow( DbDataReader reader ) {
@__trainingCourseId = (System.Int32)reader.GetValue( 0 );
@__name = (System.String)reader.GetValue( 1 );
@__destinationUrl = (System.String)reader.GetValue( 2 );
@__isPerpetual = (System.Boolean)reader.GetValue( 3 );
@__isArchived = (System.Boolean)reader.GetValue( 4 );
@__trainingCourseTypeId = (System.Int32)reader.GetValue( 5 );
}
internal int @TrainingCourseId { get { return @__trainingCourseId; } }
internal string @Name { get { return @__name; } }
internal string @DestinationUrl { get { return @__destinationUrl; } }
internal System.Boolean @IsPerpetual { get { return @__isPerpetual; } }
internal System.Boolean @IsArchived { get { return @__isArchived; } }
internal int @TrainingCourseTypeId { get { return @__trainingCourseTypeId; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @TrainingCourseId { get { return __basicRow.@TrainingCourseId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Name { get { return __basicRow.@Name; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @DestinationUrl { get { return __basicRow.@DestinationUrl; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Boolean @IsPerpetual { get { return __basicRow.@IsPerpetual; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Boolean @IsArchived { get { return __basicRow.@IsArchived; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @TrainingCourseTypeId { get { return __basicRow.@TrainingCourseTypeId; } }
public override int GetHashCode() { 
return @TrainingCourseId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @TrainingCourseId == other.@TrainingCourseId && @Name == other.@Name && @DestinationUrl == other.@DestinationUrl && @IsPerpetual == other.@IsPerpetual && @IsArchived == other.@IsArchived && @TrainingCourseTypeId == other.@TrainingCourseTypeId;
}
public Modification.@TrainingCoursesModification ToModification() {
return Modification.@TrainingCoursesModification.CreateForSingleRowUpdate( @TrainingCourseId, @Name, @DestinationUrl, @IsPerpetual, @IsArchived, @TrainingCourseTypeId );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "TrainingCoursesTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.TrainingCoursesTableCondition[] conditions ) {
var trainingCourseIdCondition = conditions.OfType<CommandConditions.@TrainingCoursesTableEqualityConditions.@TrainingCourseId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = trainingCourseIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( trainingCourseIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM TrainingCourses", !isPkQuery, orderByClause: "ORDER BY TrainingCourseId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@TrainingCourseId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@TrainingCoursesTableEqualityConditions.@TrainingCourseId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@TrainingCourseId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the TrainingCourseTypes table.
/// </summary>
public static partial class @TrainingCourseTypesTableRetrieval {
internal class BasicRow {
private readonly int @__trainingCourseTypeId;
private readonly string @__name;
internal BasicRow( DbDataReader reader ) {
@__trainingCourseTypeId = (System.Int32)reader.GetValue( 0 );
@__name = (System.String)reader.GetValue( 1 );
}
internal int @TrainingCourseTypeId { get { return @__trainingCourseTypeId; } }
internal string @Name { get { return @__name; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @TrainingCourseTypeId { get { return __basicRow.@TrainingCourseTypeId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Name { get { return __basicRow.@Name; } }
public override int GetHashCode() { 
return @TrainingCourseTypeId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @TrainingCourseTypeId == other.@TrainingCourseTypeId && @Name == other.@Name;
}
public Modification.@TrainingCourseTypesModification ToModification() {
return Modification.@TrainingCourseTypesModification.CreateForSingleRowUpdate( @TrainingCourseTypeId, @Name );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "TrainingCourseTypesTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.TrainingCourseTypesTableCondition[] conditions ) {
var trainingCourseTypeIdCondition = conditions.OfType<CommandConditions.@TrainingCourseTypesTableEqualityConditions.@TrainingCourseTypeId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = trainingCourseTypeIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( trainingCourseTypeIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM TrainingCourseTypes", !isPkQuery, orderByClause: "ORDER BY TrainingCourseTypeId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@TrainingCourseTypeId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@TrainingCourseTypesTableEqualityConditions.@TrainingCourseTypeId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@TrainingCourseTypeId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the UserLoginLogs table.
/// </summary>
public static partial class @UserLoginLogsTableRetrieval {
internal class BasicRow {
private readonly int @__userLoginLogId;
private readonly int @__userId;
private readonly DateTime @__dateTimeUtc;
internal BasicRow( DbDataReader reader ) {
@__userLoginLogId = (System.Int32)reader.GetValue( 0 );
@__userId = (System.Int32)reader.GetValue( 1 );
@__dateTimeUtc = (System.DateTime)reader.GetValue( 2 );
}
internal int @UserLoginLogId { get { return @__userLoginLogId; } }
internal int @UserId { get { return @__userId; } }
internal DateTime @DateTimeUtc { get { return @__dateTimeUtc; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @UserLoginLogId { get { return __basicRow.@UserLoginLogId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @UserId { get { return __basicRow.@UserId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @DateTimeUtc { get { return __basicRow.@DateTimeUtc; } }
public override int GetHashCode() { 
return @UserLoginLogId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @UserLoginLogId == other.@UserLoginLogId && @UserId == other.@UserId && @DateTimeUtc == other.@DateTimeUtc;
}
public Modification.@UserLoginLogsModification ToModification() {
return Modification.@UserLoginLogsModification.CreateForSingleRowUpdate( @UserLoginLogId, @UserId, @DateTimeUtc );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "UserLoginLogsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.UserLoginLogsTableCondition[] conditions ) {
var userLoginLogIdCondition = conditions.OfType<CommandConditions.@UserLoginLogsTableEqualityConditions.@UserLoginLogId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = userLoginLogIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( userLoginLogIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM UserLoginLogs", !isPkQuery, orderByClause: "ORDER BY UserLoginLogId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@UserLoginLogId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@UserLoginLogsTableEqualityConditions.@UserLoginLogId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@UserLoginLogId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the UserLogMessages table.
/// </summary>
public static partial class @UserLogMessagesTableRetrieval {
internal class BasicRow {
private readonly int @__userLogMessageId;
private readonly System.Guid @__userId;
private readonly DateTime @__dateAndTime;
private readonly System.Byte[] @__iv;
private readonly System.Byte[] @__message;
internal BasicRow( DbDataReader reader ) {
@__userLogMessageId = (System.Int32)reader.GetValue( 0 );
@__userId = (System.Guid)reader.GetValue( 1 );
@__dateAndTime = (System.DateTime)reader.GetValue( 2 );
@__iv = (System.Byte[])reader.GetValue( 3 );
@__message = (System.Byte[])reader.GetValue( 4 );
}
internal int @UserLogMessageId { get { return @__userLogMessageId; } }
internal System.Guid @UserId { get { return @__userId; } }
internal DateTime @DateAndTime { get { return @__dateAndTime; } }
internal System.Byte[] @Iv { get { return @__iv; } }
internal System.Byte[] @Message { get { return @__message; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @UserLogMessageId { get { return __basicRow.@UserLogMessageId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Guid @UserId { get { return __basicRow.@UserId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @DateAndTime { get { return __basicRow.@DateAndTime; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @Iv { get { return __basicRow.@Iv; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @Message { get { return __basicRow.@Message; } }
public override int GetHashCode() { 
return @UserLogMessageId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @UserLogMessageId == other.@UserLogMessageId && @UserId == other.@UserId && @DateAndTime == other.@DateAndTime;
}
public Modification.@UserLogMessagesModification ToModification() {
return Modification.@UserLogMessagesModification.CreateForSingleRowUpdate( @UserLogMessageId, @UserId, @DateAndTime, @Iv, @Message );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "UserLogMessagesTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.UserLogMessagesTableCondition[] conditions ) {
var userLogMessageIdCondition = conditions.OfType<CommandConditions.@UserLogMessagesTableEqualityConditions.@UserLogMessageId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = userLogMessageIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( userLogMessageIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM UserLogMessages", !isPkQuery, orderByClause: "ORDER BY UserLogMessageId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@UserLogMessageId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@UserLogMessagesTableEqualityConditions.@UserLogMessageId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@UserLogMessageId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the Users table.
/// </summary>
public static partial class @UsersTableRetrieval {
internal class BasicRow {
private readonly int @__userId;
private readonly string @__emailAddress;
private readonly int @__roleId;
private readonly int @__salt;
private readonly System.Byte[] @__password;
private readonly System.DateTime? @__lastRequestDateTime;
private readonly System.Boolean @__mustChangePassword;
private readonly System.Boolean @__disabled;
private readonly System.Byte @__invalidPasswordAttempts;
private readonly DateTime @__lastPasswordChangeDate;
private readonly string @__firstName;
private readonly string @__lastName;
private readonly System.DateTime? @__lastAlertEmailSentDateTime;
private readonly DateTime @__createdDateTime;
private readonly string @__emailVerificationCode;
private readonly System.DateTime? @__emailVerifiedDateUtc;
private readonly System.Boolean @__deleted;
private readonly string @__random2;
internal BasicRow( DbDataReader reader ) {
@__userId = (System.Int32)reader.GetValue( 0 );
@__emailAddress = (System.String)reader.GetValue( 1 );
@__roleId = (System.Int32)reader.GetValue( 2 );
@__salt = (System.Int32)reader.GetValue( 3 );
@__password = (System.Byte[])reader.GetValue( 4 );
@__lastRequestDateTime = reader.IsDBNull( 5 ) ? (System.DateTime?)null : (System.DateTime)reader.GetValue( 5 );
@__mustChangePassword = (System.Boolean)reader.GetValue( 6 );
@__disabled = (System.Boolean)reader.GetValue( 7 );
@__invalidPasswordAttempts = (System.Byte)reader.GetValue( 8 );
@__lastPasswordChangeDate = (System.DateTime)reader.GetValue( 9 );
@__firstName = (System.String)reader.GetValue( 10 );
@__lastName = (System.String)reader.GetValue( 11 );
@__lastAlertEmailSentDateTime = reader.IsDBNull( 12 ) ? (System.DateTime?)null : (System.DateTime)reader.GetValue( 12 );
@__createdDateTime = (System.DateTime)reader.GetValue( 13 );
@__emailVerificationCode = (System.String)reader.GetValue( 14 );
@__emailVerifiedDateUtc = reader.IsDBNull( 15 ) ? (System.DateTime?)null : (System.DateTime)reader.GetValue( 15 );
@__deleted = (System.Boolean)reader.GetValue( 16 );
@__random2 = (System.String)reader.GetValue( 17 );
}
internal int @UserId { get { return @__userId; } }
internal string @EmailAddress { get { return @__emailAddress; } }
internal int @RoleId { get { return @__roleId; } }
internal int @Salt { get { return @__salt; } }
internal System.Byte[] @Password { get { return @__password; } }
internal System.DateTime? @LastRequestDateTime { get { return @__lastRequestDateTime; } }
internal System.Boolean @MustChangePassword { get { return @__mustChangePassword; } }
internal System.Boolean @Disabled { get { return @__disabled; } }
internal System.Byte @InvalidPasswordAttempts { get { return @__invalidPasswordAttempts; } }
internal DateTime @LastPasswordChangeDate { get { return @__lastPasswordChangeDate; } }
internal string @FirstName { get { return @__firstName; } }
internal string @LastName { get { return @__lastName; } }
internal System.DateTime? @LastAlertEmailSentDateTime { get { return @__lastAlertEmailSentDateTime; } }
internal DateTime @CreatedDateTime { get { return @__createdDateTime; } }
internal string @EmailVerificationCode { get { return @__emailVerificationCode; } }
internal System.DateTime? @EmailVerifiedDateUtc { get { return @__emailVerifiedDateUtc; } }
internal System.Boolean @Deleted { get { return @__deleted; } }
internal string @Random2 { get { return @__random2; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @UserId { get { return __basicRow.@UserId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @EmailAddress { get { return __basicRow.@EmailAddress; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @RoleId { get { return __basicRow.@RoleId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @Salt { get { return __basicRow.@Salt; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @Password { get { return __basicRow.@Password; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.DateTime? @LastRequestDateTime { get { return __basicRow.@LastRequestDateTime; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Boolean @MustChangePassword { get { return __basicRow.@MustChangePassword; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Boolean @Disabled { get { return __basicRow.@Disabled; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte @InvalidPasswordAttempts { get { return __basicRow.@InvalidPasswordAttempts; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @LastPasswordChangeDate { get { return __basicRow.@LastPasswordChangeDate; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @FirstName { get { return __basicRow.@FirstName; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @LastName { get { return __basicRow.@LastName; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.DateTime? @LastAlertEmailSentDateTime { get { return __basicRow.@LastAlertEmailSentDateTime; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @CreatedDateTime { get { return __basicRow.@CreatedDateTime; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @EmailVerificationCode { get { return __basicRow.@EmailVerificationCode; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.DateTime? @EmailVerifiedDateUtc { get { return __basicRow.@EmailVerifiedDateUtc; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Boolean @Deleted { get { return __basicRow.@Deleted; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Random2 { get { return __basicRow.@Random2; } }
public override int GetHashCode() { 
return @UserId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @UserId == other.@UserId && @EmailAddress == other.@EmailAddress && @RoleId == other.@RoleId && @Salt == other.@Salt && @LastRequestDateTime == other.@LastRequestDateTime && @MustChangePassword == other.@MustChangePassword && @Disabled == other.@Disabled && @InvalidPasswordAttempts == other.@InvalidPasswordAttempts && @LastPasswordChangeDate == other.@LastPasswordChangeDate && @FirstName == other.@FirstName && @LastName == other.@LastName && @LastAlertEmailSentDateTime == other.@LastAlertEmailSentDateTime && @CreatedDateTime == other.@CreatedDateTime && @EmailVerificationCode == other.@EmailVerificationCode && @EmailVerifiedDateUtc == other.@EmailVerifiedDateUtc && @Deleted == other.@Deleted && @Random2 == other.@Random2;
}
public Modification.@UsersModification ToModification() {
return Modification.@UsersModification.CreateForSingleRowUpdate( @UserId, @EmailAddress, @RoleId, @Salt, @Password, @LastRequestDateTime, @MustChangePassword, @Disabled, @InvalidPasswordAttempts, @LastPasswordChangeDate, @FirstName, @LastName, @LastAlertEmailSentDateTime, @CreatedDateTime, @EmailVerificationCode, @EmailVerifiedDateUtc, @Deleted, @Random2 );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "UsersTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.UsersTableCondition[] conditions ) {
var userIdCondition = conditions.OfType<CommandConditions.@UsersTableEqualityConditions.@UserId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = userIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( userIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM Users", !isPkQuery, orderByClause: "ORDER BY UserId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@UserId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@UsersTableEqualityConditions.@UserId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@UserId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the UsersToHiddenTrainingCourseTypes table.
/// </summary>
public static partial class @UsersToHiddenTrainingCourseTypesTableRetrieval {
internal class BasicRow {
private readonly int @__userId;
private readonly int @__trainingCourseTypeId;
internal BasicRow( DbDataReader reader ) {
@__userId = (System.Int32)reader.GetValue( 0 );
@__trainingCourseTypeId = (System.Int32)reader.GetValue( 1 );
}
internal int @UserId { get { return @__userId; } }
internal int @TrainingCourseTypeId { get { return @__trainingCourseTypeId; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @UserId { get { return __basicRow.@UserId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @TrainingCourseTypeId { get { return __basicRow.@TrainingCourseTypeId; } }
public override int GetHashCode() { 
return @UserId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @UserId == other.@UserId && @TrainingCourseTypeId == other.@TrainingCourseTypeId;
}
public Modification.@UsersToHiddenTrainingCourseTypesModification ToModification() {
return Modification.@UsersToHiddenTrainingCourseTypesModification.CreateForSingleRowUpdate( @UserId, @TrainingCourseTypeId );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "UsersToHiddenTrainingCourseTypesTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int, int>, Row> rowsByPk = new Dictionary<Tuple<int, int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int, int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.UsersToHiddenTrainingCourseTypesTableCondition[] conditions ) {
var userIdCondition = conditions.OfType<CommandConditions.@UsersToHiddenTrainingCourseTypesTableEqualityConditions.@UserId>().FirstOrDefault();
var trainingCourseTypeIdCondition = conditions.OfType<CommandConditions.@UsersToHiddenTrainingCourseTypesTableEqualityConditions.@TrainingCourseTypeId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = userIdCondition != null && trainingCourseTypeIdCondition != null && conditions.Count() == 2;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( userIdCondition.Value, trainingCourseTypeIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM UsersToHiddenTrainingCourseTypes", !isPkQuery, orderByClause: "ORDER BY UserId, TrainingCourseTypeId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@UserId, i.@TrainingCourseTypeId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingPk( int userId, int trainingCourseTypeId, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@UsersToHiddenTrainingCourseTypesTableEqualityConditions.@UserId( userId ), new CommandConditions.@UsersToHiddenTrainingCourseTypesTableEqualityConditions.@TrainingCourseTypeId( trainingCourseTypeId ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
}
/// <summary>
/// Contains logic that retrieves rows from the UsersToOrganizations table.
/// </summary>
public static partial class @UsersToOrganizationsTableRetrieval {
internal class BasicRow {
private readonly int @__usersToOrganizationId;
private readonly int @__userId;
private readonly int @__organizationId;
private readonly System.DateTime? @__startDate;
private readonly System.DateTime? @__endDate;
internal BasicRow( DbDataReader reader ) {
@__usersToOrganizationId = (System.Int32)reader.GetValue( 0 );
@__userId = (System.Int32)reader.GetValue( 1 );
@__organizationId = (System.Int32)reader.GetValue( 2 );
@__startDate = reader.IsDBNull( 3 ) ? (System.DateTime?)null : (System.DateTime)reader.GetValue( 3 );
@__endDate = reader.IsDBNull( 4 ) ? (System.DateTime?)null : (System.DateTime)reader.GetValue( 4 );
}
internal int @UsersToOrganizationId { get { return @__usersToOrganizationId; } }
internal int @UserId { get { return @__userId; } }
internal int @OrganizationId { get { return @__organizationId; } }
internal System.DateTime? @StartDate { get { return @__startDate; } }
internal System.DateTime? @EndDate { get { return @__endDate; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @UsersToOrganizationId { get { return __basicRow.@UsersToOrganizationId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @UserId { get { return __basicRow.@UserId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @OrganizationId { get { return __basicRow.@OrganizationId; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.DateTime? @StartDate { get { return __basicRow.@StartDate; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.DateTime? @EndDate { get { return __basicRow.@EndDate; } }
public override int GetHashCode() { 
return @UsersToOrganizationId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @UsersToOrganizationId == other.@UsersToOrganizationId && @UserId == other.@UserId && @OrganizationId == other.@OrganizationId && @StartDate == other.@StartDate && @EndDate == other.@EndDate;
}
public Modification.@UsersToOrganizationsModification ToModification() {
return Modification.@UsersToOrganizationsModification.CreateForSingleRowUpdate( @UsersToOrganizationId, @UserId, @OrganizationId, @StartDate, @EndDate );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "UsersToOrganizationsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.UsersToOrganizationsTableCondition[] conditions ) {
var usersToOrganizationIdCondition = conditions.OfType<CommandConditions.@UsersToOrganizationsTableEqualityConditions.@UsersToOrganizationId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = usersToOrganizationIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( usersToOrganizationIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM UsersToOrganizations", !isPkQuery, orderByClause: "ORDER BY UsersToOrganizationId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@UsersToOrganizationId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@UsersToOrganizationsTableEqualityConditions.@UsersToOrganizationId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@UsersToOrganizationId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the UsersToPasswordResetQuestions table.
/// </summary>
public static partial class @UsersToPasswordResetQuestionsTableRetrieval {
internal class BasicRow {
private readonly int @__usersToPasswordResetQuestionId;
private readonly int @__userId;
private readonly int @__passwordResetQuestionId;
private readonly System.Byte[] @__iv;
private readonly System.Byte[] @__answer;
internal BasicRow( DbDataReader reader ) {
@__usersToPasswordResetQuestionId = (System.Int32)reader.GetValue( 0 );
@__userId = (System.Int32)reader.GetValue( 1 );
@__passwordResetQuestionId = (System.Int32)reader.GetValue( 2 );
@__iv = (System.Byte[])reader.GetValue( 3 );
@__answer = (System.Byte[])reader.GetValue( 4 );
}
internal int @UsersToPasswordResetQuestionId { get { return @__usersToPasswordResetQuestionId; } }
internal int @UserId { get { return @__userId; } }
internal int @PasswordResetQuestionId { get { return @__passwordResetQuestionId; } }
internal System.Byte[] @Iv { get { return @__iv; } }
internal System.Byte[] @Answer { get { return @__answer; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @UsersToPasswordResetQuestionId { get { return __basicRow.@UsersToPasswordResetQuestionId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @UserId { get { return __basicRow.@UserId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @PasswordResetQuestionId { get { return __basicRow.@PasswordResetQuestionId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @Iv { get { return __basicRow.@Iv; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @Answer { get { return __basicRow.@Answer; } }
public override int GetHashCode() { 
return @UsersToPasswordResetQuestionId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @UsersToPasswordResetQuestionId == other.@UsersToPasswordResetQuestionId && @UserId == other.@UserId && @PasswordResetQuestionId == other.@PasswordResetQuestionId;
}
public Modification.@UsersToPasswordResetQuestionsModification ToModification() {
return Modification.@UsersToPasswordResetQuestionsModification.CreateForSingleRowUpdate( @UsersToPasswordResetQuestionId, @UserId, @PasswordResetQuestionId, @Iv, @Answer );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "UsersToPasswordResetQuestionsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.UsersToPasswordResetQuestionsTableCondition[] conditions ) {
var usersToPasswordResetQuestionIdCondition = conditions.OfType<CommandConditions.@UsersToPasswordResetQuestionsTableEqualityConditions.@UsersToPasswordResetQuestionId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = usersToPasswordResetQuestionIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( usersToPasswordResetQuestionIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM UsersToPasswordResetQuestions", !isPkQuery, orderByClause: "ORDER BY UsersToPasswordResetQuestionId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@UsersToPasswordResetQuestionId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@UsersToPasswordResetQuestionsTableEqualityConditions.@UsersToPasswordResetQuestionId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@UsersToPasswordResetQuestionId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the VhrAccessLogs table.
/// </summary>
public static partial class @VhrAccessLogsTableRetrieval {
internal class BasicRow {
private readonly int @__vhrAccessLogId;
private readonly int @__vhrProfileId;
private readonly DateTime @__dateTimeUtc;
internal BasicRow( DbDataReader reader ) {
@__vhrAccessLogId = (System.Int32)reader.GetValue( 0 );
@__vhrProfileId = (System.Int32)reader.GetValue( 1 );
@__dateTimeUtc = (System.DateTime)reader.GetValue( 2 );
}
internal int @VhrAccessLogId { get { return @__vhrAccessLogId; } }
internal int @VhrProfileId { get { return @__vhrProfileId; } }
internal DateTime @DateTimeUtc { get { return @__dateTimeUtc; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @VhrAccessLogId { get { return __basicRow.@VhrAccessLogId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @VhrProfileId { get { return __basicRow.@VhrProfileId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public DateTime @DateTimeUtc { get { return __basicRow.@DateTimeUtc; } }
public override int GetHashCode() { 
return @VhrAccessLogId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @VhrAccessLogId == other.@VhrAccessLogId && @VhrProfileId == other.@VhrProfileId && @DateTimeUtc == other.@DateTimeUtc;
}
public Modification.@VhrAccessLogsModification ToModification() {
return Modification.@VhrAccessLogsModification.CreateForSingleRowUpdate( @VhrAccessLogId, @VhrProfileId, @DateTimeUtc );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "VhrAccessLogsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.VhrAccessLogsTableCondition[] conditions ) {
var vhrAccessLogIdCondition = conditions.OfType<CommandConditions.@VhrAccessLogsTableEqualityConditions.@VhrAccessLogId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = vhrAccessLogIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( vhrAccessLogIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM VhrAccessLogs", !isPkQuery, orderByClause: "ORDER BY VhrAccessLogId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@VhrAccessLogId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@VhrAccessLogsTableEqualityConditions.@VhrAccessLogId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@VhrAccessLogId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the VhrEnvironmentConfigurations table.
/// </summary>
public static partial class @VhrEnvironmentConfigurationsTableRetrieval {
internal class BasicRow {
private readonly int @__vhrProviderId;
private readonly int @__vhrEnvironmentId;
private readonly string @__endpointUrl;
private readonly string @__ssoSiteId;
private readonly System.Byte[] @__ssoCertificate;
private readonly System.Byte[] @__ssoPassword;
private readonly System.Byte[] @__ssoIv;
private readonly System.Byte[] @__clientCertificate;
private readonly System.Byte[] @__clientPassword;
private readonly System.Byte[] @__clientIv;
private readonly string @__ssoSendingParty;
private readonly string @__redirectToUrl;
internal BasicRow( DbDataReader reader ) {
@__vhrProviderId = (System.Int32)reader.GetValue( 0 );
@__vhrEnvironmentId = (System.Int32)reader.GetValue( 1 );
@__endpointUrl = (System.String)reader.GetValue( 2 );
@__ssoSiteId = (System.String)reader.GetValue( 3 );
@__ssoCertificate = reader.IsDBNull( 4 ) ? (System.Byte[])null : (System.Byte[])reader.GetValue( 4 );
@__ssoPassword = reader.IsDBNull( 5 ) ? (System.Byte[])null : (System.Byte[])reader.GetValue( 5 );
@__ssoIv = reader.IsDBNull( 6 ) ? (System.Byte[])null : (System.Byte[])reader.GetValue( 6 );
@__clientCertificate = reader.IsDBNull( 7 ) ? (System.Byte[])null : (System.Byte[])reader.GetValue( 7 );
@__clientPassword = reader.IsDBNull( 8 ) ? (System.Byte[])null : (System.Byte[])reader.GetValue( 8 );
@__clientIv = reader.IsDBNull( 9 ) ? (System.Byte[])null : (System.Byte[])reader.GetValue( 9 );
@__ssoSendingParty = (System.String)reader.GetValue( 10 );
@__redirectToUrl = (System.String)reader.GetValue( 11 );
}
internal int @VhrProviderId { get { return @__vhrProviderId; } }
internal int @VhrEnvironmentId { get { return @__vhrEnvironmentId; } }
internal string @EndpointUrl { get { return @__endpointUrl; } }
internal string @SsoSiteId { get { return @__ssoSiteId; } }
internal System.Byte[] @SsoCertificate { get { return @__ssoCertificate; } }
internal System.Byte[] @SsoPassword { get { return @__ssoPassword; } }
internal System.Byte[] @SsoIv { get { return @__ssoIv; } }
internal System.Byte[] @ClientCertificate { get { return @__clientCertificate; } }
internal System.Byte[] @ClientPassword { get { return @__clientPassword; } }
internal System.Byte[] @ClientIv { get { return @__clientIv; } }
internal string @SsoSendingParty { get { return @__ssoSendingParty; } }
internal string @RedirectToUrl { get { return @__redirectToUrl; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @VhrProviderId { get { return __basicRow.@VhrProviderId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @VhrEnvironmentId { get { return __basicRow.@VhrEnvironmentId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @EndpointUrl { get { return __basicRow.@EndpointUrl; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @SsoSiteId { get { return __basicRow.@SsoSiteId; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.Byte[] @SsoCertificate { get { return __basicRow.@SsoCertificate; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.Byte[] @SsoPassword { get { return __basicRow.@SsoPassword; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.Byte[] @SsoIv { get { return __basicRow.@SsoIv; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.Byte[] @ClientCertificate { get { return __basicRow.@ClientCertificate; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.Byte[] @ClientPassword { get { return __basicRow.@ClientPassword; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.Byte[] @ClientIv { get { return __basicRow.@ClientIv; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @SsoSendingParty { get { return __basicRow.@SsoSendingParty; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @RedirectToUrl { get { return __basicRow.@RedirectToUrl; } }
public override int GetHashCode() { 
return @VhrProviderId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @VhrProviderId == other.@VhrProviderId && @VhrEnvironmentId == other.@VhrEnvironmentId && @EndpointUrl == other.@EndpointUrl && @SsoSiteId == other.@SsoSiteId && @SsoSendingParty == other.@SsoSendingParty && @RedirectToUrl == other.@RedirectToUrl;
}
public Modification.@VhrEnvironmentConfigurationsModification ToModification() {
return Modification.@VhrEnvironmentConfigurationsModification.CreateForSingleRowUpdate( @VhrProviderId, @VhrEnvironmentId, @EndpointUrl, @SsoSiteId, @SsoCertificate, @SsoPassword, @SsoIv, @ClientCertificate, @ClientPassword, @ClientIv, @SsoSendingParty, @RedirectToUrl );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "VhrEnvironmentConfigurationsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int, int>, Row> rowsByPk = new Dictionary<Tuple<int, int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int, int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.VhrEnvironmentConfigurationsTableCondition[] conditions ) {
var vhrProviderIdCondition = conditions.OfType<CommandConditions.@VhrEnvironmentConfigurationsTableEqualityConditions.@VhrProviderId>().FirstOrDefault();
var vhrEnvironmentIdCondition = conditions.OfType<CommandConditions.@VhrEnvironmentConfigurationsTableEqualityConditions.@VhrEnvironmentId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = vhrProviderIdCondition != null && vhrEnvironmentIdCondition != null && conditions.Count() == 2;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( vhrProviderIdCondition.Value, vhrEnvironmentIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM VhrEnvironmentConfigurations", !isPkQuery, orderByClause: "ORDER BY VhrProviderId, VhrEnvironmentId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@VhrProviderId, i.@VhrEnvironmentId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingPk( int vhrProviderId, int vhrEnvironmentId, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@VhrEnvironmentConfigurationsTableEqualityConditions.@VhrProviderId( vhrProviderId ), new CommandConditions.@VhrEnvironmentConfigurationsTableEqualityConditions.@VhrEnvironmentId( vhrEnvironmentId ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
}
/// <summary>
/// Contains logic that retrieves rows from the VhrEnvironments table.
/// </summary>
public static partial class @VhrEnvironmentsTableRetrieval {
internal class BasicRow {
private readonly int @__vhrEnvironmentId;
private readonly string @__name;
internal BasicRow( DbDataReader reader ) {
@__vhrEnvironmentId = (System.Int32)reader.GetValue( 0 );
@__name = (System.String)reader.GetValue( 1 );
}
internal int @VhrEnvironmentId { get { return @__vhrEnvironmentId; } }
internal string @Name { get { return @__name; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @VhrEnvironmentId { get { return __basicRow.@VhrEnvironmentId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Name { get { return __basicRow.@Name; } }
public override int GetHashCode() { 
return @VhrEnvironmentId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @VhrEnvironmentId == other.@VhrEnvironmentId && @Name == other.@Name;
}
public Modification.@VhrEnvironmentsModification ToModification() {
return Modification.@VhrEnvironmentsModification.CreateForSingleRowUpdate( @VhrEnvironmentId, @Name );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "VhrEnvironmentsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.VhrEnvironmentsTableCondition[] conditions ) {
var vhrEnvironmentIdCondition = conditions.OfType<CommandConditions.@VhrEnvironmentsTableEqualityConditions.@VhrEnvironmentId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = vhrEnvironmentIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( vhrEnvironmentIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM VhrEnvironments", !isPkQuery, orderByClause: "ORDER BY VhrEnvironmentId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@VhrEnvironmentId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@VhrEnvironmentsTableEqualityConditions.@VhrEnvironmentId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@VhrEnvironmentId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the VhrProfiles table.
/// </summary>
public static partial class @VhrProfilesTableRetrieval {
internal class BasicRow {
private readonly int @__vhrProfileId;
private readonly string @__vhrUserName;
private readonly string @__description;
private readonly System.Boolean @__deleted;
private readonly int @__vhrProviderId;
private readonly System.Boolean @__disabled;
private readonly int @__userId;
private readonly int @__vhrEnvironmentId;
internal BasicRow( DbDataReader reader ) {
@__vhrProfileId = (System.Int32)reader.GetValue( 0 );
@__vhrUserName = (System.String)reader.GetValue( 1 );
@__description = (System.String)reader.GetValue( 2 );
@__deleted = (System.Boolean)reader.GetValue( 3 );
@__vhrProviderId = (System.Int32)reader.GetValue( 4 );
@__disabled = (System.Boolean)reader.GetValue( 5 );
@__userId = (System.Int32)reader.GetValue( 6 );
@__vhrEnvironmentId = (System.Int32)reader.GetValue( 7 );
}
internal int @VhrProfileId { get { return @__vhrProfileId; } }
internal string @VhrUserName { get { return @__vhrUserName; } }
internal string @Description { get { return @__description; } }
internal System.Boolean @Deleted { get { return @__deleted; } }
internal int @VhrProviderId { get { return @__vhrProviderId; } }
internal System.Boolean @Disabled { get { return @__disabled; } }
internal int @UserId { get { return @__userId; } }
internal int @VhrEnvironmentId { get { return @__vhrEnvironmentId; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @VhrProfileId { get { return __basicRow.@VhrProfileId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @VhrUserName { get { return __basicRow.@VhrUserName; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Description { get { return __basicRow.@Description; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Boolean @Deleted { get { return __basicRow.@Deleted; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @VhrProviderId { get { return __basicRow.@VhrProviderId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Boolean @Disabled { get { return __basicRow.@Disabled; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @UserId { get { return __basicRow.@UserId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @VhrEnvironmentId { get { return __basicRow.@VhrEnvironmentId; } }
public override int GetHashCode() { 
return @VhrProfileId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @VhrProfileId == other.@VhrProfileId && @VhrUserName == other.@VhrUserName && @Description == other.@Description && @Deleted == other.@Deleted && @VhrProviderId == other.@VhrProviderId && @Disabled == other.@Disabled && @UserId == other.@UserId && @VhrEnvironmentId == other.@VhrEnvironmentId;
}
public Modification.@VhrProfilesModification ToModification() {
return Modification.@VhrProfilesModification.CreateForSingleRowUpdate( @VhrProfileId, @VhrUserName, @Description, @Deleted, @VhrProviderId, @Disabled, @UserId, @VhrEnvironmentId );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "VhrProfilesTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.VhrProfilesTableCondition[] conditions ) {
var vhrProfileIdCondition = conditions.OfType<CommandConditions.@VhrProfilesTableEqualityConditions.@VhrProfileId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = vhrProfileIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( vhrProfileIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM VhrProfiles", !isPkQuery, orderByClause: "ORDER BY VhrProfileId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@VhrProfileId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@VhrProfilesTableEqualityConditions.@VhrProfileId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@VhrProfileId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the VhrProviders table.
/// </summary>
public static partial class @VhrProvidersTableRetrieval {
internal class BasicRow {
private readonly int @__vhrProviderId;
private readonly string @__name;
private readonly System.Boolean @__isVhr;
private readonly System.Boolean @__archived;
internal BasicRow( DbDataReader reader ) {
@__vhrProviderId = (System.Int32)reader.GetValue( 0 );
@__name = (System.String)reader.GetValue( 1 );
@__isVhr = (System.Boolean)reader.GetValue( 2 );
@__archived = (System.Boolean)reader.GetValue( 3 );
}
internal int @VhrProviderId { get { return @__vhrProviderId; } }
internal string @Name { get { return @__name; } }
internal System.Boolean @IsVhr { get { return @__isVhr; } }
internal System.Boolean @Archived { get { return @__archived; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @VhrProviderId { get { return __basicRow.@VhrProviderId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Name { get { return __basicRow.@Name; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Boolean @IsVhr { get { return __basicRow.@IsVhr; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Boolean @Archived { get { return __basicRow.@Archived; } }
public override int GetHashCode() { 
return @VhrProviderId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @VhrProviderId == other.@VhrProviderId && @Name == other.@Name && @IsVhr == other.@IsVhr && @Archived == other.@Archived;
}
public Modification.@VhrProvidersModification ToModification() {
return Modification.@VhrProvidersModification.CreateForSingleRowUpdate( @VhrProviderId, @Name, @IsVhr, @Archived );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "VhrProvidersTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.VhrProvidersTableCondition[] conditions ) {
var vhrProviderIdCondition = conditions.OfType<CommandConditions.@VhrProvidersTableEqualityConditions.@VhrProviderId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = vhrProviderIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( vhrProviderIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM VhrProviders", !isPkQuery, orderByClause: "ORDER BY VhrProviderId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@VhrProviderId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@VhrProvidersTableEqualityConditions.@VhrProviderId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@VhrProviderId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the VitalsDataSource table.
/// </summary>
public static partial class @VitalsDataSourceTableRetrieval {
internal class BasicRow {
private readonly int @__id;
private readonly string @__name;
private readonly System.Boolean @__isAutoSyncEnabled;
private readonly System.DateTime? @__lastSyncTime;
private readonly System.Boolean @__isEnrollable;
private readonly System.Boolean @__allowsMultipleEnrollments;
private readonly int @__displayOrder;
private readonly string @__connectCredentialsFormPath;
private readonly string @__internalIdentifier;
private readonly string @__vitalsRecordOrderDescription;
internal BasicRow( DbDataReader reader ) {
@__id = (System.Int32)reader.GetValue( 0 );
@__name = (System.String)reader.GetValue( 1 );
@__isAutoSyncEnabled = (System.Boolean)reader.GetValue( 2 );
@__lastSyncTime = reader.IsDBNull( 3 ) ? (System.DateTime?)null : (System.DateTime)reader.GetValue( 3 );
@__isEnrollable = (System.Boolean)reader.GetValue( 4 );
@__allowsMultipleEnrollments = (System.Boolean)reader.GetValue( 5 );
@__displayOrder = (System.Int32)reader.GetValue( 6 );
@__connectCredentialsFormPath = (System.String)reader.GetValue( 7 );
@__internalIdentifier = (System.String)reader.GetValue( 8 );
@__vitalsRecordOrderDescription = (System.String)reader.GetValue( 9 );
}
internal int @Id { get { return @__id; } }
internal string @Name { get { return @__name; } }
internal System.Boolean @IsAutoSyncEnabled { get { return @__isAutoSyncEnabled; } }
internal System.DateTime? @LastSyncTime { get { return @__lastSyncTime; } }
internal System.Boolean @IsEnrollable { get { return @__isEnrollable; } }
internal System.Boolean @AllowsMultipleEnrollments { get { return @__allowsMultipleEnrollments; } }
internal int @DisplayOrder { get { return @__displayOrder; } }
internal string @ConnectCredentialsFormPath { get { return @__connectCredentialsFormPath; } }
internal string @InternalIdentifier { get { return @__internalIdentifier; } }
internal string @VitalsRecordOrderDescription { get { return @__vitalsRecordOrderDescription; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @Id { get { return __basicRow.@Id; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Name { get { return __basicRow.@Name; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Boolean @IsAutoSyncEnabled { get { return __basicRow.@IsAutoSyncEnabled; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.DateTime? @LastSyncTime { get { return __basicRow.@LastSyncTime; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Boolean @IsEnrollable { get { return __basicRow.@IsEnrollable; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Boolean @AllowsMultipleEnrollments { get { return __basicRow.@AllowsMultipleEnrollments; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @DisplayOrder { get { return __basicRow.@DisplayOrder; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @ConnectCredentialsFormPath { get { return __basicRow.@ConnectCredentialsFormPath; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @InternalIdentifier { get { return __basicRow.@InternalIdentifier; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @VitalsRecordOrderDescription { get { return __basicRow.@VitalsRecordOrderDescription; } }
public override int GetHashCode() { 
return @Id.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @Id == other.@Id && @Name == other.@Name && @IsAutoSyncEnabled == other.@IsAutoSyncEnabled && @LastSyncTime == other.@LastSyncTime && @IsEnrollable == other.@IsEnrollable && @AllowsMultipleEnrollments == other.@AllowsMultipleEnrollments && @DisplayOrder == other.@DisplayOrder && @ConnectCredentialsFormPath == other.@ConnectCredentialsFormPath && @InternalIdentifier == other.@InternalIdentifier && @VitalsRecordOrderDescription == other.@VitalsRecordOrderDescription;
}
public Modification.@VitalsDataSourceModification ToModification() {
return Modification.@VitalsDataSourceModification.CreateForSingleRowUpdate( @Id, @Name, @IsAutoSyncEnabled, @LastSyncTime, @IsEnrollable, @AllowsMultipleEnrollments, @DisplayOrder, @ConnectCredentialsFormPath, @InternalIdentifier, @VitalsRecordOrderDescription );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "VitalsDataSourceTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.VitalsDataSourceTableCondition[] conditions ) {
var idCondition = conditions.OfType<CommandConditions.@VitalsDataSourceTableEqualityConditions.@Id>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = idCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( idCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM VitalsDataSource", !isPkQuery, orderByClause: "ORDER BY Id" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@Id ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@VitalsDataSourceTableEqualityConditions.@Id( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@Id );
}
}
/// <summary>
/// Contains logic that retrieves rows from the VitalsEnrollment table.
/// </summary>
public static partial class @VitalsEnrollmentTableRetrieval {
internal class BasicRow {
private readonly int @__id;
private readonly int @__dataSourceId;
private readonly string @__encKV;
private readonly System.Byte[] @__encIV;
private readonly string @__patientUsername;
private readonly string @__enrollmentName;
private readonly string @__credentials;
private readonly string @__dataSourceUniqueId;
internal BasicRow( DbDataReader reader ) {
@__id = (System.Int32)reader.GetValue( 0 );
@__dataSourceId = (System.Int32)reader.GetValue( 1 );
@__encKV = (System.String)reader.GetValue( 2 );
@__encIV = (System.Byte[])reader.GetValue( 3 );
@__patientUsername = (System.String)reader.GetValue( 4 );
@__enrollmentName = (System.String)reader.GetValue( 5 );
@__credentials = (System.String)reader.GetValue( 6 );
@__dataSourceUniqueId = (System.String)reader.GetValue( 7 );
}
internal int @Id { get { return @__id; } }
internal int @DataSourceId { get { return @__dataSourceId; } }
internal string @EncKV { get { return @__encKV; } }
internal System.Byte[] @EncIV { get { return @__encIV; } }
internal string @PatientUsername { get { return @__patientUsername; } }
internal string @EnrollmentName { get { return @__enrollmentName; } }
internal string @Credentials { get { return @__credentials; } }
internal string @DataSourceUniqueId { get { return @__dataSourceUniqueId; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @Id { get { return __basicRow.@Id; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @DataSourceId { get { return __basicRow.@DataSourceId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @EncKV { get { return __basicRow.@EncKV; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Byte[] @EncIV { get { return __basicRow.@EncIV; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @PatientUsername { get { return __basicRow.@PatientUsername; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @EnrollmentName { get { return __basicRow.@EnrollmentName; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Credentials { get { return __basicRow.@Credentials; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @DataSourceUniqueId { get { return __basicRow.@DataSourceUniqueId; } }
public override int GetHashCode() { 
return @Id.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @Id == other.@Id && @DataSourceId == other.@DataSourceId && @EncKV == other.@EncKV && @PatientUsername == other.@PatientUsername && @EnrollmentName == other.@EnrollmentName && @Credentials == other.@Credentials && @DataSourceUniqueId == other.@DataSourceUniqueId;
}
public Modification.@VitalsEnrollmentModification ToModification() {
return Modification.@VitalsEnrollmentModification.CreateForSingleRowUpdate( @Id, @DataSourceId, @EncKV, @EncIV, @PatientUsername, @EnrollmentName, @Credentials, @DataSourceUniqueId );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "VitalsEnrollmentTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.VitalsEnrollmentTableCondition[] conditions ) {
var idCondition = conditions.OfType<CommandConditions.@VitalsEnrollmentTableEqualityConditions.@Id>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = idCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( idCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM VitalsEnrollment", !isPkQuery, orderByClause: "ORDER BY Id" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@Id ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@VitalsEnrollmentTableEqualityConditions.@Id( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@Id );
}
}
/// <summary>
/// Contains logic that retrieves rows from the VitalsEnrollmentEvents table.
/// </summary>
public static partial class @VitalsEnrollmentEventsTableRetrieval {
internal class BasicRow {
private readonly int @__vitalsEnrollmentEventId;
private readonly int @__vitalsDataSourceId;
private readonly System.DateTime? @__enrolledDateTime;
private readonly System.DateTime? @__unenrolledDateTime;
internal BasicRow( DbDataReader reader ) {
@__vitalsEnrollmentEventId = (System.Int32)reader.GetValue( 0 );
@__vitalsDataSourceId = (System.Int32)reader.GetValue( 1 );
@__enrolledDateTime = reader.IsDBNull( 2 ) ? (System.DateTime?)null : (System.DateTime)reader.GetValue( 2 );
@__unenrolledDateTime = reader.IsDBNull( 3 ) ? (System.DateTime?)null : (System.DateTime)reader.GetValue( 3 );
}
internal int @VitalsEnrollmentEventId { get { return @__vitalsEnrollmentEventId; } }
internal int @VitalsDataSourceId { get { return @__vitalsDataSourceId; } }
internal System.DateTime? @EnrolledDateTime { get { return @__enrolledDateTime; } }
internal System.DateTime? @UnenrolledDateTime { get { return @__unenrolledDateTime; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @VitalsEnrollmentEventId { get { return __basicRow.@VitalsEnrollmentEventId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @VitalsDataSourceId { get { return __basicRow.@VitalsDataSourceId; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.DateTime? @EnrolledDateTime { get { return __basicRow.@EnrolledDateTime; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.DateTime? @UnenrolledDateTime { get { return __basicRow.@UnenrolledDateTime; } }
public override int GetHashCode() { 
return @VitalsEnrollmentEventId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @VitalsEnrollmentEventId == other.@VitalsEnrollmentEventId && @VitalsDataSourceId == other.@VitalsDataSourceId && @EnrolledDateTime == other.@EnrolledDateTime && @UnenrolledDateTime == other.@UnenrolledDateTime;
}
public Modification.@VitalsEnrollmentEventsModification ToModification() {
return Modification.@VitalsEnrollmentEventsModification.CreateForSingleRowUpdate( @VitalsEnrollmentEventId, @VitalsDataSourceId, @EnrolledDateTime, @UnenrolledDateTime );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "VitalsEnrollmentEventsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.VitalsEnrollmentEventsTableCondition[] conditions ) {
var vitalsEnrollmentEventIdCondition = conditions.OfType<CommandConditions.@VitalsEnrollmentEventsTableEqualityConditions.@VitalsEnrollmentEventId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = vitalsEnrollmentEventIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( vitalsEnrollmentEventIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM VitalsEnrollmentEvents", !isPkQuery, orderByClause: "ORDER BY VitalsEnrollmentEventId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@VitalsEnrollmentEventId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@VitalsEnrollmentEventsTableEqualityConditions.@VitalsEnrollmentEventId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@VitalsEnrollmentEventId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the Workgroup table.
/// </summary>
public static partial class @WorkgroupTableRetrieval {
internal class BasicRow {
private readonly int @__workGroupID;
private readonly string @__name;
private readonly System.DateTime? @__lastUpdated;
private readonly System.DateTime? @__created;
private readonly System.Int32? @__healthPlanID;
private readonly int @__consentLevel;
private readonly System.Boolean @__hidden;
internal BasicRow( DbDataReader reader ) {
@__workGroupID = (System.Int32)reader.GetValue( 0 );
@__name = (System.String)reader.GetValue( 1 );
@__lastUpdated = reader.IsDBNull( 2 ) ? (System.DateTime?)null : (System.DateTime)reader.GetValue( 2 );
@__created = reader.IsDBNull( 3 ) ? (System.DateTime?)null : (System.DateTime)reader.GetValue( 3 );
@__healthPlanID = reader.IsDBNull( 4 ) ? (System.Int32?)null : (System.Int32)reader.GetValue( 4 );
@__consentLevel = (System.Int32)reader.GetValue( 5 );
@__hidden = (System.Boolean)reader.GetValue( 6 );
}
internal int @WorkGroupID { get { return @__workGroupID; } }
internal string @Name { get { return @__name; } }
internal System.DateTime? @LastUpdated { get { return @__lastUpdated; } }
internal System.DateTime? @Created { get { return @__created; } }
internal System.Int32? @HealthPlanID { get { return @__healthPlanID; } }
internal int @ConsentLevel { get { return @__consentLevel; } }
internal System.Boolean @Hidden { get { return @__hidden; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @WorkGroupID { get { return __basicRow.@WorkGroupID; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @Name { get { return __basicRow.@Name; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.DateTime? @LastUpdated { get { return __basicRow.@LastUpdated; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.DateTime? @Created { get { return __basicRow.@Created; } }
/// <summary>
/// This object will sometimes be null.
/// </summary>
public System.Int32? @HealthPlanID { get { return __basicRow.@HealthPlanID; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @ConsentLevel { get { return __basicRow.@ConsentLevel; } }
/// <summary>
/// This object will never be null.
/// </summary>
public System.Boolean @Hidden { get { return __basicRow.@Hidden; } }
public override int GetHashCode() { 
return @WorkGroupID.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @WorkGroupID == other.@WorkGroupID && @Name == other.@Name && @LastUpdated == other.@LastUpdated && @Created == other.@Created && @HealthPlanID == other.@HealthPlanID && @ConsentLevel == other.@ConsentLevel && @Hidden == other.@Hidden;
}
public Modification.@WorkgroupModification ToModification() {
return Modification.@WorkgroupModification.CreateForSingleRowUpdate( @WorkGroupID, @Name, @LastUpdated, @Created, @HealthPlanID, @ConsentLevel, @Hidden );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "WorkgroupTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.WorkgroupTableCondition[] conditions ) {
var workGroupIDCondition = conditions.OfType<CommandConditions.@WorkgroupTableEqualityConditions.@WorkGroupID>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = workGroupIDCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( workGroupIDCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM Workgroup", !isPkQuery, orderByClause: "ORDER BY WorkGroupID" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@WorkGroupID ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@WorkgroupTableEqualityConditions.@WorkGroupID( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@WorkGroupID );
}
}
/// <summary>
/// Contains logic that retrieves rows from the WorkgroupLocations table.
/// </summary>
public static partial class @WorkgroupLocationsTableRetrieval {
internal class BasicRow {
private readonly int @__workgroupLocationId;
private readonly int @__workgroupId;
private readonly string @__locationName;
internal BasicRow( DbDataReader reader ) {
@__workgroupLocationId = (System.Int32)reader.GetValue( 0 );
@__workgroupId = (System.Int32)reader.GetValue( 1 );
@__locationName = (System.String)reader.GetValue( 2 );
}
internal int @WorkgroupLocationId { get { return @__workgroupLocationId; } }
internal int @WorkgroupId { get { return @__workgroupId; } }
internal string @LocationName { get { return @__locationName; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @WorkgroupLocationId { get { return __basicRow.@WorkgroupLocationId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public int @WorkgroupId { get { return __basicRow.@WorkgroupId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @LocationName { get { return __basicRow.@LocationName; } }
public override int GetHashCode() { 
return @WorkgroupLocationId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @WorkgroupLocationId == other.@WorkgroupLocationId && @WorkgroupId == other.@WorkgroupId && @LocationName == other.@LocationName;
}
public Modification.@WorkgroupLocationsModification ToModification() {
return Modification.@WorkgroupLocationsModification.CreateForSingleRowUpdate( @WorkgroupLocationId, @WorkgroupId, @LocationName );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "WorkgroupLocationsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int>, Row> rowsByPk = new Dictionary<Tuple<int>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.WorkgroupLocationsTableCondition[] conditions ) {
var workgroupLocationIdCondition = conditions.OfType<CommandConditions.@WorkgroupLocationsTableEqualityConditions.@WorkgroupLocationId>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = workgroupLocationIdCondition != null && conditions.Count() == 1;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( workgroupLocationIdCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM WorkgroupLocations", !isPkQuery, orderByClause: "ORDER BY WorkgroupLocationId" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@WorkgroupLocationId ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingId( int id, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@WorkgroupLocationsTableEqualityConditions.@WorkgroupLocationId( id ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
public static Dictionary<int, Row> ToIdDictionary( this IEnumerable<Row> rows ) {
return rows.ToDictionary( i => i.@WorkgroupLocationId );
}
}
/// <summary>
/// Contains logic that retrieves rows from the ZipCodesToDeploymentCoordinators table.
/// </summary>
public static partial class @ZipCodesToDeploymentCoordinatorsTableRetrieval {
internal class BasicRow {
private readonly int @__userId;
private readonly string @__zipCode;
internal BasicRow( DbDataReader reader ) {
@__userId = (System.Int32)reader.GetValue( 0 );
@__zipCode = (System.String)reader.GetValue( 1 );
}
internal int @UserId { get { return @__userId; } }
internal string @ZipCode { get { return @__zipCode; } }
}
/// <summary>
/// Holds data for a row of this result.
/// </summary>
public partial class Row: IEquatable<Row> {
private readonly BasicRow __basicRow;
internal Row( BasicRow basicRow ) {
__basicRow = basicRow;
}
/// <summary>
/// This object will never be null.
/// </summary>
public int @UserId { get { return __basicRow.@UserId; } }
/// <summary>
/// This object will never be null.
/// </summary>
public string @ZipCode { get { return __basicRow.@ZipCode; } }
public override int GetHashCode() { 
return @UserId.GetHashCode();
}
public static bool operator == ( Row row1, Row row2 ) => Equals( row1, row2 );
			public static bool operator !=( Row row1, Row row2 ) => !Equals( row1, row2 );
public override bool Equals( object obj ) {
return Equals( obj as Row );
}
public bool Equals( Row other ) {
if( other == null ) return false;
return @UserId == other.@UserId && @ZipCode == other.@ZipCode;
}
public Modification.@ZipCodesToDeploymentCoordinatorsModification ToModification() {
return Modification.@ZipCodesToDeploymentCoordinatorsModification.CreateForSingleRowUpdate( @UserId, @ZipCode );
}
}
private partial class Cache {
internal static Cache Current { get { return DataAccessState.Current.GetCacheValue( "ZipCodesToDeploymentCoordinatorsTableRetrieval", () => new Cache() ); } }
private readonly TableRetrievalQueryCache<Row> queries = new TableRetrievalQueryCache<Row>();
private readonly Dictionary<Tuple<int, string>, Row> rowsByPk = new Dictionary<Tuple<int, string>, Row>();
private Cache() {}
internal TableRetrievalQueryCache<Row> Queries => queries; 
internal Dictionary<Tuple<int, string>, Row> RowsByPk => rowsByPk;
}
/// <summary>
/// Retrieves the rows from the table that match the specified conditions, ordered in a stable way.
/// </summary>
public static IEnumerable<Row> GetRows( params CommandConditions.ZipCodesToDeploymentCoordinatorsTableCondition[] conditions ) {
var userIdCondition = conditions.OfType<CommandConditions.@ZipCodesToDeploymentCoordinatorsTableEqualityConditions.@UserId>().FirstOrDefault();
var zipCodeCondition = conditions.OfType<CommandConditions.@ZipCodesToDeploymentCoordinatorsTableEqualityConditions.@ZipCode>().FirstOrDefault();
var cache = Cache.Current;
var isPkQuery = userIdCondition != null && zipCodeCondition != null && conditions.Count() == 2;
if( isPkQuery ) {
Row row;
if( cache.RowsByPk.TryGetValue( Tuple.Create( userIdCondition.Value, zipCodeCondition.Value ), out row ) )
return new [] {row};
}
return cache.Queries.GetResultSet( conditions.Select( i => i.CommandCondition ), commandConditions => {
var command = new InlineSelect( new[] { "*" }, "FROM ZipCodesToDeploymentCoordinators", !isPkQuery, orderByClause: "ORDER BY UserId, ZipCode" );
foreach( var i in commandConditions ) command.AddCondition( i );
var results = new List<Row>();
command.Execute( DataAccessState.Current.PrimaryDatabaseConnection, r => { while( r.Read() ) results.Add( new Row( new BasicRow( r ) ) ); } );
foreach( var i in results ) {
cache.RowsByPk[ System.Tuple.Create( i.@UserId, i.@ZipCode ) ] = i;
}
return results;
} );
}
public static Row GetRowMatchingPk( int userId, string zipCode, bool returnNullIfNoMatch = false ) {
var rows = GetRows( new CommandConditions.@ZipCodesToDeploymentCoordinatorsTableEqualityConditions.@UserId( userId ), new CommandConditions.@ZipCodesToDeploymentCoordinatorsTableEqualityConditions.@ZipCode( zipCode ) );
return returnNullIfNoMatch ? rows.SingleOrDefault() : rows.Single();
}
}
}

namespace ExampleNamespace.DataAccess.Modification {
public partial class @AdministratorsModification {
/// <summary>
/// Inserts a row into the Administrators table.
/// </summary>
/// <param name="administratorId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="phoneNumber">Object does not allow null.</param>
/// <param name="photoFileCollectionId">Object does not allow null.</param>
public static void InsertRow( int @administratorId, int @userId, string @phoneNumber, int @photoFileCollectionId ) { 
var mod = CreateForInsert();
mod.@administratorIdColumnValue.Value = @administratorId;
mod.@userIdColumnValue.Value = @userId;
mod.@phoneNumberColumnValue.Value = @phoneNumber;
mod.@photoFileCollectionIdColumnValue.Value = @photoFileCollectionId;
mod.Execute();
}
/// <summary>
/// Inserts a row into the Administrators table.
/// </summary>
/// <param name="administratorId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="phoneNumber">Object does not allow null.</param>
/// <param name="photoFileCollectionId">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @administratorId, int @userId, string @phoneNumber, int @photoFileCollectionId ) { 
var mod = CreateForInsert();
mod.@administratorIdColumnValue.Value = @administratorId;
mod.@userIdColumnValue.Value = @userId;
mod.@phoneNumberColumnValue.Value = @phoneNumber;
mod.@photoFileCollectionIdColumnValue.Value = @photoFileCollectionId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the Administrators table that match the specified conditions with the specified data.
/// </summary>
/// <param name="administratorId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="phoneNumber">Object does not allow null.</param>
/// <param name="photoFileCollectionId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @administratorId, int @userId, string @phoneNumber, int @photoFileCollectionId, CommandConditions.AdministratorsTableCondition requiredCondition, params CommandConditions.AdministratorsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@administratorIdColumnValue.Value = @administratorId;
mod.@userIdColumnValue.Value = @userId;
mod.@phoneNumberColumnValue.Value = @phoneNumber;
mod.@photoFileCollectionIdColumnValue.Value = @photoFileCollectionId;
mod.Execute();
}
/// <summary>
/// Updates rows in the Administrators table that match the specified conditions with the specified data.
/// </summary>
/// <param name="administratorId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="phoneNumber">Object does not allow null.</param>
/// <param name="photoFileCollectionId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @administratorId, int @userId, string @phoneNumber, int @photoFileCollectionId, CommandConditions.AdministratorsTableCondition requiredCondition, params CommandConditions.AdministratorsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@administratorIdColumnValue.Value = @administratorId;
mod.@userIdColumnValue.Value = @userId;
mod.@phoneNumberColumnValue.Value = @phoneNumber;
mod.@photoFileCollectionIdColumnValue.Value = @photoFileCollectionId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.AdministratorsTableCondition requiredCondition, params CommandConditions.AdministratorsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@AdministratorsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.AdministratorsTableCondition requiredCondition, params CommandConditions.AdministratorsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.AdministratorsTableCondition> conditions ) {
var delete = new InlineDelete( "Administrators" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.AdministratorsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@AdministratorsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.AdministratorsTableCondition> conditions;
private readonly DataValue<int> @administratorIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the AdministratorId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @AdministratorId { get { return @administratorIdColumnValue.Value; } set { @administratorIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the AdministratorId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @AdministratorIdHasChanged { get { return @administratorIdColumnValue.Changed; } }
private readonly DataValue<int> @userIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the UserId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @UserId { get { return @userIdColumnValue.Value; } set { @userIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the UserId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @UserIdHasChanged { get { return @userIdColumnValue.Changed; } }
private readonly DataValue<string> @phoneNumberColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the PhoneNumber column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @PhoneNumber { get { return @phoneNumberColumnValue.Value; } set { @phoneNumberColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PhoneNumber has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PhoneNumberHasChanged { get { return @phoneNumberColumnValue.Changed; } }
private readonly DataValue<int> @photoFileCollectionIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the PhotoFileCollectionId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @PhotoFileCollectionId { get { return @photoFileCollectionIdColumnValue.Value; } set { @photoFileCollectionIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PhotoFileCollectionId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PhotoFileCollectionIdHasChanged { get { return @photoFileCollectionIdColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the Administrators table.
/// </summary>
public static @AdministratorsModification CreateForInsert() {
return new @AdministratorsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the Administrators table.
/// </summary>
public static @AdministratorsModification CreateForUpdate( CommandConditions.AdministratorsTableCondition requiredCondition, params CommandConditions.AdministratorsTableCondition[] additionalConditions ) {
var mod = new @AdministratorsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@AdministratorsTableEqualityConditions.@AdministratorId )
mod.@administratorIdColumnValue.Value = ( condition as CommandConditions.@AdministratorsTableEqualityConditions.@AdministratorId ).Value;
else if( condition is CommandConditions.@AdministratorsTableEqualityConditions.@UserId )
mod.@userIdColumnValue.Value = ( condition as CommandConditions.@AdministratorsTableEqualityConditions.@UserId ).Value;
else if( condition is CommandConditions.@AdministratorsTableEqualityConditions.@PhoneNumber )
mod.@phoneNumberColumnValue.Value = ( condition as CommandConditions.@AdministratorsTableEqualityConditions.@PhoneNumber ).Value;
else if( condition is CommandConditions.@AdministratorsTableEqualityConditions.@PhotoFileCollectionId )
mod.@photoFileCollectionIdColumnValue.Value = ( condition as CommandConditions.@AdministratorsTableEqualityConditions.@PhotoFileCollectionId ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the Administrators table.
/// </summary>
public static @AdministratorsModification CreateForSingleRowUpdate( int @administratorId, int @userId, string @phoneNumber, int @photoFileCollectionId ) {
var mod = new @AdministratorsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.AdministratorsTableCondition>();
mod.conditions.Add( new CommandConditions.@AdministratorsTableEqualityConditions.@AdministratorId( @administratorId ) );
mod.@administratorIdColumnValue.Value = @administratorId;
mod.@userIdColumnValue.Value = @userId;
mod.@phoneNumberColumnValue.Value = @phoneNumber;
mod.@photoFileCollectionIdColumnValue.Value = @photoFileCollectionId;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.AdministratorsTableCondition> getConditionList( CommandConditions.AdministratorsTableCondition requiredCondition, params CommandConditions.AdministratorsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.AdministratorsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @AdministratorsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="administratorId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="phoneNumber">Object does not allow null.</param>
/// <param name="photoFileCollectionId">Object does not allow null.</param>
public void SetAllData( int @administratorId, int @userId, string @phoneNumber, int @photoFileCollectionId ) {
this.@administratorIdColumnValue.Value = @administratorId;
this.@userIdColumnValue.Value = @userId;
this.@phoneNumberColumnValue.Value = @phoneNumber;
this.@photoFileCollectionIdColumnValue.Value = @photoFileCollectionId;
}
/// <summary>
/// Executes this Administrators modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this Administrators modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "Administrators" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.AdministratorsTableCondition>();
conditions.Add( new CommandConditions.@AdministratorsTableEqualityConditions.@AdministratorId( @AdministratorId ) );
}
else {
var update = new InlineUpdate( "Administrators" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @administratorIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "AdministratorId", new DbParameterValue( @AdministratorId, "Int" ) ) );
if( @userIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( @UserId, "Int" ) ) );
if( @phoneNumberColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PhoneNumber", new DbParameterValue( @PhoneNumber, "VarChar" ) ) );
if( @photoFileCollectionIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PhotoFileCollectionId", new DbParameterValue( @PhotoFileCollectionId, "Int" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@administratorIdColumnValue.ClearChanged();
@userIdColumnValue.ClearChanged();
@phoneNumberColumnValue.ClearChanged();
@photoFileCollectionIdColumnValue.ClearChanged();
}
}
public partial class @AdvancedDirectivesHistoryModification {
/// <summary>
/// Inserts a row into the AdvancedDirectivesHistory table.
/// </summary>
/// <param name="advancedDirectivesHistoryId">Object does not allow null.</param>
/// <param name="dateAndTime">Object does not allow null.</param>
/// <param name="iv">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
public static void InsertRow( int @advancedDirectivesHistoryId, DateTime @dateAndTime, System.Byte[] @iv, System.Byte[] @userId ) { 
var mod = CreateForInsert();
mod.@advancedDirectivesHistoryIdColumnValue.Value = @advancedDirectivesHistoryId;
mod.@dateAndTimeColumnValue.Value = @dateAndTime;
mod.@ivColumnValue.Value = @iv;
mod.@userIdColumnValue.Value = @userId;
mod.Execute();
}
/// <summary>
/// Inserts a row into the AdvancedDirectivesHistory table.
/// </summary>
/// <param name="advancedDirectivesHistoryId">Object does not allow null.</param>
/// <param name="dateAndTime">Object does not allow null.</param>
/// <param name="iv">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @advancedDirectivesHistoryId, DateTime @dateAndTime, System.Byte[] @iv, System.Byte[] @userId ) { 
var mod = CreateForInsert();
mod.@advancedDirectivesHistoryIdColumnValue.Value = @advancedDirectivesHistoryId;
mod.@dateAndTimeColumnValue.Value = @dateAndTime;
mod.@ivColumnValue.Value = @iv;
mod.@userIdColumnValue.Value = @userId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the AdvancedDirectivesHistory table that match the specified conditions with the specified data.
/// </summary>
/// <param name="advancedDirectivesHistoryId">Object does not allow null.</param>
/// <param name="dateAndTime">Object does not allow null.</param>
/// <param name="iv">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @advancedDirectivesHistoryId, DateTime @dateAndTime, System.Byte[] @iv, System.Byte[] @userId, CommandConditions.AdvancedDirectivesHistoryTableCondition requiredCondition, params CommandConditions.AdvancedDirectivesHistoryTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@advancedDirectivesHistoryIdColumnValue.Value = @advancedDirectivesHistoryId;
mod.@dateAndTimeColumnValue.Value = @dateAndTime;
mod.@ivColumnValue.Value = @iv;
mod.@userIdColumnValue.Value = @userId;
mod.Execute();
}
/// <summary>
/// Updates rows in the AdvancedDirectivesHistory table that match the specified conditions with the specified data.
/// </summary>
/// <param name="advancedDirectivesHistoryId">Object does not allow null.</param>
/// <param name="dateAndTime">Object does not allow null.</param>
/// <param name="iv">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @advancedDirectivesHistoryId, DateTime @dateAndTime, System.Byte[] @iv, System.Byte[] @userId, CommandConditions.AdvancedDirectivesHistoryTableCondition requiredCondition, params CommandConditions.AdvancedDirectivesHistoryTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@advancedDirectivesHistoryIdColumnValue.Value = @advancedDirectivesHistoryId;
mod.@dateAndTimeColumnValue.Value = @dateAndTime;
mod.@ivColumnValue.Value = @iv;
mod.@userIdColumnValue.Value = @userId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.AdvancedDirectivesHistoryTableCondition requiredCondition, params CommandConditions.AdvancedDirectivesHistoryTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@AdvancedDirectivesHistoryTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.AdvancedDirectivesHistoryTableCondition requiredCondition, params CommandConditions.AdvancedDirectivesHistoryTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.AdvancedDirectivesHistoryTableCondition> conditions ) {
var delete = new InlineDelete( "AdvancedDirectivesHistory" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.AdvancedDirectivesHistoryTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@AdvancedDirectivesHistoryTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.AdvancedDirectivesHistoryTableCondition> conditions;
private readonly DataValue<int> @advancedDirectivesHistoryIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the AdvancedDirectivesHistoryId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @AdvancedDirectivesHistoryId { get { return @advancedDirectivesHistoryIdColumnValue.Value; } set { @advancedDirectivesHistoryIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the AdvancedDirectivesHistoryId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @AdvancedDirectivesHistoryIdHasChanged { get { return @advancedDirectivesHistoryIdColumnValue.Changed; } }
private readonly DataValue<DateTime> @dateAndTimeColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the DateAndTime column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @DateAndTime { get { return @dateAndTimeColumnValue.Value; } set { @dateAndTimeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the DateAndTime has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @DateAndTimeHasChanged { get { return @dateAndTimeColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @ivColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the Iv column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @Iv { get { return @ivColumnValue.Value; } set { @ivColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Iv has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @IvHasChanged { get { return @ivColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @userIdColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the UserId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @UserId { get { return @userIdColumnValue.Value; } set { @userIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the UserId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @UserIdHasChanged { get { return @userIdColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the AdvancedDirectivesHistory table.
/// </summary>
public static @AdvancedDirectivesHistoryModification CreateForInsert() {
return new @AdvancedDirectivesHistoryModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the AdvancedDirectivesHistory table.
/// </summary>
public static @AdvancedDirectivesHistoryModification CreateForUpdate( CommandConditions.AdvancedDirectivesHistoryTableCondition requiredCondition, params CommandConditions.AdvancedDirectivesHistoryTableCondition[] additionalConditions ) {
var mod = new @AdvancedDirectivesHistoryModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@AdvancedDirectivesHistoryTableEqualityConditions.@AdvancedDirectivesHistoryId )
mod.@advancedDirectivesHistoryIdColumnValue.Value = ( condition as CommandConditions.@AdvancedDirectivesHistoryTableEqualityConditions.@AdvancedDirectivesHistoryId ).Value;
else if( condition is CommandConditions.@AdvancedDirectivesHistoryTableEqualityConditions.@DateAndTime )
mod.@dateAndTimeColumnValue.Value = ( condition as CommandConditions.@AdvancedDirectivesHistoryTableEqualityConditions.@DateAndTime ).Value;
else if( condition is CommandConditions.@AdvancedDirectivesHistoryTableEqualityConditions.@Iv )
mod.@ivColumnValue.Value = ( condition as CommandConditions.@AdvancedDirectivesHistoryTableEqualityConditions.@Iv ).Value;
else if( condition is CommandConditions.@AdvancedDirectivesHistoryTableEqualityConditions.@UserId )
mod.@userIdColumnValue.Value = ( condition as CommandConditions.@AdvancedDirectivesHistoryTableEqualityConditions.@UserId ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the AdvancedDirectivesHistory table.
/// </summary>
public static @AdvancedDirectivesHistoryModification CreateForSingleRowUpdate( int @advancedDirectivesHistoryId, DateTime @dateAndTime, System.Byte[] @iv, System.Byte[] @userId ) {
var mod = new @AdvancedDirectivesHistoryModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.AdvancedDirectivesHistoryTableCondition>();
mod.conditions.Add( new CommandConditions.@AdvancedDirectivesHistoryTableEqualityConditions.@AdvancedDirectivesHistoryId( @advancedDirectivesHistoryId ) );
mod.@advancedDirectivesHistoryIdColumnValue.Value = @advancedDirectivesHistoryId;
mod.@dateAndTimeColumnValue.Value = @dateAndTime;
mod.@ivColumnValue.Value = @iv;
mod.@userIdColumnValue.Value = @userId;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.AdvancedDirectivesHistoryTableCondition> getConditionList( CommandConditions.AdvancedDirectivesHistoryTableCondition requiredCondition, params CommandConditions.AdvancedDirectivesHistoryTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.AdvancedDirectivesHistoryTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @AdvancedDirectivesHistoryModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="advancedDirectivesHistoryId">Object does not allow null.</param>
/// <param name="dateAndTime">Object does not allow null.</param>
/// <param name="iv">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
public void SetAllData( int @advancedDirectivesHistoryId, DateTime @dateAndTime, System.Byte[] @iv, System.Byte[] @userId ) {
this.@advancedDirectivesHistoryIdColumnValue.Value = @advancedDirectivesHistoryId;
this.@dateAndTimeColumnValue.Value = @dateAndTime;
this.@ivColumnValue.Value = @iv;
this.@userIdColumnValue.Value = @userId;
}
/// <summary>
/// Executes this AdvancedDirectivesHistory modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this AdvancedDirectivesHistory modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "AdvancedDirectivesHistory" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.AdvancedDirectivesHistoryTableCondition>();
conditions.Add( new CommandConditions.@AdvancedDirectivesHistoryTableEqualityConditions.@AdvancedDirectivesHistoryId( @AdvancedDirectivesHistoryId ) );
}
else {
var update = new InlineUpdate( "AdvancedDirectivesHistory" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @advancedDirectivesHistoryIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "AdvancedDirectivesHistoryId", new DbParameterValue( @AdvancedDirectivesHistoryId, "Int" ) ) );
if( @dateAndTimeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "DateAndTime", new DbParameterValue( @DateAndTime, "DateTime2" ) ) );
if( @ivColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Iv", new DbParameterValue( @Iv, "Binary" ) ) );
if( @userIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( @UserId, "Binary" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@advancedDirectivesHistoryIdColumnValue.ClearChanged();
@dateAndTimeColumnValue.ClearChanged();
@ivColumnValue.ClearChanged();
@userIdColumnValue.ClearChanged();
}
}
public partial class @AppContentModification {
/// <summary>
/// Inserts a row into the AppContent table.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="value">Object does not allow null.</param>
/// <param name="instructions">Object does not allow null.</param>
/// <param name="showInGeneralList">Object does not allow null.</param>
public static void InsertRow( string @name, string @value, string @instructions, System.Boolean @showInGeneralList ) { 
var mod = CreateForInsert();
mod.@nameColumnValue.Value = @name;
mod.@valueColumnValue.Value = @value;
mod.@instructionsColumnValue.Value = @instructions;
mod.@showInGeneralListColumnValue.Value = @showInGeneralList;
mod.Execute();
}
/// <summary>
/// Inserts a row into the AppContent table.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="value">Object does not allow null.</param>
/// <param name="instructions">Object does not allow null.</param>
/// <param name="showInGeneralList">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( string @name, string @value, string @instructions, System.Boolean @showInGeneralList ) { 
var mod = CreateForInsert();
mod.@nameColumnValue.Value = @name;
mod.@valueColumnValue.Value = @value;
mod.@instructionsColumnValue.Value = @instructions;
mod.@showInGeneralListColumnValue.Value = @showInGeneralList;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the AppContent table that match the specified conditions with the specified data.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="value">Object does not allow null.</param>
/// <param name="instructions">Object does not allow null.</param>
/// <param name="showInGeneralList">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( string @name, string @value, string @instructions, System.Boolean @showInGeneralList, CommandConditions.AppContentTableCondition requiredCondition, params CommandConditions.AppContentTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@nameColumnValue.Value = @name;
mod.@valueColumnValue.Value = @value;
mod.@instructionsColumnValue.Value = @instructions;
mod.@showInGeneralListColumnValue.Value = @showInGeneralList;
mod.Execute();
}
/// <summary>
/// Updates rows in the AppContent table that match the specified conditions with the specified data.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="value">Object does not allow null.</param>
/// <param name="instructions">Object does not allow null.</param>
/// <param name="showInGeneralList">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( string @name, string @value, string @instructions, System.Boolean @showInGeneralList, CommandConditions.AppContentTableCondition requiredCondition, params CommandConditions.AppContentTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@nameColumnValue.Value = @name;
mod.@valueColumnValue.Value = @value;
mod.@instructionsColumnValue.Value = @instructions;
mod.@showInGeneralListColumnValue.Value = @showInGeneralList;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.AppContentTableCondition requiredCondition, params CommandConditions.AppContentTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@AppContentTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.AppContentTableCondition requiredCondition, params CommandConditions.AppContentTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.AppContentTableCondition> conditions ) {
var delete = new InlineDelete( "AppContent" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.AppContentTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@AppContentTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.AppContentTableCondition> conditions;
private readonly DataValue<string> @nameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Name column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Name { get { return @nameColumnValue.Value; } set { @nameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Name has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @NameHasChanged { get { return @nameColumnValue.Changed; } }
private readonly DataValue<string> @valueColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Value column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Value { get { return @valueColumnValue.Value; } set { @valueColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Value has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ValueHasChanged { get { return @valueColumnValue.Changed; } }
private readonly DataValue<string> @instructionsColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Instructions column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Instructions { get { return @instructionsColumnValue.Value; } set { @instructionsColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Instructions has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @InstructionsHasChanged { get { return @instructionsColumnValue.Changed; } }
private readonly DataValue<System.Boolean> @showInGeneralListColumnValue = new DataValue<System.Boolean>();
/// <summary>
/// Gets or sets the value for the ShowInGeneralList column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Boolean @ShowInGeneralList { get { return @showInGeneralListColumnValue.Value; } set { @showInGeneralListColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ShowInGeneralList has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ShowInGeneralListHasChanged { get { return @showInGeneralListColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the AppContent table.
/// </summary>
public static @AppContentModification CreateForInsert() {
return new @AppContentModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the AppContent table.
/// </summary>
public static @AppContentModification CreateForUpdate( CommandConditions.AppContentTableCondition requiredCondition, params CommandConditions.AppContentTableCondition[] additionalConditions ) {
var mod = new @AppContentModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@AppContentTableEqualityConditions.@Name )
mod.@nameColumnValue.Value = ( condition as CommandConditions.@AppContentTableEqualityConditions.@Name ).Value;
else if( condition is CommandConditions.@AppContentTableEqualityConditions.@_Value )
mod.@valueColumnValue.Value = ( condition as CommandConditions.@AppContentTableEqualityConditions.@_Value ).Value;
else if( condition is CommandConditions.@AppContentTableEqualityConditions.@Instructions )
mod.@instructionsColumnValue.Value = ( condition as CommandConditions.@AppContentTableEqualityConditions.@Instructions ).Value;
else if( condition is CommandConditions.@AppContentTableEqualityConditions.@ShowInGeneralList )
mod.@showInGeneralListColumnValue.Value = ( condition as CommandConditions.@AppContentTableEqualityConditions.@ShowInGeneralList ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the AppContent table.
/// </summary>
public static @AppContentModification CreateForSingleRowUpdate( string @name, string @value, string @instructions, System.Boolean @showInGeneralList ) {
var mod = new @AppContentModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.AppContentTableCondition>();
mod.conditions.Add( new CommandConditions.@AppContentTableEqualityConditions.@Name( @name ) );
mod.@nameColumnValue.Value = @name;
mod.@valueColumnValue.Value = @value;
mod.@instructionsColumnValue.Value = @instructions;
mod.@showInGeneralListColumnValue.Value = @showInGeneralList;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.AppContentTableCondition> getConditionList( CommandConditions.AppContentTableCondition requiredCondition, params CommandConditions.AppContentTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.AppContentTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @AppContentModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="value">Object does not allow null.</param>
/// <param name="instructions">Object does not allow null.</param>
/// <param name="showInGeneralList">Object does not allow null.</param>
public void SetAllData( string @name, string @value, string @instructions, System.Boolean @showInGeneralList ) {
this.@nameColumnValue.Value = @name;
this.@valueColumnValue.Value = @value;
this.@instructionsColumnValue.Value = @instructions;
this.@showInGeneralListColumnValue.Value = @showInGeneralList;
}
/// <summary>
/// Executes this AppContent modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this AppContent modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "AppContent" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.AppContentTableCondition>();
conditions.Add( new CommandConditions.@AppContentTableEqualityConditions.@Name( @Name ) );
}
else {
var update = new InlineUpdate( "AppContent" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @nameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Name", new DbParameterValue( @Name, "NVarChar" ) ) );
if( @valueColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Value", new DbParameterValue( @Value, "NVarChar" ) ) );
if( @instructionsColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Instructions", new DbParameterValue( @Instructions, "NVarChar" ) ) );
if( @showInGeneralListColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ShowInGeneralList", new DbParameterValue( @ShowInGeneralList, "Bit" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@nameColumnValue.ClearChanged();
@valueColumnValue.ClearChanged();
@instructionsColumnValue.ClearChanged();
@showInGeneralListColumnValue.ClearChanged();
}
}
public partial class @AppEnumsModification {
/// <summary>
/// Inserts a row into the AppEnums table.
/// </summary>
/// <param name="category">Object does not allow null.</param>
/// <param name="paramName">Object does not allow null.</param>
/// <param name="paramValue">Object allows null.</param>
public static void InsertRow( string @category, string @paramName, System.Int32? @paramValue ) { 
var mod = CreateForInsert();
mod.@categoryColumnValue.Value = @category;
mod.@paramNameColumnValue.Value = @paramName;
mod.@paramValueColumnValue.Value = @paramValue;
mod.Execute();
}
/// <summary>
/// Inserts a row into the AppEnums table.
/// </summary>
/// <param name="category">Object does not allow null.</param>
/// <param name="paramName">Object does not allow null.</param>
/// <param name="paramValue">Object allows null.</param>
public static void InsertRowWithoutAdditionalLogic( string @category, string @paramName, System.Int32? @paramValue ) { 
var mod = CreateForInsert();
mod.@categoryColumnValue.Value = @category;
mod.@paramNameColumnValue.Value = @paramName;
mod.@paramValueColumnValue.Value = @paramValue;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the AppEnums table that match the specified conditions with the specified data.
/// </summary>
/// <param name="category">Object does not allow null.</param>
/// <param name="paramName">Object does not allow null.</param>
/// <param name="paramValue">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( string @category, string @paramName, System.Int32? @paramValue, CommandConditions.AppEnumsTableCondition requiredCondition, params CommandConditions.AppEnumsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@categoryColumnValue.Value = @category;
mod.@paramNameColumnValue.Value = @paramName;
mod.@paramValueColumnValue.Value = @paramValue;
mod.Execute();
}
/// <summary>
/// Updates rows in the AppEnums table that match the specified conditions with the specified data.
/// </summary>
/// <param name="category">Object does not allow null.</param>
/// <param name="paramName">Object does not allow null.</param>
/// <param name="paramValue">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( string @category, string @paramName, System.Int32? @paramValue, CommandConditions.AppEnumsTableCondition requiredCondition, params CommandConditions.AppEnumsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@categoryColumnValue.Value = @category;
mod.@paramNameColumnValue.Value = @paramName;
mod.@paramValueColumnValue.Value = @paramValue;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.AppEnumsTableCondition requiredCondition, params CommandConditions.AppEnumsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@AppEnumsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.AppEnumsTableCondition requiredCondition, params CommandConditions.AppEnumsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.AppEnumsTableCondition> conditions ) {
var delete = new InlineDelete( "AppEnums" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.AppEnumsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@AppEnumsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.AppEnumsTableCondition> conditions;
private readonly DataValue<string> @categoryColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Category column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Category { get { return @categoryColumnValue.Value; } set { @categoryColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Category has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @CategoryHasChanged { get { return @categoryColumnValue.Changed; } }
private readonly DataValue<string> @paramNameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the ParamName column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @ParamName { get { return @paramNameColumnValue.Value; } set { @paramNameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ParamName has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ParamNameHasChanged { get { return @paramNameColumnValue.Changed; } }
private readonly DataValue<System.Int32?> @paramValueColumnValue = new DataValue<System.Int32?>();
/// <summary>
/// Gets or sets the value for the ParamValue column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.Int32? @ParamValue { get { return @paramValueColumnValue.Value; } set { @paramValueColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ParamValue has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ParamValueHasChanged { get { return @paramValueColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the AppEnums table.
/// </summary>
public static @AppEnumsModification CreateForInsert() {
return new @AppEnumsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the AppEnums table.
/// </summary>
public static @AppEnumsModification CreateForUpdate( CommandConditions.AppEnumsTableCondition requiredCondition, params CommandConditions.AppEnumsTableCondition[] additionalConditions ) {
var mod = new @AppEnumsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@AppEnumsTableEqualityConditions.@Category )
mod.@categoryColumnValue.Value = ( condition as CommandConditions.@AppEnumsTableEqualityConditions.@Category ).Value;
else if( condition is CommandConditions.@AppEnumsTableEqualityConditions.@ParamName )
mod.@paramNameColumnValue.Value = ( condition as CommandConditions.@AppEnumsTableEqualityConditions.@ParamName ).Value;
else if( condition is CommandConditions.@AppEnumsTableEqualityConditions.@ParamValue )
mod.@paramValueColumnValue.Value = ( condition as CommandConditions.@AppEnumsTableEqualityConditions.@ParamValue ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the AppEnums table.
/// </summary>
public static @AppEnumsModification CreateForSingleRowUpdate( string @category, string @paramName, System.Int32? @paramValue ) {
var mod = new @AppEnumsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.AppEnumsTableCondition>();
mod.conditions.Add( new CommandConditions.@AppEnumsTableEqualityConditions.@Category( @category ) );
mod.conditions.Add( new CommandConditions.@AppEnumsTableEqualityConditions.@ParamName( @paramName ) );
mod.@categoryColumnValue.Value = @category;
mod.@paramNameColumnValue.Value = @paramName;
mod.@paramValueColumnValue.Value = @paramValue;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.AppEnumsTableCondition> getConditionList( CommandConditions.AppEnumsTableCondition requiredCondition, params CommandConditions.AppEnumsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.AppEnumsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @AppEnumsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="category">Object does not allow null.</param>
/// <param name="paramName">Object does not allow null.</param>
/// <param name="paramValue">Object allows null.</param>
public void SetAllData( string @category, string @paramName, System.Int32? @paramValue ) {
this.@categoryColumnValue.Value = @category;
this.@paramNameColumnValue.Value = @paramName;
this.@paramValueColumnValue.Value = @paramValue;
}
/// <summary>
/// Executes this AppEnums modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this AppEnums modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "AppEnums" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.AppEnumsTableCondition>();
conditions.Add( new CommandConditions.@AppEnumsTableEqualityConditions.@Category( @Category ) );
conditions.Add( new CommandConditions.@AppEnumsTableEqualityConditions.@ParamName( @ParamName ) );
}
else {
var update = new InlineUpdate( "AppEnums" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @categoryColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Category", new DbParameterValue( @Category, "NVarChar" ) ) );
if( @paramNameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ParamName", new DbParameterValue( @ParamName, "NVarChar" ) ) );
if( @paramValueColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ParamValue", new DbParameterValue( @ParamValue, "Int" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@categoryColumnValue.ClearChanged();
@paramNameColumnValue.ClearChanged();
@paramValueColumnValue.ClearChanged();
}
}
public partial class @aspnet_ApplicationsModification {
/// <summary>
/// Inserts a row into the aspnet_Applications table.
/// </summary>
/// <param name="applicationName">Object does not allow null.</param>
/// <param name="loweredApplicationName">Object does not allow null.</param>
/// <param name="applicationId">Object does not allow null.</param>
/// <param name="description">Object allows null.</param>
public static void InsertRow( string @applicationName, string @loweredApplicationName, System.Guid @applicationId, System.String @description ) { 
var mod = CreateForInsert();
mod.@applicationNameColumnValue.Value = @applicationName;
mod.@loweredApplicationNameColumnValue.Value = @loweredApplicationName;
mod.@applicationIdColumnValue.Value = @applicationId;
mod.@descriptionColumnValue.Value = @description;
mod.Execute();
}
/// <summary>
/// Inserts a row into the aspnet_Applications table.
/// </summary>
/// <param name="applicationName">Object does not allow null.</param>
/// <param name="loweredApplicationName">Object does not allow null.</param>
/// <param name="applicationId">Object does not allow null.</param>
/// <param name="description">Object allows null.</param>
public static void InsertRowWithoutAdditionalLogic( string @applicationName, string @loweredApplicationName, System.Guid @applicationId, System.String @description ) { 
var mod = CreateForInsert();
mod.@applicationNameColumnValue.Value = @applicationName;
mod.@loweredApplicationNameColumnValue.Value = @loweredApplicationName;
mod.@applicationIdColumnValue.Value = @applicationId;
mod.@descriptionColumnValue.Value = @description;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the aspnet_Applications table that match the specified conditions with the specified data.
/// </summary>
/// <param name="applicationName">Object does not allow null.</param>
/// <param name="loweredApplicationName">Object does not allow null.</param>
/// <param name="applicationId">Object does not allow null.</param>
/// <param name="description">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( string @applicationName, string @loweredApplicationName, System.Guid @applicationId, System.String @description, CommandConditions.aspnet_ApplicationsTableCondition requiredCondition, params CommandConditions.aspnet_ApplicationsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@applicationNameColumnValue.Value = @applicationName;
mod.@loweredApplicationNameColumnValue.Value = @loweredApplicationName;
mod.@applicationIdColumnValue.Value = @applicationId;
mod.@descriptionColumnValue.Value = @description;
mod.Execute();
}
/// <summary>
/// Updates rows in the aspnet_Applications table that match the specified conditions with the specified data.
/// </summary>
/// <param name="applicationName">Object does not allow null.</param>
/// <param name="loweredApplicationName">Object does not allow null.</param>
/// <param name="applicationId">Object does not allow null.</param>
/// <param name="description">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( string @applicationName, string @loweredApplicationName, System.Guid @applicationId, System.String @description, CommandConditions.aspnet_ApplicationsTableCondition requiredCondition, params CommandConditions.aspnet_ApplicationsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@applicationNameColumnValue.Value = @applicationName;
mod.@loweredApplicationNameColumnValue.Value = @loweredApplicationName;
mod.@applicationIdColumnValue.Value = @applicationId;
mod.@descriptionColumnValue.Value = @description;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.aspnet_ApplicationsTableCondition requiredCondition, params CommandConditions.aspnet_ApplicationsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@aspnet_ApplicationsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.aspnet_ApplicationsTableCondition requiredCondition, params CommandConditions.aspnet_ApplicationsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.aspnet_ApplicationsTableCondition> conditions ) {
var delete = new InlineDelete( "aspnet_Applications" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.aspnet_ApplicationsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@aspnet_ApplicationsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.aspnet_ApplicationsTableCondition> conditions;
private readonly DataValue<string> @applicationNameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the ApplicationName column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @ApplicationName { get { return @applicationNameColumnValue.Value; } set { @applicationNameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ApplicationName has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ApplicationNameHasChanged { get { return @applicationNameColumnValue.Changed; } }
private readonly DataValue<string> @loweredApplicationNameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the LoweredApplicationName column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @LoweredApplicationName { get { return @loweredApplicationNameColumnValue.Value; } set { @loweredApplicationNameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LoweredApplicationName has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LoweredApplicationNameHasChanged { get { return @loweredApplicationNameColumnValue.Changed; } }
private readonly DataValue<System.Guid> @applicationIdColumnValue = new DataValue<System.Guid>();
/// <summary>
/// Gets or sets the value for the ApplicationId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Guid @ApplicationId { get { return @applicationIdColumnValue.Value; } set { @applicationIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ApplicationId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ApplicationIdHasChanged { get { return @applicationIdColumnValue.Changed; } }
private readonly DataValue<System.String> @descriptionColumnValue = new DataValue<System.String>();
/// <summary>
/// Gets or sets the value for the Description column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.String @Description { get { return @descriptionColumnValue.Value; } set { @descriptionColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Description has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @DescriptionHasChanged { get { return @descriptionColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the aspnet_Applications table.
/// </summary>
public static @aspnet_ApplicationsModification CreateForInsert() {
return new @aspnet_ApplicationsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the aspnet_Applications table.
/// </summary>
public static @aspnet_ApplicationsModification CreateForUpdate( CommandConditions.aspnet_ApplicationsTableCondition requiredCondition, params CommandConditions.aspnet_ApplicationsTableCondition[] additionalConditions ) {
var mod = new @aspnet_ApplicationsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@aspnet_ApplicationsTableEqualityConditions.@ApplicationName )
mod.@applicationNameColumnValue.Value = ( condition as CommandConditions.@aspnet_ApplicationsTableEqualityConditions.@ApplicationName ).Value;
else if( condition is CommandConditions.@aspnet_ApplicationsTableEqualityConditions.@LoweredApplicationName )
mod.@loweredApplicationNameColumnValue.Value = ( condition as CommandConditions.@aspnet_ApplicationsTableEqualityConditions.@LoweredApplicationName ).Value;
else if( condition is CommandConditions.@aspnet_ApplicationsTableEqualityConditions.@ApplicationId )
mod.@applicationIdColumnValue.Value = ( condition as CommandConditions.@aspnet_ApplicationsTableEqualityConditions.@ApplicationId ).Value;
else if( condition is CommandConditions.@aspnet_ApplicationsTableEqualityConditions.@Description )
mod.@descriptionColumnValue.Value = ( condition as CommandConditions.@aspnet_ApplicationsTableEqualityConditions.@Description ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the aspnet_Applications table.
/// </summary>
public static @aspnet_ApplicationsModification CreateForSingleRowUpdate( string @applicationName, string @loweredApplicationName, System.Guid @applicationId, System.String @description ) {
var mod = new @aspnet_ApplicationsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.aspnet_ApplicationsTableCondition>();
mod.conditions.Add( new CommandConditions.@aspnet_ApplicationsTableEqualityConditions.@ApplicationId( @applicationId ) );
mod.@applicationNameColumnValue.Value = @applicationName;
mod.@loweredApplicationNameColumnValue.Value = @loweredApplicationName;
mod.@applicationIdColumnValue.Value = @applicationId;
mod.@descriptionColumnValue.Value = @description;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.aspnet_ApplicationsTableCondition> getConditionList( CommandConditions.aspnet_ApplicationsTableCondition requiredCondition, params CommandConditions.aspnet_ApplicationsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.aspnet_ApplicationsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @aspnet_ApplicationsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="applicationName">Object does not allow null.</param>
/// <param name="loweredApplicationName">Object does not allow null.</param>
/// <param name="applicationId">Object does not allow null.</param>
/// <param name="description">Object allows null.</param>
public void SetAllData( string @applicationName, string @loweredApplicationName, System.Guid @applicationId, System.String @description ) {
this.@applicationNameColumnValue.Value = @applicationName;
this.@loweredApplicationNameColumnValue.Value = @loweredApplicationName;
this.@applicationIdColumnValue.Value = @applicationId;
this.@descriptionColumnValue.Value = @description;
}
/// <summary>
/// Executes this aspnet_Applications modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this aspnet_Applications modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "aspnet_Applications" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.aspnet_ApplicationsTableCondition>();
conditions.Add( new CommandConditions.@aspnet_ApplicationsTableEqualityConditions.@ApplicationId( @ApplicationId ) );
}
else {
var update = new InlineUpdate( "aspnet_Applications" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @applicationNameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ApplicationName", new DbParameterValue( @ApplicationName, "NVarChar" ) ) );
if( @loweredApplicationNameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LoweredApplicationName", new DbParameterValue( @LoweredApplicationName, "NVarChar" ) ) );
if( @applicationIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ApplicationId", new DbParameterValue( @ApplicationId, "UniqueIdentifier" ) ) );
if( @descriptionColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Description", new DbParameterValue( @Description, "NVarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@applicationNameColumnValue.ClearChanged();
@loweredApplicationNameColumnValue.ClearChanged();
@applicationIdColumnValue.ClearChanged();
@descriptionColumnValue.ClearChanged();
}
}
public partial class @aspnet_MembershipModification {
/// <summary>
/// Inserts a row into the aspnet_Membership table.
/// </summary>
/// <param name="applicationId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="password">Object does not allow null.</param>
/// <param name="passwordFormat">Object does not allow null.</param>
/// <param name="passwordSalt">Object does not allow null.</param>
/// <param name="mobilePIN">Object allows null.</param>
/// <param name="email">Object allows null.</param>
/// <param name="loweredEmail">Object allows null.</param>
/// <param name="passwordQuestion">Object allows null.</param>
/// <param name="passwordAnswer">Object allows null.</param>
/// <param name="isApproved">Object does not allow null.</param>
/// <param name="isLockedOut">Object does not allow null.</param>
/// <param name="createDate">Object does not allow null.</param>
/// <param name="lastLoginDate">Object does not allow null.</param>
/// <param name="lastPasswordChangedDate">Object does not allow null.</param>
/// <param name="lastLockoutDate">Object does not allow null.</param>
/// <param name="failedPasswordAttemptCount">Object does not allow null.</param>
/// <param name="failedPasswordAttemptWindowStart">Object does not allow null.</param>
/// <param name="failedPasswordAnswerAttemptCount">Object does not allow null.</param>
/// <param name="failedPasswordAnswerAttemptWindowStart">Object does not allow null.</param>
/// <param name="comment">Object allows null.</param>
public static void InsertRow( System.Guid @applicationId, System.Guid @userId, string @password, int @passwordFormat, string @passwordSalt, System.String @mobilePIN, System.String @email, System.String @loweredEmail, System.String @passwordQuestion, System.String @passwordAnswer, System.Boolean @isApproved, System.Boolean @isLockedOut, DateTime @createDate, DateTime @lastLoginDate, DateTime @lastPasswordChangedDate, DateTime @lastLockoutDate, int @failedPasswordAttemptCount, DateTime @failedPasswordAttemptWindowStart, int @failedPasswordAnswerAttemptCount, DateTime @failedPasswordAnswerAttemptWindowStart, System.String @comment ) { 
var mod = CreateForInsert();
mod.@applicationIdColumnValue.Value = @applicationId;
mod.@userIdColumnValue.Value = @userId;
mod.@passwordColumnValue.Value = @password;
mod.@passwordFormatColumnValue.Value = @passwordFormat;
mod.@passwordSaltColumnValue.Value = @passwordSalt;
mod.@mobilePINColumnValue.Value = @mobilePIN;
mod.@emailColumnValue.Value = @email;
mod.@loweredEmailColumnValue.Value = @loweredEmail;
mod.@passwordQuestionColumnValue.Value = @passwordQuestion;
mod.@passwordAnswerColumnValue.Value = @passwordAnswer;
mod.@isApprovedColumnValue.Value = @isApproved;
mod.@isLockedOutColumnValue.Value = @isLockedOut;
mod.@createDateColumnValue.Value = @createDate;
mod.@lastLoginDateColumnValue.Value = @lastLoginDate;
mod.@lastPasswordChangedDateColumnValue.Value = @lastPasswordChangedDate;
mod.@lastLockoutDateColumnValue.Value = @lastLockoutDate;
mod.@failedPasswordAttemptCountColumnValue.Value = @failedPasswordAttemptCount;
mod.@failedPasswordAttemptWindowStartColumnValue.Value = @failedPasswordAttemptWindowStart;
mod.@failedPasswordAnswerAttemptCountColumnValue.Value = @failedPasswordAnswerAttemptCount;
mod.@failedPasswordAnswerAttemptWindowStartColumnValue.Value = @failedPasswordAnswerAttemptWindowStart;
mod.@commentColumnValue.Value = @comment;
mod.Execute();
}
/// <summary>
/// Inserts a row into the aspnet_Membership table.
/// </summary>
/// <param name="applicationId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="password">Object does not allow null.</param>
/// <param name="passwordFormat">Object does not allow null.</param>
/// <param name="passwordSalt">Object does not allow null.</param>
/// <param name="mobilePIN">Object allows null.</param>
/// <param name="email">Object allows null.</param>
/// <param name="loweredEmail">Object allows null.</param>
/// <param name="passwordQuestion">Object allows null.</param>
/// <param name="passwordAnswer">Object allows null.</param>
/// <param name="isApproved">Object does not allow null.</param>
/// <param name="isLockedOut">Object does not allow null.</param>
/// <param name="createDate">Object does not allow null.</param>
/// <param name="lastLoginDate">Object does not allow null.</param>
/// <param name="lastPasswordChangedDate">Object does not allow null.</param>
/// <param name="lastLockoutDate">Object does not allow null.</param>
/// <param name="failedPasswordAttemptCount">Object does not allow null.</param>
/// <param name="failedPasswordAttemptWindowStart">Object does not allow null.</param>
/// <param name="failedPasswordAnswerAttemptCount">Object does not allow null.</param>
/// <param name="failedPasswordAnswerAttemptWindowStart">Object does not allow null.</param>
/// <param name="comment">Object allows null.</param>
public static void InsertRowWithoutAdditionalLogic( System.Guid @applicationId, System.Guid @userId, string @password, int @passwordFormat, string @passwordSalt, System.String @mobilePIN, System.String @email, System.String @loweredEmail, System.String @passwordQuestion, System.String @passwordAnswer, System.Boolean @isApproved, System.Boolean @isLockedOut, DateTime @createDate, DateTime @lastLoginDate, DateTime @lastPasswordChangedDate, DateTime @lastLockoutDate, int @failedPasswordAttemptCount, DateTime @failedPasswordAttemptWindowStart, int @failedPasswordAnswerAttemptCount, DateTime @failedPasswordAnswerAttemptWindowStart, System.String @comment ) { 
var mod = CreateForInsert();
mod.@applicationIdColumnValue.Value = @applicationId;
mod.@userIdColumnValue.Value = @userId;
mod.@passwordColumnValue.Value = @password;
mod.@passwordFormatColumnValue.Value = @passwordFormat;
mod.@passwordSaltColumnValue.Value = @passwordSalt;
mod.@mobilePINColumnValue.Value = @mobilePIN;
mod.@emailColumnValue.Value = @email;
mod.@loweredEmailColumnValue.Value = @loweredEmail;
mod.@passwordQuestionColumnValue.Value = @passwordQuestion;
mod.@passwordAnswerColumnValue.Value = @passwordAnswer;
mod.@isApprovedColumnValue.Value = @isApproved;
mod.@isLockedOutColumnValue.Value = @isLockedOut;
mod.@createDateColumnValue.Value = @createDate;
mod.@lastLoginDateColumnValue.Value = @lastLoginDate;
mod.@lastPasswordChangedDateColumnValue.Value = @lastPasswordChangedDate;
mod.@lastLockoutDateColumnValue.Value = @lastLockoutDate;
mod.@failedPasswordAttemptCountColumnValue.Value = @failedPasswordAttemptCount;
mod.@failedPasswordAttemptWindowStartColumnValue.Value = @failedPasswordAttemptWindowStart;
mod.@failedPasswordAnswerAttemptCountColumnValue.Value = @failedPasswordAnswerAttemptCount;
mod.@failedPasswordAnswerAttemptWindowStartColumnValue.Value = @failedPasswordAnswerAttemptWindowStart;
mod.@commentColumnValue.Value = @comment;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the aspnet_Membership table that match the specified conditions with the specified data.
/// </summary>
/// <param name="applicationId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="password">Object does not allow null.</param>
/// <param name="passwordFormat">Object does not allow null.</param>
/// <param name="passwordSalt">Object does not allow null.</param>
/// <param name="mobilePIN">Object allows null.</param>
/// <param name="email">Object allows null.</param>
/// <param name="loweredEmail">Object allows null.</param>
/// <param name="passwordQuestion">Object allows null.</param>
/// <param name="passwordAnswer">Object allows null.</param>
/// <param name="isApproved">Object does not allow null.</param>
/// <param name="isLockedOut">Object does not allow null.</param>
/// <param name="createDate">Object does not allow null.</param>
/// <param name="lastLoginDate">Object does not allow null.</param>
/// <param name="lastPasswordChangedDate">Object does not allow null.</param>
/// <param name="lastLockoutDate">Object does not allow null.</param>
/// <param name="failedPasswordAttemptCount">Object does not allow null.</param>
/// <param name="failedPasswordAttemptWindowStart">Object does not allow null.</param>
/// <param name="failedPasswordAnswerAttemptCount">Object does not allow null.</param>
/// <param name="failedPasswordAnswerAttemptWindowStart">Object does not allow null.</param>
/// <param name="comment">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( System.Guid @applicationId, System.Guid @userId, string @password, int @passwordFormat, string @passwordSalt, System.String @mobilePIN, System.String @email, System.String @loweredEmail, System.String @passwordQuestion, System.String @passwordAnswer, System.Boolean @isApproved, System.Boolean @isLockedOut, DateTime @createDate, DateTime @lastLoginDate, DateTime @lastPasswordChangedDate, DateTime @lastLockoutDate, int @failedPasswordAttemptCount, DateTime @failedPasswordAttemptWindowStart, int @failedPasswordAnswerAttemptCount, DateTime @failedPasswordAnswerAttemptWindowStart, System.String @comment, CommandConditions.aspnet_MembershipTableCondition requiredCondition, params CommandConditions.aspnet_MembershipTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@applicationIdColumnValue.Value = @applicationId;
mod.@userIdColumnValue.Value = @userId;
mod.@passwordColumnValue.Value = @password;
mod.@passwordFormatColumnValue.Value = @passwordFormat;
mod.@passwordSaltColumnValue.Value = @passwordSalt;
mod.@mobilePINColumnValue.Value = @mobilePIN;
mod.@emailColumnValue.Value = @email;
mod.@loweredEmailColumnValue.Value = @loweredEmail;
mod.@passwordQuestionColumnValue.Value = @passwordQuestion;
mod.@passwordAnswerColumnValue.Value = @passwordAnswer;
mod.@isApprovedColumnValue.Value = @isApproved;
mod.@isLockedOutColumnValue.Value = @isLockedOut;
mod.@createDateColumnValue.Value = @createDate;
mod.@lastLoginDateColumnValue.Value = @lastLoginDate;
mod.@lastPasswordChangedDateColumnValue.Value = @lastPasswordChangedDate;
mod.@lastLockoutDateColumnValue.Value = @lastLockoutDate;
mod.@failedPasswordAttemptCountColumnValue.Value = @failedPasswordAttemptCount;
mod.@failedPasswordAttemptWindowStartColumnValue.Value = @failedPasswordAttemptWindowStart;
mod.@failedPasswordAnswerAttemptCountColumnValue.Value = @failedPasswordAnswerAttemptCount;
mod.@failedPasswordAnswerAttemptWindowStartColumnValue.Value = @failedPasswordAnswerAttemptWindowStart;
mod.@commentColumnValue.Value = @comment;
mod.Execute();
}
/// <summary>
/// Updates rows in the aspnet_Membership table that match the specified conditions with the specified data.
/// </summary>
/// <param name="applicationId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="password">Object does not allow null.</param>
/// <param name="passwordFormat">Object does not allow null.</param>
/// <param name="passwordSalt">Object does not allow null.</param>
/// <param name="mobilePIN">Object allows null.</param>
/// <param name="email">Object allows null.</param>
/// <param name="loweredEmail">Object allows null.</param>
/// <param name="passwordQuestion">Object allows null.</param>
/// <param name="passwordAnswer">Object allows null.</param>
/// <param name="isApproved">Object does not allow null.</param>
/// <param name="isLockedOut">Object does not allow null.</param>
/// <param name="createDate">Object does not allow null.</param>
/// <param name="lastLoginDate">Object does not allow null.</param>
/// <param name="lastPasswordChangedDate">Object does not allow null.</param>
/// <param name="lastLockoutDate">Object does not allow null.</param>
/// <param name="failedPasswordAttemptCount">Object does not allow null.</param>
/// <param name="failedPasswordAttemptWindowStart">Object does not allow null.</param>
/// <param name="failedPasswordAnswerAttemptCount">Object does not allow null.</param>
/// <param name="failedPasswordAnswerAttemptWindowStart">Object does not allow null.</param>
/// <param name="comment">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( System.Guid @applicationId, System.Guid @userId, string @password, int @passwordFormat, string @passwordSalt, System.String @mobilePIN, System.String @email, System.String @loweredEmail, System.String @passwordQuestion, System.String @passwordAnswer, System.Boolean @isApproved, System.Boolean @isLockedOut, DateTime @createDate, DateTime @lastLoginDate, DateTime @lastPasswordChangedDate, DateTime @lastLockoutDate, int @failedPasswordAttemptCount, DateTime @failedPasswordAttemptWindowStart, int @failedPasswordAnswerAttemptCount, DateTime @failedPasswordAnswerAttemptWindowStart, System.String @comment, CommandConditions.aspnet_MembershipTableCondition requiredCondition, params CommandConditions.aspnet_MembershipTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@applicationIdColumnValue.Value = @applicationId;
mod.@userIdColumnValue.Value = @userId;
mod.@passwordColumnValue.Value = @password;
mod.@passwordFormatColumnValue.Value = @passwordFormat;
mod.@passwordSaltColumnValue.Value = @passwordSalt;
mod.@mobilePINColumnValue.Value = @mobilePIN;
mod.@emailColumnValue.Value = @email;
mod.@loweredEmailColumnValue.Value = @loweredEmail;
mod.@passwordQuestionColumnValue.Value = @passwordQuestion;
mod.@passwordAnswerColumnValue.Value = @passwordAnswer;
mod.@isApprovedColumnValue.Value = @isApproved;
mod.@isLockedOutColumnValue.Value = @isLockedOut;
mod.@createDateColumnValue.Value = @createDate;
mod.@lastLoginDateColumnValue.Value = @lastLoginDate;
mod.@lastPasswordChangedDateColumnValue.Value = @lastPasswordChangedDate;
mod.@lastLockoutDateColumnValue.Value = @lastLockoutDate;
mod.@failedPasswordAttemptCountColumnValue.Value = @failedPasswordAttemptCount;
mod.@failedPasswordAttemptWindowStartColumnValue.Value = @failedPasswordAttemptWindowStart;
mod.@failedPasswordAnswerAttemptCountColumnValue.Value = @failedPasswordAnswerAttemptCount;
mod.@failedPasswordAnswerAttemptWindowStartColumnValue.Value = @failedPasswordAnswerAttemptWindowStart;
mod.@commentColumnValue.Value = @comment;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.aspnet_MembershipTableCondition requiredCondition, params CommandConditions.aspnet_MembershipTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@aspnet_MembershipTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.aspnet_MembershipTableCondition requiredCondition, params CommandConditions.aspnet_MembershipTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.aspnet_MembershipTableCondition> conditions ) {
var delete = new InlineDelete( "aspnet_Membership" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.aspnet_MembershipTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@aspnet_MembershipTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.aspnet_MembershipTableCondition> conditions;
private readonly DataValue<System.Guid> @applicationIdColumnValue = new DataValue<System.Guid>();
/// <summary>
/// Gets or sets the value for the ApplicationId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Guid @ApplicationId { get { return @applicationIdColumnValue.Value; } set { @applicationIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ApplicationId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ApplicationIdHasChanged { get { return @applicationIdColumnValue.Changed; } }
private readonly DataValue<System.Guid> @userIdColumnValue = new DataValue<System.Guid>();
/// <summary>
/// Gets or sets the value for the UserId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Guid @UserId { get { return @userIdColumnValue.Value; } set { @userIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the UserId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @UserIdHasChanged { get { return @userIdColumnValue.Changed; } }
private readonly DataValue<string> @passwordColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Password column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Password { get { return @passwordColumnValue.Value; } set { @passwordColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Password has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PasswordHasChanged { get { return @passwordColumnValue.Changed; } }
private readonly DataValue<int> @passwordFormatColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the PasswordFormat column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @PasswordFormat { get { return @passwordFormatColumnValue.Value; } set { @passwordFormatColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PasswordFormat has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PasswordFormatHasChanged { get { return @passwordFormatColumnValue.Changed; } }
private readonly DataValue<string> @passwordSaltColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the PasswordSalt column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @PasswordSalt { get { return @passwordSaltColumnValue.Value; } set { @passwordSaltColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PasswordSalt has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PasswordSaltHasChanged { get { return @passwordSaltColumnValue.Changed; } }
private readonly DataValue<System.String> @mobilePINColumnValue = new DataValue<System.String>();
/// <summary>
/// Gets or sets the value for the MobilePIN column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.String @MobilePIN { get { return @mobilePINColumnValue.Value; } set { @mobilePINColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the MobilePIN has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @MobilePINHasChanged { get { return @mobilePINColumnValue.Changed; } }
private readonly DataValue<System.String> @emailColumnValue = new DataValue<System.String>();
/// <summary>
/// Gets or sets the value for the Email column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.String @Email { get { return @emailColumnValue.Value; } set { @emailColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Email has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EmailHasChanged { get { return @emailColumnValue.Changed; } }
private readonly DataValue<System.String> @loweredEmailColumnValue = new DataValue<System.String>();
/// <summary>
/// Gets or sets the value for the LoweredEmail column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.String @LoweredEmail { get { return @loweredEmailColumnValue.Value; } set { @loweredEmailColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LoweredEmail has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LoweredEmailHasChanged { get { return @loweredEmailColumnValue.Changed; } }
private readonly DataValue<System.String> @passwordQuestionColumnValue = new DataValue<System.String>();
/// <summary>
/// Gets or sets the value for the PasswordQuestion column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.String @PasswordQuestion { get { return @passwordQuestionColumnValue.Value; } set { @passwordQuestionColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PasswordQuestion has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PasswordQuestionHasChanged { get { return @passwordQuestionColumnValue.Changed; } }
private readonly DataValue<System.String> @passwordAnswerColumnValue = new DataValue<System.String>();
/// <summary>
/// Gets or sets the value for the PasswordAnswer column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.String @PasswordAnswer { get { return @passwordAnswerColumnValue.Value; } set { @passwordAnswerColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PasswordAnswer has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PasswordAnswerHasChanged { get { return @passwordAnswerColumnValue.Changed; } }
private readonly DataValue<System.Boolean> @isApprovedColumnValue = new DataValue<System.Boolean>();
/// <summary>
/// Gets or sets the value for the IsApproved column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Boolean @IsApproved { get { return @isApprovedColumnValue.Value; } set { @isApprovedColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the IsApproved has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @IsApprovedHasChanged { get { return @isApprovedColumnValue.Changed; } }
private readonly DataValue<System.Boolean> @isLockedOutColumnValue = new DataValue<System.Boolean>();
/// <summary>
/// Gets or sets the value for the IsLockedOut column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Boolean @IsLockedOut { get { return @isLockedOutColumnValue.Value; } set { @isLockedOutColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the IsLockedOut has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @IsLockedOutHasChanged { get { return @isLockedOutColumnValue.Changed; } }
private readonly DataValue<DateTime> @createDateColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the CreateDate column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @CreateDate { get { return @createDateColumnValue.Value; } set { @createDateColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the CreateDate has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @CreateDateHasChanged { get { return @createDateColumnValue.Changed; } }
private readonly DataValue<DateTime> @lastLoginDateColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the LastLoginDate column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @LastLoginDate { get { return @lastLoginDateColumnValue.Value; } set { @lastLoginDateColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LastLoginDate has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LastLoginDateHasChanged { get { return @lastLoginDateColumnValue.Changed; } }
private readonly DataValue<DateTime> @lastPasswordChangedDateColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the LastPasswordChangedDate column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @LastPasswordChangedDate { get { return @lastPasswordChangedDateColumnValue.Value; } set { @lastPasswordChangedDateColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LastPasswordChangedDate has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LastPasswordChangedDateHasChanged { get { return @lastPasswordChangedDateColumnValue.Changed; } }
private readonly DataValue<DateTime> @lastLockoutDateColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the LastLockoutDate column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @LastLockoutDate { get { return @lastLockoutDateColumnValue.Value; } set { @lastLockoutDateColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LastLockoutDate has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LastLockoutDateHasChanged { get { return @lastLockoutDateColumnValue.Changed; } }
private readonly DataValue<int> @failedPasswordAttemptCountColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the FailedPasswordAttemptCount column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @FailedPasswordAttemptCount { get { return @failedPasswordAttemptCountColumnValue.Value; } set { @failedPasswordAttemptCountColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the FailedPasswordAttemptCount has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @FailedPasswordAttemptCountHasChanged { get { return @failedPasswordAttemptCountColumnValue.Changed; } }
private readonly DataValue<DateTime> @failedPasswordAttemptWindowStartColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the FailedPasswordAttemptWindowStart column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @FailedPasswordAttemptWindowStart { get { return @failedPasswordAttemptWindowStartColumnValue.Value; } set { @failedPasswordAttemptWindowStartColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the FailedPasswordAttemptWindowStart has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @FailedPasswordAttemptWindowStartHasChanged { get { return @failedPasswordAttemptWindowStartColumnValue.Changed; } }
private readonly DataValue<int> @failedPasswordAnswerAttemptCountColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the FailedPasswordAnswerAttemptCount column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @FailedPasswordAnswerAttemptCount { get { return @failedPasswordAnswerAttemptCountColumnValue.Value; } set { @failedPasswordAnswerAttemptCountColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the FailedPasswordAnswerAttemptCount has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @FailedPasswordAnswerAttemptCountHasChanged { get { return @failedPasswordAnswerAttemptCountColumnValue.Changed; } }
private readonly DataValue<DateTime> @failedPasswordAnswerAttemptWindowStartColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the FailedPasswordAnswerAttemptWindowStart column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @FailedPasswordAnswerAttemptWindowStart { get { return @failedPasswordAnswerAttemptWindowStartColumnValue.Value; } set { @failedPasswordAnswerAttemptWindowStartColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the FailedPasswordAnswerAttemptWindowStart has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @FailedPasswordAnswerAttemptWindowStartHasChanged { get { return @failedPasswordAnswerAttemptWindowStartColumnValue.Changed; } }
private readonly DataValue<System.String> @commentColumnValue = new DataValue<System.String>();
/// <summary>
/// Gets or sets the value for the Comment column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.String @Comment { get { return @commentColumnValue.Value; } set { @commentColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Comment has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @CommentHasChanged { get { return @commentColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the aspnet_Membership table.
/// </summary>
public static @aspnet_MembershipModification CreateForInsert() {
return new @aspnet_MembershipModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the aspnet_Membership table.
/// </summary>
public static @aspnet_MembershipModification CreateForUpdate( CommandConditions.aspnet_MembershipTableCondition requiredCondition, params CommandConditions.aspnet_MembershipTableCondition[] additionalConditions ) {
var mod = new @aspnet_MembershipModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@aspnet_MembershipTableEqualityConditions.@ApplicationId )
mod.@applicationIdColumnValue.Value = ( condition as CommandConditions.@aspnet_MembershipTableEqualityConditions.@ApplicationId ).Value;
else if( condition is CommandConditions.@aspnet_MembershipTableEqualityConditions.@UserId )
mod.@userIdColumnValue.Value = ( condition as CommandConditions.@aspnet_MembershipTableEqualityConditions.@UserId ).Value;
else if( condition is CommandConditions.@aspnet_MembershipTableEqualityConditions.@Password )
mod.@passwordColumnValue.Value = ( condition as CommandConditions.@aspnet_MembershipTableEqualityConditions.@Password ).Value;
else if( condition is CommandConditions.@aspnet_MembershipTableEqualityConditions.@PasswordFormat )
mod.@passwordFormatColumnValue.Value = ( condition as CommandConditions.@aspnet_MembershipTableEqualityConditions.@PasswordFormat ).Value;
else if( condition is CommandConditions.@aspnet_MembershipTableEqualityConditions.@PasswordSalt )
mod.@passwordSaltColumnValue.Value = ( condition as CommandConditions.@aspnet_MembershipTableEqualityConditions.@PasswordSalt ).Value;
else if( condition is CommandConditions.@aspnet_MembershipTableEqualityConditions.@MobilePIN )
mod.@mobilePINColumnValue.Value = ( condition as CommandConditions.@aspnet_MembershipTableEqualityConditions.@MobilePIN ).Value;
else if( condition is CommandConditions.@aspnet_MembershipTableEqualityConditions.@Email )
mod.@emailColumnValue.Value = ( condition as CommandConditions.@aspnet_MembershipTableEqualityConditions.@Email ).Value;
else if( condition is CommandConditions.@aspnet_MembershipTableEqualityConditions.@LoweredEmail )
mod.@loweredEmailColumnValue.Value = ( condition as CommandConditions.@aspnet_MembershipTableEqualityConditions.@LoweredEmail ).Value;
else if( condition is CommandConditions.@aspnet_MembershipTableEqualityConditions.@PasswordQuestion )
mod.@passwordQuestionColumnValue.Value = ( condition as CommandConditions.@aspnet_MembershipTableEqualityConditions.@PasswordQuestion ).Value;
else if( condition is CommandConditions.@aspnet_MembershipTableEqualityConditions.@PasswordAnswer )
mod.@passwordAnswerColumnValue.Value = ( condition as CommandConditions.@aspnet_MembershipTableEqualityConditions.@PasswordAnswer ).Value;
else if( condition is CommandConditions.@aspnet_MembershipTableEqualityConditions.@IsApproved )
mod.@isApprovedColumnValue.Value = ( condition as CommandConditions.@aspnet_MembershipTableEqualityConditions.@IsApproved ).Value;
else if( condition is CommandConditions.@aspnet_MembershipTableEqualityConditions.@IsLockedOut )
mod.@isLockedOutColumnValue.Value = ( condition as CommandConditions.@aspnet_MembershipTableEqualityConditions.@IsLockedOut ).Value;
else if( condition is CommandConditions.@aspnet_MembershipTableEqualityConditions.@CreateDate )
mod.@createDateColumnValue.Value = ( condition as CommandConditions.@aspnet_MembershipTableEqualityConditions.@CreateDate ).Value;
else if( condition is CommandConditions.@aspnet_MembershipTableEqualityConditions.@LastLoginDate )
mod.@lastLoginDateColumnValue.Value = ( condition as CommandConditions.@aspnet_MembershipTableEqualityConditions.@LastLoginDate ).Value;
else if( condition is CommandConditions.@aspnet_MembershipTableEqualityConditions.@LastPasswordChangedDate )
mod.@lastPasswordChangedDateColumnValue.Value = ( condition as CommandConditions.@aspnet_MembershipTableEqualityConditions.@LastPasswordChangedDate ).Value;
else if( condition is CommandConditions.@aspnet_MembershipTableEqualityConditions.@LastLockoutDate )
mod.@lastLockoutDateColumnValue.Value = ( condition as CommandConditions.@aspnet_MembershipTableEqualityConditions.@LastLockoutDate ).Value;
else if( condition is CommandConditions.@aspnet_MembershipTableEqualityConditions.@FailedPasswordAttemptCount )
mod.@failedPasswordAttemptCountColumnValue.Value = ( condition as CommandConditions.@aspnet_MembershipTableEqualityConditions.@FailedPasswordAttemptCount ).Value;
else if( condition is CommandConditions.@aspnet_MembershipTableEqualityConditions.@FailedPasswordAttemptWindowStart )
mod.@failedPasswordAttemptWindowStartColumnValue.Value = ( condition as CommandConditions.@aspnet_MembershipTableEqualityConditions.@FailedPasswordAttemptWindowStart ).Value;
else if( condition is CommandConditions.@aspnet_MembershipTableEqualityConditions.@FailedPasswordAnswerAttemptCount )
mod.@failedPasswordAnswerAttemptCountColumnValue.Value = ( condition as CommandConditions.@aspnet_MembershipTableEqualityConditions.@FailedPasswordAnswerAttemptCount ).Value;
else if( condition is CommandConditions.@aspnet_MembershipTableEqualityConditions.@FailedPasswordAnswerAttemptWindowStart )
mod.@failedPasswordAnswerAttemptWindowStartColumnValue.Value = ( condition as CommandConditions.@aspnet_MembershipTableEqualityConditions.@FailedPasswordAnswerAttemptWindowStart ).Value;
else if( condition is CommandConditions.@aspnet_MembershipTableEqualityConditions.@Comment )
mod.@commentColumnValue.Value = ( condition as CommandConditions.@aspnet_MembershipTableEqualityConditions.@Comment ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the aspnet_Membership table.
/// </summary>
public static @aspnet_MembershipModification CreateForSingleRowUpdate( System.Guid @applicationId, System.Guid @userId, string @password, int @passwordFormat, string @passwordSalt, System.String @mobilePIN, System.String @email, System.String @loweredEmail, System.String @passwordQuestion, System.String @passwordAnswer, System.Boolean @isApproved, System.Boolean @isLockedOut, DateTime @createDate, DateTime @lastLoginDate, DateTime @lastPasswordChangedDate, DateTime @lastLockoutDate, int @failedPasswordAttemptCount, DateTime @failedPasswordAttemptWindowStart, int @failedPasswordAnswerAttemptCount, DateTime @failedPasswordAnswerAttemptWindowStart, System.String @comment ) {
var mod = new @aspnet_MembershipModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.aspnet_MembershipTableCondition>();
mod.conditions.Add( new CommandConditions.@aspnet_MembershipTableEqualityConditions.@UserId( @userId ) );
mod.@applicationIdColumnValue.Value = @applicationId;
mod.@userIdColumnValue.Value = @userId;
mod.@passwordColumnValue.Value = @password;
mod.@passwordFormatColumnValue.Value = @passwordFormat;
mod.@passwordSaltColumnValue.Value = @passwordSalt;
mod.@mobilePINColumnValue.Value = @mobilePIN;
mod.@emailColumnValue.Value = @email;
mod.@loweredEmailColumnValue.Value = @loweredEmail;
mod.@passwordQuestionColumnValue.Value = @passwordQuestion;
mod.@passwordAnswerColumnValue.Value = @passwordAnswer;
mod.@isApprovedColumnValue.Value = @isApproved;
mod.@isLockedOutColumnValue.Value = @isLockedOut;
mod.@createDateColumnValue.Value = @createDate;
mod.@lastLoginDateColumnValue.Value = @lastLoginDate;
mod.@lastPasswordChangedDateColumnValue.Value = @lastPasswordChangedDate;
mod.@lastLockoutDateColumnValue.Value = @lastLockoutDate;
mod.@failedPasswordAttemptCountColumnValue.Value = @failedPasswordAttemptCount;
mod.@failedPasswordAttemptWindowStartColumnValue.Value = @failedPasswordAttemptWindowStart;
mod.@failedPasswordAnswerAttemptCountColumnValue.Value = @failedPasswordAnswerAttemptCount;
mod.@failedPasswordAnswerAttemptWindowStartColumnValue.Value = @failedPasswordAnswerAttemptWindowStart;
mod.@commentColumnValue.Value = @comment;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.aspnet_MembershipTableCondition> getConditionList( CommandConditions.aspnet_MembershipTableCondition requiredCondition, params CommandConditions.aspnet_MembershipTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.aspnet_MembershipTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @aspnet_MembershipModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="applicationId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="password">Object does not allow null.</param>
/// <param name="passwordFormat">Object does not allow null.</param>
/// <param name="passwordSalt">Object does not allow null.</param>
/// <param name="mobilePIN">Object allows null.</param>
/// <param name="email">Object allows null.</param>
/// <param name="loweredEmail">Object allows null.</param>
/// <param name="passwordQuestion">Object allows null.</param>
/// <param name="passwordAnswer">Object allows null.</param>
/// <param name="isApproved">Object does not allow null.</param>
/// <param name="isLockedOut">Object does not allow null.</param>
/// <param name="createDate">Object does not allow null.</param>
/// <param name="lastLoginDate">Object does not allow null.</param>
/// <param name="lastPasswordChangedDate">Object does not allow null.</param>
/// <param name="lastLockoutDate">Object does not allow null.</param>
/// <param name="failedPasswordAttemptCount">Object does not allow null.</param>
/// <param name="failedPasswordAttemptWindowStart">Object does not allow null.</param>
/// <param name="failedPasswordAnswerAttemptCount">Object does not allow null.</param>
/// <param name="failedPasswordAnswerAttemptWindowStart">Object does not allow null.</param>
/// <param name="comment">Object allows null.</param>
public void SetAllData( System.Guid @applicationId, System.Guid @userId, string @password, int @passwordFormat, string @passwordSalt, System.String @mobilePIN, System.String @email, System.String @loweredEmail, System.String @passwordQuestion, System.String @passwordAnswer, System.Boolean @isApproved, System.Boolean @isLockedOut, DateTime @createDate, DateTime @lastLoginDate, DateTime @lastPasswordChangedDate, DateTime @lastLockoutDate, int @failedPasswordAttemptCount, DateTime @failedPasswordAttemptWindowStart, int @failedPasswordAnswerAttemptCount, DateTime @failedPasswordAnswerAttemptWindowStart, System.String @comment ) {
this.@applicationIdColumnValue.Value = @applicationId;
this.@userIdColumnValue.Value = @userId;
this.@passwordColumnValue.Value = @password;
this.@passwordFormatColumnValue.Value = @passwordFormat;
this.@passwordSaltColumnValue.Value = @passwordSalt;
this.@mobilePINColumnValue.Value = @mobilePIN;
this.@emailColumnValue.Value = @email;
this.@loweredEmailColumnValue.Value = @loweredEmail;
this.@passwordQuestionColumnValue.Value = @passwordQuestion;
this.@passwordAnswerColumnValue.Value = @passwordAnswer;
this.@isApprovedColumnValue.Value = @isApproved;
this.@isLockedOutColumnValue.Value = @isLockedOut;
this.@createDateColumnValue.Value = @createDate;
this.@lastLoginDateColumnValue.Value = @lastLoginDate;
this.@lastPasswordChangedDateColumnValue.Value = @lastPasswordChangedDate;
this.@lastLockoutDateColumnValue.Value = @lastLockoutDate;
this.@failedPasswordAttemptCountColumnValue.Value = @failedPasswordAttemptCount;
this.@failedPasswordAttemptWindowStartColumnValue.Value = @failedPasswordAttemptWindowStart;
this.@failedPasswordAnswerAttemptCountColumnValue.Value = @failedPasswordAnswerAttemptCount;
this.@failedPasswordAnswerAttemptWindowStartColumnValue.Value = @failedPasswordAnswerAttemptWindowStart;
this.@commentColumnValue.Value = @comment;
}
/// <summary>
/// Executes this aspnet_Membership modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this aspnet_Membership modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "aspnet_Membership" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.aspnet_MembershipTableCondition>();
conditions.Add( new CommandConditions.@aspnet_MembershipTableEqualityConditions.@UserId( @UserId ) );
}
else {
var update = new InlineUpdate( "aspnet_Membership" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @applicationIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ApplicationId", new DbParameterValue( @ApplicationId, "UniqueIdentifier" ) ) );
if( @userIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( @UserId, "UniqueIdentifier" ) ) );
if( @passwordColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Password", new DbParameterValue( @Password, "NVarChar" ) ) );
if( @passwordFormatColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PasswordFormat", new DbParameterValue( @PasswordFormat, "Int" ) ) );
if( @passwordSaltColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PasswordSalt", new DbParameterValue( @PasswordSalt, "NVarChar" ) ) );
if( @mobilePINColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "MobilePIN", new DbParameterValue( @MobilePIN, "NVarChar" ) ) );
if( @emailColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Email", new DbParameterValue( @Email, "NVarChar" ) ) );
if( @loweredEmailColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LoweredEmail", new DbParameterValue( @LoweredEmail, "NVarChar" ) ) );
if( @passwordQuestionColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PasswordQuestion", new DbParameterValue( @PasswordQuestion, "NVarChar" ) ) );
if( @passwordAnswerColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PasswordAnswer", new DbParameterValue( @PasswordAnswer, "NVarChar" ) ) );
if( @isApprovedColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "IsApproved", new DbParameterValue( @IsApproved, "Bit" ) ) );
if( @isLockedOutColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "IsLockedOut", new DbParameterValue( @IsLockedOut, "Bit" ) ) );
if( @createDateColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "CreateDate", new DbParameterValue( @CreateDate, "DateTime" ) ) );
if( @lastLoginDateColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LastLoginDate", new DbParameterValue( @LastLoginDate, "DateTime" ) ) );
if( @lastPasswordChangedDateColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LastPasswordChangedDate", new DbParameterValue( @LastPasswordChangedDate, "DateTime" ) ) );
if( @lastLockoutDateColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LastLockoutDate", new DbParameterValue( @LastLockoutDate, "DateTime" ) ) );
if( @failedPasswordAttemptCountColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "FailedPasswordAttemptCount", new DbParameterValue( @FailedPasswordAttemptCount, "Int" ) ) );
if( @failedPasswordAttemptWindowStartColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "FailedPasswordAttemptWindowStart", new DbParameterValue( @FailedPasswordAttemptWindowStart, "DateTime" ) ) );
if( @failedPasswordAnswerAttemptCountColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "FailedPasswordAnswerAttemptCount", new DbParameterValue( @FailedPasswordAnswerAttemptCount, "Int" ) ) );
if( @failedPasswordAnswerAttemptWindowStartColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "FailedPasswordAnswerAttemptWindowStart", new DbParameterValue( @FailedPasswordAnswerAttemptWindowStart, "DateTime" ) ) );
if( @commentColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Comment", new DbParameterValue( @Comment, "NText" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@applicationIdColumnValue.ClearChanged();
@userIdColumnValue.ClearChanged();
@passwordColumnValue.ClearChanged();
@passwordFormatColumnValue.ClearChanged();
@passwordSaltColumnValue.ClearChanged();
@mobilePINColumnValue.ClearChanged();
@emailColumnValue.ClearChanged();
@loweredEmailColumnValue.ClearChanged();
@passwordQuestionColumnValue.ClearChanged();
@passwordAnswerColumnValue.ClearChanged();
@isApprovedColumnValue.ClearChanged();
@isLockedOutColumnValue.ClearChanged();
@createDateColumnValue.ClearChanged();
@lastLoginDateColumnValue.ClearChanged();
@lastPasswordChangedDateColumnValue.ClearChanged();
@lastLockoutDateColumnValue.ClearChanged();
@failedPasswordAttemptCountColumnValue.ClearChanged();
@failedPasswordAttemptWindowStartColumnValue.ClearChanged();
@failedPasswordAnswerAttemptCountColumnValue.ClearChanged();
@failedPasswordAnswerAttemptWindowStartColumnValue.ClearChanged();
@commentColumnValue.ClearChanged();
}
}
public partial class @aspnet_PathsModification {
/// <summary>
/// Inserts a row into the aspnet_Paths table.
/// </summary>
/// <param name="applicationId">Object does not allow null.</param>
/// <param name="pathId">Object does not allow null.</param>
/// <param name="path">Object does not allow null.</param>
/// <param name="loweredPath">Object does not allow null.</param>
public static void InsertRow( System.Guid @applicationId, System.Guid @pathId, string @path, string @loweredPath ) { 
var mod = CreateForInsert();
mod.@applicationIdColumnValue.Value = @applicationId;
mod.@pathIdColumnValue.Value = @pathId;
mod.@pathColumnValue.Value = @path;
mod.@loweredPathColumnValue.Value = @loweredPath;
mod.Execute();
}
/// <summary>
/// Inserts a row into the aspnet_Paths table.
/// </summary>
/// <param name="applicationId">Object does not allow null.</param>
/// <param name="pathId">Object does not allow null.</param>
/// <param name="path">Object does not allow null.</param>
/// <param name="loweredPath">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( System.Guid @applicationId, System.Guid @pathId, string @path, string @loweredPath ) { 
var mod = CreateForInsert();
mod.@applicationIdColumnValue.Value = @applicationId;
mod.@pathIdColumnValue.Value = @pathId;
mod.@pathColumnValue.Value = @path;
mod.@loweredPathColumnValue.Value = @loweredPath;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the aspnet_Paths table that match the specified conditions with the specified data.
/// </summary>
/// <param name="applicationId">Object does not allow null.</param>
/// <param name="pathId">Object does not allow null.</param>
/// <param name="path">Object does not allow null.</param>
/// <param name="loweredPath">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( System.Guid @applicationId, System.Guid @pathId, string @path, string @loweredPath, CommandConditions.aspnet_PathsTableCondition requiredCondition, params CommandConditions.aspnet_PathsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@applicationIdColumnValue.Value = @applicationId;
mod.@pathIdColumnValue.Value = @pathId;
mod.@pathColumnValue.Value = @path;
mod.@loweredPathColumnValue.Value = @loweredPath;
mod.Execute();
}
/// <summary>
/// Updates rows in the aspnet_Paths table that match the specified conditions with the specified data.
/// </summary>
/// <param name="applicationId">Object does not allow null.</param>
/// <param name="pathId">Object does not allow null.</param>
/// <param name="path">Object does not allow null.</param>
/// <param name="loweredPath">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( System.Guid @applicationId, System.Guid @pathId, string @path, string @loweredPath, CommandConditions.aspnet_PathsTableCondition requiredCondition, params CommandConditions.aspnet_PathsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@applicationIdColumnValue.Value = @applicationId;
mod.@pathIdColumnValue.Value = @pathId;
mod.@pathColumnValue.Value = @path;
mod.@loweredPathColumnValue.Value = @loweredPath;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.aspnet_PathsTableCondition requiredCondition, params CommandConditions.aspnet_PathsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@aspnet_PathsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.aspnet_PathsTableCondition requiredCondition, params CommandConditions.aspnet_PathsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.aspnet_PathsTableCondition> conditions ) {
var delete = new InlineDelete( "aspnet_Paths" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.aspnet_PathsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@aspnet_PathsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.aspnet_PathsTableCondition> conditions;
private readonly DataValue<System.Guid> @applicationIdColumnValue = new DataValue<System.Guid>();
/// <summary>
/// Gets or sets the value for the ApplicationId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Guid @ApplicationId { get { return @applicationIdColumnValue.Value; } set { @applicationIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ApplicationId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ApplicationIdHasChanged { get { return @applicationIdColumnValue.Changed; } }
private readonly DataValue<System.Guid> @pathIdColumnValue = new DataValue<System.Guid>();
/// <summary>
/// Gets or sets the value for the PathId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Guid @PathId { get { return @pathIdColumnValue.Value; } set { @pathIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PathId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PathIdHasChanged { get { return @pathIdColumnValue.Changed; } }
private readonly DataValue<string> @pathColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Path column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Path { get { return @pathColumnValue.Value; } set { @pathColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Path has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PathHasChanged { get { return @pathColumnValue.Changed; } }
private readonly DataValue<string> @loweredPathColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the LoweredPath column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @LoweredPath { get { return @loweredPathColumnValue.Value; } set { @loweredPathColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LoweredPath has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LoweredPathHasChanged { get { return @loweredPathColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the aspnet_Paths table.
/// </summary>
public static @aspnet_PathsModification CreateForInsert() {
return new @aspnet_PathsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the aspnet_Paths table.
/// </summary>
public static @aspnet_PathsModification CreateForUpdate( CommandConditions.aspnet_PathsTableCondition requiredCondition, params CommandConditions.aspnet_PathsTableCondition[] additionalConditions ) {
var mod = new @aspnet_PathsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@aspnet_PathsTableEqualityConditions.@ApplicationId )
mod.@applicationIdColumnValue.Value = ( condition as CommandConditions.@aspnet_PathsTableEqualityConditions.@ApplicationId ).Value;
else if( condition is CommandConditions.@aspnet_PathsTableEqualityConditions.@PathId )
mod.@pathIdColumnValue.Value = ( condition as CommandConditions.@aspnet_PathsTableEqualityConditions.@PathId ).Value;
else if( condition is CommandConditions.@aspnet_PathsTableEqualityConditions.@Path )
mod.@pathColumnValue.Value = ( condition as CommandConditions.@aspnet_PathsTableEqualityConditions.@Path ).Value;
else if( condition is CommandConditions.@aspnet_PathsTableEqualityConditions.@LoweredPath )
mod.@loweredPathColumnValue.Value = ( condition as CommandConditions.@aspnet_PathsTableEqualityConditions.@LoweredPath ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the aspnet_Paths table.
/// </summary>
public static @aspnet_PathsModification CreateForSingleRowUpdate( System.Guid @applicationId, System.Guid @pathId, string @path, string @loweredPath ) {
var mod = new @aspnet_PathsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.aspnet_PathsTableCondition>();
mod.conditions.Add( new CommandConditions.@aspnet_PathsTableEqualityConditions.@ApplicationId( @applicationId ) );
mod.conditions.Add( new CommandConditions.@aspnet_PathsTableEqualityConditions.@LoweredPath( @loweredPath ) );
mod.@applicationIdColumnValue.Value = @applicationId;
mod.@pathIdColumnValue.Value = @pathId;
mod.@pathColumnValue.Value = @path;
mod.@loweredPathColumnValue.Value = @loweredPath;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.aspnet_PathsTableCondition> getConditionList( CommandConditions.aspnet_PathsTableCondition requiredCondition, params CommandConditions.aspnet_PathsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.aspnet_PathsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @aspnet_PathsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="applicationId">Object does not allow null.</param>
/// <param name="pathId">Object does not allow null.</param>
/// <param name="path">Object does not allow null.</param>
/// <param name="loweredPath">Object does not allow null.</param>
public void SetAllData( System.Guid @applicationId, System.Guid @pathId, string @path, string @loweredPath ) {
this.@applicationIdColumnValue.Value = @applicationId;
this.@pathIdColumnValue.Value = @pathId;
this.@pathColumnValue.Value = @path;
this.@loweredPathColumnValue.Value = @loweredPath;
}
/// <summary>
/// Executes this aspnet_Paths modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this aspnet_Paths modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "aspnet_Paths" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.aspnet_PathsTableCondition>();
conditions.Add( new CommandConditions.@aspnet_PathsTableEqualityConditions.@ApplicationId( @ApplicationId ) );
conditions.Add( new CommandConditions.@aspnet_PathsTableEqualityConditions.@LoweredPath( @LoweredPath ) );
}
else {
var update = new InlineUpdate( "aspnet_Paths" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @applicationIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ApplicationId", new DbParameterValue( @ApplicationId, "UniqueIdentifier" ) ) );
if( @pathIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PathId", new DbParameterValue( @PathId, "UniqueIdentifier" ) ) );
if( @pathColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Path", new DbParameterValue( @Path, "NVarChar" ) ) );
if( @loweredPathColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LoweredPath", new DbParameterValue( @LoweredPath, "NVarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@applicationIdColumnValue.ClearChanged();
@pathIdColumnValue.ClearChanged();
@pathColumnValue.ClearChanged();
@loweredPathColumnValue.ClearChanged();
}
}
public partial class @aspnet_PersonalizationAllUsersModification {
/// <summary>
/// Inserts a row into the aspnet_PersonalizationAllUsers table.
/// </summary>
/// <param name="pathId">Object does not allow null.</param>
/// <param name="pageSettings">Object does not allow null.</param>
/// <param name="lastUpdatedDate">Object does not allow null.</param>
public static void InsertRow( System.Guid @pathId, System.Byte[] @pageSettings, DateTime @lastUpdatedDate ) { 
var mod = CreateForInsert();
mod.@pathIdColumnValue.Value = @pathId;
mod.@pageSettingsColumnValue.Value = @pageSettings;
mod.@lastUpdatedDateColumnValue.Value = @lastUpdatedDate;
mod.Execute();
}
/// <summary>
/// Inserts a row into the aspnet_PersonalizationAllUsers table.
/// </summary>
/// <param name="pathId">Object does not allow null.</param>
/// <param name="pageSettings">Object does not allow null.</param>
/// <param name="lastUpdatedDate">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( System.Guid @pathId, System.Byte[] @pageSettings, DateTime @lastUpdatedDate ) { 
var mod = CreateForInsert();
mod.@pathIdColumnValue.Value = @pathId;
mod.@pageSettingsColumnValue.Value = @pageSettings;
mod.@lastUpdatedDateColumnValue.Value = @lastUpdatedDate;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the aspnet_PersonalizationAllUsers table that match the specified conditions with the specified data.
/// </summary>
/// <param name="pathId">Object does not allow null.</param>
/// <param name="pageSettings">Object does not allow null.</param>
/// <param name="lastUpdatedDate">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( System.Guid @pathId, System.Byte[] @pageSettings, DateTime @lastUpdatedDate, CommandConditions.aspnet_PersonalizationAllUsersTableCondition requiredCondition, params CommandConditions.aspnet_PersonalizationAllUsersTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@pathIdColumnValue.Value = @pathId;
mod.@pageSettingsColumnValue.Value = @pageSettings;
mod.@lastUpdatedDateColumnValue.Value = @lastUpdatedDate;
mod.Execute();
}
/// <summary>
/// Updates rows in the aspnet_PersonalizationAllUsers table that match the specified conditions with the specified data.
/// </summary>
/// <param name="pathId">Object does not allow null.</param>
/// <param name="pageSettings">Object does not allow null.</param>
/// <param name="lastUpdatedDate">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( System.Guid @pathId, System.Byte[] @pageSettings, DateTime @lastUpdatedDate, CommandConditions.aspnet_PersonalizationAllUsersTableCondition requiredCondition, params CommandConditions.aspnet_PersonalizationAllUsersTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@pathIdColumnValue.Value = @pathId;
mod.@pageSettingsColumnValue.Value = @pageSettings;
mod.@lastUpdatedDateColumnValue.Value = @lastUpdatedDate;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.aspnet_PersonalizationAllUsersTableCondition requiredCondition, params CommandConditions.aspnet_PersonalizationAllUsersTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@aspnet_PersonalizationAllUsersTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.aspnet_PersonalizationAllUsersTableCondition requiredCondition, params CommandConditions.aspnet_PersonalizationAllUsersTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.aspnet_PersonalizationAllUsersTableCondition> conditions ) {
var delete = new InlineDelete( "aspnet_PersonalizationAllUsers" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.aspnet_PersonalizationAllUsersTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@aspnet_PersonalizationAllUsersTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.aspnet_PersonalizationAllUsersTableCondition> conditions;
private readonly DataValue<System.Guid> @pathIdColumnValue = new DataValue<System.Guid>();
/// <summary>
/// Gets or sets the value for the PathId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Guid @PathId { get { return @pathIdColumnValue.Value; } set { @pathIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PathId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PathIdHasChanged { get { return @pathIdColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @pageSettingsColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the PageSettings column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @PageSettings { get { return @pageSettingsColumnValue.Value; } set { @pageSettingsColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PageSettings has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PageSettingsHasChanged { get { return @pageSettingsColumnValue.Changed; } }
private readonly DataValue<DateTime> @lastUpdatedDateColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the LastUpdatedDate column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @LastUpdatedDate { get { return @lastUpdatedDateColumnValue.Value; } set { @lastUpdatedDateColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LastUpdatedDate has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LastUpdatedDateHasChanged { get { return @lastUpdatedDateColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the aspnet_PersonalizationAllUsers table.
/// </summary>
public static @aspnet_PersonalizationAllUsersModification CreateForInsert() {
return new @aspnet_PersonalizationAllUsersModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the aspnet_PersonalizationAllUsers table.
/// </summary>
public static @aspnet_PersonalizationAllUsersModification CreateForUpdate( CommandConditions.aspnet_PersonalizationAllUsersTableCondition requiredCondition, params CommandConditions.aspnet_PersonalizationAllUsersTableCondition[] additionalConditions ) {
var mod = new @aspnet_PersonalizationAllUsersModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@aspnet_PersonalizationAllUsersTableEqualityConditions.@PathId )
mod.@pathIdColumnValue.Value = ( condition as CommandConditions.@aspnet_PersonalizationAllUsersTableEqualityConditions.@PathId ).Value;
else if( condition is CommandConditions.@aspnet_PersonalizationAllUsersTableEqualityConditions.@PageSettings )
mod.@pageSettingsColumnValue.Value = ( condition as CommandConditions.@aspnet_PersonalizationAllUsersTableEqualityConditions.@PageSettings ).Value;
else if( condition is CommandConditions.@aspnet_PersonalizationAllUsersTableEqualityConditions.@LastUpdatedDate )
mod.@lastUpdatedDateColumnValue.Value = ( condition as CommandConditions.@aspnet_PersonalizationAllUsersTableEqualityConditions.@LastUpdatedDate ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the aspnet_PersonalizationAllUsers table.
/// </summary>
public static @aspnet_PersonalizationAllUsersModification CreateForSingleRowUpdate( System.Guid @pathId, System.Byte[] @pageSettings, DateTime @lastUpdatedDate ) {
var mod = new @aspnet_PersonalizationAllUsersModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.aspnet_PersonalizationAllUsersTableCondition>();
mod.conditions.Add( new CommandConditions.@aspnet_PersonalizationAllUsersTableEqualityConditions.@PathId( @pathId ) );
mod.@pathIdColumnValue.Value = @pathId;
mod.@pageSettingsColumnValue.Value = @pageSettings;
mod.@lastUpdatedDateColumnValue.Value = @lastUpdatedDate;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.aspnet_PersonalizationAllUsersTableCondition> getConditionList( CommandConditions.aspnet_PersonalizationAllUsersTableCondition requiredCondition, params CommandConditions.aspnet_PersonalizationAllUsersTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.aspnet_PersonalizationAllUsersTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @aspnet_PersonalizationAllUsersModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="pathId">Object does not allow null.</param>
/// <param name="pageSettings">Object does not allow null.</param>
/// <param name="lastUpdatedDate">Object does not allow null.</param>
public void SetAllData( System.Guid @pathId, System.Byte[] @pageSettings, DateTime @lastUpdatedDate ) {
this.@pathIdColumnValue.Value = @pathId;
this.@pageSettingsColumnValue.Value = @pageSettings;
this.@lastUpdatedDateColumnValue.Value = @lastUpdatedDate;
}
/// <summary>
/// Executes this aspnet_PersonalizationAllUsers modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this aspnet_PersonalizationAllUsers modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "aspnet_PersonalizationAllUsers" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.aspnet_PersonalizationAllUsersTableCondition>();
conditions.Add( new CommandConditions.@aspnet_PersonalizationAllUsersTableEqualityConditions.@PathId( @PathId ) );
}
else {
var update = new InlineUpdate( "aspnet_PersonalizationAllUsers" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @pathIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PathId", new DbParameterValue( @PathId, "UniqueIdentifier" ) ) );
if( @pageSettingsColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PageSettings", new DbParameterValue( @PageSettings, "Image" ) ) );
if( @lastUpdatedDateColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LastUpdatedDate", new DbParameterValue( @LastUpdatedDate, "DateTime" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@pathIdColumnValue.ClearChanged();
@pageSettingsColumnValue.ClearChanged();
@lastUpdatedDateColumnValue.ClearChanged();
}
}
public partial class @aspnet_PersonalizationPerUserModification {
/// <summary>
/// Inserts a row into the aspnet_PersonalizationPerUser table.
/// </summary>
/// <param name="id">Object does not allow null.</param>
/// <param name="pathId">Object allows null.</param>
/// <param name="userId">Object allows null.</param>
/// <param name="pageSettings">Object does not allow null.</param>
/// <param name="lastUpdatedDate">Object does not allow null.</param>
public static void InsertRow( System.Guid @id, System.Guid? @pathId, System.Guid? @userId, System.Byte[] @pageSettings, DateTime @lastUpdatedDate ) { 
var mod = CreateForInsert();
mod.@idColumnValue.Value = @id;
mod.@pathIdColumnValue.Value = @pathId;
mod.@userIdColumnValue.Value = @userId;
mod.@pageSettingsColumnValue.Value = @pageSettings;
mod.@lastUpdatedDateColumnValue.Value = @lastUpdatedDate;
mod.Execute();
}
/// <summary>
/// Inserts a row into the aspnet_PersonalizationPerUser table.
/// </summary>
/// <param name="id">Object does not allow null.</param>
/// <param name="pathId">Object allows null.</param>
/// <param name="userId">Object allows null.</param>
/// <param name="pageSettings">Object does not allow null.</param>
/// <param name="lastUpdatedDate">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( System.Guid @id, System.Guid? @pathId, System.Guid? @userId, System.Byte[] @pageSettings, DateTime @lastUpdatedDate ) { 
var mod = CreateForInsert();
mod.@idColumnValue.Value = @id;
mod.@pathIdColumnValue.Value = @pathId;
mod.@userIdColumnValue.Value = @userId;
mod.@pageSettingsColumnValue.Value = @pageSettings;
mod.@lastUpdatedDateColumnValue.Value = @lastUpdatedDate;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the aspnet_PersonalizationPerUser table that match the specified conditions with the specified data.
/// </summary>
/// <param name="id">Object does not allow null.</param>
/// <param name="pathId">Object allows null.</param>
/// <param name="userId">Object allows null.</param>
/// <param name="pageSettings">Object does not allow null.</param>
/// <param name="lastUpdatedDate">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( System.Guid @id, System.Guid? @pathId, System.Guid? @userId, System.Byte[] @pageSettings, DateTime @lastUpdatedDate, CommandConditions.aspnet_PersonalizationPerUserTableCondition requiredCondition, params CommandConditions.aspnet_PersonalizationPerUserTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@idColumnValue.Value = @id;
mod.@pathIdColumnValue.Value = @pathId;
mod.@userIdColumnValue.Value = @userId;
mod.@pageSettingsColumnValue.Value = @pageSettings;
mod.@lastUpdatedDateColumnValue.Value = @lastUpdatedDate;
mod.Execute();
}
/// <summary>
/// Updates rows in the aspnet_PersonalizationPerUser table that match the specified conditions with the specified data.
/// </summary>
/// <param name="id">Object does not allow null.</param>
/// <param name="pathId">Object allows null.</param>
/// <param name="userId">Object allows null.</param>
/// <param name="pageSettings">Object does not allow null.</param>
/// <param name="lastUpdatedDate">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( System.Guid @id, System.Guid? @pathId, System.Guid? @userId, System.Byte[] @pageSettings, DateTime @lastUpdatedDate, CommandConditions.aspnet_PersonalizationPerUserTableCondition requiredCondition, params CommandConditions.aspnet_PersonalizationPerUserTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@idColumnValue.Value = @id;
mod.@pathIdColumnValue.Value = @pathId;
mod.@userIdColumnValue.Value = @userId;
mod.@pageSettingsColumnValue.Value = @pageSettings;
mod.@lastUpdatedDateColumnValue.Value = @lastUpdatedDate;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.aspnet_PersonalizationPerUserTableCondition requiredCondition, params CommandConditions.aspnet_PersonalizationPerUserTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@aspnet_PersonalizationPerUserTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.aspnet_PersonalizationPerUserTableCondition requiredCondition, params CommandConditions.aspnet_PersonalizationPerUserTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.aspnet_PersonalizationPerUserTableCondition> conditions ) {
var delete = new InlineDelete( "aspnet_PersonalizationPerUser" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.aspnet_PersonalizationPerUserTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@aspnet_PersonalizationPerUserTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.aspnet_PersonalizationPerUserTableCondition> conditions;
private readonly DataValue<System.Guid> @idColumnValue = new DataValue<System.Guid>();
/// <summary>
/// Gets or sets the value for the Id column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Guid @Id { get { return @idColumnValue.Value; } set { @idColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Id has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @IdHasChanged { get { return @idColumnValue.Changed; } }
private readonly DataValue<System.Guid?> @pathIdColumnValue = new DataValue<System.Guid?>();
/// <summary>
/// Gets or sets the value for the PathId column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.Guid? @PathId { get { return @pathIdColumnValue.Value; } set { @pathIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PathId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PathIdHasChanged { get { return @pathIdColumnValue.Changed; } }
private readonly DataValue<System.Guid?> @userIdColumnValue = new DataValue<System.Guid?>();
/// <summary>
/// Gets or sets the value for the UserId column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.Guid? @UserId { get { return @userIdColumnValue.Value; } set { @userIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the UserId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @UserIdHasChanged { get { return @userIdColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @pageSettingsColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the PageSettings column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @PageSettings { get { return @pageSettingsColumnValue.Value; } set { @pageSettingsColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PageSettings has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PageSettingsHasChanged { get { return @pageSettingsColumnValue.Changed; } }
private readonly DataValue<DateTime> @lastUpdatedDateColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the LastUpdatedDate column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @LastUpdatedDate { get { return @lastUpdatedDateColumnValue.Value; } set { @lastUpdatedDateColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LastUpdatedDate has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LastUpdatedDateHasChanged { get { return @lastUpdatedDateColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the aspnet_PersonalizationPerUser table.
/// </summary>
public static @aspnet_PersonalizationPerUserModification CreateForInsert() {
return new @aspnet_PersonalizationPerUserModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the aspnet_PersonalizationPerUser table.
/// </summary>
public static @aspnet_PersonalizationPerUserModification CreateForUpdate( CommandConditions.aspnet_PersonalizationPerUserTableCondition requiredCondition, params CommandConditions.aspnet_PersonalizationPerUserTableCondition[] additionalConditions ) {
var mod = new @aspnet_PersonalizationPerUserModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@aspnet_PersonalizationPerUserTableEqualityConditions.@Id )
mod.@idColumnValue.Value = ( condition as CommandConditions.@aspnet_PersonalizationPerUserTableEqualityConditions.@Id ).Value;
else if( condition is CommandConditions.@aspnet_PersonalizationPerUserTableEqualityConditions.@PathId )
mod.@pathIdColumnValue.Value = ( condition as CommandConditions.@aspnet_PersonalizationPerUserTableEqualityConditions.@PathId ).Value;
else if( condition is CommandConditions.@aspnet_PersonalizationPerUserTableEqualityConditions.@UserId )
mod.@userIdColumnValue.Value = ( condition as CommandConditions.@aspnet_PersonalizationPerUserTableEqualityConditions.@UserId ).Value;
else if( condition is CommandConditions.@aspnet_PersonalizationPerUserTableEqualityConditions.@PageSettings )
mod.@pageSettingsColumnValue.Value = ( condition as CommandConditions.@aspnet_PersonalizationPerUserTableEqualityConditions.@PageSettings ).Value;
else if( condition is CommandConditions.@aspnet_PersonalizationPerUserTableEqualityConditions.@LastUpdatedDate )
mod.@lastUpdatedDateColumnValue.Value = ( condition as CommandConditions.@aspnet_PersonalizationPerUserTableEqualityConditions.@LastUpdatedDate ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the aspnet_PersonalizationPerUser table.
/// </summary>
public static @aspnet_PersonalizationPerUserModification CreateForSingleRowUpdate( System.Guid @id, System.Guid? @pathId, System.Guid? @userId, System.Byte[] @pageSettings, DateTime @lastUpdatedDate ) {
var mod = new @aspnet_PersonalizationPerUserModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.aspnet_PersonalizationPerUserTableCondition>();
mod.conditions.Add( new CommandConditions.@aspnet_PersonalizationPerUserTableEqualityConditions.@PathId( @pathId ) );
mod.conditions.Add( new CommandConditions.@aspnet_PersonalizationPerUserTableEqualityConditions.@UserId( @userId ) );
mod.@idColumnValue.Value = @id;
mod.@pathIdColumnValue.Value = @pathId;
mod.@userIdColumnValue.Value = @userId;
mod.@pageSettingsColumnValue.Value = @pageSettings;
mod.@lastUpdatedDateColumnValue.Value = @lastUpdatedDate;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.aspnet_PersonalizationPerUserTableCondition> getConditionList( CommandConditions.aspnet_PersonalizationPerUserTableCondition requiredCondition, params CommandConditions.aspnet_PersonalizationPerUserTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.aspnet_PersonalizationPerUserTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @aspnet_PersonalizationPerUserModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="id">Object does not allow null.</param>
/// <param name="pathId">Object allows null.</param>
/// <param name="userId">Object allows null.</param>
/// <param name="pageSettings">Object does not allow null.</param>
/// <param name="lastUpdatedDate">Object does not allow null.</param>
public void SetAllData( System.Guid @id, System.Guid? @pathId, System.Guid? @userId, System.Byte[] @pageSettings, DateTime @lastUpdatedDate ) {
this.@idColumnValue.Value = @id;
this.@pathIdColumnValue.Value = @pathId;
this.@userIdColumnValue.Value = @userId;
this.@pageSettingsColumnValue.Value = @pageSettings;
this.@lastUpdatedDateColumnValue.Value = @lastUpdatedDate;
}
/// <summary>
/// Executes this aspnet_PersonalizationPerUser modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this aspnet_PersonalizationPerUser modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "aspnet_PersonalizationPerUser" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.aspnet_PersonalizationPerUserTableCondition>();
conditions.Add( new CommandConditions.@aspnet_PersonalizationPerUserTableEqualityConditions.@PathId( @PathId ) );
conditions.Add( new CommandConditions.@aspnet_PersonalizationPerUserTableEqualityConditions.@UserId( @UserId ) );
}
else {
var update = new InlineUpdate( "aspnet_PersonalizationPerUser" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @idColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Id", new DbParameterValue( @Id, "UniqueIdentifier" ) ) );
if( @pathIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PathId", new DbParameterValue( @PathId, "UniqueIdentifier" ) ) );
if( @userIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( @UserId, "UniqueIdentifier" ) ) );
if( @pageSettingsColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PageSettings", new DbParameterValue( @PageSettings, "Image" ) ) );
if( @lastUpdatedDateColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LastUpdatedDate", new DbParameterValue( @LastUpdatedDate, "DateTime" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@idColumnValue.ClearChanged();
@pathIdColumnValue.ClearChanged();
@userIdColumnValue.ClearChanged();
@pageSettingsColumnValue.ClearChanged();
@lastUpdatedDateColumnValue.ClearChanged();
}
}
public partial class @aspnet_ProfileModification {
/// <summary>
/// Inserts a row into the aspnet_Profile table.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="propertyNames">Object does not allow null.</param>
/// <param name="propertyValuesString">Object does not allow null.</param>
/// <param name="propertyValuesBinary">Object does not allow null.</param>
/// <param name="lastUpdatedDate">Object does not allow null.</param>
public static void InsertRow( System.Guid @userId, string @propertyNames, string @propertyValuesString, System.Byte[] @propertyValuesBinary, DateTime @lastUpdatedDate ) { 
var mod = CreateForInsert();
mod.@userIdColumnValue.Value = @userId;
mod.@propertyNamesColumnValue.Value = @propertyNames;
mod.@propertyValuesStringColumnValue.Value = @propertyValuesString;
mod.@propertyValuesBinaryColumnValue.Value = @propertyValuesBinary;
mod.@lastUpdatedDateColumnValue.Value = @lastUpdatedDate;
mod.Execute();
}
/// <summary>
/// Inserts a row into the aspnet_Profile table.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="propertyNames">Object does not allow null.</param>
/// <param name="propertyValuesString">Object does not allow null.</param>
/// <param name="propertyValuesBinary">Object does not allow null.</param>
/// <param name="lastUpdatedDate">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( System.Guid @userId, string @propertyNames, string @propertyValuesString, System.Byte[] @propertyValuesBinary, DateTime @lastUpdatedDate ) { 
var mod = CreateForInsert();
mod.@userIdColumnValue.Value = @userId;
mod.@propertyNamesColumnValue.Value = @propertyNames;
mod.@propertyValuesStringColumnValue.Value = @propertyValuesString;
mod.@propertyValuesBinaryColumnValue.Value = @propertyValuesBinary;
mod.@lastUpdatedDateColumnValue.Value = @lastUpdatedDate;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the aspnet_Profile table that match the specified conditions with the specified data.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="propertyNames">Object does not allow null.</param>
/// <param name="propertyValuesString">Object does not allow null.</param>
/// <param name="propertyValuesBinary">Object does not allow null.</param>
/// <param name="lastUpdatedDate">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( System.Guid @userId, string @propertyNames, string @propertyValuesString, System.Byte[] @propertyValuesBinary, DateTime @lastUpdatedDate, CommandConditions.aspnet_ProfileTableCondition requiredCondition, params CommandConditions.aspnet_ProfileTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@userIdColumnValue.Value = @userId;
mod.@propertyNamesColumnValue.Value = @propertyNames;
mod.@propertyValuesStringColumnValue.Value = @propertyValuesString;
mod.@propertyValuesBinaryColumnValue.Value = @propertyValuesBinary;
mod.@lastUpdatedDateColumnValue.Value = @lastUpdatedDate;
mod.Execute();
}
/// <summary>
/// Updates rows in the aspnet_Profile table that match the specified conditions with the specified data.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="propertyNames">Object does not allow null.</param>
/// <param name="propertyValuesString">Object does not allow null.</param>
/// <param name="propertyValuesBinary">Object does not allow null.</param>
/// <param name="lastUpdatedDate">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( System.Guid @userId, string @propertyNames, string @propertyValuesString, System.Byte[] @propertyValuesBinary, DateTime @lastUpdatedDate, CommandConditions.aspnet_ProfileTableCondition requiredCondition, params CommandConditions.aspnet_ProfileTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@userIdColumnValue.Value = @userId;
mod.@propertyNamesColumnValue.Value = @propertyNames;
mod.@propertyValuesStringColumnValue.Value = @propertyValuesString;
mod.@propertyValuesBinaryColumnValue.Value = @propertyValuesBinary;
mod.@lastUpdatedDateColumnValue.Value = @lastUpdatedDate;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.aspnet_ProfileTableCondition requiredCondition, params CommandConditions.aspnet_ProfileTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@aspnet_ProfileTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.aspnet_ProfileTableCondition requiredCondition, params CommandConditions.aspnet_ProfileTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.aspnet_ProfileTableCondition> conditions ) {
var delete = new InlineDelete( "aspnet_Profile" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.aspnet_ProfileTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@aspnet_ProfileTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.aspnet_ProfileTableCondition> conditions;
private readonly DataValue<System.Guid> @userIdColumnValue = new DataValue<System.Guid>();
/// <summary>
/// Gets or sets the value for the UserId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Guid @UserId { get { return @userIdColumnValue.Value; } set { @userIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the UserId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @UserIdHasChanged { get { return @userIdColumnValue.Changed; } }
private readonly DataValue<string> @propertyNamesColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the PropertyNames column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @PropertyNames { get { return @propertyNamesColumnValue.Value; } set { @propertyNamesColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PropertyNames has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PropertyNamesHasChanged { get { return @propertyNamesColumnValue.Changed; } }
private readonly DataValue<string> @propertyValuesStringColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the PropertyValuesString column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @PropertyValuesString { get { return @propertyValuesStringColumnValue.Value; } set { @propertyValuesStringColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PropertyValuesString has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PropertyValuesStringHasChanged { get { return @propertyValuesStringColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @propertyValuesBinaryColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the PropertyValuesBinary column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @PropertyValuesBinary { get { return @propertyValuesBinaryColumnValue.Value; } set { @propertyValuesBinaryColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PropertyValuesBinary has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PropertyValuesBinaryHasChanged { get { return @propertyValuesBinaryColumnValue.Changed; } }
private readonly DataValue<DateTime> @lastUpdatedDateColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the LastUpdatedDate column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @LastUpdatedDate { get { return @lastUpdatedDateColumnValue.Value; } set { @lastUpdatedDateColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LastUpdatedDate has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LastUpdatedDateHasChanged { get { return @lastUpdatedDateColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the aspnet_Profile table.
/// </summary>
public static @aspnet_ProfileModification CreateForInsert() {
return new @aspnet_ProfileModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the aspnet_Profile table.
/// </summary>
public static @aspnet_ProfileModification CreateForUpdate( CommandConditions.aspnet_ProfileTableCondition requiredCondition, params CommandConditions.aspnet_ProfileTableCondition[] additionalConditions ) {
var mod = new @aspnet_ProfileModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@aspnet_ProfileTableEqualityConditions.@UserId )
mod.@userIdColumnValue.Value = ( condition as CommandConditions.@aspnet_ProfileTableEqualityConditions.@UserId ).Value;
else if( condition is CommandConditions.@aspnet_ProfileTableEqualityConditions.@PropertyNames )
mod.@propertyNamesColumnValue.Value = ( condition as CommandConditions.@aspnet_ProfileTableEqualityConditions.@PropertyNames ).Value;
else if( condition is CommandConditions.@aspnet_ProfileTableEqualityConditions.@PropertyValuesString )
mod.@propertyValuesStringColumnValue.Value = ( condition as CommandConditions.@aspnet_ProfileTableEqualityConditions.@PropertyValuesString ).Value;
else if( condition is CommandConditions.@aspnet_ProfileTableEqualityConditions.@PropertyValuesBinary )
mod.@propertyValuesBinaryColumnValue.Value = ( condition as CommandConditions.@aspnet_ProfileTableEqualityConditions.@PropertyValuesBinary ).Value;
else if( condition is CommandConditions.@aspnet_ProfileTableEqualityConditions.@LastUpdatedDate )
mod.@lastUpdatedDateColumnValue.Value = ( condition as CommandConditions.@aspnet_ProfileTableEqualityConditions.@LastUpdatedDate ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the aspnet_Profile table.
/// </summary>
public static @aspnet_ProfileModification CreateForSingleRowUpdate( System.Guid @userId, string @propertyNames, string @propertyValuesString, System.Byte[] @propertyValuesBinary, DateTime @lastUpdatedDate ) {
var mod = new @aspnet_ProfileModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.aspnet_ProfileTableCondition>();
mod.conditions.Add( new CommandConditions.@aspnet_ProfileTableEqualityConditions.@UserId( @userId ) );
mod.@userIdColumnValue.Value = @userId;
mod.@propertyNamesColumnValue.Value = @propertyNames;
mod.@propertyValuesStringColumnValue.Value = @propertyValuesString;
mod.@propertyValuesBinaryColumnValue.Value = @propertyValuesBinary;
mod.@lastUpdatedDateColumnValue.Value = @lastUpdatedDate;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.aspnet_ProfileTableCondition> getConditionList( CommandConditions.aspnet_ProfileTableCondition requiredCondition, params CommandConditions.aspnet_ProfileTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.aspnet_ProfileTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @aspnet_ProfileModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="propertyNames">Object does not allow null.</param>
/// <param name="propertyValuesString">Object does not allow null.</param>
/// <param name="propertyValuesBinary">Object does not allow null.</param>
/// <param name="lastUpdatedDate">Object does not allow null.</param>
public void SetAllData( System.Guid @userId, string @propertyNames, string @propertyValuesString, System.Byte[] @propertyValuesBinary, DateTime @lastUpdatedDate ) {
this.@userIdColumnValue.Value = @userId;
this.@propertyNamesColumnValue.Value = @propertyNames;
this.@propertyValuesStringColumnValue.Value = @propertyValuesString;
this.@propertyValuesBinaryColumnValue.Value = @propertyValuesBinary;
this.@lastUpdatedDateColumnValue.Value = @lastUpdatedDate;
}
/// <summary>
/// Executes this aspnet_Profile modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this aspnet_Profile modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "aspnet_Profile" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.aspnet_ProfileTableCondition>();
conditions.Add( new CommandConditions.@aspnet_ProfileTableEqualityConditions.@UserId( @UserId ) );
}
else {
var update = new InlineUpdate( "aspnet_Profile" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @userIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( @UserId, "UniqueIdentifier" ) ) );
if( @propertyNamesColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PropertyNames", new DbParameterValue( @PropertyNames, "NText" ) ) );
if( @propertyValuesStringColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PropertyValuesString", new DbParameterValue( @PropertyValuesString, "NText" ) ) );
if( @propertyValuesBinaryColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PropertyValuesBinary", new DbParameterValue( @PropertyValuesBinary, "Image" ) ) );
if( @lastUpdatedDateColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LastUpdatedDate", new DbParameterValue( @LastUpdatedDate, "DateTime" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@userIdColumnValue.ClearChanged();
@propertyNamesColumnValue.ClearChanged();
@propertyValuesStringColumnValue.ClearChanged();
@propertyValuesBinaryColumnValue.ClearChanged();
@lastUpdatedDateColumnValue.ClearChanged();
}
}
public partial class @aspnet_RolesModification {
/// <summary>
/// Inserts a row into the aspnet_Roles table.
/// </summary>
/// <param name="applicationId">Object does not allow null.</param>
/// <param name="roleId">Object does not allow null.</param>
/// <param name="roleName">Object does not allow null.</param>
/// <param name="loweredRoleName">Object does not allow null.</param>
/// <param name="description">Object allows null.</param>
public static void InsertRow( System.Guid @applicationId, System.Guid @roleId, string @roleName, string @loweredRoleName, System.String @description ) { 
var mod = CreateForInsert();
mod.@applicationIdColumnValue.Value = @applicationId;
mod.@roleIdColumnValue.Value = @roleId;
mod.@roleNameColumnValue.Value = @roleName;
mod.@loweredRoleNameColumnValue.Value = @loweredRoleName;
mod.@descriptionColumnValue.Value = @description;
mod.Execute();
}
/// <summary>
/// Inserts a row into the aspnet_Roles table.
/// </summary>
/// <param name="applicationId">Object does not allow null.</param>
/// <param name="roleId">Object does not allow null.</param>
/// <param name="roleName">Object does not allow null.</param>
/// <param name="loweredRoleName">Object does not allow null.</param>
/// <param name="description">Object allows null.</param>
public static void InsertRowWithoutAdditionalLogic( System.Guid @applicationId, System.Guid @roleId, string @roleName, string @loweredRoleName, System.String @description ) { 
var mod = CreateForInsert();
mod.@applicationIdColumnValue.Value = @applicationId;
mod.@roleIdColumnValue.Value = @roleId;
mod.@roleNameColumnValue.Value = @roleName;
mod.@loweredRoleNameColumnValue.Value = @loweredRoleName;
mod.@descriptionColumnValue.Value = @description;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the aspnet_Roles table that match the specified conditions with the specified data.
/// </summary>
/// <param name="applicationId">Object does not allow null.</param>
/// <param name="roleId">Object does not allow null.</param>
/// <param name="roleName">Object does not allow null.</param>
/// <param name="loweredRoleName">Object does not allow null.</param>
/// <param name="description">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( System.Guid @applicationId, System.Guid @roleId, string @roleName, string @loweredRoleName, System.String @description, CommandConditions.aspnet_RolesTableCondition requiredCondition, params CommandConditions.aspnet_RolesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@applicationIdColumnValue.Value = @applicationId;
mod.@roleIdColumnValue.Value = @roleId;
mod.@roleNameColumnValue.Value = @roleName;
mod.@loweredRoleNameColumnValue.Value = @loweredRoleName;
mod.@descriptionColumnValue.Value = @description;
mod.Execute();
}
/// <summary>
/// Updates rows in the aspnet_Roles table that match the specified conditions with the specified data.
/// </summary>
/// <param name="applicationId">Object does not allow null.</param>
/// <param name="roleId">Object does not allow null.</param>
/// <param name="roleName">Object does not allow null.</param>
/// <param name="loweredRoleName">Object does not allow null.</param>
/// <param name="description">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( System.Guid @applicationId, System.Guid @roleId, string @roleName, string @loweredRoleName, System.String @description, CommandConditions.aspnet_RolesTableCondition requiredCondition, params CommandConditions.aspnet_RolesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@applicationIdColumnValue.Value = @applicationId;
mod.@roleIdColumnValue.Value = @roleId;
mod.@roleNameColumnValue.Value = @roleName;
mod.@loweredRoleNameColumnValue.Value = @loweredRoleName;
mod.@descriptionColumnValue.Value = @description;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.aspnet_RolesTableCondition requiredCondition, params CommandConditions.aspnet_RolesTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@aspnet_RolesTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.aspnet_RolesTableCondition requiredCondition, params CommandConditions.aspnet_RolesTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.aspnet_RolesTableCondition> conditions ) {
var delete = new InlineDelete( "aspnet_Roles" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.aspnet_RolesTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@aspnet_RolesTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.aspnet_RolesTableCondition> conditions;
private readonly DataValue<System.Guid> @applicationIdColumnValue = new DataValue<System.Guid>();
/// <summary>
/// Gets or sets the value for the ApplicationId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Guid @ApplicationId { get { return @applicationIdColumnValue.Value; } set { @applicationIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ApplicationId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ApplicationIdHasChanged { get { return @applicationIdColumnValue.Changed; } }
private readonly DataValue<System.Guid> @roleIdColumnValue = new DataValue<System.Guid>();
/// <summary>
/// Gets or sets the value for the RoleId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Guid @RoleId { get { return @roleIdColumnValue.Value; } set { @roleIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the RoleId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @RoleIdHasChanged { get { return @roleIdColumnValue.Changed; } }
private readonly DataValue<string> @roleNameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the RoleName column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @RoleName { get { return @roleNameColumnValue.Value; } set { @roleNameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the RoleName has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @RoleNameHasChanged { get { return @roleNameColumnValue.Changed; } }
private readonly DataValue<string> @loweredRoleNameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the LoweredRoleName column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @LoweredRoleName { get { return @loweredRoleNameColumnValue.Value; } set { @loweredRoleNameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LoweredRoleName has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LoweredRoleNameHasChanged { get { return @loweredRoleNameColumnValue.Changed; } }
private readonly DataValue<System.String> @descriptionColumnValue = new DataValue<System.String>();
/// <summary>
/// Gets or sets the value for the Description column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.String @Description { get { return @descriptionColumnValue.Value; } set { @descriptionColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Description has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @DescriptionHasChanged { get { return @descriptionColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the aspnet_Roles table.
/// </summary>
public static @aspnet_RolesModification CreateForInsert() {
return new @aspnet_RolesModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the aspnet_Roles table.
/// </summary>
public static @aspnet_RolesModification CreateForUpdate( CommandConditions.aspnet_RolesTableCondition requiredCondition, params CommandConditions.aspnet_RolesTableCondition[] additionalConditions ) {
var mod = new @aspnet_RolesModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@aspnet_RolesTableEqualityConditions.@ApplicationId )
mod.@applicationIdColumnValue.Value = ( condition as CommandConditions.@aspnet_RolesTableEqualityConditions.@ApplicationId ).Value;
else if( condition is CommandConditions.@aspnet_RolesTableEqualityConditions.@RoleId )
mod.@roleIdColumnValue.Value = ( condition as CommandConditions.@aspnet_RolesTableEqualityConditions.@RoleId ).Value;
else if( condition is CommandConditions.@aspnet_RolesTableEqualityConditions.@RoleName )
mod.@roleNameColumnValue.Value = ( condition as CommandConditions.@aspnet_RolesTableEqualityConditions.@RoleName ).Value;
else if( condition is CommandConditions.@aspnet_RolesTableEqualityConditions.@LoweredRoleName )
mod.@loweredRoleNameColumnValue.Value = ( condition as CommandConditions.@aspnet_RolesTableEqualityConditions.@LoweredRoleName ).Value;
else if( condition is CommandConditions.@aspnet_RolesTableEqualityConditions.@Description )
mod.@descriptionColumnValue.Value = ( condition as CommandConditions.@aspnet_RolesTableEqualityConditions.@Description ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the aspnet_Roles table.
/// </summary>
public static @aspnet_RolesModification CreateForSingleRowUpdate( System.Guid @applicationId, System.Guid @roleId, string @roleName, string @loweredRoleName, System.String @description ) {
var mod = new @aspnet_RolesModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.aspnet_RolesTableCondition>();
mod.conditions.Add( new CommandConditions.@aspnet_RolesTableEqualityConditions.@ApplicationId( @applicationId ) );
mod.conditions.Add( new CommandConditions.@aspnet_RolesTableEqualityConditions.@LoweredRoleName( @loweredRoleName ) );
mod.@applicationIdColumnValue.Value = @applicationId;
mod.@roleIdColumnValue.Value = @roleId;
mod.@roleNameColumnValue.Value = @roleName;
mod.@loweredRoleNameColumnValue.Value = @loweredRoleName;
mod.@descriptionColumnValue.Value = @description;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.aspnet_RolesTableCondition> getConditionList( CommandConditions.aspnet_RolesTableCondition requiredCondition, params CommandConditions.aspnet_RolesTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.aspnet_RolesTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @aspnet_RolesModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="applicationId">Object does not allow null.</param>
/// <param name="roleId">Object does not allow null.</param>
/// <param name="roleName">Object does not allow null.</param>
/// <param name="loweredRoleName">Object does not allow null.</param>
/// <param name="description">Object allows null.</param>
public void SetAllData( System.Guid @applicationId, System.Guid @roleId, string @roleName, string @loweredRoleName, System.String @description ) {
this.@applicationIdColumnValue.Value = @applicationId;
this.@roleIdColumnValue.Value = @roleId;
this.@roleNameColumnValue.Value = @roleName;
this.@loweredRoleNameColumnValue.Value = @loweredRoleName;
this.@descriptionColumnValue.Value = @description;
}
/// <summary>
/// Executes this aspnet_Roles modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this aspnet_Roles modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "aspnet_Roles" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.aspnet_RolesTableCondition>();
conditions.Add( new CommandConditions.@aspnet_RolesTableEqualityConditions.@ApplicationId( @ApplicationId ) );
conditions.Add( new CommandConditions.@aspnet_RolesTableEqualityConditions.@LoweredRoleName( @LoweredRoleName ) );
}
else {
var update = new InlineUpdate( "aspnet_Roles" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @applicationIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ApplicationId", new DbParameterValue( @ApplicationId, "UniqueIdentifier" ) ) );
if( @roleIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "RoleId", new DbParameterValue( @RoleId, "UniqueIdentifier" ) ) );
if( @roleNameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "RoleName", new DbParameterValue( @RoleName, "NVarChar" ) ) );
if( @loweredRoleNameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LoweredRoleName", new DbParameterValue( @LoweredRoleName, "NVarChar" ) ) );
if( @descriptionColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Description", new DbParameterValue( @Description, "NVarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@applicationIdColumnValue.ClearChanged();
@roleIdColumnValue.ClearChanged();
@roleNameColumnValue.ClearChanged();
@loweredRoleNameColumnValue.ClearChanged();
@descriptionColumnValue.ClearChanged();
}
}
public partial class @aspnet_SchemaVersionsModification {
/// <summary>
/// Inserts a row into the aspnet_SchemaVersions table.
/// </summary>
/// <param name="feature">Object does not allow null.</param>
/// <param name="compatibleSchemaVersion">Object does not allow null.</param>
/// <param name="isCurrentVersion">Object does not allow null.</param>
public static void InsertRow( string @feature, string @compatibleSchemaVersion, System.Boolean @isCurrentVersion ) { 
var mod = CreateForInsert();
mod.@featureColumnValue.Value = @feature;
mod.@compatibleSchemaVersionColumnValue.Value = @compatibleSchemaVersion;
mod.@isCurrentVersionColumnValue.Value = @isCurrentVersion;
mod.Execute();
}
/// <summary>
/// Inserts a row into the aspnet_SchemaVersions table.
/// </summary>
/// <param name="feature">Object does not allow null.</param>
/// <param name="compatibleSchemaVersion">Object does not allow null.</param>
/// <param name="isCurrentVersion">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( string @feature, string @compatibleSchemaVersion, System.Boolean @isCurrentVersion ) { 
var mod = CreateForInsert();
mod.@featureColumnValue.Value = @feature;
mod.@compatibleSchemaVersionColumnValue.Value = @compatibleSchemaVersion;
mod.@isCurrentVersionColumnValue.Value = @isCurrentVersion;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the aspnet_SchemaVersions table that match the specified conditions with the specified data.
/// </summary>
/// <param name="feature">Object does not allow null.</param>
/// <param name="compatibleSchemaVersion">Object does not allow null.</param>
/// <param name="isCurrentVersion">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( string @feature, string @compatibleSchemaVersion, System.Boolean @isCurrentVersion, CommandConditions.aspnet_SchemaVersionsTableCondition requiredCondition, params CommandConditions.aspnet_SchemaVersionsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@featureColumnValue.Value = @feature;
mod.@compatibleSchemaVersionColumnValue.Value = @compatibleSchemaVersion;
mod.@isCurrentVersionColumnValue.Value = @isCurrentVersion;
mod.Execute();
}
/// <summary>
/// Updates rows in the aspnet_SchemaVersions table that match the specified conditions with the specified data.
/// </summary>
/// <param name="feature">Object does not allow null.</param>
/// <param name="compatibleSchemaVersion">Object does not allow null.</param>
/// <param name="isCurrentVersion">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( string @feature, string @compatibleSchemaVersion, System.Boolean @isCurrentVersion, CommandConditions.aspnet_SchemaVersionsTableCondition requiredCondition, params CommandConditions.aspnet_SchemaVersionsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@featureColumnValue.Value = @feature;
mod.@compatibleSchemaVersionColumnValue.Value = @compatibleSchemaVersion;
mod.@isCurrentVersionColumnValue.Value = @isCurrentVersion;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.aspnet_SchemaVersionsTableCondition requiredCondition, params CommandConditions.aspnet_SchemaVersionsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@aspnet_SchemaVersionsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.aspnet_SchemaVersionsTableCondition requiredCondition, params CommandConditions.aspnet_SchemaVersionsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.aspnet_SchemaVersionsTableCondition> conditions ) {
var delete = new InlineDelete( "aspnet_SchemaVersions" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.aspnet_SchemaVersionsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@aspnet_SchemaVersionsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.aspnet_SchemaVersionsTableCondition> conditions;
private readonly DataValue<string> @featureColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Feature column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Feature { get { return @featureColumnValue.Value; } set { @featureColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Feature has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @FeatureHasChanged { get { return @featureColumnValue.Changed; } }
private readonly DataValue<string> @compatibleSchemaVersionColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the CompatibleSchemaVersion column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @CompatibleSchemaVersion { get { return @compatibleSchemaVersionColumnValue.Value; } set { @compatibleSchemaVersionColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the CompatibleSchemaVersion has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @CompatibleSchemaVersionHasChanged { get { return @compatibleSchemaVersionColumnValue.Changed; } }
private readonly DataValue<System.Boolean> @isCurrentVersionColumnValue = new DataValue<System.Boolean>();
/// <summary>
/// Gets or sets the value for the IsCurrentVersion column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Boolean @IsCurrentVersion { get { return @isCurrentVersionColumnValue.Value; } set { @isCurrentVersionColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the IsCurrentVersion has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @IsCurrentVersionHasChanged { get { return @isCurrentVersionColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the aspnet_SchemaVersions table.
/// </summary>
public static @aspnet_SchemaVersionsModification CreateForInsert() {
return new @aspnet_SchemaVersionsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the aspnet_SchemaVersions table.
/// </summary>
public static @aspnet_SchemaVersionsModification CreateForUpdate( CommandConditions.aspnet_SchemaVersionsTableCondition requiredCondition, params CommandConditions.aspnet_SchemaVersionsTableCondition[] additionalConditions ) {
var mod = new @aspnet_SchemaVersionsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@aspnet_SchemaVersionsTableEqualityConditions.@Feature )
mod.@featureColumnValue.Value = ( condition as CommandConditions.@aspnet_SchemaVersionsTableEqualityConditions.@Feature ).Value;
else if( condition is CommandConditions.@aspnet_SchemaVersionsTableEqualityConditions.@CompatibleSchemaVersion )
mod.@compatibleSchemaVersionColumnValue.Value = ( condition as CommandConditions.@aspnet_SchemaVersionsTableEqualityConditions.@CompatibleSchemaVersion ).Value;
else if( condition is CommandConditions.@aspnet_SchemaVersionsTableEqualityConditions.@IsCurrentVersion )
mod.@isCurrentVersionColumnValue.Value = ( condition as CommandConditions.@aspnet_SchemaVersionsTableEqualityConditions.@IsCurrentVersion ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the aspnet_SchemaVersions table.
/// </summary>
public static @aspnet_SchemaVersionsModification CreateForSingleRowUpdate( string @feature, string @compatibleSchemaVersion, System.Boolean @isCurrentVersion ) {
var mod = new @aspnet_SchemaVersionsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.aspnet_SchemaVersionsTableCondition>();
mod.conditions.Add( new CommandConditions.@aspnet_SchemaVersionsTableEqualityConditions.@Feature( @feature ) );
mod.conditions.Add( new CommandConditions.@aspnet_SchemaVersionsTableEqualityConditions.@CompatibleSchemaVersion( @compatibleSchemaVersion ) );
mod.@featureColumnValue.Value = @feature;
mod.@compatibleSchemaVersionColumnValue.Value = @compatibleSchemaVersion;
mod.@isCurrentVersionColumnValue.Value = @isCurrentVersion;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.aspnet_SchemaVersionsTableCondition> getConditionList( CommandConditions.aspnet_SchemaVersionsTableCondition requiredCondition, params CommandConditions.aspnet_SchemaVersionsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.aspnet_SchemaVersionsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @aspnet_SchemaVersionsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="feature">Object does not allow null.</param>
/// <param name="compatibleSchemaVersion">Object does not allow null.</param>
/// <param name="isCurrentVersion">Object does not allow null.</param>
public void SetAllData( string @feature, string @compatibleSchemaVersion, System.Boolean @isCurrentVersion ) {
this.@featureColumnValue.Value = @feature;
this.@compatibleSchemaVersionColumnValue.Value = @compatibleSchemaVersion;
this.@isCurrentVersionColumnValue.Value = @isCurrentVersion;
}
/// <summary>
/// Executes this aspnet_SchemaVersions modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this aspnet_SchemaVersions modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "aspnet_SchemaVersions" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.aspnet_SchemaVersionsTableCondition>();
conditions.Add( new CommandConditions.@aspnet_SchemaVersionsTableEqualityConditions.@Feature( @Feature ) );
conditions.Add( new CommandConditions.@aspnet_SchemaVersionsTableEqualityConditions.@CompatibleSchemaVersion( @CompatibleSchemaVersion ) );
}
else {
var update = new InlineUpdate( "aspnet_SchemaVersions" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @featureColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Feature", new DbParameterValue( @Feature, "NVarChar" ) ) );
if( @compatibleSchemaVersionColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "CompatibleSchemaVersion", new DbParameterValue( @CompatibleSchemaVersion, "NVarChar" ) ) );
if( @isCurrentVersionColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "IsCurrentVersion", new DbParameterValue( @IsCurrentVersion, "Bit" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@featureColumnValue.ClearChanged();
@compatibleSchemaVersionColumnValue.ClearChanged();
@isCurrentVersionColumnValue.ClearChanged();
}
}
public partial class @aspnet_UsersModification {
/// <summary>
/// Inserts a row into the aspnet_Users table.
/// </summary>
/// <param name="applicationId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="userName">Object does not allow null.</param>
/// <param name="loweredUserName">Object does not allow null.</param>
/// <param name="mobileAlias">Object allows null.</param>
/// <param name="isAnonymous">Object does not allow null.</param>
/// <param name="lastActivityDate">Object does not allow null.</param>
public static void InsertRow( System.Guid @applicationId, System.Guid @userId, string @userName, string @loweredUserName, System.String @mobileAlias, System.Boolean @isAnonymous, DateTime @lastActivityDate ) { 
var mod = CreateForInsert();
mod.@applicationIdColumnValue.Value = @applicationId;
mod.@userIdColumnValue.Value = @userId;
mod.@userNameColumnValue.Value = @userName;
mod.@loweredUserNameColumnValue.Value = @loweredUserName;
mod.@mobileAliasColumnValue.Value = @mobileAlias;
mod.@isAnonymousColumnValue.Value = @isAnonymous;
mod.@lastActivityDateColumnValue.Value = @lastActivityDate;
mod.Execute();
}
/// <summary>
/// Inserts a row into the aspnet_Users table.
/// </summary>
/// <param name="applicationId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="userName">Object does not allow null.</param>
/// <param name="loweredUserName">Object does not allow null.</param>
/// <param name="mobileAlias">Object allows null.</param>
/// <param name="isAnonymous">Object does not allow null.</param>
/// <param name="lastActivityDate">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( System.Guid @applicationId, System.Guid @userId, string @userName, string @loweredUserName, System.String @mobileAlias, System.Boolean @isAnonymous, DateTime @lastActivityDate ) { 
var mod = CreateForInsert();
mod.@applicationIdColumnValue.Value = @applicationId;
mod.@userIdColumnValue.Value = @userId;
mod.@userNameColumnValue.Value = @userName;
mod.@loweredUserNameColumnValue.Value = @loweredUserName;
mod.@mobileAliasColumnValue.Value = @mobileAlias;
mod.@isAnonymousColumnValue.Value = @isAnonymous;
mod.@lastActivityDateColumnValue.Value = @lastActivityDate;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the aspnet_Users table that match the specified conditions with the specified data.
/// </summary>
/// <param name="applicationId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="userName">Object does not allow null.</param>
/// <param name="loweredUserName">Object does not allow null.</param>
/// <param name="mobileAlias">Object allows null.</param>
/// <param name="isAnonymous">Object does not allow null.</param>
/// <param name="lastActivityDate">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( System.Guid @applicationId, System.Guid @userId, string @userName, string @loweredUserName, System.String @mobileAlias, System.Boolean @isAnonymous, DateTime @lastActivityDate, CommandConditions.aspnet_UsersTableCondition requiredCondition, params CommandConditions.aspnet_UsersTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@applicationIdColumnValue.Value = @applicationId;
mod.@userIdColumnValue.Value = @userId;
mod.@userNameColumnValue.Value = @userName;
mod.@loweredUserNameColumnValue.Value = @loweredUserName;
mod.@mobileAliasColumnValue.Value = @mobileAlias;
mod.@isAnonymousColumnValue.Value = @isAnonymous;
mod.@lastActivityDateColumnValue.Value = @lastActivityDate;
mod.Execute();
}
/// <summary>
/// Updates rows in the aspnet_Users table that match the specified conditions with the specified data.
/// </summary>
/// <param name="applicationId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="userName">Object does not allow null.</param>
/// <param name="loweredUserName">Object does not allow null.</param>
/// <param name="mobileAlias">Object allows null.</param>
/// <param name="isAnonymous">Object does not allow null.</param>
/// <param name="lastActivityDate">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( System.Guid @applicationId, System.Guid @userId, string @userName, string @loweredUserName, System.String @mobileAlias, System.Boolean @isAnonymous, DateTime @lastActivityDate, CommandConditions.aspnet_UsersTableCondition requiredCondition, params CommandConditions.aspnet_UsersTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@applicationIdColumnValue.Value = @applicationId;
mod.@userIdColumnValue.Value = @userId;
mod.@userNameColumnValue.Value = @userName;
mod.@loweredUserNameColumnValue.Value = @loweredUserName;
mod.@mobileAliasColumnValue.Value = @mobileAlias;
mod.@isAnonymousColumnValue.Value = @isAnonymous;
mod.@lastActivityDateColumnValue.Value = @lastActivityDate;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.aspnet_UsersTableCondition requiredCondition, params CommandConditions.aspnet_UsersTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@aspnet_UsersTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.aspnet_UsersTableCondition requiredCondition, params CommandConditions.aspnet_UsersTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.aspnet_UsersTableCondition> conditions ) {
var delete = new InlineDelete( "aspnet_Users" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.aspnet_UsersTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@aspnet_UsersTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.aspnet_UsersTableCondition> conditions;
private readonly DataValue<System.Guid> @applicationIdColumnValue = new DataValue<System.Guid>();
/// <summary>
/// Gets or sets the value for the ApplicationId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Guid @ApplicationId { get { return @applicationIdColumnValue.Value; } set { @applicationIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ApplicationId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ApplicationIdHasChanged { get { return @applicationIdColumnValue.Changed; } }
private readonly DataValue<System.Guid> @userIdColumnValue = new DataValue<System.Guid>();
/// <summary>
/// Gets or sets the value for the UserId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Guid @UserId { get { return @userIdColumnValue.Value; } set { @userIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the UserId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @UserIdHasChanged { get { return @userIdColumnValue.Changed; } }
private readonly DataValue<string> @userNameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the UserName column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @UserName { get { return @userNameColumnValue.Value; } set { @userNameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the UserName has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @UserNameHasChanged { get { return @userNameColumnValue.Changed; } }
private readonly DataValue<string> @loweredUserNameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the LoweredUserName column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @LoweredUserName { get { return @loweredUserNameColumnValue.Value; } set { @loweredUserNameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LoweredUserName has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LoweredUserNameHasChanged { get { return @loweredUserNameColumnValue.Changed; } }
private readonly DataValue<System.String> @mobileAliasColumnValue = new DataValue<System.String>();
/// <summary>
/// Gets or sets the value for the MobileAlias column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.String @MobileAlias { get { return @mobileAliasColumnValue.Value; } set { @mobileAliasColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the MobileAlias has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @MobileAliasHasChanged { get { return @mobileAliasColumnValue.Changed; } }
private readonly DataValue<System.Boolean> @isAnonymousColumnValue = new DataValue<System.Boolean>();
/// <summary>
/// Gets or sets the value for the IsAnonymous column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Boolean @IsAnonymous { get { return @isAnonymousColumnValue.Value; } set { @isAnonymousColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the IsAnonymous has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @IsAnonymousHasChanged { get { return @isAnonymousColumnValue.Changed; } }
private readonly DataValue<DateTime> @lastActivityDateColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the LastActivityDate column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @LastActivityDate { get { return @lastActivityDateColumnValue.Value; } set { @lastActivityDateColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LastActivityDate has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LastActivityDateHasChanged { get { return @lastActivityDateColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the aspnet_Users table.
/// </summary>
public static @aspnet_UsersModification CreateForInsert() {
return new @aspnet_UsersModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the aspnet_Users table.
/// </summary>
public static @aspnet_UsersModification CreateForUpdate( CommandConditions.aspnet_UsersTableCondition requiredCondition, params CommandConditions.aspnet_UsersTableCondition[] additionalConditions ) {
var mod = new @aspnet_UsersModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@aspnet_UsersTableEqualityConditions.@ApplicationId )
mod.@applicationIdColumnValue.Value = ( condition as CommandConditions.@aspnet_UsersTableEqualityConditions.@ApplicationId ).Value;
else if( condition is CommandConditions.@aspnet_UsersTableEqualityConditions.@UserId )
mod.@userIdColumnValue.Value = ( condition as CommandConditions.@aspnet_UsersTableEqualityConditions.@UserId ).Value;
else if( condition is CommandConditions.@aspnet_UsersTableEqualityConditions.@UserName )
mod.@userNameColumnValue.Value = ( condition as CommandConditions.@aspnet_UsersTableEqualityConditions.@UserName ).Value;
else if( condition is CommandConditions.@aspnet_UsersTableEqualityConditions.@LoweredUserName )
mod.@loweredUserNameColumnValue.Value = ( condition as CommandConditions.@aspnet_UsersTableEqualityConditions.@LoweredUserName ).Value;
else if( condition is CommandConditions.@aspnet_UsersTableEqualityConditions.@MobileAlias )
mod.@mobileAliasColumnValue.Value = ( condition as CommandConditions.@aspnet_UsersTableEqualityConditions.@MobileAlias ).Value;
else if( condition is CommandConditions.@aspnet_UsersTableEqualityConditions.@IsAnonymous )
mod.@isAnonymousColumnValue.Value = ( condition as CommandConditions.@aspnet_UsersTableEqualityConditions.@IsAnonymous ).Value;
else if( condition is CommandConditions.@aspnet_UsersTableEqualityConditions.@LastActivityDate )
mod.@lastActivityDateColumnValue.Value = ( condition as CommandConditions.@aspnet_UsersTableEqualityConditions.@LastActivityDate ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the aspnet_Users table.
/// </summary>
public static @aspnet_UsersModification CreateForSingleRowUpdate( System.Guid @applicationId, System.Guid @userId, string @userName, string @loweredUserName, System.String @mobileAlias, System.Boolean @isAnonymous, DateTime @lastActivityDate ) {
var mod = new @aspnet_UsersModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.aspnet_UsersTableCondition>();
mod.conditions.Add( new CommandConditions.@aspnet_UsersTableEqualityConditions.@ApplicationId( @applicationId ) );
mod.conditions.Add( new CommandConditions.@aspnet_UsersTableEqualityConditions.@LoweredUserName( @loweredUserName ) );
mod.@applicationIdColumnValue.Value = @applicationId;
mod.@userIdColumnValue.Value = @userId;
mod.@userNameColumnValue.Value = @userName;
mod.@loweredUserNameColumnValue.Value = @loweredUserName;
mod.@mobileAliasColumnValue.Value = @mobileAlias;
mod.@isAnonymousColumnValue.Value = @isAnonymous;
mod.@lastActivityDateColumnValue.Value = @lastActivityDate;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.aspnet_UsersTableCondition> getConditionList( CommandConditions.aspnet_UsersTableCondition requiredCondition, params CommandConditions.aspnet_UsersTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.aspnet_UsersTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @aspnet_UsersModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="applicationId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="userName">Object does not allow null.</param>
/// <param name="loweredUserName">Object does not allow null.</param>
/// <param name="mobileAlias">Object allows null.</param>
/// <param name="isAnonymous">Object does not allow null.</param>
/// <param name="lastActivityDate">Object does not allow null.</param>
public void SetAllData( System.Guid @applicationId, System.Guid @userId, string @userName, string @loweredUserName, System.String @mobileAlias, System.Boolean @isAnonymous, DateTime @lastActivityDate ) {
this.@applicationIdColumnValue.Value = @applicationId;
this.@userIdColumnValue.Value = @userId;
this.@userNameColumnValue.Value = @userName;
this.@loweredUserNameColumnValue.Value = @loweredUserName;
this.@mobileAliasColumnValue.Value = @mobileAlias;
this.@isAnonymousColumnValue.Value = @isAnonymous;
this.@lastActivityDateColumnValue.Value = @lastActivityDate;
}
/// <summary>
/// Executes this aspnet_Users modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this aspnet_Users modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "aspnet_Users" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.aspnet_UsersTableCondition>();
conditions.Add( new CommandConditions.@aspnet_UsersTableEqualityConditions.@ApplicationId( @ApplicationId ) );
conditions.Add( new CommandConditions.@aspnet_UsersTableEqualityConditions.@LoweredUserName( @LoweredUserName ) );
}
else {
var update = new InlineUpdate( "aspnet_Users" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @applicationIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ApplicationId", new DbParameterValue( @ApplicationId, "UniqueIdentifier" ) ) );
if( @userIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( @UserId, "UniqueIdentifier" ) ) );
if( @userNameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "UserName", new DbParameterValue( @UserName, "NVarChar" ) ) );
if( @loweredUserNameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LoweredUserName", new DbParameterValue( @LoweredUserName, "NVarChar" ) ) );
if( @mobileAliasColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "MobileAlias", new DbParameterValue( @MobileAlias, "NVarChar" ) ) );
if( @isAnonymousColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "IsAnonymous", new DbParameterValue( @IsAnonymous, "Bit" ) ) );
if( @lastActivityDateColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LastActivityDate", new DbParameterValue( @LastActivityDate, "DateTime" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@applicationIdColumnValue.ClearChanged();
@userIdColumnValue.ClearChanged();
@userNameColumnValue.ClearChanged();
@loweredUserNameColumnValue.ClearChanged();
@mobileAliasColumnValue.ClearChanged();
@isAnonymousColumnValue.ClearChanged();
@lastActivityDateColumnValue.ClearChanged();
}
}
public partial class @aspnet_UsersInRolesModification {
/// <summary>
/// Inserts a row into the aspnet_UsersInRoles table.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="roleId">Object does not allow null.</param>
public static void InsertRow( System.Guid @userId, System.Guid @roleId ) { 
var mod = CreateForInsert();
mod.@userIdColumnValue.Value = @userId;
mod.@roleIdColumnValue.Value = @roleId;
mod.Execute();
}
/// <summary>
/// Inserts a row into the aspnet_UsersInRoles table.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="roleId">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( System.Guid @userId, System.Guid @roleId ) { 
var mod = CreateForInsert();
mod.@userIdColumnValue.Value = @userId;
mod.@roleIdColumnValue.Value = @roleId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the aspnet_UsersInRoles table that match the specified conditions with the specified data.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="roleId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( System.Guid @userId, System.Guid @roleId, CommandConditions.aspnet_UsersInRolesTableCondition requiredCondition, params CommandConditions.aspnet_UsersInRolesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@userIdColumnValue.Value = @userId;
mod.@roleIdColumnValue.Value = @roleId;
mod.Execute();
}
/// <summary>
/// Updates rows in the aspnet_UsersInRoles table that match the specified conditions with the specified data.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="roleId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( System.Guid @userId, System.Guid @roleId, CommandConditions.aspnet_UsersInRolesTableCondition requiredCondition, params CommandConditions.aspnet_UsersInRolesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@userIdColumnValue.Value = @userId;
mod.@roleIdColumnValue.Value = @roleId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.aspnet_UsersInRolesTableCondition requiredCondition, params CommandConditions.aspnet_UsersInRolesTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@aspnet_UsersInRolesTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.aspnet_UsersInRolesTableCondition requiredCondition, params CommandConditions.aspnet_UsersInRolesTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.aspnet_UsersInRolesTableCondition> conditions ) {
var delete = new InlineDelete( "aspnet_UsersInRoles" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.aspnet_UsersInRolesTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@aspnet_UsersInRolesTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.aspnet_UsersInRolesTableCondition> conditions;
private readonly DataValue<System.Guid> @userIdColumnValue = new DataValue<System.Guid>();
/// <summary>
/// Gets or sets the value for the UserId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Guid @UserId { get { return @userIdColumnValue.Value; } set { @userIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the UserId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @UserIdHasChanged { get { return @userIdColumnValue.Changed; } }
private readonly DataValue<System.Guid> @roleIdColumnValue = new DataValue<System.Guid>();
/// <summary>
/// Gets or sets the value for the RoleId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Guid @RoleId { get { return @roleIdColumnValue.Value; } set { @roleIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the RoleId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @RoleIdHasChanged { get { return @roleIdColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the aspnet_UsersInRoles table.
/// </summary>
public static @aspnet_UsersInRolesModification CreateForInsert() {
return new @aspnet_UsersInRolesModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the aspnet_UsersInRoles table.
/// </summary>
public static @aspnet_UsersInRolesModification CreateForUpdate( CommandConditions.aspnet_UsersInRolesTableCondition requiredCondition, params CommandConditions.aspnet_UsersInRolesTableCondition[] additionalConditions ) {
var mod = new @aspnet_UsersInRolesModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@aspnet_UsersInRolesTableEqualityConditions.@UserId )
mod.@userIdColumnValue.Value = ( condition as CommandConditions.@aspnet_UsersInRolesTableEqualityConditions.@UserId ).Value;
else if( condition is CommandConditions.@aspnet_UsersInRolesTableEqualityConditions.@RoleId )
mod.@roleIdColumnValue.Value = ( condition as CommandConditions.@aspnet_UsersInRolesTableEqualityConditions.@RoleId ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the aspnet_UsersInRoles table.
/// </summary>
public static @aspnet_UsersInRolesModification CreateForSingleRowUpdate( System.Guid @userId, System.Guid @roleId ) {
var mod = new @aspnet_UsersInRolesModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.aspnet_UsersInRolesTableCondition>();
mod.conditions.Add( new CommandConditions.@aspnet_UsersInRolesTableEqualityConditions.@UserId( @userId ) );
mod.conditions.Add( new CommandConditions.@aspnet_UsersInRolesTableEqualityConditions.@RoleId( @roleId ) );
mod.@userIdColumnValue.Value = @userId;
mod.@roleIdColumnValue.Value = @roleId;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.aspnet_UsersInRolesTableCondition> getConditionList( CommandConditions.aspnet_UsersInRolesTableCondition requiredCondition, params CommandConditions.aspnet_UsersInRolesTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.aspnet_UsersInRolesTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @aspnet_UsersInRolesModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="roleId">Object does not allow null.</param>
public void SetAllData( System.Guid @userId, System.Guid @roleId ) {
this.@userIdColumnValue.Value = @userId;
this.@roleIdColumnValue.Value = @roleId;
}
/// <summary>
/// Executes this aspnet_UsersInRoles modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this aspnet_UsersInRoles modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "aspnet_UsersInRoles" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.aspnet_UsersInRolesTableCondition>();
conditions.Add( new CommandConditions.@aspnet_UsersInRolesTableEqualityConditions.@UserId( @UserId ) );
conditions.Add( new CommandConditions.@aspnet_UsersInRolesTableEqualityConditions.@RoleId( @RoleId ) );
}
else {
var update = new InlineUpdate( "aspnet_UsersInRoles" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @userIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( @UserId, "UniqueIdentifier" ) ) );
if( @roleIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "RoleId", new DbParameterValue( @RoleId, "UniqueIdentifier" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@userIdColumnValue.ClearChanged();
@roleIdColumnValue.ClearChanged();
}
}
public partial class @aspnet_WebEvent_EventsModification {
/// <summary>
/// Inserts a row into the aspnet_WebEvent_Events table.
/// </summary>
/// <param name="eventId">Object does not allow null.</param>
/// <param name="eventTimeUtc">Object does not allow null.</param>
/// <param name="eventTime">Object does not allow null.</param>
/// <param name="eventType">Object does not allow null.</param>
/// <param name="eventSequence">Object does not allow null.</param>
/// <param name="eventOccurrence">Object does not allow null.</param>
/// <param name="eventCode">Object does not allow null.</param>
/// <param name="eventDetailCode">Object does not allow null.</param>
/// <param name="message">Object allows null.</param>
/// <param name="applicationPath">Object allows null.</param>
/// <param name="applicationVirtualPath">Object allows null.</param>
/// <param name="machineName">Object does not allow null.</param>
/// <param name="requestUrl">Object allows null.</param>
/// <param name="exceptionType">Object allows null.</param>
/// <param name="details">Object allows null.</param>
public static void InsertRow( string @eventId, DateTime @eventTimeUtc, DateTime @eventTime, string @eventType, decimal @eventSequence, decimal @eventOccurrence, int @eventCode, int @eventDetailCode, System.String @message, System.String @applicationPath, System.String @applicationVirtualPath, string @machineName, System.String @requestUrl, System.String @exceptionType, System.String @details ) { 
var mod = CreateForInsert();
mod.@eventIdColumnValue.Value = @eventId;
mod.@eventTimeUtcColumnValue.Value = @eventTimeUtc;
mod.@eventTimeColumnValue.Value = @eventTime;
mod.@eventTypeColumnValue.Value = @eventType;
mod.@eventSequenceColumnValue.Value = @eventSequence;
mod.@eventOccurrenceColumnValue.Value = @eventOccurrence;
mod.@eventCodeColumnValue.Value = @eventCode;
mod.@eventDetailCodeColumnValue.Value = @eventDetailCode;
mod.@messageColumnValue.Value = @message;
mod.@applicationPathColumnValue.Value = @applicationPath;
mod.@applicationVirtualPathColumnValue.Value = @applicationVirtualPath;
mod.@machineNameColumnValue.Value = @machineName;
mod.@requestUrlColumnValue.Value = @requestUrl;
mod.@exceptionTypeColumnValue.Value = @exceptionType;
mod.@detailsColumnValue.Value = @details;
mod.Execute();
}
/// <summary>
/// Inserts a row into the aspnet_WebEvent_Events table.
/// </summary>
/// <param name="eventId">Object does not allow null.</param>
/// <param name="eventTimeUtc">Object does not allow null.</param>
/// <param name="eventTime">Object does not allow null.</param>
/// <param name="eventType">Object does not allow null.</param>
/// <param name="eventSequence">Object does not allow null.</param>
/// <param name="eventOccurrence">Object does not allow null.</param>
/// <param name="eventCode">Object does not allow null.</param>
/// <param name="eventDetailCode">Object does not allow null.</param>
/// <param name="message">Object allows null.</param>
/// <param name="applicationPath">Object allows null.</param>
/// <param name="applicationVirtualPath">Object allows null.</param>
/// <param name="machineName">Object does not allow null.</param>
/// <param name="requestUrl">Object allows null.</param>
/// <param name="exceptionType">Object allows null.</param>
/// <param name="details">Object allows null.</param>
public static void InsertRowWithoutAdditionalLogic( string @eventId, DateTime @eventTimeUtc, DateTime @eventTime, string @eventType, decimal @eventSequence, decimal @eventOccurrence, int @eventCode, int @eventDetailCode, System.String @message, System.String @applicationPath, System.String @applicationVirtualPath, string @machineName, System.String @requestUrl, System.String @exceptionType, System.String @details ) { 
var mod = CreateForInsert();
mod.@eventIdColumnValue.Value = @eventId;
mod.@eventTimeUtcColumnValue.Value = @eventTimeUtc;
mod.@eventTimeColumnValue.Value = @eventTime;
mod.@eventTypeColumnValue.Value = @eventType;
mod.@eventSequenceColumnValue.Value = @eventSequence;
mod.@eventOccurrenceColumnValue.Value = @eventOccurrence;
mod.@eventCodeColumnValue.Value = @eventCode;
mod.@eventDetailCodeColumnValue.Value = @eventDetailCode;
mod.@messageColumnValue.Value = @message;
mod.@applicationPathColumnValue.Value = @applicationPath;
mod.@applicationVirtualPathColumnValue.Value = @applicationVirtualPath;
mod.@machineNameColumnValue.Value = @machineName;
mod.@requestUrlColumnValue.Value = @requestUrl;
mod.@exceptionTypeColumnValue.Value = @exceptionType;
mod.@detailsColumnValue.Value = @details;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the aspnet_WebEvent_Events table that match the specified conditions with the specified data.
/// </summary>
/// <param name="eventId">Object does not allow null.</param>
/// <param name="eventTimeUtc">Object does not allow null.</param>
/// <param name="eventTime">Object does not allow null.</param>
/// <param name="eventType">Object does not allow null.</param>
/// <param name="eventSequence">Object does not allow null.</param>
/// <param name="eventOccurrence">Object does not allow null.</param>
/// <param name="eventCode">Object does not allow null.</param>
/// <param name="eventDetailCode">Object does not allow null.</param>
/// <param name="message">Object allows null.</param>
/// <param name="applicationPath">Object allows null.</param>
/// <param name="applicationVirtualPath">Object allows null.</param>
/// <param name="machineName">Object does not allow null.</param>
/// <param name="requestUrl">Object allows null.</param>
/// <param name="exceptionType">Object allows null.</param>
/// <param name="details">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( string @eventId, DateTime @eventTimeUtc, DateTime @eventTime, string @eventType, decimal @eventSequence, decimal @eventOccurrence, int @eventCode, int @eventDetailCode, System.String @message, System.String @applicationPath, System.String @applicationVirtualPath, string @machineName, System.String @requestUrl, System.String @exceptionType, System.String @details, CommandConditions.aspnet_WebEvent_EventsTableCondition requiredCondition, params CommandConditions.aspnet_WebEvent_EventsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@eventIdColumnValue.Value = @eventId;
mod.@eventTimeUtcColumnValue.Value = @eventTimeUtc;
mod.@eventTimeColumnValue.Value = @eventTime;
mod.@eventTypeColumnValue.Value = @eventType;
mod.@eventSequenceColumnValue.Value = @eventSequence;
mod.@eventOccurrenceColumnValue.Value = @eventOccurrence;
mod.@eventCodeColumnValue.Value = @eventCode;
mod.@eventDetailCodeColumnValue.Value = @eventDetailCode;
mod.@messageColumnValue.Value = @message;
mod.@applicationPathColumnValue.Value = @applicationPath;
mod.@applicationVirtualPathColumnValue.Value = @applicationVirtualPath;
mod.@machineNameColumnValue.Value = @machineName;
mod.@requestUrlColumnValue.Value = @requestUrl;
mod.@exceptionTypeColumnValue.Value = @exceptionType;
mod.@detailsColumnValue.Value = @details;
mod.Execute();
}
/// <summary>
/// Updates rows in the aspnet_WebEvent_Events table that match the specified conditions with the specified data.
/// </summary>
/// <param name="eventId">Object does not allow null.</param>
/// <param name="eventTimeUtc">Object does not allow null.</param>
/// <param name="eventTime">Object does not allow null.</param>
/// <param name="eventType">Object does not allow null.</param>
/// <param name="eventSequence">Object does not allow null.</param>
/// <param name="eventOccurrence">Object does not allow null.</param>
/// <param name="eventCode">Object does not allow null.</param>
/// <param name="eventDetailCode">Object does not allow null.</param>
/// <param name="message">Object allows null.</param>
/// <param name="applicationPath">Object allows null.</param>
/// <param name="applicationVirtualPath">Object allows null.</param>
/// <param name="machineName">Object does not allow null.</param>
/// <param name="requestUrl">Object allows null.</param>
/// <param name="exceptionType">Object allows null.</param>
/// <param name="details">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( string @eventId, DateTime @eventTimeUtc, DateTime @eventTime, string @eventType, decimal @eventSequence, decimal @eventOccurrence, int @eventCode, int @eventDetailCode, System.String @message, System.String @applicationPath, System.String @applicationVirtualPath, string @machineName, System.String @requestUrl, System.String @exceptionType, System.String @details, CommandConditions.aspnet_WebEvent_EventsTableCondition requiredCondition, params CommandConditions.aspnet_WebEvent_EventsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@eventIdColumnValue.Value = @eventId;
mod.@eventTimeUtcColumnValue.Value = @eventTimeUtc;
mod.@eventTimeColumnValue.Value = @eventTime;
mod.@eventTypeColumnValue.Value = @eventType;
mod.@eventSequenceColumnValue.Value = @eventSequence;
mod.@eventOccurrenceColumnValue.Value = @eventOccurrence;
mod.@eventCodeColumnValue.Value = @eventCode;
mod.@eventDetailCodeColumnValue.Value = @eventDetailCode;
mod.@messageColumnValue.Value = @message;
mod.@applicationPathColumnValue.Value = @applicationPath;
mod.@applicationVirtualPathColumnValue.Value = @applicationVirtualPath;
mod.@machineNameColumnValue.Value = @machineName;
mod.@requestUrlColumnValue.Value = @requestUrl;
mod.@exceptionTypeColumnValue.Value = @exceptionType;
mod.@detailsColumnValue.Value = @details;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.aspnet_WebEvent_EventsTableCondition requiredCondition, params CommandConditions.aspnet_WebEvent_EventsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@aspnet_WebEvent_EventsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.aspnet_WebEvent_EventsTableCondition requiredCondition, params CommandConditions.aspnet_WebEvent_EventsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.aspnet_WebEvent_EventsTableCondition> conditions ) {
var delete = new InlineDelete( "aspnet_WebEvent_Events" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.aspnet_WebEvent_EventsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@aspnet_WebEvent_EventsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.aspnet_WebEvent_EventsTableCondition> conditions;
private readonly DataValue<string> @eventIdColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the EventId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @EventId { get { return @eventIdColumnValue.Value; } set { @eventIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EventId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EventIdHasChanged { get { return @eventIdColumnValue.Changed; } }
private readonly DataValue<DateTime> @eventTimeUtcColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the EventTimeUtc column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @EventTimeUtc { get { return @eventTimeUtcColumnValue.Value; } set { @eventTimeUtcColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EventTimeUtc has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EventTimeUtcHasChanged { get { return @eventTimeUtcColumnValue.Changed; } }
private readonly DataValue<DateTime> @eventTimeColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the EventTime column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @EventTime { get { return @eventTimeColumnValue.Value; } set { @eventTimeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EventTime has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EventTimeHasChanged { get { return @eventTimeColumnValue.Changed; } }
private readonly DataValue<string> @eventTypeColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the EventType column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @EventType { get { return @eventTypeColumnValue.Value; } set { @eventTypeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EventType has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EventTypeHasChanged { get { return @eventTypeColumnValue.Changed; } }
private readonly DataValue<decimal> @eventSequenceColumnValue = new DataValue<decimal>();
/// <summary>
/// Gets or sets the value for the EventSequence column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public decimal @EventSequence { get { return @eventSequenceColumnValue.Value; } set { @eventSequenceColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EventSequence has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EventSequenceHasChanged { get { return @eventSequenceColumnValue.Changed; } }
private readonly DataValue<decimal> @eventOccurrenceColumnValue = new DataValue<decimal>();
/// <summary>
/// Gets or sets the value for the EventOccurrence column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public decimal @EventOccurrence { get { return @eventOccurrenceColumnValue.Value; } set { @eventOccurrenceColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EventOccurrence has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EventOccurrenceHasChanged { get { return @eventOccurrenceColumnValue.Changed; } }
private readonly DataValue<int> @eventCodeColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the EventCode column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @EventCode { get { return @eventCodeColumnValue.Value; } set { @eventCodeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EventCode has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EventCodeHasChanged { get { return @eventCodeColumnValue.Changed; } }
private readonly DataValue<int> @eventDetailCodeColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the EventDetailCode column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @EventDetailCode { get { return @eventDetailCodeColumnValue.Value; } set { @eventDetailCodeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EventDetailCode has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EventDetailCodeHasChanged { get { return @eventDetailCodeColumnValue.Changed; } }
private readonly DataValue<System.String> @messageColumnValue = new DataValue<System.String>();
/// <summary>
/// Gets or sets the value for the Message column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.String @Message { get { return @messageColumnValue.Value; } set { @messageColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Message has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @MessageHasChanged { get { return @messageColumnValue.Changed; } }
private readonly DataValue<System.String> @applicationPathColumnValue = new DataValue<System.String>();
/// <summary>
/// Gets or sets the value for the ApplicationPath column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.String @ApplicationPath { get { return @applicationPathColumnValue.Value; } set { @applicationPathColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ApplicationPath has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ApplicationPathHasChanged { get { return @applicationPathColumnValue.Changed; } }
private readonly DataValue<System.String> @applicationVirtualPathColumnValue = new DataValue<System.String>();
/// <summary>
/// Gets or sets the value for the ApplicationVirtualPath column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.String @ApplicationVirtualPath { get { return @applicationVirtualPathColumnValue.Value; } set { @applicationVirtualPathColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ApplicationVirtualPath has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ApplicationVirtualPathHasChanged { get { return @applicationVirtualPathColumnValue.Changed; } }
private readonly DataValue<string> @machineNameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the MachineName column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @MachineName { get { return @machineNameColumnValue.Value; } set { @machineNameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the MachineName has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @MachineNameHasChanged { get { return @machineNameColumnValue.Changed; } }
private readonly DataValue<System.String> @requestUrlColumnValue = new DataValue<System.String>();
/// <summary>
/// Gets or sets the value for the RequestUrl column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.String @RequestUrl { get { return @requestUrlColumnValue.Value; } set { @requestUrlColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the RequestUrl has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @RequestUrlHasChanged { get { return @requestUrlColumnValue.Changed; } }
private readonly DataValue<System.String> @exceptionTypeColumnValue = new DataValue<System.String>();
/// <summary>
/// Gets or sets the value for the ExceptionType column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.String @ExceptionType { get { return @exceptionTypeColumnValue.Value; } set { @exceptionTypeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ExceptionType has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ExceptionTypeHasChanged { get { return @exceptionTypeColumnValue.Changed; } }
private readonly DataValue<System.String> @detailsColumnValue = new DataValue<System.String>();
/// <summary>
/// Gets or sets the value for the Details column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.String @Details { get { return @detailsColumnValue.Value; } set { @detailsColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Details has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @DetailsHasChanged { get { return @detailsColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the aspnet_WebEvent_Events table.
/// </summary>
public static @aspnet_WebEvent_EventsModification CreateForInsert() {
return new @aspnet_WebEvent_EventsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the aspnet_WebEvent_Events table.
/// </summary>
public static @aspnet_WebEvent_EventsModification CreateForUpdate( CommandConditions.aspnet_WebEvent_EventsTableCondition requiredCondition, params CommandConditions.aspnet_WebEvent_EventsTableCondition[] additionalConditions ) {
var mod = new @aspnet_WebEvent_EventsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@EventId )
mod.@eventIdColumnValue.Value = ( condition as CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@EventId ).Value;
else if( condition is CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@EventTimeUtc )
mod.@eventTimeUtcColumnValue.Value = ( condition as CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@EventTimeUtc ).Value;
else if( condition is CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@EventTime )
mod.@eventTimeColumnValue.Value = ( condition as CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@EventTime ).Value;
else if( condition is CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@EventType )
mod.@eventTypeColumnValue.Value = ( condition as CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@EventType ).Value;
else if( condition is CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@EventSequence )
mod.@eventSequenceColumnValue.Value = ( condition as CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@EventSequence ).Value;
else if( condition is CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@EventOccurrence )
mod.@eventOccurrenceColumnValue.Value = ( condition as CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@EventOccurrence ).Value;
else if( condition is CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@EventCode )
mod.@eventCodeColumnValue.Value = ( condition as CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@EventCode ).Value;
else if( condition is CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@EventDetailCode )
mod.@eventDetailCodeColumnValue.Value = ( condition as CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@EventDetailCode ).Value;
else if( condition is CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@Message )
mod.@messageColumnValue.Value = ( condition as CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@Message ).Value;
else if( condition is CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@ApplicationPath )
mod.@applicationPathColumnValue.Value = ( condition as CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@ApplicationPath ).Value;
else if( condition is CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@ApplicationVirtualPath )
mod.@applicationVirtualPathColumnValue.Value = ( condition as CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@ApplicationVirtualPath ).Value;
else if( condition is CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@MachineName )
mod.@machineNameColumnValue.Value = ( condition as CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@MachineName ).Value;
else if( condition is CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@RequestUrl )
mod.@requestUrlColumnValue.Value = ( condition as CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@RequestUrl ).Value;
else if( condition is CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@ExceptionType )
mod.@exceptionTypeColumnValue.Value = ( condition as CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@ExceptionType ).Value;
else if( condition is CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@Details )
mod.@detailsColumnValue.Value = ( condition as CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@Details ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the aspnet_WebEvent_Events table.
/// </summary>
public static @aspnet_WebEvent_EventsModification CreateForSingleRowUpdate( string @eventId, DateTime @eventTimeUtc, DateTime @eventTime, string @eventType, decimal @eventSequence, decimal @eventOccurrence, int @eventCode, int @eventDetailCode, System.String @message, System.String @applicationPath, System.String @applicationVirtualPath, string @machineName, System.String @requestUrl, System.String @exceptionType, System.String @details ) {
var mod = new @aspnet_WebEvent_EventsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.aspnet_WebEvent_EventsTableCondition>();
mod.conditions.Add( new CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@EventId( @eventId ) );
mod.@eventIdColumnValue.Value = @eventId;
mod.@eventTimeUtcColumnValue.Value = @eventTimeUtc;
mod.@eventTimeColumnValue.Value = @eventTime;
mod.@eventTypeColumnValue.Value = @eventType;
mod.@eventSequenceColumnValue.Value = @eventSequence;
mod.@eventOccurrenceColumnValue.Value = @eventOccurrence;
mod.@eventCodeColumnValue.Value = @eventCode;
mod.@eventDetailCodeColumnValue.Value = @eventDetailCode;
mod.@messageColumnValue.Value = @message;
mod.@applicationPathColumnValue.Value = @applicationPath;
mod.@applicationVirtualPathColumnValue.Value = @applicationVirtualPath;
mod.@machineNameColumnValue.Value = @machineName;
mod.@requestUrlColumnValue.Value = @requestUrl;
mod.@exceptionTypeColumnValue.Value = @exceptionType;
mod.@detailsColumnValue.Value = @details;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.aspnet_WebEvent_EventsTableCondition> getConditionList( CommandConditions.aspnet_WebEvent_EventsTableCondition requiredCondition, params CommandConditions.aspnet_WebEvent_EventsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.aspnet_WebEvent_EventsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @aspnet_WebEvent_EventsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="eventId">Object does not allow null.</param>
/// <param name="eventTimeUtc">Object does not allow null.</param>
/// <param name="eventTime">Object does not allow null.</param>
/// <param name="eventType">Object does not allow null.</param>
/// <param name="eventSequence">Object does not allow null.</param>
/// <param name="eventOccurrence">Object does not allow null.</param>
/// <param name="eventCode">Object does not allow null.</param>
/// <param name="eventDetailCode">Object does not allow null.</param>
/// <param name="message">Object allows null.</param>
/// <param name="applicationPath">Object allows null.</param>
/// <param name="applicationVirtualPath">Object allows null.</param>
/// <param name="machineName">Object does not allow null.</param>
/// <param name="requestUrl">Object allows null.</param>
/// <param name="exceptionType">Object allows null.</param>
/// <param name="details">Object allows null.</param>
public void SetAllData( string @eventId, DateTime @eventTimeUtc, DateTime @eventTime, string @eventType, decimal @eventSequence, decimal @eventOccurrence, int @eventCode, int @eventDetailCode, System.String @message, System.String @applicationPath, System.String @applicationVirtualPath, string @machineName, System.String @requestUrl, System.String @exceptionType, System.String @details ) {
this.@eventIdColumnValue.Value = @eventId;
this.@eventTimeUtcColumnValue.Value = @eventTimeUtc;
this.@eventTimeColumnValue.Value = @eventTime;
this.@eventTypeColumnValue.Value = @eventType;
this.@eventSequenceColumnValue.Value = @eventSequence;
this.@eventOccurrenceColumnValue.Value = @eventOccurrence;
this.@eventCodeColumnValue.Value = @eventCode;
this.@eventDetailCodeColumnValue.Value = @eventDetailCode;
this.@messageColumnValue.Value = @message;
this.@applicationPathColumnValue.Value = @applicationPath;
this.@applicationVirtualPathColumnValue.Value = @applicationVirtualPath;
this.@machineNameColumnValue.Value = @machineName;
this.@requestUrlColumnValue.Value = @requestUrl;
this.@exceptionTypeColumnValue.Value = @exceptionType;
this.@detailsColumnValue.Value = @details;
}
/// <summary>
/// Executes this aspnet_WebEvent_Events modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this aspnet_WebEvent_Events modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "aspnet_WebEvent_Events" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.aspnet_WebEvent_EventsTableCondition>();
conditions.Add( new CommandConditions.@aspnet_WebEvent_EventsTableEqualityConditions.@EventId( @EventId ) );
}
else {
var update = new InlineUpdate( "aspnet_WebEvent_Events" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @eventIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EventId", new DbParameterValue( @EventId, "Char" ) ) );
if( @eventTimeUtcColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EventTimeUtc", new DbParameterValue( @EventTimeUtc, "DateTime" ) ) );
if( @eventTimeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EventTime", new DbParameterValue( @EventTime, "DateTime" ) ) );
if( @eventTypeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EventType", new DbParameterValue( @EventType, "NVarChar" ) ) );
if( @eventSequenceColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EventSequence", new DbParameterValue( @EventSequence, "Decimal" ) ) );
if( @eventOccurrenceColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EventOccurrence", new DbParameterValue( @EventOccurrence, "Decimal" ) ) );
if( @eventCodeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EventCode", new DbParameterValue( @EventCode, "Int" ) ) );
if( @eventDetailCodeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EventDetailCode", new DbParameterValue( @EventDetailCode, "Int" ) ) );
if( @messageColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Message", new DbParameterValue( @Message, "NVarChar" ) ) );
if( @applicationPathColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ApplicationPath", new DbParameterValue( @ApplicationPath, "NVarChar" ) ) );
if( @applicationVirtualPathColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ApplicationVirtualPath", new DbParameterValue( @ApplicationVirtualPath, "NVarChar" ) ) );
if( @machineNameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "MachineName", new DbParameterValue( @MachineName, "NVarChar" ) ) );
if( @requestUrlColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "RequestUrl", new DbParameterValue( @RequestUrl, "NVarChar" ) ) );
if( @exceptionTypeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ExceptionType", new DbParameterValue( @ExceptionType, "NVarChar" ) ) );
if( @detailsColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Details", new DbParameterValue( @Details, "NText" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@eventIdColumnValue.ClearChanged();
@eventTimeUtcColumnValue.ClearChanged();
@eventTimeColumnValue.ClearChanged();
@eventTypeColumnValue.ClearChanged();
@eventSequenceColumnValue.ClearChanged();
@eventOccurrenceColumnValue.ClearChanged();
@eventCodeColumnValue.ClearChanged();
@eventDetailCodeColumnValue.ClearChanged();
@messageColumnValue.ClearChanged();
@applicationPathColumnValue.ClearChanged();
@applicationVirtualPathColumnValue.ClearChanged();
@machineNameColumnValue.ClearChanged();
@requestUrlColumnValue.ClearChanged();
@exceptionTypeColumnValue.ClearChanged();
@detailsColumnValue.ClearChanged();
}
}
public partial class @BackgroundNotifierLogsModification {
/// <summary>
/// Inserts a row into the BackgroundNotifierLogs table. Returns the value of the BackgroundNotifierLogId column.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="isError">Object does not allow null.</param>
/// <param name="details">Object does not allow null.</param>
/// <param name="sentDateTimeUtc">Object does not allow null.</param>
public static int InsertRow( int @userId, System.Boolean @isError, string @details, DateTime @sentDateTimeUtc ) { 
var mod = CreateForInsert();
mod.@userIdColumnValue.Value = @userId;
mod.@isErrorColumnValue.Value = @isError;
mod.@detailsColumnValue.Value = @details;
mod.@sentDateTimeUtcColumnValue.Value = @sentDateTimeUtc;
mod.Execute();
return mod.BackgroundNotifierLogId;
}
/// <summary>
/// Inserts a row into the BackgroundNotifierLogs table. Returns the value of the BackgroundNotifierLogId column.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="isError">Object does not allow null.</param>
/// <param name="details">Object does not allow null.</param>
/// <param name="sentDateTimeUtc">Object does not allow null.</param>
public static int InsertRowWithoutAdditionalLogic( int @userId, System.Boolean @isError, string @details, DateTime @sentDateTimeUtc ) { 
var mod = CreateForInsert();
mod.@userIdColumnValue.Value = @userId;
mod.@isErrorColumnValue.Value = @isError;
mod.@detailsColumnValue.Value = @details;
mod.@sentDateTimeUtcColumnValue.Value = @sentDateTimeUtc;
mod.ExecuteWithoutAdditionalLogic();
return mod.BackgroundNotifierLogId;
}
/// <summary>
/// Updates rows in the BackgroundNotifierLogs table that match the specified conditions with the specified data.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="isError">Object does not allow null.</param>
/// <param name="details">Object does not allow null.</param>
/// <param name="sentDateTimeUtc">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @userId, System.Boolean @isError, string @details, DateTime @sentDateTimeUtc, CommandConditions.BackgroundNotifierLogsTableCondition requiredCondition, params CommandConditions.BackgroundNotifierLogsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@userIdColumnValue.Value = @userId;
mod.@isErrorColumnValue.Value = @isError;
mod.@detailsColumnValue.Value = @details;
mod.@sentDateTimeUtcColumnValue.Value = @sentDateTimeUtc;
mod.Execute();
}
/// <summary>
/// Updates rows in the BackgroundNotifierLogs table that match the specified conditions with the specified data.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="isError">Object does not allow null.</param>
/// <param name="details">Object does not allow null.</param>
/// <param name="sentDateTimeUtc">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @userId, System.Boolean @isError, string @details, DateTime @sentDateTimeUtc, CommandConditions.BackgroundNotifierLogsTableCondition requiredCondition, params CommandConditions.BackgroundNotifierLogsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@userIdColumnValue.Value = @userId;
mod.@isErrorColumnValue.Value = @isError;
mod.@detailsColumnValue.Value = @details;
mod.@sentDateTimeUtcColumnValue.Value = @sentDateTimeUtc;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.BackgroundNotifierLogsTableCondition requiredCondition, params CommandConditions.BackgroundNotifierLogsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@BackgroundNotifierLogsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.BackgroundNotifierLogsTableCondition requiredCondition, params CommandConditions.BackgroundNotifierLogsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.BackgroundNotifierLogsTableCondition> conditions ) {
var delete = new InlineDelete( "BackgroundNotifierLogs" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.BackgroundNotifierLogsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@BackgroundNotifierLogsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.BackgroundNotifierLogsTableCondition> conditions;
private readonly DataValue<int> @backgroundNotifierLogIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets the value for the BackgroundNotifierLogId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @BackgroundNotifierLogId { get { return @backgroundNotifierLogIdColumnValue.Value; } }
private readonly DataValue<int> @userIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the UserId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @UserId { get { return @userIdColumnValue.Value; } set { @userIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the UserId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @UserIdHasChanged { get { return @userIdColumnValue.Changed; } }
private readonly DataValue<System.Boolean> @isErrorColumnValue = new DataValue<System.Boolean>();
/// <summary>
/// Gets or sets the value for the IsError column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Boolean @IsError { get { return @isErrorColumnValue.Value; } set { @isErrorColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the IsError has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @IsErrorHasChanged { get { return @isErrorColumnValue.Changed; } }
private readonly DataValue<string> @detailsColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Details column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Details { get { return @detailsColumnValue.Value; } set { @detailsColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Details has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @DetailsHasChanged { get { return @detailsColumnValue.Changed; } }
private readonly DataValue<DateTime> @sentDateTimeUtcColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the SentDateTimeUtc column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @SentDateTimeUtc { get { return @sentDateTimeUtcColumnValue.Value; } set { @sentDateTimeUtcColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the SentDateTimeUtc has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @SentDateTimeUtcHasChanged { get { return @sentDateTimeUtcColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the BackgroundNotifierLogs table.
/// </summary>
public static @BackgroundNotifierLogsModification CreateForInsert() {
return new @BackgroundNotifierLogsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the BackgroundNotifierLogs table.
/// </summary>
public static @BackgroundNotifierLogsModification CreateForUpdate( CommandConditions.BackgroundNotifierLogsTableCondition requiredCondition, params CommandConditions.BackgroundNotifierLogsTableCondition[] additionalConditions ) {
var mod = new @BackgroundNotifierLogsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@BackgroundNotifierLogsTableEqualityConditions.@BackgroundNotifierLogId )
mod.@backgroundNotifierLogIdColumnValue.Value = ( condition as CommandConditions.@BackgroundNotifierLogsTableEqualityConditions.@BackgroundNotifierLogId ).Value;
else if( condition is CommandConditions.@BackgroundNotifierLogsTableEqualityConditions.@UserId )
mod.@userIdColumnValue.Value = ( condition as CommandConditions.@BackgroundNotifierLogsTableEqualityConditions.@UserId ).Value;
else if( condition is CommandConditions.@BackgroundNotifierLogsTableEqualityConditions.@IsError )
mod.@isErrorColumnValue.Value = ( condition as CommandConditions.@BackgroundNotifierLogsTableEqualityConditions.@IsError ).Value;
else if( condition is CommandConditions.@BackgroundNotifierLogsTableEqualityConditions.@Details )
mod.@detailsColumnValue.Value = ( condition as CommandConditions.@BackgroundNotifierLogsTableEqualityConditions.@Details ).Value;
else if( condition is CommandConditions.@BackgroundNotifierLogsTableEqualityConditions.@SentDateTimeUtc )
mod.@sentDateTimeUtcColumnValue.Value = ( condition as CommandConditions.@BackgroundNotifierLogsTableEqualityConditions.@SentDateTimeUtc ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the BackgroundNotifierLogs table.
/// </summary>
public static @BackgroundNotifierLogsModification CreateForSingleRowUpdate( int @backgroundNotifierLogId, int @userId, System.Boolean @isError, string @details, DateTime @sentDateTimeUtc ) {
var mod = new @BackgroundNotifierLogsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.BackgroundNotifierLogsTableCondition>();
mod.conditions.Add( new CommandConditions.@BackgroundNotifierLogsTableEqualityConditions.@BackgroundNotifierLogId( @backgroundNotifierLogId ) );
mod.@backgroundNotifierLogIdColumnValue.Value = @backgroundNotifierLogId;
mod.@userIdColumnValue.Value = @userId;
mod.@isErrorColumnValue.Value = @isError;
mod.@detailsColumnValue.Value = @details;
mod.@sentDateTimeUtcColumnValue.Value = @sentDateTimeUtc;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.BackgroundNotifierLogsTableCondition> getConditionList( CommandConditions.BackgroundNotifierLogsTableCondition requiredCondition, params CommandConditions.BackgroundNotifierLogsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.BackgroundNotifierLogsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @BackgroundNotifierLogsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="isError">Object does not allow null.</param>
/// <param name="details">Object does not allow null.</param>
/// <param name="sentDateTimeUtc">Object does not allow null.</param>
public void SetAllData( int @userId, System.Boolean @isError, string @details, DateTime @sentDateTimeUtc ) {
this.@userIdColumnValue.Value = @userId;
this.@isErrorColumnValue.Value = @isError;
this.@detailsColumnValue.Value = @details;
this.@sentDateTimeUtcColumnValue.Value = @sentDateTimeUtc;
}
/// <summary>
/// Executes this BackgroundNotifierLogs modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this BackgroundNotifierLogs modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "BackgroundNotifierLogs" );
addColumnModifications( insert );
@backgroundNotifierLogIdColumnValue.Value = (System.Int32)Utility.ChangeType( insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection ), typeof( System.Int32 ) );
modType = ModificationType.Update;
conditions = new List<CommandConditions.BackgroundNotifierLogsTableCondition>();
conditions.Add( new CommandConditions.@BackgroundNotifierLogsTableEqualityConditions.@BackgroundNotifierLogId( @BackgroundNotifierLogId ) );
}
else {
var update = new InlineUpdate( "BackgroundNotifierLogs" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @userIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( @UserId, "Int" ) ) );
if( @isErrorColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "IsError", new DbParameterValue( @IsError, "Bit" ) ) );
if( @detailsColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Details", new DbParameterValue( @Details, "NVarChar" ) ) );
if( @sentDateTimeUtcColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "SentDateTimeUtc", new DbParameterValue( @SentDateTimeUtc, "DateTime2" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@backgroundNotifierLogIdColumnValue.ClearChanged();
@userIdColumnValue.ClearChanged();
@isErrorColumnValue.ClearChanged();
@detailsColumnValue.ClearChanged();
@sentDateTimeUtcColumnValue.ClearChanged();
}
}
public partial class @CareZonesModification {
/// <summary>
/// Inserts a row into the CareZones table. Returns the value of the CareZoneId column.
/// </summary>
/// <param name="name">Object does not allow null.</param>
public static int InsertRow( string @name ) { 
var mod = CreateForInsert();
mod.@nameColumnValue.Value = @name;
mod.Execute();
return mod.CareZoneId;
}
/// <summary>
/// Inserts a row into the CareZones table. Returns the value of the CareZoneId column.
/// </summary>
/// <param name="name">Object does not allow null.</param>
public static int InsertRowWithoutAdditionalLogic( string @name ) { 
var mod = CreateForInsert();
mod.@nameColumnValue.Value = @name;
mod.ExecuteWithoutAdditionalLogic();
return mod.CareZoneId;
}
/// <summary>
/// Updates rows in the CareZones table that match the specified conditions with the specified data.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( string @name, CommandConditions.CareZonesTableCondition requiredCondition, params CommandConditions.CareZonesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@nameColumnValue.Value = @name;
mod.Execute();
}
/// <summary>
/// Updates rows in the CareZones table that match the specified conditions with the specified data.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( string @name, CommandConditions.CareZonesTableCondition requiredCondition, params CommandConditions.CareZonesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@nameColumnValue.Value = @name;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.CareZonesTableCondition requiredCondition, params CommandConditions.CareZonesTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@CareZonesTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.CareZonesTableCondition requiredCondition, params CommandConditions.CareZonesTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.CareZonesTableCondition> conditions ) {
var delete = new InlineDelete( "CareZones" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.CareZonesTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@CareZonesTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.CareZonesTableCondition> conditions;
private readonly DataValue<int> @careZoneIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets the value for the CareZoneId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @CareZoneId { get { return @careZoneIdColumnValue.Value; } }
private readonly DataValue<string> @nameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Name column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Name { get { return @nameColumnValue.Value; } set { @nameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Name has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @NameHasChanged { get { return @nameColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the CareZones table.
/// </summary>
public static @CareZonesModification CreateForInsert() {
return new @CareZonesModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the CareZones table.
/// </summary>
public static @CareZonesModification CreateForUpdate( CommandConditions.CareZonesTableCondition requiredCondition, params CommandConditions.CareZonesTableCondition[] additionalConditions ) {
var mod = new @CareZonesModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@CareZonesTableEqualityConditions.@CareZoneId )
mod.@careZoneIdColumnValue.Value = ( condition as CommandConditions.@CareZonesTableEqualityConditions.@CareZoneId ).Value;
else if( condition is CommandConditions.@CareZonesTableEqualityConditions.@Name )
mod.@nameColumnValue.Value = ( condition as CommandConditions.@CareZonesTableEqualityConditions.@Name ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the CareZones table.
/// </summary>
public static @CareZonesModification CreateForSingleRowUpdate( int @careZoneId, string @name ) {
var mod = new @CareZonesModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.CareZonesTableCondition>();
mod.conditions.Add( new CommandConditions.@CareZonesTableEqualityConditions.@CareZoneId( @careZoneId ) );
mod.@careZoneIdColumnValue.Value = @careZoneId;
mod.@nameColumnValue.Value = @name;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.CareZonesTableCondition> getConditionList( CommandConditions.CareZonesTableCondition requiredCondition, params CommandConditions.CareZonesTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.CareZonesTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @CareZonesModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="name">Object does not allow null.</param>
public void SetAllData( string @name ) {
this.@nameColumnValue.Value = @name;
}
/// <summary>
/// Executes this CareZones modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this CareZones modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "CareZones" );
addColumnModifications( insert );
@careZoneIdColumnValue.Value = (System.Int32)Utility.ChangeType( insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection ), typeof( System.Int32 ) );
modType = ModificationType.Update;
conditions = new List<CommandConditions.CareZonesTableCondition>();
conditions.Add( new CommandConditions.@CareZonesTableEqualityConditions.@CareZoneId( @CareZoneId ) );
}
else {
var update = new InlineUpdate( "CareZones" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @nameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Name", new DbParameterValue( @Name, "NVarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@careZoneIdColumnValue.ClearChanged();
@nameColumnValue.ClearChanged();
}
}
public partial class @CareZonesToWorkGroupsModification {
/// <summary>
/// Inserts a row into the CareZonesToWorkGroups table. Returns the value of the CareZoneToWorkGroupId column.
/// </summary>
/// <param name="careZoneId">Object does not allow null.</param>
/// <param name="workGroupId">Object does not allow null.</param>
public static int InsertRow( int @careZoneId, int @workGroupId ) { 
var mod = CreateForInsert();
mod.@careZoneIdColumnValue.Value = @careZoneId;
mod.@workGroupIdColumnValue.Value = @workGroupId;
mod.Execute();
return mod.CareZoneToWorkGroupId;
}
/// <summary>
/// Inserts a row into the CareZonesToWorkGroups table. Returns the value of the CareZoneToWorkGroupId column.
/// </summary>
/// <param name="careZoneId">Object does not allow null.</param>
/// <param name="workGroupId">Object does not allow null.</param>
public static int InsertRowWithoutAdditionalLogic( int @careZoneId, int @workGroupId ) { 
var mod = CreateForInsert();
mod.@careZoneIdColumnValue.Value = @careZoneId;
mod.@workGroupIdColumnValue.Value = @workGroupId;
mod.ExecuteWithoutAdditionalLogic();
return mod.CareZoneToWorkGroupId;
}
/// <summary>
/// Updates rows in the CareZonesToWorkGroups table that match the specified conditions with the specified data.
/// </summary>
/// <param name="careZoneId">Object does not allow null.</param>
/// <param name="workGroupId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @careZoneId, int @workGroupId, CommandConditions.CareZonesToWorkGroupsTableCondition requiredCondition, params CommandConditions.CareZonesToWorkGroupsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@careZoneIdColumnValue.Value = @careZoneId;
mod.@workGroupIdColumnValue.Value = @workGroupId;
mod.Execute();
}
/// <summary>
/// Updates rows in the CareZonesToWorkGroups table that match the specified conditions with the specified data.
/// </summary>
/// <param name="careZoneId">Object does not allow null.</param>
/// <param name="workGroupId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @careZoneId, int @workGroupId, CommandConditions.CareZonesToWorkGroupsTableCondition requiredCondition, params CommandConditions.CareZonesToWorkGroupsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@careZoneIdColumnValue.Value = @careZoneId;
mod.@workGroupIdColumnValue.Value = @workGroupId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.CareZonesToWorkGroupsTableCondition requiredCondition, params CommandConditions.CareZonesToWorkGroupsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@CareZonesToWorkGroupsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.CareZonesToWorkGroupsTableCondition requiredCondition, params CommandConditions.CareZonesToWorkGroupsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.CareZonesToWorkGroupsTableCondition> conditions ) {
var delete = new InlineDelete( "CareZonesToWorkGroups" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.CareZonesToWorkGroupsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@CareZonesToWorkGroupsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.CareZonesToWorkGroupsTableCondition> conditions;
private readonly DataValue<int> @careZoneToWorkGroupIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets the value for the CareZoneToWorkGroupId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @CareZoneToWorkGroupId { get { return @careZoneToWorkGroupIdColumnValue.Value; } }
private readonly DataValue<int> @careZoneIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the CareZoneId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @CareZoneId { get { return @careZoneIdColumnValue.Value; } set { @careZoneIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the CareZoneId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @CareZoneIdHasChanged { get { return @careZoneIdColumnValue.Changed; } }
private readonly DataValue<int> @workGroupIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the WorkGroupId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @WorkGroupId { get { return @workGroupIdColumnValue.Value; } set { @workGroupIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the WorkGroupId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @WorkGroupIdHasChanged { get { return @workGroupIdColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the CareZonesToWorkGroups table.
/// </summary>
public static @CareZonesToWorkGroupsModification CreateForInsert() {
return new @CareZonesToWorkGroupsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the CareZonesToWorkGroups table.
/// </summary>
public static @CareZonesToWorkGroupsModification CreateForUpdate( CommandConditions.CareZonesToWorkGroupsTableCondition requiredCondition, params CommandConditions.CareZonesToWorkGroupsTableCondition[] additionalConditions ) {
var mod = new @CareZonesToWorkGroupsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@CareZonesToWorkGroupsTableEqualityConditions.@CareZoneToWorkGroupId )
mod.@careZoneToWorkGroupIdColumnValue.Value = ( condition as CommandConditions.@CareZonesToWorkGroupsTableEqualityConditions.@CareZoneToWorkGroupId ).Value;
else if( condition is CommandConditions.@CareZonesToWorkGroupsTableEqualityConditions.@CareZoneId )
mod.@careZoneIdColumnValue.Value = ( condition as CommandConditions.@CareZonesToWorkGroupsTableEqualityConditions.@CareZoneId ).Value;
else if( condition is CommandConditions.@CareZonesToWorkGroupsTableEqualityConditions.@WorkGroupId )
mod.@workGroupIdColumnValue.Value = ( condition as CommandConditions.@CareZonesToWorkGroupsTableEqualityConditions.@WorkGroupId ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the CareZonesToWorkGroups table.
/// </summary>
public static @CareZonesToWorkGroupsModification CreateForSingleRowUpdate( int @careZoneToWorkGroupId, int @careZoneId, int @workGroupId ) {
var mod = new @CareZonesToWorkGroupsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.CareZonesToWorkGroupsTableCondition>();
mod.conditions.Add( new CommandConditions.@CareZonesToWorkGroupsTableEqualityConditions.@CareZoneToWorkGroupId( @careZoneToWorkGroupId ) );
mod.@careZoneToWorkGroupIdColumnValue.Value = @careZoneToWorkGroupId;
mod.@careZoneIdColumnValue.Value = @careZoneId;
mod.@workGroupIdColumnValue.Value = @workGroupId;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.CareZonesToWorkGroupsTableCondition> getConditionList( CommandConditions.CareZonesToWorkGroupsTableCondition requiredCondition, params CommandConditions.CareZonesToWorkGroupsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.CareZonesToWorkGroupsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @CareZonesToWorkGroupsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="careZoneId">Object does not allow null.</param>
/// <param name="workGroupId">Object does not allow null.</param>
public void SetAllData( int @careZoneId, int @workGroupId ) {
this.@careZoneIdColumnValue.Value = @careZoneId;
this.@workGroupIdColumnValue.Value = @workGroupId;
}
/// <summary>
/// Executes this CareZonesToWorkGroups modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this CareZonesToWorkGroups modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "CareZonesToWorkGroups" );
addColumnModifications( insert );
@careZoneToWorkGroupIdColumnValue.Value = (System.Int32)Utility.ChangeType( insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection ), typeof( System.Int32 ) );
modType = ModificationType.Update;
conditions = new List<CommandConditions.CareZonesToWorkGroupsTableCondition>();
conditions.Add( new CommandConditions.@CareZonesToWorkGroupsTableEqualityConditions.@CareZoneToWorkGroupId( @CareZoneToWorkGroupId ) );
}
else {
var update = new InlineUpdate( "CareZonesToWorkGroups" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @careZoneIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "CareZoneId", new DbParameterValue( @CareZoneId, "Int" ) ) );
if( @workGroupIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "WorkGroupId", new DbParameterValue( @WorkGroupId, "Int" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@careZoneToWorkGroupIdColumnValue.ClearChanged();
@careZoneIdColumnValue.ClearChanged();
@workGroupIdColumnValue.ClearChanged();
}
}
public partial class @ClinicianPatientsModification {
/// <summary>
/// Inserts a row into the ClinicianPatients table.
/// </summary>
/// <param name="clinicianPatientId">Object does not allow null.</param>
/// <param name="encryptionKeyVersion">Object does not allow null.</param>
/// <param name="encryptionIv">Object does not allow null.</param>
/// <param name="clinicianId">Object does not allow null.</param>
/// <param name="patientInfoId">Object does not allow null.</param>
public static void InsertRow( int @clinicianPatientId, string @encryptionKeyVersion, System.Byte[] @encryptionIv, int @clinicianId, System.Byte[] @patientInfoId ) { 
var mod = CreateForInsert();
mod.@clinicianPatientIdColumnValue.Value = @clinicianPatientId;
mod.@encryptionKeyVersionColumnValue.Value = @encryptionKeyVersion;
mod.@encryptionIvColumnValue.Value = @encryptionIv;
mod.@clinicianIdColumnValue.Value = @clinicianId;
mod.@patientInfoIdColumnValue.Value = @patientInfoId;
mod.Execute();
}
/// <summary>
/// Inserts a row into the ClinicianPatients table.
/// </summary>
/// <param name="clinicianPatientId">Object does not allow null.</param>
/// <param name="encryptionKeyVersion">Object does not allow null.</param>
/// <param name="encryptionIv">Object does not allow null.</param>
/// <param name="clinicianId">Object does not allow null.</param>
/// <param name="patientInfoId">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @clinicianPatientId, string @encryptionKeyVersion, System.Byte[] @encryptionIv, int @clinicianId, System.Byte[] @patientInfoId ) { 
var mod = CreateForInsert();
mod.@clinicianPatientIdColumnValue.Value = @clinicianPatientId;
mod.@encryptionKeyVersionColumnValue.Value = @encryptionKeyVersion;
mod.@encryptionIvColumnValue.Value = @encryptionIv;
mod.@clinicianIdColumnValue.Value = @clinicianId;
mod.@patientInfoIdColumnValue.Value = @patientInfoId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the ClinicianPatients table that match the specified conditions with the specified data.
/// </summary>
/// <param name="clinicianPatientId">Object does not allow null.</param>
/// <param name="encryptionKeyVersion">Object does not allow null.</param>
/// <param name="encryptionIv">Object does not allow null.</param>
/// <param name="clinicianId">Object does not allow null.</param>
/// <param name="patientInfoId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @clinicianPatientId, string @encryptionKeyVersion, System.Byte[] @encryptionIv, int @clinicianId, System.Byte[] @patientInfoId, CommandConditions.ClinicianPatientsTableCondition requiredCondition, params CommandConditions.ClinicianPatientsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@clinicianPatientIdColumnValue.Value = @clinicianPatientId;
mod.@encryptionKeyVersionColumnValue.Value = @encryptionKeyVersion;
mod.@encryptionIvColumnValue.Value = @encryptionIv;
mod.@clinicianIdColumnValue.Value = @clinicianId;
mod.@patientInfoIdColumnValue.Value = @patientInfoId;
mod.Execute();
}
/// <summary>
/// Updates rows in the ClinicianPatients table that match the specified conditions with the specified data.
/// </summary>
/// <param name="clinicianPatientId">Object does not allow null.</param>
/// <param name="encryptionKeyVersion">Object does not allow null.</param>
/// <param name="encryptionIv">Object does not allow null.</param>
/// <param name="clinicianId">Object does not allow null.</param>
/// <param name="patientInfoId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @clinicianPatientId, string @encryptionKeyVersion, System.Byte[] @encryptionIv, int @clinicianId, System.Byte[] @patientInfoId, CommandConditions.ClinicianPatientsTableCondition requiredCondition, params CommandConditions.ClinicianPatientsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@clinicianPatientIdColumnValue.Value = @clinicianPatientId;
mod.@encryptionKeyVersionColumnValue.Value = @encryptionKeyVersion;
mod.@encryptionIvColumnValue.Value = @encryptionIv;
mod.@clinicianIdColumnValue.Value = @clinicianId;
mod.@patientInfoIdColumnValue.Value = @patientInfoId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.ClinicianPatientsTableCondition requiredCondition, params CommandConditions.ClinicianPatientsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@ClinicianPatientsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.ClinicianPatientsTableCondition requiredCondition, params CommandConditions.ClinicianPatientsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.ClinicianPatientsTableCondition> conditions ) {
var delete = new InlineDelete( "ClinicianPatients" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.ClinicianPatientsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@ClinicianPatientsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.ClinicianPatientsTableCondition> conditions;
private readonly DataValue<int> @clinicianPatientIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the ClinicianPatientId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @ClinicianPatientId { get { return @clinicianPatientIdColumnValue.Value; } set { @clinicianPatientIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ClinicianPatientId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ClinicianPatientIdHasChanged { get { return @clinicianPatientIdColumnValue.Changed; } }
private readonly DataValue<string> @encryptionKeyVersionColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the EncryptionKeyVersion column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @EncryptionKeyVersion { get { return @encryptionKeyVersionColumnValue.Value; } set { @encryptionKeyVersionColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EncryptionKeyVersion has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EncryptionKeyVersionHasChanged { get { return @encryptionKeyVersionColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @encryptionIvColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the EncryptionIv column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @EncryptionIv { get { return @encryptionIvColumnValue.Value; } set { @encryptionIvColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EncryptionIv has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EncryptionIvHasChanged { get { return @encryptionIvColumnValue.Changed; } }
private readonly DataValue<int> @clinicianIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the ClinicianId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @ClinicianId { get { return @clinicianIdColumnValue.Value; } set { @clinicianIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ClinicianId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ClinicianIdHasChanged { get { return @clinicianIdColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @patientInfoIdColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the PatientInfoId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @PatientInfoId { get { return @patientInfoIdColumnValue.Value; } set { @patientInfoIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PatientInfoId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PatientInfoIdHasChanged { get { return @patientInfoIdColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the ClinicianPatients table.
/// </summary>
public static @ClinicianPatientsModification CreateForInsert() {
return new @ClinicianPatientsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the ClinicianPatients table.
/// </summary>
public static @ClinicianPatientsModification CreateForUpdate( CommandConditions.ClinicianPatientsTableCondition requiredCondition, params CommandConditions.ClinicianPatientsTableCondition[] additionalConditions ) {
var mod = new @ClinicianPatientsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@ClinicianPatientsTableEqualityConditions.@ClinicianPatientId )
mod.@clinicianPatientIdColumnValue.Value = ( condition as CommandConditions.@ClinicianPatientsTableEqualityConditions.@ClinicianPatientId ).Value;
else if( condition is CommandConditions.@ClinicianPatientsTableEqualityConditions.@EncryptionKeyVersion )
mod.@encryptionKeyVersionColumnValue.Value = ( condition as CommandConditions.@ClinicianPatientsTableEqualityConditions.@EncryptionKeyVersion ).Value;
else if( condition is CommandConditions.@ClinicianPatientsTableEqualityConditions.@EncryptionIv )
mod.@encryptionIvColumnValue.Value = ( condition as CommandConditions.@ClinicianPatientsTableEqualityConditions.@EncryptionIv ).Value;
else if( condition is CommandConditions.@ClinicianPatientsTableEqualityConditions.@ClinicianId )
mod.@clinicianIdColumnValue.Value = ( condition as CommandConditions.@ClinicianPatientsTableEqualityConditions.@ClinicianId ).Value;
else if( condition is CommandConditions.@ClinicianPatientsTableEqualityConditions.@PatientInfoId )
mod.@patientInfoIdColumnValue.Value = ( condition as CommandConditions.@ClinicianPatientsTableEqualityConditions.@PatientInfoId ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the ClinicianPatients table.
/// </summary>
public static @ClinicianPatientsModification CreateForSingleRowUpdate( int @clinicianPatientId, string @encryptionKeyVersion, System.Byte[] @encryptionIv, int @clinicianId, System.Byte[] @patientInfoId ) {
var mod = new @ClinicianPatientsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.ClinicianPatientsTableCondition>();
mod.conditions.Add( new CommandConditions.@ClinicianPatientsTableEqualityConditions.@ClinicianPatientId( @clinicianPatientId ) );
mod.@clinicianPatientIdColumnValue.Value = @clinicianPatientId;
mod.@encryptionKeyVersionColumnValue.Value = @encryptionKeyVersion;
mod.@encryptionIvColumnValue.Value = @encryptionIv;
mod.@clinicianIdColumnValue.Value = @clinicianId;
mod.@patientInfoIdColumnValue.Value = @patientInfoId;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.ClinicianPatientsTableCondition> getConditionList( CommandConditions.ClinicianPatientsTableCondition requiredCondition, params CommandConditions.ClinicianPatientsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.ClinicianPatientsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @ClinicianPatientsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="clinicianPatientId">Object does not allow null.</param>
/// <param name="encryptionKeyVersion">Object does not allow null.</param>
/// <param name="encryptionIv">Object does not allow null.</param>
/// <param name="clinicianId">Object does not allow null.</param>
/// <param name="patientInfoId">Object does not allow null.</param>
public void SetAllData( int @clinicianPatientId, string @encryptionKeyVersion, System.Byte[] @encryptionIv, int @clinicianId, System.Byte[] @patientInfoId ) {
this.@clinicianPatientIdColumnValue.Value = @clinicianPatientId;
this.@encryptionKeyVersionColumnValue.Value = @encryptionKeyVersion;
this.@encryptionIvColumnValue.Value = @encryptionIv;
this.@clinicianIdColumnValue.Value = @clinicianId;
this.@patientInfoIdColumnValue.Value = @patientInfoId;
}
/// <summary>
/// Executes this ClinicianPatients modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this ClinicianPatients modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "ClinicianPatients" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.ClinicianPatientsTableCondition>();
conditions.Add( new CommandConditions.@ClinicianPatientsTableEqualityConditions.@ClinicianPatientId( @ClinicianPatientId ) );
}
else {
var update = new InlineUpdate( "ClinicianPatients" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @clinicianPatientIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ClinicianPatientId", new DbParameterValue( @ClinicianPatientId, "Int" ) ) );
if( @encryptionKeyVersionColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EncryptionKeyVersion", new DbParameterValue( @EncryptionKeyVersion, "NVarChar" ) ) );
if( @encryptionIvColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EncryptionIv", new DbParameterValue( @EncryptionIv, "VarBinary" ) ) );
if( @clinicianIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ClinicianId", new DbParameterValue( @ClinicianId, "Int" ) ) );
if( @patientInfoIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PatientInfoId", new DbParameterValue( @PatientInfoId, "VarBinary" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@clinicianPatientIdColumnValue.ClearChanged();
@encryptionKeyVersionColumnValue.ClearChanged();
@encryptionIvColumnValue.ClearChanged();
@clinicianIdColumnValue.ClearChanged();
@patientInfoIdColumnValue.ClearChanged();
}
}
public partial class @CliniciansModification {
/// <summary>
/// Inserts a row into the Clinicians table.
/// </summary>
/// <param name="clinicianId">Object does not allow null.</param>
/// <param name="firstName">Object does not allow null.</param>
/// <param name="lastName">Object does not allow null.</param>
/// <param name="workGroupId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
public static void InsertRow( int @clinicianId, string @firstName, string @lastName, int @workGroupId, int @userId ) { 
var mod = CreateForInsert();
mod.@clinicianIdColumnValue.Value = @clinicianId;
mod.@firstNameColumnValue.Value = @firstName;
mod.@lastNameColumnValue.Value = @lastName;
mod.@workGroupIdColumnValue.Value = @workGroupId;
mod.@userIdColumnValue.Value = @userId;
mod.Execute();
}
/// <summary>
/// Inserts a row into the Clinicians table.
/// </summary>
/// <param name="clinicianId">Object does not allow null.</param>
/// <param name="firstName">Object does not allow null.</param>
/// <param name="lastName">Object does not allow null.</param>
/// <param name="workGroupId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @clinicianId, string @firstName, string @lastName, int @workGroupId, int @userId ) { 
var mod = CreateForInsert();
mod.@clinicianIdColumnValue.Value = @clinicianId;
mod.@firstNameColumnValue.Value = @firstName;
mod.@lastNameColumnValue.Value = @lastName;
mod.@workGroupIdColumnValue.Value = @workGroupId;
mod.@userIdColumnValue.Value = @userId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the Clinicians table that match the specified conditions with the specified data.
/// </summary>
/// <param name="clinicianId">Object does not allow null.</param>
/// <param name="firstName">Object does not allow null.</param>
/// <param name="lastName">Object does not allow null.</param>
/// <param name="workGroupId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @clinicianId, string @firstName, string @lastName, int @workGroupId, int @userId, CommandConditions.CliniciansTableCondition requiredCondition, params CommandConditions.CliniciansTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@clinicianIdColumnValue.Value = @clinicianId;
mod.@firstNameColumnValue.Value = @firstName;
mod.@lastNameColumnValue.Value = @lastName;
mod.@workGroupIdColumnValue.Value = @workGroupId;
mod.@userIdColumnValue.Value = @userId;
mod.Execute();
}
/// <summary>
/// Updates rows in the Clinicians table that match the specified conditions with the specified data.
/// </summary>
/// <param name="clinicianId">Object does not allow null.</param>
/// <param name="firstName">Object does not allow null.</param>
/// <param name="lastName">Object does not allow null.</param>
/// <param name="workGroupId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @clinicianId, string @firstName, string @lastName, int @workGroupId, int @userId, CommandConditions.CliniciansTableCondition requiredCondition, params CommandConditions.CliniciansTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@clinicianIdColumnValue.Value = @clinicianId;
mod.@firstNameColumnValue.Value = @firstName;
mod.@lastNameColumnValue.Value = @lastName;
mod.@workGroupIdColumnValue.Value = @workGroupId;
mod.@userIdColumnValue.Value = @userId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.CliniciansTableCondition requiredCondition, params CommandConditions.CliniciansTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@CliniciansTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.CliniciansTableCondition requiredCondition, params CommandConditions.CliniciansTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.CliniciansTableCondition> conditions ) {
var delete = new InlineDelete( "Clinicians" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.CliniciansTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@CliniciansTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.CliniciansTableCondition> conditions;
private readonly DataValue<int> @clinicianIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the ClinicianId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @ClinicianId { get { return @clinicianIdColumnValue.Value; } set { @clinicianIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ClinicianId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ClinicianIdHasChanged { get { return @clinicianIdColumnValue.Changed; } }
private readonly DataValue<string> @firstNameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the FirstName column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @FirstName { get { return @firstNameColumnValue.Value; } set { @firstNameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the FirstName has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @FirstNameHasChanged { get { return @firstNameColumnValue.Changed; } }
private readonly DataValue<string> @lastNameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the LastName column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @LastName { get { return @lastNameColumnValue.Value; } set { @lastNameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LastName has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LastNameHasChanged { get { return @lastNameColumnValue.Changed; } }
private readonly DataValue<int> @workGroupIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the WorkGroupId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @WorkGroupId { get { return @workGroupIdColumnValue.Value; } set { @workGroupIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the WorkGroupId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @WorkGroupIdHasChanged { get { return @workGroupIdColumnValue.Changed; } }
private readonly DataValue<int> @userIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the UserId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @UserId { get { return @userIdColumnValue.Value; } set { @userIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the UserId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @UserIdHasChanged { get { return @userIdColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the Clinicians table.
/// </summary>
public static @CliniciansModification CreateForInsert() {
return new @CliniciansModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the Clinicians table.
/// </summary>
public static @CliniciansModification CreateForUpdate( CommandConditions.CliniciansTableCondition requiredCondition, params CommandConditions.CliniciansTableCondition[] additionalConditions ) {
var mod = new @CliniciansModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@CliniciansTableEqualityConditions.@ClinicianId )
mod.@clinicianIdColumnValue.Value = ( condition as CommandConditions.@CliniciansTableEqualityConditions.@ClinicianId ).Value;
else if( condition is CommandConditions.@CliniciansTableEqualityConditions.@FirstName )
mod.@firstNameColumnValue.Value = ( condition as CommandConditions.@CliniciansTableEqualityConditions.@FirstName ).Value;
else if( condition is CommandConditions.@CliniciansTableEqualityConditions.@LastName )
mod.@lastNameColumnValue.Value = ( condition as CommandConditions.@CliniciansTableEqualityConditions.@LastName ).Value;
else if( condition is CommandConditions.@CliniciansTableEqualityConditions.@WorkGroupId )
mod.@workGroupIdColumnValue.Value = ( condition as CommandConditions.@CliniciansTableEqualityConditions.@WorkGroupId ).Value;
else if( condition is CommandConditions.@CliniciansTableEqualityConditions.@UserId )
mod.@userIdColumnValue.Value = ( condition as CommandConditions.@CliniciansTableEqualityConditions.@UserId ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the Clinicians table.
/// </summary>
public static @CliniciansModification CreateForSingleRowUpdate( int @clinicianId, string @firstName, string @lastName, int @workGroupId, int @userId ) {
var mod = new @CliniciansModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.CliniciansTableCondition>();
mod.conditions.Add( new CommandConditions.@CliniciansTableEqualityConditions.@ClinicianId( @clinicianId ) );
mod.@clinicianIdColumnValue.Value = @clinicianId;
mod.@firstNameColumnValue.Value = @firstName;
mod.@lastNameColumnValue.Value = @lastName;
mod.@workGroupIdColumnValue.Value = @workGroupId;
mod.@userIdColumnValue.Value = @userId;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.CliniciansTableCondition> getConditionList( CommandConditions.CliniciansTableCondition requiredCondition, params CommandConditions.CliniciansTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.CliniciansTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @CliniciansModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="clinicianId">Object does not allow null.</param>
/// <param name="firstName">Object does not allow null.</param>
/// <param name="lastName">Object does not allow null.</param>
/// <param name="workGroupId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
public void SetAllData( int @clinicianId, string @firstName, string @lastName, int @workGroupId, int @userId ) {
this.@clinicianIdColumnValue.Value = @clinicianId;
this.@firstNameColumnValue.Value = @firstName;
this.@lastNameColumnValue.Value = @lastName;
this.@workGroupIdColumnValue.Value = @workGroupId;
this.@userIdColumnValue.Value = @userId;
}
/// <summary>
/// Executes this Clinicians modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this Clinicians modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "Clinicians" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.CliniciansTableCondition>();
conditions.Add( new CommandConditions.@CliniciansTableEqualityConditions.@ClinicianId( @ClinicianId ) );
}
else {
var update = new InlineUpdate( "Clinicians" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @clinicianIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ClinicianId", new DbParameterValue( @ClinicianId, "Int" ) ) );
if( @firstNameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "FirstName", new DbParameterValue( @FirstName, "NVarChar" ) ) );
if( @lastNameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LastName", new DbParameterValue( @LastName, "NVarChar" ) ) );
if( @workGroupIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "WorkGroupId", new DbParameterValue( @WorkGroupId, "Int" ) ) );
if( @userIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( @UserId, "Int" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@clinicianIdColumnValue.ClearChanged();
@firstNameColumnValue.ClearChanged();
@lastNameColumnValue.ClearChanged();
@workGroupIdColumnValue.ClearChanged();
@userIdColumnValue.ClearChanged();
}
}
public partial class @CompletedCoursesModification {
/// <summary>
/// Inserts a row into the CompletedCourses table.
/// </summary>
/// <param name="completedCourseId">Object does not allow null.</param>
/// <param name="trainingCourseId">Object does not allow null.</param>
/// <param name="startDateTime">Object allows null.</param>
/// <param name="finishedDateTime">Object allows null.</param>
/// <param name="userId">Object does not allow null.</param>
public static void InsertRow( int @completedCourseId, int @trainingCourseId, System.DateTime? @startDateTime, System.DateTime? @finishedDateTime, int @userId ) { 
var mod = CreateForInsert();
mod.@completedCourseIdColumnValue.Value = @completedCourseId;
mod.@trainingCourseIdColumnValue.Value = @trainingCourseId;
mod.@startDateTimeColumnValue.Value = @startDateTime;
mod.@finishedDateTimeColumnValue.Value = @finishedDateTime;
mod.@userIdColumnValue.Value = @userId;
mod.Execute();
}
/// <summary>
/// Inserts a row into the CompletedCourses table.
/// </summary>
/// <param name="completedCourseId">Object does not allow null.</param>
/// <param name="trainingCourseId">Object does not allow null.</param>
/// <param name="startDateTime">Object allows null.</param>
/// <param name="finishedDateTime">Object allows null.</param>
/// <param name="userId">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @completedCourseId, int @trainingCourseId, System.DateTime? @startDateTime, System.DateTime? @finishedDateTime, int @userId ) { 
var mod = CreateForInsert();
mod.@completedCourseIdColumnValue.Value = @completedCourseId;
mod.@trainingCourseIdColumnValue.Value = @trainingCourseId;
mod.@startDateTimeColumnValue.Value = @startDateTime;
mod.@finishedDateTimeColumnValue.Value = @finishedDateTime;
mod.@userIdColumnValue.Value = @userId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the CompletedCourses table that match the specified conditions with the specified data.
/// </summary>
/// <param name="completedCourseId">Object does not allow null.</param>
/// <param name="trainingCourseId">Object does not allow null.</param>
/// <param name="startDateTime">Object allows null.</param>
/// <param name="finishedDateTime">Object allows null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @completedCourseId, int @trainingCourseId, System.DateTime? @startDateTime, System.DateTime? @finishedDateTime, int @userId, CommandConditions.CompletedCoursesTableCondition requiredCondition, params CommandConditions.CompletedCoursesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@completedCourseIdColumnValue.Value = @completedCourseId;
mod.@trainingCourseIdColumnValue.Value = @trainingCourseId;
mod.@startDateTimeColumnValue.Value = @startDateTime;
mod.@finishedDateTimeColumnValue.Value = @finishedDateTime;
mod.@userIdColumnValue.Value = @userId;
mod.Execute();
}
/// <summary>
/// Updates rows in the CompletedCourses table that match the specified conditions with the specified data.
/// </summary>
/// <param name="completedCourseId">Object does not allow null.</param>
/// <param name="trainingCourseId">Object does not allow null.</param>
/// <param name="startDateTime">Object allows null.</param>
/// <param name="finishedDateTime">Object allows null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @completedCourseId, int @trainingCourseId, System.DateTime? @startDateTime, System.DateTime? @finishedDateTime, int @userId, CommandConditions.CompletedCoursesTableCondition requiredCondition, params CommandConditions.CompletedCoursesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@completedCourseIdColumnValue.Value = @completedCourseId;
mod.@trainingCourseIdColumnValue.Value = @trainingCourseId;
mod.@startDateTimeColumnValue.Value = @startDateTime;
mod.@finishedDateTimeColumnValue.Value = @finishedDateTime;
mod.@userIdColumnValue.Value = @userId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.CompletedCoursesTableCondition requiredCondition, params CommandConditions.CompletedCoursesTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@CompletedCoursesTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.CompletedCoursesTableCondition requiredCondition, params CommandConditions.CompletedCoursesTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.CompletedCoursesTableCondition> conditions ) {
var delete = new InlineDelete( "CompletedCourses" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.CompletedCoursesTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@CompletedCoursesTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.CompletedCoursesTableCondition> conditions;
private readonly DataValue<int> @completedCourseIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the CompletedCourseId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @CompletedCourseId { get { return @completedCourseIdColumnValue.Value; } set { @completedCourseIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the CompletedCourseId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @CompletedCourseIdHasChanged { get { return @completedCourseIdColumnValue.Changed; } }
private readonly DataValue<int> @trainingCourseIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the TrainingCourseId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @TrainingCourseId { get { return @trainingCourseIdColumnValue.Value; } set { @trainingCourseIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the TrainingCourseId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @TrainingCourseIdHasChanged { get { return @trainingCourseIdColumnValue.Changed; } }
private readonly DataValue<System.DateTime?> @startDateTimeColumnValue = new DataValue<System.DateTime?>();
/// <summary>
/// Gets or sets the value for the StartDateTime column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.DateTime? @StartDateTime { get { return @startDateTimeColumnValue.Value; } set { @startDateTimeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the StartDateTime has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @StartDateTimeHasChanged { get { return @startDateTimeColumnValue.Changed; } }
private readonly DataValue<System.DateTime?> @finishedDateTimeColumnValue = new DataValue<System.DateTime?>();
/// <summary>
/// Gets or sets the value for the FinishedDateTime column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.DateTime? @FinishedDateTime { get { return @finishedDateTimeColumnValue.Value; } set { @finishedDateTimeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the FinishedDateTime has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @FinishedDateTimeHasChanged { get { return @finishedDateTimeColumnValue.Changed; } }
private readonly DataValue<int> @userIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the UserId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @UserId { get { return @userIdColumnValue.Value; } set { @userIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the UserId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @UserIdHasChanged { get { return @userIdColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the CompletedCourses table.
/// </summary>
public static @CompletedCoursesModification CreateForInsert() {
return new @CompletedCoursesModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the CompletedCourses table.
/// </summary>
public static @CompletedCoursesModification CreateForUpdate( CommandConditions.CompletedCoursesTableCondition requiredCondition, params CommandConditions.CompletedCoursesTableCondition[] additionalConditions ) {
var mod = new @CompletedCoursesModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@CompletedCoursesTableEqualityConditions.@CompletedCourseId )
mod.@completedCourseIdColumnValue.Value = ( condition as CommandConditions.@CompletedCoursesTableEqualityConditions.@CompletedCourseId ).Value;
else if( condition is CommandConditions.@CompletedCoursesTableEqualityConditions.@TrainingCourseId )
mod.@trainingCourseIdColumnValue.Value = ( condition as CommandConditions.@CompletedCoursesTableEqualityConditions.@TrainingCourseId ).Value;
else if( condition is CommandConditions.@CompletedCoursesTableEqualityConditions.@StartDateTime )
mod.@startDateTimeColumnValue.Value = ( condition as CommandConditions.@CompletedCoursesTableEqualityConditions.@StartDateTime ).Value;
else if( condition is CommandConditions.@CompletedCoursesTableEqualityConditions.@FinishedDateTime )
mod.@finishedDateTimeColumnValue.Value = ( condition as CommandConditions.@CompletedCoursesTableEqualityConditions.@FinishedDateTime ).Value;
else if( condition is CommandConditions.@CompletedCoursesTableEqualityConditions.@UserId )
mod.@userIdColumnValue.Value = ( condition as CommandConditions.@CompletedCoursesTableEqualityConditions.@UserId ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the CompletedCourses table.
/// </summary>
public static @CompletedCoursesModification CreateForSingleRowUpdate( int @completedCourseId, int @trainingCourseId, System.DateTime? @startDateTime, System.DateTime? @finishedDateTime, int @userId ) {
var mod = new @CompletedCoursesModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.CompletedCoursesTableCondition>();
mod.conditions.Add( new CommandConditions.@CompletedCoursesTableEqualityConditions.@CompletedCourseId( @completedCourseId ) );
mod.@completedCourseIdColumnValue.Value = @completedCourseId;
mod.@trainingCourseIdColumnValue.Value = @trainingCourseId;
mod.@startDateTimeColumnValue.Value = @startDateTime;
mod.@finishedDateTimeColumnValue.Value = @finishedDateTime;
mod.@userIdColumnValue.Value = @userId;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.CompletedCoursesTableCondition> getConditionList( CommandConditions.CompletedCoursesTableCondition requiredCondition, params CommandConditions.CompletedCoursesTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.CompletedCoursesTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @CompletedCoursesModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="completedCourseId">Object does not allow null.</param>
/// <param name="trainingCourseId">Object does not allow null.</param>
/// <param name="startDateTime">Object allows null.</param>
/// <param name="finishedDateTime">Object allows null.</param>
/// <param name="userId">Object does not allow null.</param>
public void SetAllData( int @completedCourseId, int @trainingCourseId, System.DateTime? @startDateTime, System.DateTime? @finishedDateTime, int @userId ) {
this.@completedCourseIdColumnValue.Value = @completedCourseId;
this.@trainingCourseIdColumnValue.Value = @trainingCourseId;
this.@startDateTimeColumnValue.Value = @startDateTime;
this.@finishedDateTimeColumnValue.Value = @finishedDateTime;
this.@userIdColumnValue.Value = @userId;
}
/// <summary>
/// Executes this CompletedCourses modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this CompletedCourses modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "CompletedCourses" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.CompletedCoursesTableCondition>();
conditions.Add( new CommandConditions.@CompletedCoursesTableEqualityConditions.@CompletedCourseId( @CompletedCourseId ) );
}
else {
var update = new InlineUpdate( "CompletedCourses" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @completedCourseIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "CompletedCourseId", new DbParameterValue( @CompletedCourseId, "Int" ) ) );
if( @trainingCourseIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "TrainingCourseId", new DbParameterValue( @TrainingCourseId, "Int" ) ) );
if( @startDateTimeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "StartDateTime", new DbParameterValue( @StartDateTime, "DateTime2" ) ) );
if( @finishedDateTimeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "FinishedDateTime", new DbParameterValue( @FinishedDateTime, "DateTime2" ) ) );
if( @userIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( @UserId, "Int" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@completedCourseIdColumnValue.ClearChanged();
@trainingCourseIdColumnValue.ClearChanged();
@startDateTimeColumnValue.ClearChanged();
@finishedDateTimeColumnValue.ClearChanged();
@userIdColumnValue.ClearChanged();
}
}
public partial class @ConsentTypesModification {
/// <summary>
/// Inserts a row into the ConsentTypes table.
/// </summary>
/// <param name="consentTypeId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
public static void InsertRow( int @consentTypeId, string @name ) { 
var mod = CreateForInsert();
mod.@consentTypeIdColumnValue.Value = @consentTypeId;
mod.@nameColumnValue.Value = @name;
mod.Execute();
}
/// <summary>
/// Inserts a row into the ConsentTypes table.
/// </summary>
/// <param name="consentTypeId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @consentTypeId, string @name ) { 
var mod = CreateForInsert();
mod.@consentTypeIdColumnValue.Value = @consentTypeId;
mod.@nameColumnValue.Value = @name;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the ConsentTypes table that match the specified conditions with the specified data.
/// </summary>
/// <param name="consentTypeId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @consentTypeId, string @name, CommandConditions.ConsentTypesTableCondition requiredCondition, params CommandConditions.ConsentTypesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@consentTypeIdColumnValue.Value = @consentTypeId;
mod.@nameColumnValue.Value = @name;
mod.Execute();
}
/// <summary>
/// Updates rows in the ConsentTypes table that match the specified conditions with the specified data.
/// </summary>
/// <param name="consentTypeId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @consentTypeId, string @name, CommandConditions.ConsentTypesTableCondition requiredCondition, params CommandConditions.ConsentTypesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@consentTypeIdColumnValue.Value = @consentTypeId;
mod.@nameColumnValue.Value = @name;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.ConsentTypesTableCondition requiredCondition, params CommandConditions.ConsentTypesTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@ConsentTypesTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.ConsentTypesTableCondition requiredCondition, params CommandConditions.ConsentTypesTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.ConsentTypesTableCondition> conditions ) {
var delete = new InlineDelete( "ConsentTypes" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.ConsentTypesTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@ConsentTypesTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.ConsentTypesTableCondition> conditions;
private readonly DataValue<int> @consentTypeIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the ConsentTypeId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @ConsentTypeId { get { return @consentTypeIdColumnValue.Value; } set { @consentTypeIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ConsentTypeId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ConsentTypeIdHasChanged { get { return @consentTypeIdColumnValue.Changed; } }
private readonly DataValue<string> @nameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Name column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Name { get { return @nameColumnValue.Value; } set { @nameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Name has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @NameHasChanged { get { return @nameColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the ConsentTypes table.
/// </summary>
public static @ConsentTypesModification CreateForInsert() {
return new @ConsentTypesModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the ConsentTypes table.
/// </summary>
public static @ConsentTypesModification CreateForUpdate( CommandConditions.ConsentTypesTableCondition requiredCondition, params CommandConditions.ConsentTypesTableCondition[] additionalConditions ) {
var mod = new @ConsentTypesModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@ConsentTypesTableEqualityConditions.@ConsentTypeId )
mod.@consentTypeIdColumnValue.Value = ( condition as CommandConditions.@ConsentTypesTableEqualityConditions.@ConsentTypeId ).Value;
else if( condition is CommandConditions.@ConsentTypesTableEqualityConditions.@Name )
mod.@nameColumnValue.Value = ( condition as CommandConditions.@ConsentTypesTableEqualityConditions.@Name ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the ConsentTypes table.
/// </summary>
public static @ConsentTypesModification CreateForSingleRowUpdate( int @consentTypeId, string @name ) {
var mod = new @ConsentTypesModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.ConsentTypesTableCondition>();
mod.conditions.Add( new CommandConditions.@ConsentTypesTableEqualityConditions.@ConsentTypeId( @consentTypeId ) );
mod.@consentTypeIdColumnValue.Value = @consentTypeId;
mod.@nameColumnValue.Value = @name;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.ConsentTypesTableCondition> getConditionList( CommandConditions.ConsentTypesTableCondition requiredCondition, params CommandConditions.ConsentTypesTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.ConsentTypesTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @ConsentTypesModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="consentTypeId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
public void SetAllData( int @consentTypeId, string @name ) {
this.@consentTypeIdColumnValue.Value = @consentTypeId;
this.@nameColumnValue.Value = @name;
}
/// <summary>
/// Executes this ConsentTypes modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this ConsentTypes modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "ConsentTypes" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.ConsentTypesTableCondition>();
conditions.Add( new CommandConditions.@ConsentTypesTableEqualityConditions.@ConsentTypeId( @ConsentTypeId ) );
}
else {
var update = new InlineUpdate( "ConsentTypes" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @consentTypeIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ConsentTypeId", new DbParameterValue( @ConsentTypeId, "Int" ) ) );
if( @nameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Name", new DbParameterValue( @Name, "VarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@consentTypeIdColumnValue.ClearChanged();
@nameColumnValue.ClearChanged();
}
}
public partial class @ContentModification {
/// <summary>
/// Inserts a row into the Content table.
/// </summary>
/// <param name="contentId">Object does not allow null.</param>
/// <param name="text">Object does not allow null.</param>
/// <param name="htmlBlockId">Object does not allow null.</param>
/// <param name="orderRankId">Object does not allow null.</param>
/// <param name="contentTabId">Object does not allow null.</param>
public static void InsertRow( int @contentId, string @text, int @htmlBlockId, int @orderRankId, int @contentTabId ) { 
var mod = CreateForInsert();
mod.@contentIdColumnValue.Value = @contentId;
mod.@textColumnValue.Value = @text;
mod.@htmlBlockIdColumnValue.Value = @htmlBlockId;
mod.@orderRankIdColumnValue.Value = @orderRankId;
mod.@contentTabIdColumnValue.Value = @contentTabId;
mod.Execute();
}
/// <summary>
/// Inserts a row into the Content table.
/// </summary>
/// <param name="contentId">Object does not allow null.</param>
/// <param name="text">Object does not allow null.</param>
/// <param name="htmlBlockId">Object does not allow null.</param>
/// <param name="orderRankId">Object does not allow null.</param>
/// <param name="contentTabId">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @contentId, string @text, int @htmlBlockId, int @orderRankId, int @contentTabId ) { 
var mod = CreateForInsert();
mod.@contentIdColumnValue.Value = @contentId;
mod.@textColumnValue.Value = @text;
mod.@htmlBlockIdColumnValue.Value = @htmlBlockId;
mod.@orderRankIdColumnValue.Value = @orderRankId;
mod.@contentTabIdColumnValue.Value = @contentTabId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the Content table that match the specified conditions with the specified data.
/// </summary>
/// <param name="contentId">Object does not allow null.</param>
/// <param name="text">Object does not allow null.</param>
/// <param name="htmlBlockId">Object does not allow null.</param>
/// <param name="orderRankId">Object does not allow null.</param>
/// <param name="contentTabId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @contentId, string @text, int @htmlBlockId, int @orderRankId, int @contentTabId, CommandConditions.ContentTableCondition requiredCondition, params CommandConditions.ContentTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@contentIdColumnValue.Value = @contentId;
mod.@textColumnValue.Value = @text;
mod.@htmlBlockIdColumnValue.Value = @htmlBlockId;
mod.@orderRankIdColumnValue.Value = @orderRankId;
mod.@contentTabIdColumnValue.Value = @contentTabId;
mod.Execute();
}
/// <summary>
/// Updates rows in the Content table that match the specified conditions with the specified data.
/// </summary>
/// <param name="contentId">Object does not allow null.</param>
/// <param name="text">Object does not allow null.</param>
/// <param name="htmlBlockId">Object does not allow null.</param>
/// <param name="orderRankId">Object does not allow null.</param>
/// <param name="contentTabId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @contentId, string @text, int @htmlBlockId, int @orderRankId, int @contentTabId, CommandConditions.ContentTableCondition requiredCondition, params CommandConditions.ContentTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@contentIdColumnValue.Value = @contentId;
mod.@textColumnValue.Value = @text;
mod.@htmlBlockIdColumnValue.Value = @htmlBlockId;
mod.@orderRankIdColumnValue.Value = @orderRankId;
mod.@contentTabIdColumnValue.Value = @contentTabId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.ContentTableCondition requiredCondition, params CommandConditions.ContentTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@ContentTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.ContentTableCondition requiredCondition, params CommandConditions.ContentTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.ContentTableCondition> conditions ) {
var delete = new InlineDelete( "Content" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.ContentTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@ContentTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.ContentTableCondition> conditions;
private readonly DataValue<int> @contentIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the ContentId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @ContentId { get { return @contentIdColumnValue.Value; } set { @contentIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ContentId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ContentIdHasChanged { get { return @contentIdColumnValue.Changed; } }
private readonly DataValue<string> @textColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Text column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Text { get { return @textColumnValue.Value; } set { @textColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Text has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @TextHasChanged { get { return @textColumnValue.Changed; } }
private readonly DataValue<int> @htmlBlockIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the HtmlBlockId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @HtmlBlockId { get { return @htmlBlockIdColumnValue.Value; } set { @htmlBlockIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the HtmlBlockId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @HtmlBlockIdHasChanged { get { return @htmlBlockIdColumnValue.Changed; } }
private readonly DataValue<int> @orderRankIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the OrderRankId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @OrderRankId { get { return @orderRankIdColumnValue.Value; } set { @orderRankIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the OrderRankId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @OrderRankIdHasChanged { get { return @orderRankIdColumnValue.Changed; } }
private readonly DataValue<int> @contentTabIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the ContentTabId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @ContentTabId { get { return @contentTabIdColumnValue.Value; } set { @contentTabIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ContentTabId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ContentTabIdHasChanged { get { return @contentTabIdColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the Content table.
/// </summary>
public static @ContentModification CreateForInsert() {
return new @ContentModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the Content table.
/// </summary>
public static @ContentModification CreateForUpdate( CommandConditions.ContentTableCondition requiredCondition, params CommandConditions.ContentTableCondition[] additionalConditions ) {
var mod = new @ContentModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@ContentTableEqualityConditions.@ContentId )
mod.@contentIdColumnValue.Value = ( condition as CommandConditions.@ContentTableEqualityConditions.@ContentId ).Value;
else if( condition is CommandConditions.@ContentTableEqualityConditions.@Text )
mod.@textColumnValue.Value = ( condition as CommandConditions.@ContentTableEqualityConditions.@Text ).Value;
else if( condition is CommandConditions.@ContentTableEqualityConditions.@HtmlBlockId )
mod.@htmlBlockIdColumnValue.Value = ( condition as CommandConditions.@ContentTableEqualityConditions.@HtmlBlockId ).Value;
else if( condition is CommandConditions.@ContentTableEqualityConditions.@OrderRankId )
mod.@orderRankIdColumnValue.Value = ( condition as CommandConditions.@ContentTableEqualityConditions.@OrderRankId ).Value;
else if( condition is CommandConditions.@ContentTableEqualityConditions.@ContentTabId )
mod.@contentTabIdColumnValue.Value = ( condition as CommandConditions.@ContentTableEqualityConditions.@ContentTabId ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the Content table.
/// </summary>
public static @ContentModification CreateForSingleRowUpdate( int @contentId, string @text, int @htmlBlockId, int @orderRankId, int @contentTabId ) {
var mod = new @ContentModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.ContentTableCondition>();
mod.conditions.Add( new CommandConditions.@ContentTableEqualityConditions.@ContentId( @contentId ) );
mod.@contentIdColumnValue.Value = @contentId;
mod.@textColumnValue.Value = @text;
mod.@htmlBlockIdColumnValue.Value = @htmlBlockId;
mod.@orderRankIdColumnValue.Value = @orderRankId;
mod.@contentTabIdColumnValue.Value = @contentTabId;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.ContentTableCondition> getConditionList( CommandConditions.ContentTableCondition requiredCondition, params CommandConditions.ContentTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.ContentTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @ContentModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="contentId">Object does not allow null.</param>
/// <param name="text">Object does not allow null.</param>
/// <param name="htmlBlockId">Object does not allow null.</param>
/// <param name="orderRankId">Object does not allow null.</param>
/// <param name="contentTabId">Object does not allow null.</param>
public void SetAllData( int @contentId, string @text, int @htmlBlockId, int @orderRankId, int @contentTabId ) {
this.@contentIdColumnValue.Value = @contentId;
this.@textColumnValue.Value = @text;
this.@htmlBlockIdColumnValue.Value = @htmlBlockId;
this.@orderRankIdColumnValue.Value = @orderRankId;
this.@contentTabIdColumnValue.Value = @contentTabId;
}
/// <summary>
/// Executes this Content modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this Content modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "Content" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.ContentTableCondition>();
conditions.Add( new CommandConditions.@ContentTableEqualityConditions.@ContentId( @ContentId ) );
}
else {
var update = new InlineUpdate( "Content" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @contentIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ContentId", new DbParameterValue( @ContentId, "Int" ) ) );
if( @textColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Text", new DbParameterValue( @Text, "NVarChar" ) ) );
if( @htmlBlockIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "HtmlBlockId", new DbParameterValue( @HtmlBlockId, "Int" ) ) );
if( @orderRankIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "OrderRankId", new DbParameterValue( @OrderRankId, "Int" ) ) );
if( @contentTabIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ContentTabId", new DbParameterValue( @ContentTabId, "Int" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@contentIdColumnValue.ClearChanged();
@textColumnValue.ClearChanged();
@htmlBlockIdColumnValue.ClearChanged();
@orderRankIdColumnValue.ClearChanged();
@contentTabIdColumnValue.ClearChanged();
}
}
public partial class @ContentTabsModification {
/// <summary>
/// Inserts a row into the ContentTabs table.
/// </summary>
/// <param name="contentTabId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="hasProviderPortalTab">Object does not allow null.</param>
public static void InsertRow( int @contentTabId, string @name, System.Boolean @hasProviderPortalTab ) { 
var mod = CreateForInsert();
mod.@contentTabIdColumnValue.Value = @contentTabId;
mod.@nameColumnValue.Value = @name;
mod.@hasProviderPortalTabColumnValue.Value = @hasProviderPortalTab;
mod.Execute();
}
/// <summary>
/// Inserts a row into the ContentTabs table.
/// </summary>
/// <param name="contentTabId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="hasProviderPortalTab">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @contentTabId, string @name, System.Boolean @hasProviderPortalTab ) { 
var mod = CreateForInsert();
mod.@contentTabIdColumnValue.Value = @contentTabId;
mod.@nameColumnValue.Value = @name;
mod.@hasProviderPortalTabColumnValue.Value = @hasProviderPortalTab;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the ContentTabs table that match the specified conditions with the specified data.
/// </summary>
/// <param name="contentTabId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="hasProviderPortalTab">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @contentTabId, string @name, System.Boolean @hasProviderPortalTab, CommandConditions.ContentTabsTableCondition requiredCondition, params CommandConditions.ContentTabsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@contentTabIdColumnValue.Value = @contentTabId;
mod.@nameColumnValue.Value = @name;
mod.@hasProviderPortalTabColumnValue.Value = @hasProviderPortalTab;
mod.Execute();
}
/// <summary>
/// Updates rows in the ContentTabs table that match the specified conditions with the specified data.
/// </summary>
/// <param name="contentTabId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="hasProviderPortalTab">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @contentTabId, string @name, System.Boolean @hasProviderPortalTab, CommandConditions.ContentTabsTableCondition requiredCondition, params CommandConditions.ContentTabsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@contentTabIdColumnValue.Value = @contentTabId;
mod.@nameColumnValue.Value = @name;
mod.@hasProviderPortalTabColumnValue.Value = @hasProviderPortalTab;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.ContentTabsTableCondition requiredCondition, params CommandConditions.ContentTabsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@ContentTabsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.ContentTabsTableCondition requiredCondition, params CommandConditions.ContentTabsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.ContentTabsTableCondition> conditions ) {
var delete = new InlineDelete( "ContentTabs" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.ContentTabsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@ContentTabsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.ContentTabsTableCondition> conditions;
private readonly DataValue<int> @contentTabIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the ContentTabId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @ContentTabId { get { return @contentTabIdColumnValue.Value; } set { @contentTabIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ContentTabId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ContentTabIdHasChanged { get { return @contentTabIdColumnValue.Changed; } }
private readonly DataValue<string> @nameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Name column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Name { get { return @nameColumnValue.Value; } set { @nameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Name has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @NameHasChanged { get { return @nameColumnValue.Changed; } }
private readonly DataValue<System.Boolean> @hasProviderPortalTabColumnValue = new DataValue<System.Boolean>();
/// <summary>
/// Gets or sets the value for the HasProviderPortalTab column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Boolean @HasProviderPortalTab { get { return @hasProviderPortalTabColumnValue.Value; } set { @hasProviderPortalTabColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the HasProviderPortalTab has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @HasProviderPortalTabHasChanged { get { return @hasProviderPortalTabColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the ContentTabs table.
/// </summary>
public static @ContentTabsModification CreateForInsert() {
return new @ContentTabsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the ContentTabs table.
/// </summary>
public static @ContentTabsModification CreateForUpdate( CommandConditions.ContentTabsTableCondition requiredCondition, params CommandConditions.ContentTabsTableCondition[] additionalConditions ) {
var mod = new @ContentTabsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@ContentTabsTableEqualityConditions.@ContentTabId )
mod.@contentTabIdColumnValue.Value = ( condition as CommandConditions.@ContentTabsTableEqualityConditions.@ContentTabId ).Value;
else if( condition is CommandConditions.@ContentTabsTableEqualityConditions.@Name )
mod.@nameColumnValue.Value = ( condition as CommandConditions.@ContentTabsTableEqualityConditions.@Name ).Value;
else if( condition is CommandConditions.@ContentTabsTableEqualityConditions.@HasProviderPortalTab )
mod.@hasProviderPortalTabColumnValue.Value = ( condition as CommandConditions.@ContentTabsTableEqualityConditions.@HasProviderPortalTab ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the ContentTabs table.
/// </summary>
public static @ContentTabsModification CreateForSingleRowUpdate( int @contentTabId, string @name, System.Boolean @hasProviderPortalTab ) {
var mod = new @ContentTabsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.ContentTabsTableCondition>();
mod.conditions.Add( new CommandConditions.@ContentTabsTableEqualityConditions.@ContentTabId( @contentTabId ) );
mod.@contentTabIdColumnValue.Value = @contentTabId;
mod.@nameColumnValue.Value = @name;
mod.@hasProviderPortalTabColumnValue.Value = @hasProviderPortalTab;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.ContentTabsTableCondition> getConditionList( CommandConditions.ContentTabsTableCondition requiredCondition, params CommandConditions.ContentTabsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.ContentTabsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @ContentTabsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="contentTabId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="hasProviderPortalTab">Object does not allow null.</param>
public void SetAllData( int @contentTabId, string @name, System.Boolean @hasProviderPortalTab ) {
this.@contentTabIdColumnValue.Value = @contentTabId;
this.@nameColumnValue.Value = @name;
this.@hasProviderPortalTabColumnValue.Value = @hasProviderPortalTab;
}
/// <summary>
/// Executes this ContentTabs modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this ContentTabs modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "ContentTabs" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.ContentTabsTableCondition>();
conditions.Add( new CommandConditions.@ContentTabsTableEqualityConditions.@ContentTabId( @ContentTabId ) );
}
else {
var update = new InlineUpdate( "ContentTabs" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @contentTabIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ContentTabId", new DbParameterValue( @ContentTabId, "Int" ) ) );
if( @nameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Name", new DbParameterValue( @Name, "VarChar" ) ) );
if( @hasProviderPortalTabColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "HasProviderPortalTab", new DbParameterValue( @HasProviderPortalTab, "Bit" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@contentTabIdColumnValue.ClearChanged();
@nameColumnValue.ClearChanged();
@hasProviderPortalTabColumnValue.ClearChanged();
}
}
public partial class @DirectAccessLogsModification {
/// <summary>
/// Inserts a row into the DirectAccessLogs table. Returns the value of the DirectAccessLogs column.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="dateTimeUtc">Object does not allow null.</param>
public static int InsertRow( int @userId, DateTime @dateTimeUtc ) { 
var mod = CreateForInsert();
mod.@userIdColumnValue.Value = @userId;
mod.@dateTimeUtcColumnValue.Value = @dateTimeUtc;
mod.Execute();
return mod.DirectAccessLogs;
}
/// <summary>
/// Inserts a row into the DirectAccessLogs table. Returns the value of the DirectAccessLogs column.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="dateTimeUtc">Object does not allow null.</param>
public static int InsertRowWithoutAdditionalLogic( int @userId, DateTime @dateTimeUtc ) { 
var mod = CreateForInsert();
mod.@userIdColumnValue.Value = @userId;
mod.@dateTimeUtcColumnValue.Value = @dateTimeUtc;
mod.ExecuteWithoutAdditionalLogic();
return mod.DirectAccessLogs;
}
/// <summary>
/// Updates rows in the DirectAccessLogs table that match the specified conditions with the specified data.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="dateTimeUtc">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @userId, DateTime @dateTimeUtc, CommandConditions.DirectAccessLogsTableCondition requiredCondition, params CommandConditions.DirectAccessLogsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@userIdColumnValue.Value = @userId;
mod.@dateTimeUtcColumnValue.Value = @dateTimeUtc;
mod.Execute();
}
/// <summary>
/// Updates rows in the DirectAccessLogs table that match the specified conditions with the specified data.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="dateTimeUtc">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @userId, DateTime @dateTimeUtc, CommandConditions.DirectAccessLogsTableCondition requiredCondition, params CommandConditions.DirectAccessLogsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@userIdColumnValue.Value = @userId;
mod.@dateTimeUtcColumnValue.Value = @dateTimeUtc;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.DirectAccessLogsTableCondition requiredCondition, params CommandConditions.DirectAccessLogsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@DirectAccessLogsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.DirectAccessLogsTableCondition requiredCondition, params CommandConditions.DirectAccessLogsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.DirectAccessLogsTableCondition> conditions ) {
var delete = new InlineDelete( "DirectAccessLogs" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.DirectAccessLogsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@DirectAccessLogsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.DirectAccessLogsTableCondition> conditions;
private readonly DataValue<int> @directAccessLogsColumnValue = new DataValue<int>();
/// <summary>
/// Gets the value for the DirectAccessLogs column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @DirectAccessLogs { get { return @directAccessLogsColumnValue.Value; } }
private readonly DataValue<int> @userIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the UserId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @UserId { get { return @userIdColumnValue.Value; } set { @userIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the UserId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @UserIdHasChanged { get { return @userIdColumnValue.Changed; } }
private readonly DataValue<DateTime> @dateTimeUtcColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the DateTimeUtc column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @DateTimeUtc { get { return @dateTimeUtcColumnValue.Value; } set { @dateTimeUtcColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the DateTimeUtc has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @DateTimeUtcHasChanged { get { return @dateTimeUtcColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the DirectAccessLogs table.
/// </summary>
public static @DirectAccessLogsModification CreateForInsert() {
return new @DirectAccessLogsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the DirectAccessLogs table.
/// </summary>
public static @DirectAccessLogsModification CreateForUpdate( CommandConditions.DirectAccessLogsTableCondition requiredCondition, params CommandConditions.DirectAccessLogsTableCondition[] additionalConditions ) {
var mod = new @DirectAccessLogsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@DirectAccessLogsTableEqualityConditions.@DirectAccessLogs )
mod.@directAccessLogsColumnValue.Value = ( condition as CommandConditions.@DirectAccessLogsTableEqualityConditions.@DirectAccessLogs ).Value;
else if( condition is CommandConditions.@DirectAccessLogsTableEqualityConditions.@UserId )
mod.@userIdColumnValue.Value = ( condition as CommandConditions.@DirectAccessLogsTableEqualityConditions.@UserId ).Value;
else if( condition is CommandConditions.@DirectAccessLogsTableEqualityConditions.@DateTimeUtc )
mod.@dateTimeUtcColumnValue.Value = ( condition as CommandConditions.@DirectAccessLogsTableEqualityConditions.@DateTimeUtc ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the DirectAccessLogs table.
/// </summary>
public static @DirectAccessLogsModification CreateForSingleRowUpdate( int @directAccessLogs, int @userId, DateTime @dateTimeUtc ) {
var mod = new @DirectAccessLogsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.DirectAccessLogsTableCondition>();
mod.conditions.Add( new CommandConditions.@DirectAccessLogsTableEqualityConditions.@DirectAccessLogs( @directAccessLogs ) );
mod.@directAccessLogsColumnValue.Value = @directAccessLogs;
mod.@userIdColumnValue.Value = @userId;
mod.@dateTimeUtcColumnValue.Value = @dateTimeUtc;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.DirectAccessLogsTableCondition> getConditionList( CommandConditions.DirectAccessLogsTableCondition requiredCondition, params CommandConditions.DirectAccessLogsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.DirectAccessLogsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @DirectAccessLogsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="dateTimeUtc">Object does not allow null.</param>
public void SetAllData( int @userId, DateTime @dateTimeUtc ) {
this.@userIdColumnValue.Value = @userId;
this.@dateTimeUtcColumnValue.Value = @dateTimeUtc;
}
/// <summary>
/// Executes this DirectAccessLogs modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this DirectAccessLogs modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "DirectAccessLogs" );
addColumnModifications( insert );
@directAccessLogsColumnValue.Value = (System.Int32)Utility.ChangeType( insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection ), typeof( System.Int32 ) );
modType = ModificationType.Update;
conditions = new List<CommandConditions.DirectAccessLogsTableCondition>();
conditions.Add( new CommandConditions.@DirectAccessLogsTableEqualityConditions.@DirectAccessLogs( @DirectAccessLogs ) );
}
else {
var update = new InlineUpdate( "DirectAccessLogs" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @userIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( @UserId, "Int" ) ) );
if( @dateTimeUtcColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "DateTimeUtc", new DbParameterValue( @DateTimeUtc, "DateTime2" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@directAccessLogsColumnValue.ClearChanged();
@userIdColumnValue.ClearChanged();
@dateTimeUtcColumnValue.ClearChanged();
}
}
public partial class @EmailTemplatesModification {
/// <summary>
/// Inserts a row into the EmailTemplates table.
/// </summary>
/// <param name="emailTemplateId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="subject">Object does not allow null.</param>
/// <param name="htmlBlockId">Object does not allow null.</param>
/// <param name="roleId">Object allows null.</param>
/// <param name="emailTemplateTypeId">Object does not allow null.</param>
public static void InsertRow( int @emailTemplateId, string @name, string @subject, int @htmlBlockId, System.Int32? @roleId, int @emailTemplateTypeId ) { 
var mod = CreateForInsert();
mod.@emailTemplateIdColumnValue.Value = @emailTemplateId;
mod.@nameColumnValue.Value = @name;
mod.@subjectColumnValue.Value = @subject;
mod.@htmlBlockIdColumnValue.Value = @htmlBlockId;
mod.@roleIdColumnValue.Value = @roleId;
mod.@emailTemplateTypeIdColumnValue.Value = @emailTemplateTypeId;
mod.Execute();
}
/// <summary>
/// Inserts a row into the EmailTemplates table.
/// </summary>
/// <param name="emailTemplateId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="subject">Object does not allow null.</param>
/// <param name="htmlBlockId">Object does not allow null.</param>
/// <param name="roleId">Object allows null.</param>
/// <param name="emailTemplateTypeId">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @emailTemplateId, string @name, string @subject, int @htmlBlockId, System.Int32? @roleId, int @emailTemplateTypeId ) { 
var mod = CreateForInsert();
mod.@emailTemplateIdColumnValue.Value = @emailTemplateId;
mod.@nameColumnValue.Value = @name;
mod.@subjectColumnValue.Value = @subject;
mod.@htmlBlockIdColumnValue.Value = @htmlBlockId;
mod.@roleIdColumnValue.Value = @roleId;
mod.@emailTemplateTypeIdColumnValue.Value = @emailTemplateTypeId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the EmailTemplates table that match the specified conditions with the specified data.
/// </summary>
/// <param name="emailTemplateId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="subject">Object does not allow null.</param>
/// <param name="htmlBlockId">Object does not allow null.</param>
/// <param name="roleId">Object allows null.</param>
/// <param name="emailTemplateTypeId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @emailTemplateId, string @name, string @subject, int @htmlBlockId, System.Int32? @roleId, int @emailTemplateTypeId, CommandConditions.EmailTemplatesTableCondition requiredCondition, params CommandConditions.EmailTemplatesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@emailTemplateIdColumnValue.Value = @emailTemplateId;
mod.@nameColumnValue.Value = @name;
mod.@subjectColumnValue.Value = @subject;
mod.@htmlBlockIdColumnValue.Value = @htmlBlockId;
mod.@roleIdColumnValue.Value = @roleId;
mod.@emailTemplateTypeIdColumnValue.Value = @emailTemplateTypeId;
mod.Execute();
}
/// <summary>
/// Updates rows in the EmailTemplates table that match the specified conditions with the specified data.
/// </summary>
/// <param name="emailTemplateId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="subject">Object does not allow null.</param>
/// <param name="htmlBlockId">Object does not allow null.</param>
/// <param name="roleId">Object allows null.</param>
/// <param name="emailTemplateTypeId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @emailTemplateId, string @name, string @subject, int @htmlBlockId, System.Int32? @roleId, int @emailTemplateTypeId, CommandConditions.EmailTemplatesTableCondition requiredCondition, params CommandConditions.EmailTemplatesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@emailTemplateIdColumnValue.Value = @emailTemplateId;
mod.@nameColumnValue.Value = @name;
mod.@subjectColumnValue.Value = @subject;
mod.@htmlBlockIdColumnValue.Value = @htmlBlockId;
mod.@roleIdColumnValue.Value = @roleId;
mod.@emailTemplateTypeIdColumnValue.Value = @emailTemplateTypeId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.EmailTemplatesTableCondition requiredCondition, params CommandConditions.EmailTemplatesTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@EmailTemplatesTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.EmailTemplatesTableCondition requiredCondition, params CommandConditions.EmailTemplatesTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.EmailTemplatesTableCondition> conditions ) {
var delete = new InlineDelete( "EmailTemplates" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.EmailTemplatesTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@EmailTemplatesTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.EmailTemplatesTableCondition> conditions;
private readonly DataValue<int> @emailTemplateIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the EmailTemplateId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @EmailTemplateId { get { return @emailTemplateIdColumnValue.Value; } set { @emailTemplateIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EmailTemplateId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EmailTemplateIdHasChanged { get { return @emailTemplateIdColumnValue.Changed; } }
private readonly DataValue<string> @nameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Name column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Name { get { return @nameColumnValue.Value; } set { @nameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Name has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @NameHasChanged { get { return @nameColumnValue.Changed; } }
private readonly DataValue<string> @subjectColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Subject column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Subject { get { return @subjectColumnValue.Value; } set { @subjectColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Subject has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @SubjectHasChanged { get { return @subjectColumnValue.Changed; } }
private readonly DataValue<int> @htmlBlockIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the HtmlBlockId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @HtmlBlockId { get { return @htmlBlockIdColumnValue.Value; } set { @htmlBlockIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the HtmlBlockId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @HtmlBlockIdHasChanged { get { return @htmlBlockIdColumnValue.Changed; } }
private readonly DataValue<System.Int32?> @roleIdColumnValue = new DataValue<System.Int32?>();
/// <summary>
/// Gets or sets the value for the RoleId column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.Int32? @RoleId { get { return @roleIdColumnValue.Value; } set { @roleIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the RoleId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @RoleIdHasChanged { get { return @roleIdColumnValue.Changed; } }
private readonly DataValue<int> @emailTemplateTypeIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the EmailTemplateTypeId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @EmailTemplateTypeId { get { return @emailTemplateTypeIdColumnValue.Value; } set { @emailTemplateTypeIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EmailTemplateTypeId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EmailTemplateTypeIdHasChanged { get { return @emailTemplateTypeIdColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the EmailTemplates table.
/// </summary>
public static @EmailTemplatesModification CreateForInsert() {
return new @EmailTemplatesModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the EmailTemplates table.
/// </summary>
public static @EmailTemplatesModification CreateForUpdate( CommandConditions.EmailTemplatesTableCondition requiredCondition, params CommandConditions.EmailTemplatesTableCondition[] additionalConditions ) {
var mod = new @EmailTemplatesModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@EmailTemplatesTableEqualityConditions.@EmailTemplateId )
mod.@emailTemplateIdColumnValue.Value = ( condition as CommandConditions.@EmailTemplatesTableEqualityConditions.@EmailTemplateId ).Value;
else if( condition is CommandConditions.@EmailTemplatesTableEqualityConditions.@Name )
mod.@nameColumnValue.Value = ( condition as CommandConditions.@EmailTemplatesTableEqualityConditions.@Name ).Value;
else if( condition is CommandConditions.@EmailTemplatesTableEqualityConditions.@Subject )
mod.@subjectColumnValue.Value = ( condition as CommandConditions.@EmailTemplatesTableEqualityConditions.@Subject ).Value;
else if( condition is CommandConditions.@EmailTemplatesTableEqualityConditions.@HtmlBlockId )
mod.@htmlBlockIdColumnValue.Value = ( condition as CommandConditions.@EmailTemplatesTableEqualityConditions.@HtmlBlockId ).Value;
else if( condition is CommandConditions.@EmailTemplatesTableEqualityConditions.@RoleId )
mod.@roleIdColumnValue.Value = ( condition as CommandConditions.@EmailTemplatesTableEqualityConditions.@RoleId ).Value;
else if( condition is CommandConditions.@EmailTemplatesTableEqualityConditions.@EmailTemplateTypeId )
mod.@emailTemplateTypeIdColumnValue.Value = ( condition as CommandConditions.@EmailTemplatesTableEqualityConditions.@EmailTemplateTypeId ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the EmailTemplates table.
/// </summary>
public static @EmailTemplatesModification CreateForSingleRowUpdate( int @emailTemplateId, string @name, string @subject, int @htmlBlockId, System.Int32? @roleId, int @emailTemplateTypeId ) {
var mod = new @EmailTemplatesModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.EmailTemplatesTableCondition>();
mod.conditions.Add( new CommandConditions.@EmailTemplatesTableEqualityConditions.@EmailTemplateId( @emailTemplateId ) );
mod.@emailTemplateIdColumnValue.Value = @emailTemplateId;
mod.@nameColumnValue.Value = @name;
mod.@subjectColumnValue.Value = @subject;
mod.@htmlBlockIdColumnValue.Value = @htmlBlockId;
mod.@roleIdColumnValue.Value = @roleId;
mod.@emailTemplateTypeIdColumnValue.Value = @emailTemplateTypeId;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.EmailTemplatesTableCondition> getConditionList( CommandConditions.EmailTemplatesTableCondition requiredCondition, params CommandConditions.EmailTemplatesTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.EmailTemplatesTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @EmailTemplatesModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="emailTemplateId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="subject">Object does not allow null.</param>
/// <param name="htmlBlockId">Object does not allow null.</param>
/// <param name="roleId">Object allows null.</param>
/// <param name="emailTemplateTypeId">Object does not allow null.</param>
public void SetAllData( int @emailTemplateId, string @name, string @subject, int @htmlBlockId, System.Int32? @roleId, int @emailTemplateTypeId ) {
this.@emailTemplateIdColumnValue.Value = @emailTemplateId;
this.@nameColumnValue.Value = @name;
this.@subjectColumnValue.Value = @subject;
this.@htmlBlockIdColumnValue.Value = @htmlBlockId;
this.@roleIdColumnValue.Value = @roleId;
this.@emailTemplateTypeIdColumnValue.Value = @emailTemplateTypeId;
}
/// <summary>
/// Executes this EmailTemplates modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this EmailTemplates modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "EmailTemplates" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.EmailTemplatesTableCondition>();
conditions.Add( new CommandConditions.@EmailTemplatesTableEqualityConditions.@EmailTemplateId( @EmailTemplateId ) );
}
else {
var update = new InlineUpdate( "EmailTemplates" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @emailTemplateIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EmailTemplateId", new DbParameterValue( @EmailTemplateId, "Int" ) ) );
if( @nameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Name", new DbParameterValue( @Name, "NVarChar" ) ) );
if( @subjectColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Subject", new DbParameterValue( @Subject, "NVarChar" ) ) );
if( @htmlBlockIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "HtmlBlockId", new DbParameterValue( @HtmlBlockId, "Int" ) ) );
if( @roleIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "RoleId", new DbParameterValue( @RoleId, "Int" ) ) );
if( @emailTemplateTypeIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EmailTemplateTypeId", new DbParameterValue( @EmailTemplateTypeId, "Int" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@emailTemplateIdColumnValue.ClearChanged();
@nameColumnValue.ClearChanged();
@subjectColumnValue.ClearChanged();
@htmlBlockIdColumnValue.ClearChanged();
@roleIdColumnValue.ClearChanged();
@emailTemplateTypeIdColumnValue.ClearChanged();
}
}
public partial class @EmailTemplateTypesModification {
/// <summary>
/// Inserts a row into the EmailTemplateTypes table.
/// </summary>
/// <param name="emailTemplateTypeId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
public static void InsertRow( int @emailTemplateTypeId, string @name ) { 
var mod = CreateForInsert();
mod.@emailTemplateTypeIdColumnValue.Value = @emailTemplateTypeId;
mod.@nameColumnValue.Value = @name;
mod.Execute();
}
/// <summary>
/// Inserts a row into the EmailTemplateTypes table.
/// </summary>
/// <param name="emailTemplateTypeId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @emailTemplateTypeId, string @name ) { 
var mod = CreateForInsert();
mod.@emailTemplateTypeIdColumnValue.Value = @emailTemplateTypeId;
mod.@nameColumnValue.Value = @name;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the EmailTemplateTypes table that match the specified conditions with the specified data.
/// </summary>
/// <param name="emailTemplateTypeId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @emailTemplateTypeId, string @name, CommandConditions.EmailTemplateTypesTableCondition requiredCondition, params CommandConditions.EmailTemplateTypesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@emailTemplateTypeIdColumnValue.Value = @emailTemplateTypeId;
mod.@nameColumnValue.Value = @name;
mod.Execute();
}
/// <summary>
/// Updates rows in the EmailTemplateTypes table that match the specified conditions with the specified data.
/// </summary>
/// <param name="emailTemplateTypeId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @emailTemplateTypeId, string @name, CommandConditions.EmailTemplateTypesTableCondition requiredCondition, params CommandConditions.EmailTemplateTypesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@emailTemplateTypeIdColumnValue.Value = @emailTemplateTypeId;
mod.@nameColumnValue.Value = @name;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.EmailTemplateTypesTableCondition requiredCondition, params CommandConditions.EmailTemplateTypesTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@EmailTemplateTypesTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.EmailTemplateTypesTableCondition requiredCondition, params CommandConditions.EmailTemplateTypesTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.EmailTemplateTypesTableCondition> conditions ) {
var delete = new InlineDelete( "EmailTemplateTypes" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.EmailTemplateTypesTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@EmailTemplateTypesTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.EmailTemplateTypesTableCondition> conditions;
private readonly DataValue<int> @emailTemplateTypeIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the EmailTemplateTypeId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @EmailTemplateTypeId { get { return @emailTemplateTypeIdColumnValue.Value; } set { @emailTemplateTypeIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EmailTemplateTypeId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EmailTemplateTypeIdHasChanged { get { return @emailTemplateTypeIdColumnValue.Changed; } }
private readonly DataValue<string> @nameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Name column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Name { get { return @nameColumnValue.Value; } set { @nameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Name has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @NameHasChanged { get { return @nameColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the EmailTemplateTypes table.
/// </summary>
public static @EmailTemplateTypesModification CreateForInsert() {
return new @EmailTemplateTypesModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the EmailTemplateTypes table.
/// </summary>
public static @EmailTemplateTypesModification CreateForUpdate( CommandConditions.EmailTemplateTypesTableCondition requiredCondition, params CommandConditions.EmailTemplateTypesTableCondition[] additionalConditions ) {
var mod = new @EmailTemplateTypesModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@EmailTemplateTypesTableEqualityConditions.@EmailTemplateTypeId )
mod.@emailTemplateTypeIdColumnValue.Value = ( condition as CommandConditions.@EmailTemplateTypesTableEqualityConditions.@EmailTemplateTypeId ).Value;
else if( condition is CommandConditions.@EmailTemplateTypesTableEqualityConditions.@Name )
mod.@nameColumnValue.Value = ( condition as CommandConditions.@EmailTemplateTypesTableEqualityConditions.@Name ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the EmailTemplateTypes table.
/// </summary>
public static @EmailTemplateTypesModification CreateForSingleRowUpdate( int @emailTemplateTypeId, string @name ) {
var mod = new @EmailTemplateTypesModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.EmailTemplateTypesTableCondition>();
mod.conditions.Add( new CommandConditions.@EmailTemplateTypesTableEqualityConditions.@EmailTemplateTypeId( @emailTemplateTypeId ) );
mod.@emailTemplateTypeIdColumnValue.Value = @emailTemplateTypeId;
mod.@nameColumnValue.Value = @name;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.EmailTemplateTypesTableCondition> getConditionList( CommandConditions.EmailTemplateTypesTableCondition requiredCondition, params CommandConditions.EmailTemplateTypesTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.EmailTemplateTypesTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @EmailTemplateTypesModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="emailTemplateTypeId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
public void SetAllData( int @emailTemplateTypeId, string @name ) {
this.@emailTemplateTypeIdColumnValue.Value = @emailTemplateTypeId;
this.@nameColumnValue.Value = @name;
}
/// <summary>
/// Executes this EmailTemplateTypes modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this EmailTemplateTypes modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "EmailTemplateTypes" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.EmailTemplateTypesTableCondition>();
conditions.Add( new CommandConditions.@EmailTemplateTypesTableEqualityConditions.@EmailTemplateTypeId( @EmailTemplateTypeId ) );
}
else {
var update = new InlineUpdate( "EmailTemplateTypes" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @emailTemplateTypeIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EmailTemplateTypeId", new DbParameterValue( @EmailTemplateTypeId, "Int" ) ) );
if( @nameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Name", new DbParameterValue( @Name, "NVarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@emailTemplateTypeIdColumnValue.ClearChanged();
@nameColumnValue.ClearChanged();
}
}
public partial class @EventLogModification {
/// <summary>
/// Inserts a row into the EventLog table.
/// </summary>
/// <param name="eventID">Object does not allow null.</param>
/// <param name="eventTime">Object does not allow null.</param>
/// <param name="category">Object does not allow null.</param>
/// <param name="subCategory">Object does not allow null.</param>
/// <param name="errorLevel">Object does not allow null.</param>
/// <param name="eventCode">Object does not allow null.</param>
/// <param name="encKV">Object does not allow null.</param>
/// <param name="encIV">Object allows null.</param>
/// <param name="userID">Object allows null.</param>
/// <param name="userType">Object does not allow null.</param>
/// <param name="iPAddress">Object does not allow null.</param>
/// <param name="eventSummary">Object does not allow null.</param>
/// <param name="eventURL">Object does not allow null.</param>
/// <param name="additionalData">Object does not allow null.</param>
/// <param name="protectedData">Object allows null.</param>
/// <param name="accessReasonCode">Object does not allow null.</param>
/// <param name="accessReasonText">Object does not allow null.</param>
/// <param name="accessScope">Object does not allow null.</param>
/// <param name="accessType">Object does not allow null.</param>
/// <param name="reviewStatus">Object does not allow null.</param>
/// <param name="suggestedAction">Object does not allow null.</param>
/// <param name="reviewedBy">Object allows null.</param>
/// <param name="reviewDate">Object allows null.</param>
/// <param name="reviewSummary">Object does not allow null.</param>
public static void InsertRow( System.Guid @eventID, DateTime @eventTime, string @category, string @subCategory, int @errorLevel, string @eventCode, string @encKV, System.Byte[] @encIV, System.Guid? @userID, string @userType, string @iPAddress, string @eventSummary, string @eventURL, string @additionalData, System.Byte[] @protectedData, string @accessReasonCode, string @accessReasonText, string @accessScope, int @accessType, string @reviewStatus, string @suggestedAction, System.Guid? @reviewedBy, System.DateTime? @reviewDate, string @reviewSummary ) { 
var mod = CreateForInsert();
mod.@eventIDColumnValue.Value = @eventID;
mod.@eventTimeColumnValue.Value = @eventTime;
mod.@categoryColumnValue.Value = @category;
mod.@subCategoryColumnValue.Value = @subCategory;
mod.@errorLevelColumnValue.Value = @errorLevel;
mod.@eventCodeColumnValue.Value = @eventCode;
mod.@encKVColumnValue.Value = @encKV;
mod.@encIVColumnValue.Value = @encIV;
mod.@userIDColumnValue.Value = @userID;
mod.@userTypeColumnValue.Value = @userType;
mod.@iPAddressColumnValue.Value = @iPAddress;
mod.@eventSummaryColumnValue.Value = @eventSummary;
mod.@eventURLColumnValue.Value = @eventURL;
mod.@additionalDataColumnValue.Value = @additionalData;
mod.@protectedDataColumnValue.Value = @protectedData;
mod.@accessReasonCodeColumnValue.Value = @accessReasonCode;
mod.@accessReasonTextColumnValue.Value = @accessReasonText;
mod.@accessScopeColumnValue.Value = @accessScope;
mod.@accessTypeColumnValue.Value = @accessType;
mod.@reviewStatusColumnValue.Value = @reviewStatus;
mod.@suggestedActionColumnValue.Value = @suggestedAction;
mod.@reviewedByColumnValue.Value = @reviewedBy;
mod.@reviewDateColumnValue.Value = @reviewDate;
mod.@reviewSummaryColumnValue.Value = @reviewSummary;
mod.Execute();
}
/// <summary>
/// Inserts a row into the EventLog table.
/// </summary>
/// <param name="eventID">Object does not allow null.</param>
/// <param name="eventTime">Object does not allow null.</param>
/// <param name="category">Object does not allow null.</param>
/// <param name="subCategory">Object does not allow null.</param>
/// <param name="errorLevel">Object does not allow null.</param>
/// <param name="eventCode">Object does not allow null.</param>
/// <param name="encKV">Object does not allow null.</param>
/// <param name="encIV">Object allows null.</param>
/// <param name="userID">Object allows null.</param>
/// <param name="userType">Object does not allow null.</param>
/// <param name="iPAddress">Object does not allow null.</param>
/// <param name="eventSummary">Object does not allow null.</param>
/// <param name="eventURL">Object does not allow null.</param>
/// <param name="additionalData">Object does not allow null.</param>
/// <param name="protectedData">Object allows null.</param>
/// <param name="accessReasonCode">Object does not allow null.</param>
/// <param name="accessReasonText">Object does not allow null.</param>
/// <param name="accessScope">Object does not allow null.</param>
/// <param name="accessType">Object does not allow null.</param>
/// <param name="reviewStatus">Object does not allow null.</param>
/// <param name="suggestedAction">Object does not allow null.</param>
/// <param name="reviewedBy">Object allows null.</param>
/// <param name="reviewDate">Object allows null.</param>
/// <param name="reviewSummary">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( System.Guid @eventID, DateTime @eventTime, string @category, string @subCategory, int @errorLevel, string @eventCode, string @encKV, System.Byte[] @encIV, System.Guid? @userID, string @userType, string @iPAddress, string @eventSummary, string @eventURL, string @additionalData, System.Byte[] @protectedData, string @accessReasonCode, string @accessReasonText, string @accessScope, int @accessType, string @reviewStatus, string @suggestedAction, System.Guid? @reviewedBy, System.DateTime? @reviewDate, string @reviewSummary ) { 
var mod = CreateForInsert();
mod.@eventIDColumnValue.Value = @eventID;
mod.@eventTimeColumnValue.Value = @eventTime;
mod.@categoryColumnValue.Value = @category;
mod.@subCategoryColumnValue.Value = @subCategory;
mod.@errorLevelColumnValue.Value = @errorLevel;
mod.@eventCodeColumnValue.Value = @eventCode;
mod.@encKVColumnValue.Value = @encKV;
mod.@encIVColumnValue.Value = @encIV;
mod.@userIDColumnValue.Value = @userID;
mod.@userTypeColumnValue.Value = @userType;
mod.@iPAddressColumnValue.Value = @iPAddress;
mod.@eventSummaryColumnValue.Value = @eventSummary;
mod.@eventURLColumnValue.Value = @eventURL;
mod.@additionalDataColumnValue.Value = @additionalData;
mod.@protectedDataColumnValue.Value = @protectedData;
mod.@accessReasonCodeColumnValue.Value = @accessReasonCode;
mod.@accessReasonTextColumnValue.Value = @accessReasonText;
mod.@accessScopeColumnValue.Value = @accessScope;
mod.@accessTypeColumnValue.Value = @accessType;
mod.@reviewStatusColumnValue.Value = @reviewStatus;
mod.@suggestedActionColumnValue.Value = @suggestedAction;
mod.@reviewedByColumnValue.Value = @reviewedBy;
mod.@reviewDateColumnValue.Value = @reviewDate;
mod.@reviewSummaryColumnValue.Value = @reviewSummary;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the EventLog table that match the specified conditions with the specified data.
/// </summary>
/// <param name="eventID">Object does not allow null.</param>
/// <param name="eventTime">Object does not allow null.</param>
/// <param name="category">Object does not allow null.</param>
/// <param name="subCategory">Object does not allow null.</param>
/// <param name="errorLevel">Object does not allow null.</param>
/// <param name="eventCode">Object does not allow null.</param>
/// <param name="encKV">Object does not allow null.</param>
/// <param name="encIV">Object allows null.</param>
/// <param name="userID">Object allows null.</param>
/// <param name="userType">Object does not allow null.</param>
/// <param name="iPAddress">Object does not allow null.</param>
/// <param name="eventSummary">Object does not allow null.</param>
/// <param name="eventURL">Object does not allow null.</param>
/// <param name="additionalData">Object does not allow null.</param>
/// <param name="protectedData">Object allows null.</param>
/// <param name="accessReasonCode">Object does not allow null.</param>
/// <param name="accessReasonText">Object does not allow null.</param>
/// <param name="accessScope">Object does not allow null.</param>
/// <param name="accessType">Object does not allow null.</param>
/// <param name="reviewStatus">Object does not allow null.</param>
/// <param name="suggestedAction">Object does not allow null.</param>
/// <param name="reviewedBy">Object allows null.</param>
/// <param name="reviewDate">Object allows null.</param>
/// <param name="reviewSummary">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( System.Guid @eventID, DateTime @eventTime, string @category, string @subCategory, int @errorLevel, string @eventCode, string @encKV, System.Byte[] @encIV, System.Guid? @userID, string @userType, string @iPAddress, string @eventSummary, string @eventURL, string @additionalData, System.Byte[] @protectedData, string @accessReasonCode, string @accessReasonText, string @accessScope, int @accessType, string @reviewStatus, string @suggestedAction, System.Guid? @reviewedBy, System.DateTime? @reviewDate, string @reviewSummary, CommandConditions.EventLogTableCondition requiredCondition, params CommandConditions.EventLogTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@eventIDColumnValue.Value = @eventID;
mod.@eventTimeColumnValue.Value = @eventTime;
mod.@categoryColumnValue.Value = @category;
mod.@subCategoryColumnValue.Value = @subCategory;
mod.@errorLevelColumnValue.Value = @errorLevel;
mod.@eventCodeColumnValue.Value = @eventCode;
mod.@encKVColumnValue.Value = @encKV;
mod.@encIVColumnValue.Value = @encIV;
mod.@userIDColumnValue.Value = @userID;
mod.@userTypeColumnValue.Value = @userType;
mod.@iPAddressColumnValue.Value = @iPAddress;
mod.@eventSummaryColumnValue.Value = @eventSummary;
mod.@eventURLColumnValue.Value = @eventURL;
mod.@additionalDataColumnValue.Value = @additionalData;
mod.@protectedDataColumnValue.Value = @protectedData;
mod.@accessReasonCodeColumnValue.Value = @accessReasonCode;
mod.@accessReasonTextColumnValue.Value = @accessReasonText;
mod.@accessScopeColumnValue.Value = @accessScope;
mod.@accessTypeColumnValue.Value = @accessType;
mod.@reviewStatusColumnValue.Value = @reviewStatus;
mod.@suggestedActionColumnValue.Value = @suggestedAction;
mod.@reviewedByColumnValue.Value = @reviewedBy;
mod.@reviewDateColumnValue.Value = @reviewDate;
mod.@reviewSummaryColumnValue.Value = @reviewSummary;
mod.Execute();
}
/// <summary>
/// Updates rows in the EventLog table that match the specified conditions with the specified data.
/// </summary>
/// <param name="eventID">Object does not allow null.</param>
/// <param name="eventTime">Object does not allow null.</param>
/// <param name="category">Object does not allow null.</param>
/// <param name="subCategory">Object does not allow null.</param>
/// <param name="errorLevel">Object does not allow null.</param>
/// <param name="eventCode">Object does not allow null.</param>
/// <param name="encKV">Object does not allow null.</param>
/// <param name="encIV">Object allows null.</param>
/// <param name="userID">Object allows null.</param>
/// <param name="userType">Object does not allow null.</param>
/// <param name="iPAddress">Object does not allow null.</param>
/// <param name="eventSummary">Object does not allow null.</param>
/// <param name="eventURL">Object does not allow null.</param>
/// <param name="additionalData">Object does not allow null.</param>
/// <param name="protectedData">Object allows null.</param>
/// <param name="accessReasonCode">Object does not allow null.</param>
/// <param name="accessReasonText">Object does not allow null.</param>
/// <param name="accessScope">Object does not allow null.</param>
/// <param name="accessType">Object does not allow null.</param>
/// <param name="reviewStatus">Object does not allow null.</param>
/// <param name="suggestedAction">Object does not allow null.</param>
/// <param name="reviewedBy">Object allows null.</param>
/// <param name="reviewDate">Object allows null.</param>
/// <param name="reviewSummary">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( System.Guid @eventID, DateTime @eventTime, string @category, string @subCategory, int @errorLevel, string @eventCode, string @encKV, System.Byte[] @encIV, System.Guid? @userID, string @userType, string @iPAddress, string @eventSummary, string @eventURL, string @additionalData, System.Byte[] @protectedData, string @accessReasonCode, string @accessReasonText, string @accessScope, int @accessType, string @reviewStatus, string @suggestedAction, System.Guid? @reviewedBy, System.DateTime? @reviewDate, string @reviewSummary, CommandConditions.EventLogTableCondition requiredCondition, params CommandConditions.EventLogTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@eventIDColumnValue.Value = @eventID;
mod.@eventTimeColumnValue.Value = @eventTime;
mod.@categoryColumnValue.Value = @category;
mod.@subCategoryColumnValue.Value = @subCategory;
mod.@errorLevelColumnValue.Value = @errorLevel;
mod.@eventCodeColumnValue.Value = @eventCode;
mod.@encKVColumnValue.Value = @encKV;
mod.@encIVColumnValue.Value = @encIV;
mod.@userIDColumnValue.Value = @userID;
mod.@userTypeColumnValue.Value = @userType;
mod.@iPAddressColumnValue.Value = @iPAddress;
mod.@eventSummaryColumnValue.Value = @eventSummary;
mod.@eventURLColumnValue.Value = @eventURL;
mod.@additionalDataColumnValue.Value = @additionalData;
mod.@protectedDataColumnValue.Value = @protectedData;
mod.@accessReasonCodeColumnValue.Value = @accessReasonCode;
mod.@accessReasonTextColumnValue.Value = @accessReasonText;
mod.@accessScopeColumnValue.Value = @accessScope;
mod.@accessTypeColumnValue.Value = @accessType;
mod.@reviewStatusColumnValue.Value = @reviewStatus;
mod.@suggestedActionColumnValue.Value = @suggestedAction;
mod.@reviewedByColumnValue.Value = @reviewedBy;
mod.@reviewDateColumnValue.Value = @reviewDate;
mod.@reviewSummaryColumnValue.Value = @reviewSummary;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.EventLogTableCondition requiredCondition, params CommandConditions.EventLogTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@EventLogTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.EventLogTableCondition requiredCondition, params CommandConditions.EventLogTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.EventLogTableCondition> conditions ) {
var delete = new InlineDelete( "EventLog" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.EventLogTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@EventLogTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.EventLogTableCondition> conditions;
private readonly DataValue<System.Guid> @eventIDColumnValue = new DataValue<System.Guid>();
/// <summary>
/// Gets or sets the value for the EventID column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Guid @EventID { get { return @eventIDColumnValue.Value; } set { @eventIDColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EventID has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EventIDHasChanged { get { return @eventIDColumnValue.Changed; } }
private readonly DataValue<DateTime> @eventTimeColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the EventTime column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @EventTime { get { return @eventTimeColumnValue.Value; } set { @eventTimeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EventTime has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EventTimeHasChanged { get { return @eventTimeColumnValue.Changed; } }
private readonly DataValue<string> @categoryColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Category column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Category { get { return @categoryColumnValue.Value; } set { @categoryColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Category has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @CategoryHasChanged { get { return @categoryColumnValue.Changed; } }
private readonly DataValue<string> @subCategoryColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the SubCategory column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @SubCategory { get { return @subCategoryColumnValue.Value; } set { @subCategoryColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the SubCategory has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @SubCategoryHasChanged { get { return @subCategoryColumnValue.Changed; } }
private readonly DataValue<int> @errorLevelColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the ErrorLevel column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @ErrorLevel { get { return @errorLevelColumnValue.Value; } set { @errorLevelColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ErrorLevel has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ErrorLevelHasChanged { get { return @errorLevelColumnValue.Changed; } }
private readonly DataValue<string> @eventCodeColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the EventCode column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @EventCode { get { return @eventCodeColumnValue.Value; } set { @eventCodeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EventCode has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EventCodeHasChanged { get { return @eventCodeColumnValue.Changed; } }
private readonly DataValue<string> @encKVColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the EncKV column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @EncKV { get { return @encKVColumnValue.Value; } set { @encKVColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EncKV has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EncKVHasChanged { get { return @encKVColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @encIVColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the EncIV column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.Byte[] @EncIV { get { return @encIVColumnValue.Value; } set { @encIVColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EncIV has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EncIVHasChanged { get { return @encIVColumnValue.Changed; } }
private readonly DataValue<System.Guid?> @userIDColumnValue = new DataValue<System.Guid?>();
/// <summary>
/// Gets or sets the value for the UserID column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.Guid? @UserID { get { return @userIDColumnValue.Value; } set { @userIDColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the UserID has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @UserIDHasChanged { get { return @userIDColumnValue.Changed; } }
private readonly DataValue<string> @userTypeColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the UserType column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @UserType { get { return @userTypeColumnValue.Value; } set { @userTypeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the UserType has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @UserTypeHasChanged { get { return @userTypeColumnValue.Changed; } }
private readonly DataValue<string> @iPAddressColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the IPAddress column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @IPAddress { get { return @iPAddressColumnValue.Value; } set { @iPAddressColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the IPAddress has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @IPAddressHasChanged { get { return @iPAddressColumnValue.Changed; } }
private readonly DataValue<string> @eventSummaryColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the EventSummary column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @EventSummary { get { return @eventSummaryColumnValue.Value; } set { @eventSummaryColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EventSummary has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EventSummaryHasChanged { get { return @eventSummaryColumnValue.Changed; } }
private readonly DataValue<string> @eventURLColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the EventURL column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @EventURL { get { return @eventURLColumnValue.Value; } set { @eventURLColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EventURL has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EventURLHasChanged { get { return @eventURLColumnValue.Changed; } }
private readonly DataValue<string> @additionalDataColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the AdditionalData column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @AdditionalData { get { return @additionalDataColumnValue.Value; } set { @additionalDataColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the AdditionalData has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @AdditionalDataHasChanged { get { return @additionalDataColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @protectedDataColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the ProtectedData column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.Byte[] @ProtectedData { get { return @protectedDataColumnValue.Value; } set { @protectedDataColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ProtectedData has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ProtectedDataHasChanged { get { return @protectedDataColumnValue.Changed; } }
private readonly DataValue<string> @accessReasonCodeColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the AccessReasonCode column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @AccessReasonCode { get { return @accessReasonCodeColumnValue.Value; } set { @accessReasonCodeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the AccessReasonCode has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @AccessReasonCodeHasChanged { get { return @accessReasonCodeColumnValue.Changed; } }
private readonly DataValue<string> @accessReasonTextColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the AccessReasonText column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @AccessReasonText { get { return @accessReasonTextColumnValue.Value; } set { @accessReasonTextColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the AccessReasonText has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @AccessReasonTextHasChanged { get { return @accessReasonTextColumnValue.Changed; } }
private readonly DataValue<string> @accessScopeColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the AccessScope column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @AccessScope { get { return @accessScopeColumnValue.Value; } set { @accessScopeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the AccessScope has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @AccessScopeHasChanged { get { return @accessScopeColumnValue.Changed; } }
private readonly DataValue<int> @accessTypeColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the AccessType column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @AccessType { get { return @accessTypeColumnValue.Value; } set { @accessTypeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the AccessType has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @AccessTypeHasChanged { get { return @accessTypeColumnValue.Changed; } }
private readonly DataValue<string> @reviewStatusColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the ReviewStatus column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @ReviewStatus { get { return @reviewStatusColumnValue.Value; } set { @reviewStatusColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ReviewStatus has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ReviewStatusHasChanged { get { return @reviewStatusColumnValue.Changed; } }
private readonly DataValue<string> @suggestedActionColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the SuggestedAction column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @SuggestedAction { get { return @suggestedActionColumnValue.Value; } set { @suggestedActionColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the SuggestedAction has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @SuggestedActionHasChanged { get { return @suggestedActionColumnValue.Changed; } }
private readonly DataValue<System.Guid?> @reviewedByColumnValue = new DataValue<System.Guid?>();
/// <summary>
/// Gets or sets the value for the ReviewedBy column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.Guid? @ReviewedBy { get { return @reviewedByColumnValue.Value; } set { @reviewedByColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ReviewedBy has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ReviewedByHasChanged { get { return @reviewedByColumnValue.Changed; } }
private readonly DataValue<System.DateTime?> @reviewDateColumnValue = new DataValue<System.DateTime?>();
/// <summary>
/// Gets or sets the value for the ReviewDate column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.DateTime? @ReviewDate { get { return @reviewDateColumnValue.Value; } set { @reviewDateColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ReviewDate has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ReviewDateHasChanged { get { return @reviewDateColumnValue.Changed; } }
private readonly DataValue<string> @reviewSummaryColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the ReviewSummary column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @ReviewSummary { get { return @reviewSummaryColumnValue.Value; } set { @reviewSummaryColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ReviewSummary has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ReviewSummaryHasChanged { get { return @reviewSummaryColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the EventLog table.
/// </summary>
public static @EventLogModification CreateForInsert() {
return new @EventLogModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the EventLog table.
/// </summary>
public static @EventLogModification CreateForUpdate( CommandConditions.EventLogTableCondition requiredCondition, params CommandConditions.EventLogTableCondition[] additionalConditions ) {
var mod = new @EventLogModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@EventLogTableEqualityConditions.@EventID )
mod.@eventIDColumnValue.Value = ( condition as CommandConditions.@EventLogTableEqualityConditions.@EventID ).Value;
else if( condition is CommandConditions.@EventLogTableEqualityConditions.@EventTime )
mod.@eventTimeColumnValue.Value = ( condition as CommandConditions.@EventLogTableEqualityConditions.@EventTime ).Value;
else if( condition is CommandConditions.@EventLogTableEqualityConditions.@Category )
mod.@categoryColumnValue.Value = ( condition as CommandConditions.@EventLogTableEqualityConditions.@Category ).Value;
else if( condition is CommandConditions.@EventLogTableEqualityConditions.@SubCategory )
mod.@subCategoryColumnValue.Value = ( condition as CommandConditions.@EventLogTableEqualityConditions.@SubCategory ).Value;
else if( condition is CommandConditions.@EventLogTableEqualityConditions.@ErrorLevel )
mod.@errorLevelColumnValue.Value = ( condition as CommandConditions.@EventLogTableEqualityConditions.@ErrorLevel ).Value;
else if( condition is CommandConditions.@EventLogTableEqualityConditions.@EventCode )
mod.@eventCodeColumnValue.Value = ( condition as CommandConditions.@EventLogTableEqualityConditions.@EventCode ).Value;
else if( condition is CommandConditions.@EventLogTableEqualityConditions.@EncKV )
mod.@encKVColumnValue.Value = ( condition as CommandConditions.@EventLogTableEqualityConditions.@EncKV ).Value;
else if( condition is CommandConditions.@EventLogTableEqualityConditions.@EncIV )
mod.@encIVColumnValue.Value = ( condition as CommandConditions.@EventLogTableEqualityConditions.@EncIV ).Value;
else if( condition is CommandConditions.@EventLogTableEqualityConditions.@UserID )
mod.@userIDColumnValue.Value = ( condition as CommandConditions.@EventLogTableEqualityConditions.@UserID ).Value;
else if( condition is CommandConditions.@EventLogTableEqualityConditions.@UserType )
mod.@userTypeColumnValue.Value = ( condition as CommandConditions.@EventLogTableEqualityConditions.@UserType ).Value;
else if( condition is CommandConditions.@EventLogTableEqualityConditions.@IPAddress )
mod.@iPAddressColumnValue.Value = ( condition as CommandConditions.@EventLogTableEqualityConditions.@IPAddress ).Value;
else if( condition is CommandConditions.@EventLogTableEqualityConditions.@EventSummary )
mod.@eventSummaryColumnValue.Value = ( condition as CommandConditions.@EventLogTableEqualityConditions.@EventSummary ).Value;
else if( condition is CommandConditions.@EventLogTableEqualityConditions.@EventURL )
mod.@eventURLColumnValue.Value = ( condition as CommandConditions.@EventLogTableEqualityConditions.@EventURL ).Value;
else if( condition is CommandConditions.@EventLogTableEqualityConditions.@AdditionalData )
mod.@additionalDataColumnValue.Value = ( condition as CommandConditions.@EventLogTableEqualityConditions.@AdditionalData ).Value;
else if( condition is CommandConditions.@EventLogTableEqualityConditions.@ProtectedData )
mod.@protectedDataColumnValue.Value = ( condition as CommandConditions.@EventLogTableEqualityConditions.@ProtectedData ).Value;
else if( condition is CommandConditions.@EventLogTableEqualityConditions.@AccessReasonCode )
mod.@accessReasonCodeColumnValue.Value = ( condition as CommandConditions.@EventLogTableEqualityConditions.@AccessReasonCode ).Value;
else if( condition is CommandConditions.@EventLogTableEqualityConditions.@AccessReasonText )
mod.@accessReasonTextColumnValue.Value = ( condition as CommandConditions.@EventLogTableEqualityConditions.@AccessReasonText ).Value;
else if( condition is CommandConditions.@EventLogTableEqualityConditions.@AccessScope )
mod.@accessScopeColumnValue.Value = ( condition as CommandConditions.@EventLogTableEqualityConditions.@AccessScope ).Value;
else if( condition is CommandConditions.@EventLogTableEqualityConditions.@AccessType )
mod.@accessTypeColumnValue.Value = ( condition as CommandConditions.@EventLogTableEqualityConditions.@AccessType ).Value;
else if( condition is CommandConditions.@EventLogTableEqualityConditions.@ReviewStatus )
mod.@reviewStatusColumnValue.Value = ( condition as CommandConditions.@EventLogTableEqualityConditions.@ReviewStatus ).Value;
else if( condition is CommandConditions.@EventLogTableEqualityConditions.@SuggestedAction )
mod.@suggestedActionColumnValue.Value = ( condition as CommandConditions.@EventLogTableEqualityConditions.@SuggestedAction ).Value;
else if( condition is CommandConditions.@EventLogTableEqualityConditions.@ReviewedBy )
mod.@reviewedByColumnValue.Value = ( condition as CommandConditions.@EventLogTableEqualityConditions.@ReviewedBy ).Value;
else if( condition is CommandConditions.@EventLogTableEqualityConditions.@ReviewDate )
mod.@reviewDateColumnValue.Value = ( condition as CommandConditions.@EventLogTableEqualityConditions.@ReviewDate ).Value;
else if( condition is CommandConditions.@EventLogTableEqualityConditions.@ReviewSummary )
mod.@reviewSummaryColumnValue.Value = ( condition as CommandConditions.@EventLogTableEqualityConditions.@ReviewSummary ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the EventLog table.
/// </summary>
public static @EventLogModification CreateForSingleRowUpdate( System.Guid @eventID, DateTime @eventTime, string @category, string @subCategory, int @errorLevel, string @eventCode, string @encKV, System.Byte[] @encIV, System.Guid? @userID, string @userType, string @iPAddress, string @eventSummary, string @eventURL, string @additionalData, System.Byte[] @protectedData, string @accessReasonCode, string @accessReasonText, string @accessScope, int @accessType, string @reviewStatus, string @suggestedAction, System.Guid? @reviewedBy, System.DateTime? @reviewDate, string @reviewSummary ) {
var mod = new @EventLogModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.EventLogTableCondition>();
mod.conditions.Add( new CommandConditions.@EventLogTableEqualityConditions.@EventID( @eventID ) );
mod.conditions.Add( new CommandConditions.@EventLogTableEqualityConditions.@EventTime( @eventTime ) );
mod.conditions.Add( new CommandConditions.@EventLogTableEqualityConditions.@Category( @category ) );
mod.conditions.Add( new CommandConditions.@EventLogTableEqualityConditions.@SubCategory( @subCategory ) );
mod.@eventIDColumnValue.Value = @eventID;
mod.@eventTimeColumnValue.Value = @eventTime;
mod.@categoryColumnValue.Value = @category;
mod.@subCategoryColumnValue.Value = @subCategory;
mod.@errorLevelColumnValue.Value = @errorLevel;
mod.@eventCodeColumnValue.Value = @eventCode;
mod.@encKVColumnValue.Value = @encKV;
mod.@encIVColumnValue.Value = @encIV;
mod.@userIDColumnValue.Value = @userID;
mod.@userTypeColumnValue.Value = @userType;
mod.@iPAddressColumnValue.Value = @iPAddress;
mod.@eventSummaryColumnValue.Value = @eventSummary;
mod.@eventURLColumnValue.Value = @eventURL;
mod.@additionalDataColumnValue.Value = @additionalData;
mod.@protectedDataColumnValue.Value = @protectedData;
mod.@accessReasonCodeColumnValue.Value = @accessReasonCode;
mod.@accessReasonTextColumnValue.Value = @accessReasonText;
mod.@accessScopeColumnValue.Value = @accessScope;
mod.@accessTypeColumnValue.Value = @accessType;
mod.@reviewStatusColumnValue.Value = @reviewStatus;
mod.@suggestedActionColumnValue.Value = @suggestedAction;
mod.@reviewedByColumnValue.Value = @reviewedBy;
mod.@reviewDateColumnValue.Value = @reviewDate;
mod.@reviewSummaryColumnValue.Value = @reviewSummary;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.EventLogTableCondition> getConditionList( CommandConditions.EventLogTableCondition requiredCondition, params CommandConditions.EventLogTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.EventLogTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @EventLogModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="eventID">Object does not allow null.</param>
/// <param name="eventTime">Object does not allow null.</param>
/// <param name="category">Object does not allow null.</param>
/// <param name="subCategory">Object does not allow null.</param>
/// <param name="errorLevel">Object does not allow null.</param>
/// <param name="eventCode">Object does not allow null.</param>
/// <param name="encKV">Object does not allow null.</param>
/// <param name="encIV">Object allows null.</param>
/// <param name="userID">Object allows null.</param>
/// <param name="userType">Object does not allow null.</param>
/// <param name="iPAddress">Object does not allow null.</param>
/// <param name="eventSummary">Object does not allow null.</param>
/// <param name="eventURL">Object does not allow null.</param>
/// <param name="additionalData">Object does not allow null.</param>
/// <param name="protectedData">Object allows null.</param>
/// <param name="accessReasonCode">Object does not allow null.</param>
/// <param name="accessReasonText">Object does not allow null.</param>
/// <param name="accessScope">Object does not allow null.</param>
/// <param name="accessType">Object does not allow null.</param>
/// <param name="reviewStatus">Object does not allow null.</param>
/// <param name="suggestedAction">Object does not allow null.</param>
/// <param name="reviewedBy">Object allows null.</param>
/// <param name="reviewDate">Object allows null.</param>
/// <param name="reviewSummary">Object does not allow null.</param>
public void SetAllData( System.Guid @eventID, DateTime @eventTime, string @category, string @subCategory, int @errorLevel, string @eventCode, string @encKV, System.Byte[] @encIV, System.Guid? @userID, string @userType, string @iPAddress, string @eventSummary, string @eventURL, string @additionalData, System.Byte[] @protectedData, string @accessReasonCode, string @accessReasonText, string @accessScope, int @accessType, string @reviewStatus, string @suggestedAction, System.Guid? @reviewedBy, System.DateTime? @reviewDate, string @reviewSummary ) {
this.@eventIDColumnValue.Value = @eventID;
this.@eventTimeColumnValue.Value = @eventTime;
this.@categoryColumnValue.Value = @category;
this.@subCategoryColumnValue.Value = @subCategory;
this.@errorLevelColumnValue.Value = @errorLevel;
this.@eventCodeColumnValue.Value = @eventCode;
this.@encKVColumnValue.Value = @encKV;
this.@encIVColumnValue.Value = @encIV;
this.@userIDColumnValue.Value = @userID;
this.@userTypeColumnValue.Value = @userType;
this.@iPAddressColumnValue.Value = @iPAddress;
this.@eventSummaryColumnValue.Value = @eventSummary;
this.@eventURLColumnValue.Value = @eventURL;
this.@additionalDataColumnValue.Value = @additionalData;
this.@protectedDataColumnValue.Value = @protectedData;
this.@accessReasonCodeColumnValue.Value = @accessReasonCode;
this.@accessReasonTextColumnValue.Value = @accessReasonText;
this.@accessScopeColumnValue.Value = @accessScope;
this.@accessTypeColumnValue.Value = @accessType;
this.@reviewStatusColumnValue.Value = @reviewStatus;
this.@suggestedActionColumnValue.Value = @suggestedAction;
this.@reviewedByColumnValue.Value = @reviewedBy;
this.@reviewDateColumnValue.Value = @reviewDate;
this.@reviewSummaryColumnValue.Value = @reviewSummary;
}
/// <summary>
/// Executes this EventLog modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this EventLog modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "EventLog" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.EventLogTableCondition>();
conditions.Add( new CommandConditions.@EventLogTableEqualityConditions.@EventID( @EventID ) );
conditions.Add( new CommandConditions.@EventLogTableEqualityConditions.@EventTime( @EventTime ) );
conditions.Add( new CommandConditions.@EventLogTableEqualityConditions.@Category( @Category ) );
conditions.Add( new CommandConditions.@EventLogTableEqualityConditions.@SubCategory( @SubCategory ) );
}
else {
var update = new InlineUpdate( "EventLog" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @eventIDColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EventID", new DbParameterValue( @EventID, "UniqueIdentifier" ) ) );
if( @eventTimeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EventTime", new DbParameterValue( @EventTime, "DateTime" ) ) );
if( @categoryColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Category", new DbParameterValue( @Category, "NVarChar" ) ) );
if( @subCategoryColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "SubCategory", new DbParameterValue( @SubCategory, "NVarChar" ) ) );
if( @errorLevelColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ErrorLevel", new DbParameterValue( @ErrorLevel, "Int" ) ) );
if( @eventCodeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EventCode", new DbParameterValue( @EventCode, "NVarChar" ) ) );
if( @encKVColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EncKV", new DbParameterValue( @EncKV, "NVarChar" ) ) );
if( @encIVColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EncIV", new DbParameterValue( @EncIV, "VarBinary" ) ) );
if( @userIDColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "UserID", new DbParameterValue( @UserID, "UniqueIdentifier" ) ) );
if( @userTypeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "UserType", new DbParameterValue( @UserType, "NVarChar" ) ) );
if( @iPAddressColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "IPAddress", new DbParameterValue( @IPAddress, "VarChar" ) ) );
if( @eventSummaryColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EventSummary", new DbParameterValue( @EventSummary, "NVarChar" ) ) );
if( @eventURLColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EventURL", new DbParameterValue( @EventURL, "NVarChar" ) ) );
if( @additionalDataColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "AdditionalData", new DbParameterValue( @AdditionalData, "NVarChar" ) ) );
if( @protectedDataColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ProtectedData", new DbParameterValue( @ProtectedData, "VarBinary" ) ) );
if( @accessReasonCodeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "AccessReasonCode", new DbParameterValue( @AccessReasonCode, "NVarChar" ) ) );
if( @accessReasonTextColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "AccessReasonText", new DbParameterValue( @AccessReasonText, "NVarChar" ) ) );
if( @accessScopeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "AccessScope", new DbParameterValue( @AccessScope, "NVarChar" ) ) );
if( @accessTypeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "AccessType", new DbParameterValue( @AccessType, "Int" ) ) );
if( @reviewStatusColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ReviewStatus", new DbParameterValue( @ReviewStatus, "NVarChar" ) ) );
if( @suggestedActionColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "SuggestedAction", new DbParameterValue( @SuggestedAction, "NVarChar" ) ) );
if( @reviewedByColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ReviewedBy", new DbParameterValue( @ReviewedBy, "UniqueIdentifier" ) ) );
if( @reviewDateColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ReviewDate", new DbParameterValue( @ReviewDate, "DateTime" ) ) );
if( @reviewSummaryColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ReviewSummary", new DbParameterValue( @ReviewSummary, "NVarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@eventIDColumnValue.ClearChanged();
@eventTimeColumnValue.ClearChanged();
@categoryColumnValue.ClearChanged();
@subCategoryColumnValue.ClearChanged();
@errorLevelColumnValue.ClearChanged();
@eventCodeColumnValue.ClearChanged();
@encKVColumnValue.ClearChanged();
@encIVColumnValue.ClearChanged();
@userIDColumnValue.ClearChanged();
@userTypeColumnValue.ClearChanged();
@iPAddressColumnValue.ClearChanged();
@eventSummaryColumnValue.ClearChanged();
@eventURLColumnValue.ClearChanged();
@additionalDataColumnValue.ClearChanged();
@protectedDataColumnValue.ClearChanged();
@accessReasonCodeColumnValue.ClearChanged();
@accessReasonTextColumnValue.ClearChanged();
@accessScopeColumnValue.ClearChanged();
@accessTypeColumnValue.ClearChanged();
@reviewStatusColumnValue.ClearChanged();
@suggestedActionColumnValue.ClearChanged();
@reviewedByColumnValue.ClearChanged();
@reviewDateColumnValue.ClearChanged();
@reviewSummaryColumnValue.ClearChanged();
}
}
public partial class @FileCollectionsModification {
/// <summary>
/// Inserts a row into the FileCollections table.
/// </summary>
/// <param name="fileCollectionId">Object does not allow null.</param>
public static void InsertRow( int @fileCollectionId ) { 
var mod = CreateForInsert();
mod.@fileCollectionIdColumnValue.Value = @fileCollectionId;
mod.Execute();
}
/// <summary>
/// Inserts a row into the FileCollections table.
/// </summary>
/// <param name="fileCollectionId">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @fileCollectionId ) { 
var mod = CreateForInsert();
mod.@fileCollectionIdColumnValue.Value = @fileCollectionId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the FileCollections table that match the specified conditions with the specified data.
/// </summary>
/// <param name="fileCollectionId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @fileCollectionId, CommandConditions.FileCollectionsTableCondition requiredCondition, params CommandConditions.FileCollectionsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@fileCollectionIdColumnValue.Value = @fileCollectionId;
mod.Execute();
}
/// <summary>
/// Updates rows in the FileCollections table that match the specified conditions with the specified data.
/// </summary>
/// <param name="fileCollectionId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @fileCollectionId, CommandConditions.FileCollectionsTableCondition requiredCondition, params CommandConditions.FileCollectionsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@fileCollectionIdColumnValue.Value = @fileCollectionId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.FileCollectionsTableCondition requiredCondition, params CommandConditions.FileCollectionsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@FileCollectionsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.FileCollectionsTableCondition requiredCondition, params CommandConditions.FileCollectionsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.FileCollectionsTableCondition> conditions ) {
var delete = new InlineDelete( "FileCollections" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.FileCollectionsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@FileCollectionsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.FileCollectionsTableCondition> conditions;
private readonly DataValue<int> @fileCollectionIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the FileCollectionId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @FileCollectionId { get { return @fileCollectionIdColumnValue.Value; } set { @fileCollectionIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the FileCollectionId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @FileCollectionIdHasChanged { get { return @fileCollectionIdColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the FileCollections table.
/// </summary>
public static @FileCollectionsModification CreateForInsert() {
return new @FileCollectionsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the FileCollections table.
/// </summary>
public static @FileCollectionsModification CreateForUpdate( CommandConditions.FileCollectionsTableCondition requiredCondition, params CommandConditions.FileCollectionsTableCondition[] additionalConditions ) {
var mod = new @FileCollectionsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@FileCollectionsTableEqualityConditions.@FileCollectionId )
mod.@fileCollectionIdColumnValue.Value = ( condition as CommandConditions.@FileCollectionsTableEqualityConditions.@FileCollectionId ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the FileCollections table.
/// </summary>
public static @FileCollectionsModification CreateForSingleRowUpdate( int @fileCollectionId ) {
var mod = new @FileCollectionsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.FileCollectionsTableCondition>();
mod.conditions.Add( new CommandConditions.@FileCollectionsTableEqualityConditions.@FileCollectionId( @fileCollectionId ) );
mod.@fileCollectionIdColumnValue.Value = @fileCollectionId;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.FileCollectionsTableCondition> getConditionList( CommandConditions.FileCollectionsTableCondition requiredCondition, params CommandConditions.FileCollectionsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.FileCollectionsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @FileCollectionsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="fileCollectionId">Object does not allow null.</param>
public void SetAllData( int @fileCollectionId ) {
this.@fileCollectionIdColumnValue.Value = @fileCollectionId;
}
/// <summary>
/// Executes this FileCollections modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this FileCollections modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "FileCollections" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.FileCollectionsTableCondition>();
conditions.Add( new CommandConditions.@FileCollectionsTableEqualityConditions.@FileCollectionId( @FileCollectionId ) );
}
else {
var update = new InlineUpdate( "FileCollections" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @fileCollectionIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "FileCollectionId", new DbParameterValue( @FileCollectionId, "Int" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@fileCollectionIdColumnValue.ClearChanged();
}
}
public partial class @FilesModification {
/// <summary>
/// Inserts a row into the Files table.
/// </summary>
/// <param name="fileId">Object does not allow null.</param>
/// <param name="fileCollectionId">Object does not allow null.</param>
/// <param name="fileName">Object does not allow null.</param>
/// <param name="contentType">Object does not allow null.</param>
/// <param name="contents">Object does not allow null.</param>
/// <param name="uploadedDate">Object does not allow null.</param>
public static void InsertRow( int @fileId, int @fileCollectionId, string @fileName, string @contentType, System.Byte[] @contents, DateTime @uploadedDate ) { 
var mod = CreateForInsert();
mod.@fileIdColumnValue.Value = @fileId;
mod.@fileCollectionIdColumnValue.Value = @fileCollectionId;
mod.@fileNameColumnValue.Value = @fileName;
mod.@contentTypeColumnValue.Value = @contentType;
mod.@contentsColumnValue.Value = @contents;
mod.@uploadedDateColumnValue.Value = @uploadedDate;
mod.Execute();
}
/// <summary>
/// Inserts a row into the Files table.
/// </summary>
/// <param name="fileId">Object does not allow null.</param>
/// <param name="fileCollectionId">Object does not allow null.</param>
/// <param name="fileName">Object does not allow null.</param>
/// <param name="contentType">Object does not allow null.</param>
/// <param name="contents">Object does not allow null.</param>
/// <param name="uploadedDate">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @fileId, int @fileCollectionId, string @fileName, string @contentType, System.Byte[] @contents, DateTime @uploadedDate ) { 
var mod = CreateForInsert();
mod.@fileIdColumnValue.Value = @fileId;
mod.@fileCollectionIdColumnValue.Value = @fileCollectionId;
mod.@fileNameColumnValue.Value = @fileName;
mod.@contentTypeColumnValue.Value = @contentType;
mod.@contentsColumnValue.Value = @contents;
mod.@uploadedDateColumnValue.Value = @uploadedDate;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the Files table that match the specified conditions with the specified data.
/// </summary>
/// <param name="fileId">Object does not allow null.</param>
/// <param name="fileCollectionId">Object does not allow null.</param>
/// <param name="fileName">Object does not allow null.</param>
/// <param name="contentType">Object does not allow null.</param>
/// <param name="contents">Object does not allow null.</param>
/// <param name="uploadedDate">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @fileId, int @fileCollectionId, string @fileName, string @contentType, System.Byte[] @contents, DateTime @uploadedDate, CommandConditions.FilesTableCondition requiredCondition, params CommandConditions.FilesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@fileIdColumnValue.Value = @fileId;
mod.@fileCollectionIdColumnValue.Value = @fileCollectionId;
mod.@fileNameColumnValue.Value = @fileName;
mod.@contentTypeColumnValue.Value = @contentType;
mod.@contentsColumnValue.Value = @contents;
mod.@uploadedDateColumnValue.Value = @uploadedDate;
mod.Execute();
}
/// <summary>
/// Updates rows in the Files table that match the specified conditions with the specified data.
/// </summary>
/// <param name="fileId">Object does not allow null.</param>
/// <param name="fileCollectionId">Object does not allow null.</param>
/// <param name="fileName">Object does not allow null.</param>
/// <param name="contentType">Object does not allow null.</param>
/// <param name="contents">Object does not allow null.</param>
/// <param name="uploadedDate">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @fileId, int @fileCollectionId, string @fileName, string @contentType, System.Byte[] @contents, DateTime @uploadedDate, CommandConditions.FilesTableCondition requiredCondition, params CommandConditions.FilesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@fileIdColumnValue.Value = @fileId;
mod.@fileCollectionIdColumnValue.Value = @fileCollectionId;
mod.@fileNameColumnValue.Value = @fileName;
mod.@contentTypeColumnValue.Value = @contentType;
mod.@contentsColumnValue.Value = @contents;
mod.@uploadedDateColumnValue.Value = @uploadedDate;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.FilesTableCondition requiredCondition, params CommandConditions.FilesTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@FilesTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.FilesTableCondition requiredCondition, params CommandConditions.FilesTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.FilesTableCondition> conditions ) {
var delete = new InlineDelete( "Files" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.FilesTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@FilesTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.FilesTableCondition> conditions;
private readonly DataValue<int> @fileIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the FileId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @FileId { get { return @fileIdColumnValue.Value; } set { @fileIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the FileId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @FileIdHasChanged { get { return @fileIdColumnValue.Changed; } }
private readonly DataValue<int> @fileCollectionIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the FileCollectionId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @FileCollectionId { get { return @fileCollectionIdColumnValue.Value; } set { @fileCollectionIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the FileCollectionId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @FileCollectionIdHasChanged { get { return @fileCollectionIdColumnValue.Changed; } }
private readonly DataValue<string> @fileNameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the FileName column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @FileName { get { return @fileNameColumnValue.Value; } set { @fileNameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the FileName has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @FileNameHasChanged { get { return @fileNameColumnValue.Changed; } }
private readonly DataValue<string> @contentTypeColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the ContentType column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @ContentType { get { return @contentTypeColumnValue.Value; } set { @contentTypeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ContentType has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ContentTypeHasChanged { get { return @contentTypeColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @contentsColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the Contents column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @Contents { get { return @contentsColumnValue.Value; } set { @contentsColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Contents has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ContentsHasChanged { get { return @contentsColumnValue.Changed; } }
private readonly DataValue<DateTime> @uploadedDateColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the UploadedDate column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @UploadedDate { get { return @uploadedDateColumnValue.Value; } set { @uploadedDateColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the UploadedDate has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @UploadedDateHasChanged { get { return @uploadedDateColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the Files table.
/// </summary>
public static @FilesModification CreateForInsert() {
return new @FilesModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the Files table.
/// </summary>
public static @FilesModification CreateForUpdate( CommandConditions.FilesTableCondition requiredCondition, params CommandConditions.FilesTableCondition[] additionalConditions ) {
var mod = new @FilesModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@FilesTableEqualityConditions.@FileId )
mod.@fileIdColumnValue.Value = ( condition as CommandConditions.@FilesTableEqualityConditions.@FileId ).Value;
else if( condition is CommandConditions.@FilesTableEqualityConditions.@FileCollectionId )
mod.@fileCollectionIdColumnValue.Value = ( condition as CommandConditions.@FilesTableEqualityConditions.@FileCollectionId ).Value;
else if( condition is CommandConditions.@FilesTableEqualityConditions.@FileName )
mod.@fileNameColumnValue.Value = ( condition as CommandConditions.@FilesTableEqualityConditions.@FileName ).Value;
else if( condition is CommandConditions.@FilesTableEqualityConditions.@ContentType )
mod.@contentTypeColumnValue.Value = ( condition as CommandConditions.@FilesTableEqualityConditions.@ContentType ).Value;
else if( condition is CommandConditions.@FilesTableEqualityConditions.@Contents )
mod.@contentsColumnValue.Value = ( condition as CommandConditions.@FilesTableEqualityConditions.@Contents ).Value;
else if( condition is CommandConditions.@FilesTableEqualityConditions.@UploadedDate )
mod.@uploadedDateColumnValue.Value = ( condition as CommandConditions.@FilesTableEqualityConditions.@UploadedDate ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the Files table.
/// </summary>
public static @FilesModification CreateForSingleRowUpdate( int @fileId, int @fileCollectionId, string @fileName, string @contentType, System.Byte[] @contents, DateTime @uploadedDate ) {
var mod = new @FilesModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.FilesTableCondition>();
mod.conditions.Add( new CommandConditions.@FilesTableEqualityConditions.@FileId( @fileId ) );
mod.@fileIdColumnValue.Value = @fileId;
mod.@fileCollectionIdColumnValue.Value = @fileCollectionId;
mod.@fileNameColumnValue.Value = @fileName;
mod.@contentTypeColumnValue.Value = @contentType;
mod.@contentsColumnValue.Value = @contents;
mod.@uploadedDateColumnValue.Value = @uploadedDate;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.FilesTableCondition> getConditionList( CommandConditions.FilesTableCondition requiredCondition, params CommandConditions.FilesTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.FilesTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @FilesModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="fileId">Object does not allow null.</param>
/// <param name="fileCollectionId">Object does not allow null.</param>
/// <param name="fileName">Object does not allow null.</param>
/// <param name="contentType">Object does not allow null.</param>
/// <param name="contents">Object does not allow null.</param>
/// <param name="uploadedDate">Object does not allow null.</param>
public void SetAllData( int @fileId, int @fileCollectionId, string @fileName, string @contentType, System.Byte[] @contents, DateTime @uploadedDate ) {
this.@fileIdColumnValue.Value = @fileId;
this.@fileCollectionIdColumnValue.Value = @fileCollectionId;
this.@fileNameColumnValue.Value = @fileName;
this.@contentTypeColumnValue.Value = @contentType;
this.@contentsColumnValue.Value = @contents;
this.@uploadedDateColumnValue.Value = @uploadedDate;
}
/// <summary>
/// Executes this Files modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this Files modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "Files" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.FilesTableCondition>();
conditions.Add( new CommandConditions.@FilesTableEqualityConditions.@FileId( @FileId ) );
}
else {
var update = new InlineUpdate( "Files" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @fileIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "FileId", new DbParameterValue( @FileId, "Int" ) ) );
if( @fileCollectionIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "FileCollectionId", new DbParameterValue( @FileCollectionId, "Int" ) ) );
if( @fileNameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "FileName", new DbParameterValue( @FileName, "VarChar" ) ) );
if( @contentTypeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ContentType", new DbParameterValue( @ContentType, "VarChar" ) ) );
if( @contentsColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Contents", new DbParameterValue( @Contents, "VarBinary" ) ) );
if( @uploadedDateColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "UploadedDate", new DbParameterValue( @UploadedDate, "SmallDateTime" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@fileIdColumnValue.ClearChanged();
@fileCollectionIdColumnValue.ClearChanged();
@fileNameColumnValue.ClearChanged();
@contentTypeColumnValue.ClearChanged();
@contentsColumnValue.ClearChanged();
@uploadedDateColumnValue.ClearChanged();
}
}
public partial class @FormInputsModification {
/// <summary>
/// Inserts a row into the FormInputs table.
/// </summary>
/// <param name="formInputId">Object does not allow null.</param>
/// <param name="formId">Object does not allow null.</param>
/// <param name="inputName">Object does not allow null.</param>
/// <param name="label">Object does not allow null.</param>
public static void InsertRow( int @formInputId, int @formId, string @inputName, string @label ) { 
var mod = CreateForInsert();
mod.@formInputIdColumnValue.Value = @formInputId;
mod.@formIdColumnValue.Value = @formId;
mod.@inputNameColumnValue.Value = @inputName;
mod.@labelColumnValue.Value = @label;
mod.Execute();
}
/// <summary>
/// Inserts a row into the FormInputs table.
/// </summary>
/// <param name="formInputId">Object does not allow null.</param>
/// <param name="formId">Object does not allow null.</param>
/// <param name="inputName">Object does not allow null.</param>
/// <param name="label">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @formInputId, int @formId, string @inputName, string @label ) { 
var mod = CreateForInsert();
mod.@formInputIdColumnValue.Value = @formInputId;
mod.@formIdColumnValue.Value = @formId;
mod.@inputNameColumnValue.Value = @inputName;
mod.@labelColumnValue.Value = @label;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the FormInputs table that match the specified conditions with the specified data.
/// </summary>
/// <param name="formInputId">Object does not allow null.</param>
/// <param name="formId">Object does not allow null.</param>
/// <param name="inputName">Object does not allow null.</param>
/// <param name="label">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @formInputId, int @formId, string @inputName, string @label, CommandConditions.FormInputsTableCondition requiredCondition, params CommandConditions.FormInputsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@formInputIdColumnValue.Value = @formInputId;
mod.@formIdColumnValue.Value = @formId;
mod.@inputNameColumnValue.Value = @inputName;
mod.@labelColumnValue.Value = @label;
mod.Execute();
}
/// <summary>
/// Updates rows in the FormInputs table that match the specified conditions with the specified data.
/// </summary>
/// <param name="formInputId">Object does not allow null.</param>
/// <param name="formId">Object does not allow null.</param>
/// <param name="inputName">Object does not allow null.</param>
/// <param name="label">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @formInputId, int @formId, string @inputName, string @label, CommandConditions.FormInputsTableCondition requiredCondition, params CommandConditions.FormInputsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@formInputIdColumnValue.Value = @formInputId;
mod.@formIdColumnValue.Value = @formId;
mod.@inputNameColumnValue.Value = @inputName;
mod.@labelColumnValue.Value = @label;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.FormInputsTableCondition requiredCondition, params CommandConditions.FormInputsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@FormInputsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.FormInputsTableCondition requiredCondition, params CommandConditions.FormInputsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.FormInputsTableCondition> conditions ) {
var delete = new InlineDelete( "FormInputs" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.FormInputsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@FormInputsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.FormInputsTableCondition> conditions;
private readonly DataValue<int> @formInputIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the FormInputId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @FormInputId { get { return @formInputIdColumnValue.Value; } set { @formInputIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the FormInputId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @FormInputIdHasChanged { get { return @formInputIdColumnValue.Changed; } }
private readonly DataValue<int> @formIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the FormId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @FormId { get { return @formIdColumnValue.Value; } set { @formIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the FormId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @FormIdHasChanged { get { return @formIdColumnValue.Changed; } }
private readonly DataValue<string> @inputNameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the InputName column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @InputName { get { return @inputNameColumnValue.Value; } set { @inputNameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the InputName has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @InputNameHasChanged { get { return @inputNameColumnValue.Changed; } }
private readonly DataValue<string> @labelColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Label column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Label { get { return @labelColumnValue.Value; } set { @labelColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Label has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LabelHasChanged { get { return @labelColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the FormInputs table.
/// </summary>
public static @FormInputsModification CreateForInsert() {
return new @FormInputsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the FormInputs table.
/// </summary>
public static @FormInputsModification CreateForUpdate( CommandConditions.FormInputsTableCondition requiredCondition, params CommandConditions.FormInputsTableCondition[] additionalConditions ) {
var mod = new @FormInputsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@FormInputsTableEqualityConditions.@FormInputId )
mod.@formInputIdColumnValue.Value = ( condition as CommandConditions.@FormInputsTableEqualityConditions.@FormInputId ).Value;
else if( condition is CommandConditions.@FormInputsTableEqualityConditions.@FormId )
mod.@formIdColumnValue.Value = ( condition as CommandConditions.@FormInputsTableEqualityConditions.@FormId ).Value;
else if( condition is CommandConditions.@FormInputsTableEqualityConditions.@InputName )
mod.@inputNameColumnValue.Value = ( condition as CommandConditions.@FormInputsTableEqualityConditions.@InputName ).Value;
else if( condition is CommandConditions.@FormInputsTableEqualityConditions.@Label )
mod.@labelColumnValue.Value = ( condition as CommandConditions.@FormInputsTableEqualityConditions.@Label ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the FormInputs table.
/// </summary>
public static @FormInputsModification CreateForSingleRowUpdate( int @formInputId, int @formId, string @inputName, string @label ) {
var mod = new @FormInputsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.FormInputsTableCondition>();
mod.conditions.Add( new CommandConditions.@FormInputsTableEqualityConditions.@FormInputId( @formInputId ) );
mod.@formInputIdColumnValue.Value = @formInputId;
mod.@formIdColumnValue.Value = @formId;
mod.@inputNameColumnValue.Value = @inputName;
mod.@labelColumnValue.Value = @label;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.FormInputsTableCondition> getConditionList( CommandConditions.FormInputsTableCondition requiredCondition, params CommandConditions.FormInputsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.FormInputsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @FormInputsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="formInputId">Object does not allow null.</param>
/// <param name="formId">Object does not allow null.</param>
/// <param name="inputName">Object does not allow null.</param>
/// <param name="label">Object does not allow null.</param>
public void SetAllData( int @formInputId, int @formId, string @inputName, string @label ) {
this.@formInputIdColumnValue.Value = @formInputId;
this.@formIdColumnValue.Value = @formId;
this.@inputNameColumnValue.Value = @inputName;
this.@labelColumnValue.Value = @label;
}
/// <summary>
/// Executes this FormInputs modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this FormInputs modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "FormInputs" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.FormInputsTableCondition>();
conditions.Add( new CommandConditions.@FormInputsTableEqualityConditions.@FormInputId( @FormInputId ) );
}
else {
var update = new InlineUpdate( "FormInputs" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @formInputIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "FormInputId", new DbParameterValue( @FormInputId, "Int" ) ) );
if( @formIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "FormId", new DbParameterValue( @FormId, "Int" ) ) );
if( @inputNameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "InputName", new DbParameterValue( @InputName, "NVarChar" ) ) );
if( @labelColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Label", new DbParameterValue( @Label, "NVarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@formInputIdColumnValue.ClearChanged();
@formIdColumnValue.ClearChanged();
@inputNameColumnValue.ClearChanged();
@labelColumnValue.ClearChanged();
}
}
public partial class @FormInstancesModification {
/// <summary>
/// Inserts a row into the FormInstances table.
/// </summary>
/// <param name="formInstanceId">Object does not allow null.</param>
/// <param name="formId">Object does not allow null.</param>
/// <param name="signedByUserId">Object does not allow null.</param>
/// <param name="signedDateTimeUtc">Object does not allow null.</param>
public static void InsertRow( int @formInstanceId, int @formId, int @signedByUserId, DateTime @signedDateTimeUtc ) { 
var mod = CreateForInsert();
mod.@formInstanceIdColumnValue.Value = @formInstanceId;
mod.@formIdColumnValue.Value = @formId;
mod.@signedByUserIdColumnValue.Value = @signedByUserId;
mod.@signedDateTimeUtcColumnValue.Value = @signedDateTimeUtc;
mod.Execute();
}
/// <summary>
/// Inserts a row into the FormInstances table.
/// </summary>
/// <param name="formInstanceId">Object does not allow null.</param>
/// <param name="formId">Object does not allow null.</param>
/// <param name="signedByUserId">Object does not allow null.</param>
/// <param name="signedDateTimeUtc">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @formInstanceId, int @formId, int @signedByUserId, DateTime @signedDateTimeUtc ) { 
var mod = CreateForInsert();
mod.@formInstanceIdColumnValue.Value = @formInstanceId;
mod.@formIdColumnValue.Value = @formId;
mod.@signedByUserIdColumnValue.Value = @signedByUserId;
mod.@signedDateTimeUtcColumnValue.Value = @signedDateTimeUtc;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the FormInstances table that match the specified conditions with the specified data.
/// </summary>
/// <param name="formInstanceId">Object does not allow null.</param>
/// <param name="formId">Object does not allow null.</param>
/// <param name="signedByUserId">Object does not allow null.</param>
/// <param name="signedDateTimeUtc">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @formInstanceId, int @formId, int @signedByUserId, DateTime @signedDateTimeUtc, CommandConditions.FormInstancesTableCondition requiredCondition, params CommandConditions.FormInstancesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@formInstanceIdColumnValue.Value = @formInstanceId;
mod.@formIdColumnValue.Value = @formId;
mod.@signedByUserIdColumnValue.Value = @signedByUserId;
mod.@signedDateTimeUtcColumnValue.Value = @signedDateTimeUtc;
mod.Execute();
}
/// <summary>
/// Updates rows in the FormInstances table that match the specified conditions with the specified data.
/// </summary>
/// <param name="formInstanceId">Object does not allow null.</param>
/// <param name="formId">Object does not allow null.</param>
/// <param name="signedByUserId">Object does not allow null.</param>
/// <param name="signedDateTimeUtc">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @formInstanceId, int @formId, int @signedByUserId, DateTime @signedDateTimeUtc, CommandConditions.FormInstancesTableCondition requiredCondition, params CommandConditions.FormInstancesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@formInstanceIdColumnValue.Value = @formInstanceId;
mod.@formIdColumnValue.Value = @formId;
mod.@signedByUserIdColumnValue.Value = @signedByUserId;
mod.@signedDateTimeUtcColumnValue.Value = @signedDateTimeUtc;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.FormInstancesTableCondition requiredCondition, params CommandConditions.FormInstancesTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@FormInstancesTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.FormInstancesTableCondition requiredCondition, params CommandConditions.FormInstancesTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.FormInstancesTableCondition> conditions ) {
var delete = new InlineDelete( "FormInstances" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.FormInstancesTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@FormInstancesTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.FormInstancesTableCondition> conditions;
private readonly DataValue<int> @formInstanceIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the FormInstanceId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @FormInstanceId { get { return @formInstanceIdColumnValue.Value; } set { @formInstanceIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the FormInstanceId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @FormInstanceIdHasChanged { get { return @formInstanceIdColumnValue.Changed; } }
private readonly DataValue<int> @formIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the FormId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @FormId { get { return @formIdColumnValue.Value; } set { @formIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the FormId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @FormIdHasChanged { get { return @formIdColumnValue.Changed; } }
private readonly DataValue<int> @signedByUserIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the SignedByUserId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @SignedByUserId { get { return @signedByUserIdColumnValue.Value; } set { @signedByUserIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the SignedByUserId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @SignedByUserIdHasChanged { get { return @signedByUserIdColumnValue.Changed; } }
private readonly DataValue<DateTime> @signedDateTimeUtcColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the SignedDateTimeUtc column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @SignedDateTimeUtc { get { return @signedDateTimeUtcColumnValue.Value; } set { @signedDateTimeUtcColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the SignedDateTimeUtc has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @SignedDateTimeUtcHasChanged { get { return @signedDateTimeUtcColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the FormInstances table.
/// </summary>
public static @FormInstancesModification CreateForInsert() {
return new @FormInstancesModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the FormInstances table.
/// </summary>
public static @FormInstancesModification CreateForUpdate( CommandConditions.FormInstancesTableCondition requiredCondition, params CommandConditions.FormInstancesTableCondition[] additionalConditions ) {
var mod = new @FormInstancesModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@FormInstancesTableEqualityConditions.@FormInstanceId )
mod.@formInstanceIdColumnValue.Value = ( condition as CommandConditions.@FormInstancesTableEqualityConditions.@FormInstanceId ).Value;
else if( condition is CommandConditions.@FormInstancesTableEqualityConditions.@FormId )
mod.@formIdColumnValue.Value = ( condition as CommandConditions.@FormInstancesTableEqualityConditions.@FormId ).Value;
else if( condition is CommandConditions.@FormInstancesTableEqualityConditions.@SignedByUserId )
mod.@signedByUserIdColumnValue.Value = ( condition as CommandConditions.@FormInstancesTableEqualityConditions.@SignedByUserId ).Value;
else if( condition is CommandConditions.@FormInstancesTableEqualityConditions.@SignedDateTimeUtc )
mod.@signedDateTimeUtcColumnValue.Value = ( condition as CommandConditions.@FormInstancesTableEqualityConditions.@SignedDateTimeUtc ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the FormInstances table.
/// </summary>
public static @FormInstancesModification CreateForSingleRowUpdate( int @formInstanceId, int @formId, int @signedByUserId, DateTime @signedDateTimeUtc ) {
var mod = new @FormInstancesModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.FormInstancesTableCondition>();
mod.conditions.Add( new CommandConditions.@FormInstancesTableEqualityConditions.@FormInstanceId( @formInstanceId ) );
mod.@formInstanceIdColumnValue.Value = @formInstanceId;
mod.@formIdColumnValue.Value = @formId;
mod.@signedByUserIdColumnValue.Value = @signedByUserId;
mod.@signedDateTimeUtcColumnValue.Value = @signedDateTimeUtc;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.FormInstancesTableCondition> getConditionList( CommandConditions.FormInstancesTableCondition requiredCondition, params CommandConditions.FormInstancesTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.FormInstancesTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @FormInstancesModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="formInstanceId">Object does not allow null.</param>
/// <param name="formId">Object does not allow null.</param>
/// <param name="signedByUserId">Object does not allow null.</param>
/// <param name="signedDateTimeUtc">Object does not allow null.</param>
public void SetAllData( int @formInstanceId, int @formId, int @signedByUserId, DateTime @signedDateTimeUtc ) {
this.@formInstanceIdColumnValue.Value = @formInstanceId;
this.@formIdColumnValue.Value = @formId;
this.@signedByUserIdColumnValue.Value = @signedByUserId;
this.@signedDateTimeUtcColumnValue.Value = @signedDateTimeUtc;
}
/// <summary>
/// Executes this FormInstances modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this FormInstances modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "FormInstances" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.FormInstancesTableCondition>();
conditions.Add( new CommandConditions.@FormInstancesTableEqualityConditions.@FormInstanceId( @FormInstanceId ) );
}
else {
var update = new InlineUpdate( "FormInstances" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @formInstanceIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "FormInstanceId", new DbParameterValue( @FormInstanceId, "Int" ) ) );
if( @formIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "FormId", new DbParameterValue( @FormId, "Int" ) ) );
if( @signedByUserIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "SignedByUserId", new DbParameterValue( @SignedByUserId, "Int" ) ) );
if( @signedDateTimeUtcColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "SignedDateTimeUtc", new DbParameterValue( @SignedDateTimeUtc, "DateTime2" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@formInstanceIdColumnValue.ClearChanged();
@formIdColumnValue.ClearChanged();
@signedByUserIdColumnValue.ClearChanged();
@signedDateTimeUtcColumnValue.ClearChanged();
}
}
public partial class @FormsModification {
/// <summary>
/// Inserts a row into the Forms table.
/// </summary>
/// <param name="formId">Object does not allow null.</param>
/// <param name="formName">Object does not allow null.</param>
public static void InsertRow( int @formId, string @formName ) { 
var mod = CreateForInsert();
mod.@formIdColumnValue.Value = @formId;
mod.@formNameColumnValue.Value = @formName;
mod.Execute();
}
/// <summary>
/// Inserts a row into the Forms table.
/// </summary>
/// <param name="formId">Object does not allow null.</param>
/// <param name="formName">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @formId, string @formName ) { 
var mod = CreateForInsert();
mod.@formIdColumnValue.Value = @formId;
mod.@formNameColumnValue.Value = @formName;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the Forms table that match the specified conditions with the specified data.
/// </summary>
/// <param name="formId">Object does not allow null.</param>
/// <param name="formName">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @formId, string @formName, CommandConditions.FormsTableCondition requiredCondition, params CommandConditions.FormsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@formIdColumnValue.Value = @formId;
mod.@formNameColumnValue.Value = @formName;
mod.Execute();
}
/// <summary>
/// Updates rows in the Forms table that match the specified conditions with the specified data.
/// </summary>
/// <param name="formId">Object does not allow null.</param>
/// <param name="formName">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @formId, string @formName, CommandConditions.FormsTableCondition requiredCondition, params CommandConditions.FormsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@formIdColumnValue.Value = @formId;
mod.@formNameColumnValue.Value = @formName;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.FormsTableCondition requiredCondition, params CommandConditions.FormsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@FormsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.FormsTableCondition requiredCondition, params CommandConditions.FormsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.FormsTableCondition> conditions ) {
var delete = new InlineDelete( "Forms" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.FormsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@FormsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.FormsTableCondition> conditions;
private readonly DataValue<int> @formIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the FormId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @FormId { get { return @formIdColumnValue.Value; } set { @formIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the FormId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @FormIdHasChanged { get { return @formIdColumnValue.Changed; } }
private readonly DataValue<string> @formNameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the FormName column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @FormName { get { return @formNameColumnValue.Value; } set { @formNameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the FormName has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @FormNameHasChanged { get { return @formNameColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the Forms table.
/// </summary>
public static @FormsModification CreateForInsert() {
return new @FormsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the Forms table.
/// </summary>
public static @FormsModification CreateForUpdate( CommandConditions.FormsTableCondition requiredCondition, params CommandConditions.FormsTableCondition[] additionalConditions ) {
var mod = new @FormsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@FormsTableEqualityConditions.@FormId )
mod.@formIdColumnValue.Value = ( condition as CommandConditions.@FormsTableEqualityConditions.@FormId ).Value;
else if( condition is CommandConditions.@FormsTableEqualityConditions.@FormName )
mod.@formNameColumnValue.Value = ( condition as CommandConditions.@FormsTableEqualityConditions.@FormName ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the Forms table.
/// </summary>
public static @FormsModification CreateForSingleRowUpdate( int @formId, string @formName ) {
var mod = new @FormsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.FormsTableCondition>();
mod.conditions.Add( new CommandConditions.@FormsTableEqualityConditions.@FormId( @formId ) );
mod.@formIdColumnValue.Value = @formId;
mod.@formNameColumnValue.Value = @formName;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.FormsTableCondition> getConditionList( CommandConditions.FormsTableCondition requiredCondition, params CommandConditions.FormsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.FormsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @FormsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="formId">Object does not allow null.</param>
/// <param name="formName">Object does not allow null.</param>
public void SetAllData( int @formId, string @formName ) {
this.@formIdColumnValue.Value = @formId;
this.@formNameColumnValue.Value = @formName;
}
/// <summary>
/// Executes this Forms modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this Forms modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "Forms" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.FormsTableCondition>();
conditions.Add( new CommandConditions.@FormsTableEqualityConditions.@FormId( @FormId ) );
}
else {
var update = new InlineUpdate( "Forms" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @formIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "FormId", new DbParameterValue( @FormId, "Int" ) ) );
if( @formNameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "FormName", new DbParameterValue( @FormName, "NVarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@formIdColumnValue.ClearChanged();
@formNameColumnValue.ClearChanged();
}
}
public partial class @FormValuesModification {
/// <summary>
/// Inserts a row into the FormValues table.
/// </summary>
/// <param name="formValueId">Object does not allow null.</param>
/// <param name="formInstanceId">Object does not allow null.</param>
/// <param name="formInputId">Object does not allow null.</param>
/// <param name="inputValue">Object does not allow null.</param>
public static void InsertRow( int @formValueId, int @formInstanceId, int @formInputId, string @inputValue ) { 
var mod = CreateForInsert();
mod.@formValueIdColumnValue.Value = @formValueId;
mod.@formInstanceIdColumnValue.Value = @formInstanceId;
mod.@formInputIdColumnValue.Value = @formInputId;
mod.@inputValueColumnValue.Value = @inputValue;
mod.Execute();
}
/// <summary>
/// Inserts a row into the FormValues table.
/// </summary>
/// <param name="formValueId">Object does not allow null.</param>
/// <param name="formInstanceId">Object does not allow null.</param>
/// <param name="formInputId">Object does not allow null.</param>
/// <param name="inputValue">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @formValueId, int @formInstanceId, int @formInputId, string @inputValue ) { 
var mod = CreateForInsert();
mod.@formValueIdColumnValue.Value = @formValueId;
mod.@formInstanceIdColumnValue.Value = @formInstanceId;
mod.@formInputIdColumnValue.Value = @formInputId;
mod.@inputValueColumnValue.Value = @inputValue;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the FormValues table that match the specified conditions with the specified data.
/// </summary>
/// <param name="formValueId">Object does not allow null.</param>
/// <param name="formInstanceId">Object does not allow null.</param>
/// <param name="formInputId">Object does not allow null.</param>
/// <param name="inputValue">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @formValueId, int @formInstanceId, int @formInputId, string @inputValue, CommandConditions.FormValuesTableCondition requiredCondition, params CommandConditions.FormValuesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@formValueIdColumnValue.Value = @formValueId;
mod.@formInstanceIdColumnValue.Value = @formInstanceId;
mod.@formInputIdColumnValue.Value = @formInputId;
mod.@inputValueColumnValue.Value = @inputValue;
mod.Execute();
}
/// <summary>
/// Updates rows in the FormValues table that match the specified conditions with the specified data.
/// </summary>
/// <param name="formValueId">Object does not allow null.</param>
/// <param name="formInstanceId">Object does not allow null.</param>
/// <param name="formInputId">Object does not allow null.</param>
/// <param name="inputValue">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @formValueId, int @formInstanceId, int @formInputId, string @inputValue, CommandConditions.FormValuesTableCondition requiredCondition, params CommandConditions.FormValuesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@formValueIdColumnValue.Value = @formValueId;
mod.@formInstanceIdColumnValue.Value = @formInstanceId;
mod.@formInputIdColumnValue.Value = @formInputId;
mod.@inputValueColumnValue.Value = @inputValue;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.FormValuesTableCondition requiredCondition, params CommandConditions.FormValuesTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@FormValuesTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.FormValuesTableCondition requiredCondition, params CommandConditions.FormValuesTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.FormValuesTableCondition> conditions ) {
var delete = new InlineDelete( "FormValues" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.FormValuesTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@FormValuesTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.FormValuesTableCondition> conditions;
private readonly DataValue<int> @formValueIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the FormValueId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @FormValueId { get { return @formValueIdColumnValue.Value; } set { @formValueIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the FormValueId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @FormValueIdHasChanged { get { return @formValueIdColumnValue.Changed; } }
private readonly DataValue<int> @formInstanceIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the FormInstanceId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @FormInstanceId { get { return @formInstanceIdColumnValue.Value; } set { @formInstanceIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the FormInstanceId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @FormInstanceIdHasChanged { get { return @formInstanceIdColumnValue.Changed; } }
private readonly DataValue<int> @formInputIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the FormInputId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @FormInputId { get { return @formInputIdColumnValue.Value; } set { @formInputIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the FormInputId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @FormInputIdHasChanged { get { return @formInputIdColumnValue.Changed; } }
private readonly DataValue<string> @inputValueColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the InputValue column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @InputValue { get { return @inputValueColumnValue.Value; } set { @inputValueColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the InputValue has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @InputValueHasChanged { get { return @inputValueColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the FormValues table.
/// </summary>
public static @FormValuesModification CreateForInsert() {
return new @FormValuesModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the FormValues table.
/// </summary>
public static @FormValuesModification CreateForUpdate( CommandConditions.FormValuesTableCondition requiredCondition, params CommandConditions.FormValuesTableCondition[] additionalConditions ) {
var mod = new @FormValuesModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@FormValuesTableEqualityConditions.@FormValueId )
mod.@formValueIdColumnValue.Value = ( condition as CommandConditions.@FormValuesTableEqualityConditions.@FormValueId ).Value;
else if( condition is CommandConditions.@FormValuesTableEqualityConditions.@FormInstanceId )
mod.@formInstanceIdColumnValue.Value = ( condition as CommandConditions.@FormValuesTableEqualityConditions.@FormInstanceId ).Value;
else if( condition is CommandConditions.@FormValuesTableEqualityConditions.@FormInputId )
mod.@formInputIdColumnValue.Value = ( condition as CommandConditions.@FormValuesTableEqualityConditions.@FormInputId ).Value;
else if( condition is CommandConditions.@FormValuesTableEqualityConditions.@InputValue )
mod.@inputValueColumnValue.Value = ( condition as CommandConditions.@FormValuesTableEqualityConditions.@InputValue ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the FormValues table.
/// </summary>
public static @FormValuesModification CreateForSingleRowUpdate( int @formValueId, int @formInstanceId, int @formInputId, string @inputValue ) {
var mod = new @FormValuesModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.FormValuesTableCondition>();
mod.conditions.Add( new CommandConditions.@FormValuesTableEqualityConditions.@FormValueId( @formValueId ) );
mod.@formValueIdColumnValue.Value = @formValueId;
mod.@formInstanceIdColumnValue.Value = @formInstanceId;
mod.@formInputIdColumnValue.Value = @formInputId;
mod.@inputValueColumnValue.Value = @inputValue;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.FormValuesTableCondition> getConditionList( CommandConditions.FormValuesTableCondition requiredCondition, params CommandConditions.FormValuesTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.FormValuesTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @FormValuesModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="formValueId">Object does not allow null.</param>
/// <param name="formInstanceId">Object does not allow null.</param>
/// <param name="formInputId">Object does not allow null.</param>
/// <param name="inputValue">Object does not allow null.</param>
public void SetAllData( int @formValueId, int @formInstanceId, int @formInputId, string @inputValue ) {
this.@formValueIdColumnValue.Value = @formValueId;
this.@formInstanceIdColumnValue.Value = @formInstanceId;
this.@formInputIdColumnValue.Value = @formInputId;
this.@inputValueColumnValue.Value = @inputValue;
}
/// <summary>
/// Executes this FormValues modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this FormValues modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "FormValues" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.FormValuesTableCondition>();
conditions.Add( new CommandConditions.@FormValuesTableEqualityConditions.@FormValueId( @FormValueId ) );
}
else {
var update = new InlineUpdate( "FormValues" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @formValueIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "FormValueId", new DbParameterValue( @FormValueId, "Int" ) ) );
if( @formInstanceIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "FormInstanceId", new DbParameterValue( @FormInstanceId, "Int" ) ) );
if( @formInputIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "FormInputId", new DbParameterValue( @FormInputId, "Int" ) ) );
if( @inputValueColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "InputValue", new DbParameterValue( @InputValue, "NVarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@formValueIdColumnValue.ClearChanged();
@formInstanceIdColumnValue.ClearChanged();
@formInputIdColumnValue.ClearChanged();
@inputValueColumnValue.ClearChanged();
}
}
public partial class @GlobalDatesModification {
/// <summary>
/// Inserts a row into the GlobalDates table.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="value">Object does not allow null.</param>
public static void InsertRow( string @name, DateTime @value ) { 
var mod = CreateForInsert();
mod.@nameColumnValue.Value = @name;
mod.@valueColumnValue.Value = @value;
mod.Execute();
}
/// <summary>
/// Inserts a row into the GlobalDates table.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="value">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( string @name, DateTime @value ) { 
var mod = CreateForInsert();
mod.@nameColumnValue.Value = @name;
mod.@valueColumnValue.Value = @value;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the GlobalDates table that match the specified conditions with the specified data.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="value">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( string @name, DateTime @value, CommandConditions.GlobalDatesTableCondition requiredCondition, params CommandConditions.GlobalDatesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@nameColumnValue.Value = @name;
mod.@valueColumnValue.Value = @value;
mod.Execute();
}
/// <summary>
/// Updates rows in the GlobalDates table that match the specified conditions with the specified data.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="value">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( string @name, DateTime @value, CommandConditions.GlobalDatesTableCondition requiredCondition, params CommandConditions.GlobalDatesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@nameColumnValue.Value = @name;
mod.@valueColumnValue.Value = @value;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.GlobalDatesTableCondition requiredCondition, params CommandConditions.GlobalDatesTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@GlobalDatesTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.GlobalDatesTableCondition requiredCondition, params CommandConditions.GlobalDatesTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.GlobalDatesTableCondition> conditions ) {
var delete = new InlineDelete( "GlobalDates" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.GlobalDatesTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@GlobalDatesTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.GlobalDatesTableCondition> conditions;
private readonly DataValue<string> @nameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Name column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Name { get { return @nameColumnValue.Value; } set { @nameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Name has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @NameHasChanged { get { return @nameColumnValue.Changed; } }
private readonly DataValue<DateTime> @valueColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the Value column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @Value { get { return @valueColumnValue.Value; } set { @valueColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Value has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ValueHasChanged { get { return @valueColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the GlobalDates table.
/// </summary>
public static @GlobalDatesModification CreateForInsert() {
return new @GlobalDatesModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the GlobalDates table.
/// </summary>
public static @GlobalDatesModification CreateForUpdate( CommandConditions.GlobalDatesTableCondition requiredCondition, params CommandConditions.GlobalDatesTableCondition[] additionalConditions ) {
var mod = new @GlobalDatesModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@GlobalDatesTableEqualityConditions.@Name )
mod.@nameColumnValue.Value = ( condition as CommandConditions.@GlobalDatesTableEqualityConditions.@Name ).Value;
else if( condition is CommandConditions.@GlobalDatesTableEqualityConditions.@_Value )
mod.@valueColumnValue.Value = ( condition as CommandConditions.@GlobalDatesTableEqualityConditions.@_Value ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the GlobalDates table.
/// </summary>
public static @GlobalDatesModification CreateForSingleRowUpdate( string @name, DateTime @value ) {
var mod = new @GlobalDatesModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.GlobalDatesTableCondition>();
mod.conditions.Add( new CommandConditions.@GlobalDatesTableEqualityConditions.@Name( @name ) );
mod.@nameColumnValue.Value = @name;
mod.@valueColumnValue.Value = @value;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.GlobalDatesTableCondition> getConditionList( CommandConditions.GlobalDatesTableCondition requiredCondition, params CommandConditions.GlobalDatesTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.GlobalDatesTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @GlobalDatesModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="value">Object does not allow null.</param>
public void SetAllData( string @name, DateTime @value ) {
this.@nameColumnValue.Value = @name;
this.@valueColumnValue.Value = @value;
}
/// <summary>
/// Executes this GlobalDates modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this GlobalDates modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "GlobalDates" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.GlobalDatesTableCondition>();
conditions.Add( new CommandConditions.@GlobalDatesTableEqualityConditions.@Name( @Name ) );
}
else {
var update = new InlineUpdate( "GlobalDates" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @nameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Name", new DbParameterValue( @Name, "VarChar" ) ) );
if( @valueColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Value", new DbParameterValue( @Value, "DateTime2" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@nameColumnValue.ClearChanged();
@valueColumnValue.ClearChanged();
}
}
public partial class @GlobalIntsModification {
/// <summary>
/// Inserts a row into the GlobalInts table.
/// </summary>
/// <param name="parameterName">Object does not allow null.</param>
/// <param name="parameterValue">Object does not allow null.</param>
public static void InsertRow( string @parameterName, int @parameterValue ) { 
var mod = CreateForInsert();
mod.@parameterNameColumnValue.Value = @parameterName;
mod.@parameterValueColumnValue.Value = @parameterValue;
mod.Execute();
}
/// <summary>
/// Inserts a row into the GlobalInts table.
/// </summary>
/// <param name="parameterName">Object does not allow null.</param>
/// <param name="parameterValue">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( string @parameterName, int @parameterValue ) { 
var mod = CreateForInsert();
mod.@parameterNameColumnValue.Value = @parameterName;
mod.@parameterValueColumnValue.Value = @parameterValue;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the GlobalInts table that match the specified conditions with the specified data.
/// </summary>
/// <param name="parameterName">Object does not allow null.</param>
/// <param name="parameterValue">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( string @parameterName, int @parameterValue, CommandConditions.GlobalIntsTableCondition requiredCondition, params CommandConditions.GlobalIntsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@parameterNameColumnValue.Value = @parameterName;
mod.@parameterValueColumnValue.Value = @parameterValue;
mod.Execute();
}
/// <summary>
/// Updates rows in the GlobalInts table that match the specified conditions with the specified data.
/// </summary>
/// <param name="parameterName">Object does not allow null.</param>
/// <param name="parameterValue">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( string @parameterName, int @parameterValue, CommandConditions.GlobalIntsTableCondition requiredCondition, params CommandConditions.GlobalIntsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@parameterNameColumnValue.Value = @parameterName;
mod.@parameterValueColumnValue.Value = @parameterValue;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.GlobalIntsTableCondition requiredCondition, params CommandConditions.GlobalIntsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@GlobalIntsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.GlobalIntsTableCondition requiredCondition, params CommandConditions.GlobalIntsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.GlobalIntsTableCondition> conditions ) {
var delete = new InlineDelete( "GlobalInts" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.GlobalIntsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@GlobalIntsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.GlobalIntsTableCondition> conditions;
private readonly DataValue<string> @parameterNameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the ParameterName column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @ParameterName { get { return @parameterNameColumnValue.Value; } set { @parameterNameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ParameterName has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ParameterNameHasChanged { get { return @parameterNameColumnValue.Changed; } }
private readonly DataValue<int> @parameterValueColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the ParameterValue column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @ParameterValue { get { return @parameterValueColumnValue.Value; } set { @parameterValueColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ParameterValue has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ParameterValueHasChanged { get { return @parameterValueColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the GlobalInts table.
/// </summary>
public static @GlobalIntsModification CreateForInsert() {
return new @GlobalIntsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the GlobalInts table.
/// </summary>
public static @GlobalIntsModification CreateForUpdate( CommandConditions.GlobalIntsTableCondition requiredCondition, params CommandConditions.GlobalIntsTableCondition[] additionalConditions ) {
var mod = new @GlobalIntsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@GlobalIntsTableEqualityConditions.@ParameterName )
mod.@parameterNameColumnValue.Value = ( condition as CommandConditions.@GlobalIntsTableEqualityConditions.@ParameterName ).Value;
else if( condition is CommandConditions.@GlobalIntsTableEqualityConditions.@ParameterValue )
mod.@parameterValueColumnValue.Value = ( condition as CommandConditions.@GlobalIntsTableEqualityConditions.@ParameterValue ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the GlobalInts table.
/// </summary>
public static @GlobalIntsModification CreateForSingleRowUpdate( string @parameterName, int @parameterValue ) {
var mod = new @GlobalIntsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.GlobalIntsTableCondition>();
mod.conditions.Add( new CommandConditions.@GlobalIntsTableEqualityConditions.@ParameterName( @parameterName ) );
mod.@parameterNameColumnValue.Value = @parameterName;
mod.@parameterValueColumnValue.Value = @parameterValue;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.GlobalIntsTableCondition> getConditionList( CommandConditions.GlobalIntsTableCondition requiredCondition, params CommandConditions.GlobalIntsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.GlobalIntsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @GlobalIntsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="parameterName">Object does not allow null.</param>
/// <param name="parameterValue">Object does not allow null.</param>
public void SetAllData( string @parameterName, int @parameterValue ) {
this.@parameterNameColumnValue.Value = @parameterName;
this.@parameterValueColumnValue.Value = @parameterValue;
}
/// <summary>
/// Executes this GlobalInts modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this GlobalInts modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "GlobalInts" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.GlobalIntsTableCondition>();
conditions.Add( new CommandConditions.@GlobalIntsTableEqualityConditions.@ParameterName( @ParameterName ) );
}
else {
var update = new InlineUpdate( "GlobalInts" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @parameterNameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ParameterName", new DbParameterValue( @ParameterName, "VarChar" ) ) );
if( @parameterValueColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ParameterValue", new DbParameterValue( @ParameterValue, "Int" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@parameterNameColumnValue.ClearChanged();
@parameterValueColumnValue.ClearChanged();
}
}
public partial class @GlobalStringsModification {
/// <summary>
/// Inserts a row into the GlobalStrings table.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="value">Object does not allow null.</param>
public static void InsertRow( string @name, string @value ) { 
var mod = CreateForInsert();
mod.@nameColumnValue.Value = @name;
mod.@valueColumnValue.Value = @value;
mod.Execute();
}
/// <summary>
/// Inserts a row into the GlobalStrings table.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="value">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( string @name, string @value ) { 
var mod = CreateForInsert();
mod.@nameColumnValue.Value = @name;
mod.@valueColumnValue.Value = @value;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the GlobalStrings table that match the specified conditions with the specified data.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="value">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( string @name, string @value, CommandConditions.GlobalStringsTableCondition requiredCondition, params CommandConditions.GlobalStringsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@nameColumnValue.Value = @name;
mod.@valueColumnValue.Value = @value;
mod.Execute();
}
/// <summary>
/// Updates rows in the GlobalStrings table that match the specified conditions with the specified data.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="value">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( string @name, string @value, CommandConditions.GlobalStringsTableCondition requiredCondition, params CommandConditions.GlobalStringsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@nameColumnValue.Value = @name;
mod.@valueColumnValue.Value = @value;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.GlobalStringsTableCondition requiredCondition, params CommandConditions.GlobalStringsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@GlobalStringsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.GlobalStringsTableCondition requiredCondition, params CommandConditions.GlobalStringsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.GlobalStringsTableCondition> conditions ) {
var delete = new InlineDelete( "GlobalStrings" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.GlobalStringsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@GlobalStringsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.GlobalStringsTableCondition> conditions;
private readonly DataValue<string> @nameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Name column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Name { get { return @nameColumnValue.Value; } set { @nameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Name has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @NameHasChanged { get { return @nameColumnValue.Changed; } }
private readonly DataValue<string> @valueColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Value column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Value { get { return @valueColumnValue.Value; } set { @valueColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Value has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ValueHasChanged { get { return @valueColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the GlobalStrings table.
/// </summary>
public static @GlobalStringsModification CreateForInsert() {
return new @GlobalStringsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the GlobalStrings table.
/// </summary>
public static @GlobalStringsModification CreateForUpdate( CommandConditions.GlobalStringsTableCondition requiredCondition, params CommandConditions.GlobalStringsTableCondition[] additionalConditions ) {
var mod = new @GlobalStringsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@GlobalStringsTableEqualityConditions.@Name )
mod.@nameColumnValue.Value = ( condition as CommandConditions.@GlobalStringsTableEqualityConditions.@Name ).Value;
else if( condition is CommandConditions.@GlobalStringsTableEqualityConditions.@_Value )
mod.@valueColumnValue.Value = ( condition as CommandConditions.@GlobalStringsTableEqualityConditions.@_Value ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the GlobalStrings table.
/// </summary>
public static @GlobalStringsModification CreateForSingleRowUpdate( string @name, string @value ) {
var mod = new @GlobalStringsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.GlobalStringsTableCondition>();
mod.conditions.Add( new CommandConditions.@GlobalStringsTableEqualityConditions.@Name( @name ) );
mod.@nameColumnValue.Value = @name;
mod.@valueColumnValue.Value = @value;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.GlobalStringsTableCondition> getConditionList( CommandConditions.GlobalStringsTableCondition requiredCondition, params CommandConditions.GlobalStringsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.GlobalStringsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @GlobalStringsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="value">Object does not allow null.</param>
public void SetAllData( string @name, string @value ) {
this.@nameColumnValue.Value = @name;
this.@valueColumnValue.Value = @value;
}
/// <summary>
/// Executes this GlobalStrings modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this GlobalStrings modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "GlobalStrings" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.GlobalStringsTableCondition>();
conditions.Add( new CommandConditions.@GlobalStringsTableEqualityConditions.@Name( @Name ) );
}
else {
var update = new InlineUpdate( "GlobalStrings" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @nameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Name", new DbParameterValue( @Name, "VarChar" ) ) );
if( @valueColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Value", new DbParameterValue( @Value, "NVarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@nameColumnValue.ClearChanged();
@valueColumnValue.ClearChanged();
}
}
public partial class @HealthPlanModification {
/// <summary>
/// Inserts a row into the HealthPlan table. Returns the value of the HealthPlanID column.
/// </summary>
/// <param name="healthPlanName">Object does not allow null.</param>
/// <param name="visible">Object does not allow null.</param>
/// <param name="logoData">Object allows null.</param>
/// <param name="logoContentType">Object does not allow null.</param>
public static int InsertRow( string @healthPlanName, System.Boolean @visible, System.Byte[] @logoData, string @logoContentType ) { 
var mod = CreateForInsert();
mod.@healthPlanNameColumnValue.Value = @healthPlanName;
mod.@visibleColumnValue.Value = @visible;
mod.@logoDataColumnValue.Value = @logoData;
mod.@logoContentTypeColumnValue.Value = @logoContentType;
mod.Execute();
return mod.HealthPlanID;
}
/// <summary>
/// Inserts a row into the HealthPlan table. Returns the value of the HealthPlanID column.
/// </summary>
/// <param name="healthPlanName">Object does not allow null.</param>
/// <param name="visible">Object does not allow null.</param>
/// <param name="logoData">Object allows null.</param>
/// <param name="logoContentType">Object does not allow null.</param>
public static int InsertRowWithoutAdditionalLogic( string @healthPlanName, System.Boolean @visible, System.Byte[] @logoData, string @logoContentType ) { 
var mod = CreateForInsert();
mod.@healthPlanNameColumnValue.Value = @healthPlanName;
mod.@visibleColumnValue.Value = @visible;
mod.@logoDataColumnValue.Value = @logoData;
mod.@logoContentTypeColumnValue.Value = @logoContentType;
mod.ExecuteWithoutAdditionalLogic();
return mod.HealthPlanID;
}
/// <summary>
/// Updates rows in the HealthPlan table that match the specified conditions with the specified data.
/// </summary>
/// <param name="healthPlanName">Object does not allow null.</param>
/// <param name="visible">Object does not allow null.</param>
/// <param name="logoData">Object allows null.</param>
/// <param name="logoContentType">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( string @healthPlanName, System.Boolean @visible, System.Byte[] @logoData, string @logoContentType, CommandConditions.HealthPlanTableCondition requiredCondition, params CommandConditions.HealthPlanTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@healthPlanNameColumnValue.Value = @healthPlanName;
mod.@visibleColumnValue.Value = @visible;
mod.@logoDataColumnValue.Value = @logoData;
mod.@logoContentTypeColumnValue.Value = @logoContentType;
mod.Execute();
}
/// <summary>
/// Updates rows in the HealthPlan table that match the specified conditions with the specified data.
/// </summary>
/// <param name="healthPlanName">Object does not allow null.</param>
/// <param name="visible">Object does not allow null.</param>
/// <param name="logoData">Object allows null.</param>
/// <param name="logoContentType">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( string @healthPlanName, System.Boolean @visible, System.Byte[] @logoData, string @logoContentType, CommandConditions.HealthPlanTableCondition requiredCondition, params CommandConditions.HealthPlanTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@healthPlanNameColumnValue.Value = @healthPlanName;
mod.@visibleColumnValue.Value = @visible;
mod.@logoDataColumnValue.Value = @logoData;
mod.@logoContentTypeColumnValue.Value = @logoContentType;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.HealthPlanTableCondition requiredCondition, params CommandConditions.HealthPlanTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@HealthPlanTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.HealthPlanTableCondition requiredCondition, params CommandConditions.HealthPlanTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.HealthPlanTableCondition> conditions ) {
var delete = new InlineDelete( "HealthPlan" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.HealthPlanTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@HealthPlanTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.HealthPlanTableCondition> conditions;
private readonly DataValue<int> @healthPlanIDColumnValue = new DataValue<int>();
/// <summary>
/// Gets the value for the HealthPlanID column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @HealthPlanID { get { return @healthPlanIDColumnValue.Value; } }
private readonly DataValue<string> @healthPlanNameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the HealthPlanName column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @HealthPlanName { get { return @healthPlanNameColumnValue.Value; } set { @healthPlanNameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the HealthPlanName has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @HealthPlanNameHasChanged { get { return @healthPlanNameColumnValue.Changed; } }
private readonly DataValue<System.Boolean> @visibleColumnValue = new DataValue<System.Boolean>();
/// <summary>
/// Gets or sets the value for the Visible column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Boolean @Visible { get { return @visibleColumnValue.Value; } set { @visibleColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Visible has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @VisibleHasChanged { get { return @visibleColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @logoDataColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the LogoData column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.Byte[] @LogoData { get { return @logoDataColumnValue.Value; } set { @logoDataColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LogoData has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LogoDataHasChanged { get { return @logoDataColumnValue.Changed; } }
private readonly DataValue<string> @logoContentTypeColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the LogoContentType column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @LogoContentType { get { return @logoContentTypeColumnValue.Value; } set { @logoContentTypeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LogoContentType has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LogoContentTypeHasChanged { get { return @logoContentTypeColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the HealthPlan table.
/// </summary>
public static @HealthPlanModification CreateForInsert() {
return new @HealthPlanModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the HealthPlan table.
/// </summary>
public static @HealthPlanModification CreateForUpdate( CommandConditions.HealthPlanTableCondition requiredCondition, params CommandConditions.HealthPlanTableCondition[] additionalConditions ) {
var mod = new @HealthPlanModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@HealthPlanTableEqualityConditions.@HealthPlanID )
mod.@healthPlanIDColumnValue.Value = ( condition as CommandConditions.@HealthPlanTableEqualityConditions.@HealthPlanID ).Value;
else if( condition is CommandConditions.@HealthPlanTableEqualityConditions.@HealthPlanName )
mod.@healthPlanNameColumnValue.Value = ( condition as CommandConditions.@HealthPlanTableEqualityConditions.@HealthPlanName ).Value;
else if( condition is CommandConditions.@HealthPlanTableEqualityConditions.@Visible )
mod.@visibleColumnValue.Value = ( condition as CommandConditions.@HealthPlanTableEqualityConditions.@Visible ).Value;
else if( condition is CommandConditions.@HealthPlanTableEqualityConditions.@LogoData )
mod.@logoDataColumnValue.Value = ( condition as CommandConditions.@HealthPlanTableEqualityConditions.@LogoData ).Value;
else if( condition is CommandConditions.@HealthPlanTableEqualityConditions.@LogoContentType )
mod.@logoContentTypeColumnValue.Value = ( condition as CommandConditions.@HealthPlanTableEqualityConditions.@LogoContentType ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the HealthPlan table.
/// </summary>
public static @HealthPlanModification CreateForSingleRowUpdate( int @healthPlanID, string @healthPlanName, System.Boolean @visible, System.Byte[] @logoData, string @logoContentType ) {
var mod = new @HealthPlanModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.HealthPlanTableCondition>();
mod.conditions.Add( new CommandConditions.@HealthPlanTableEqualityConditions.@HealthPlanID( @healthPlanID ) );
mod.@healthPlanIDColumnValue.Value = @healthPlanID;
mod.@healthPlanNameColumnValue.Value = @healthPlanName;
mod.@visibleColumnValue.Value = @visible;
mod.@logoDataColumnValue.Value = @logoData;
mod.@logoContentTypeColumnValue.Value = @logoContentType;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.HealthPlanTableCondition> getConditionList( CommandConditions.HealthPlanTableCondition requiredCondition, params CommandConditions.HealthPlanTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.HealthPlanTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @HealthPlanModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="healthPlanName">Object does not allow null.</param>
/// <param name="visible">Object does not allow null.</param>
/// <param name="logoData">Object allows null.</param>
/// <param name="logoContentType">Object does not allow null.</param>
public void SetAllData( string @healthPlanName, System.Boolean @visible, System.Byte[] @logoData, string @logoContentType ) {
this.@healthPlanNameColumnValue.Value = @healthPlanName;
this.@visibleColumnValue.Value = @visible;
this.@logoDataColumnValue.Value = @logoData;
this.@logoContentTypeColumnValue.Value = @logoContentType;
}
/// <summary>
/// Executes this HealthPlan modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this HealthPlan modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "HealthPlan" );
addColumnModifications( insert );
@healthPlanIDColumnValue.Value = (System.Int32)Utility.ChangeType( insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection ), typeof( System.Int32 ) );
modType = ModificationType.Update;
conditions = new List<CommandConditions.HealthPlanTableCondition>();
conditions.Add( new CommandConditions.@HealthPlanTableEqualityConditions.@HealthPlanID( @HealthPlanID ) );
}
else {
var update = new InlineUpdate( "HealthPlan" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @healthPlanNameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "HealthPlanName", new DbParameterValue( @HealthPlanName, "NVarChar" ) ) );
if( @visibleColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Visible", new DbParameterValue( @Visible, "Bit" ) ) );
if( @logoDataColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LogoData", new DbParameterValue( @LogoData, "VarBinary" ) ) );
if( @logoContentTypeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LogoContentType", new DbParameterValue( @LogoContentType, "NVarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@healthPlanIDColumnValue.ClearChanged();
@healthPlanNameColumnValue.ClearChanged();
@visibleColumnValue.ClearChanged();
@logoDataColumnValue.ClearChanged();
@logoContentTypeColumnValue.ClearChanged();
}
}
public partial class @HtmlBlocksModification {
/// <summary>
/// Inserts a row into the HtmlBlocks table.
/// </summary>
/// <param name="htmlBlockId">Object does not allow null.</param>
/// <param name="html">Object does not allow null.</param>
public static void InsertRow( int @htmlBlockId, string @html ) { 
var mod = CreateForInsert();
mod.@htmlBlockIdColumnValue.Value = @htmlBlockId;
mod.@htmlColumnValue.Value = @html;
mod.Execute();
}
/// <summary>
/// Inserts a row into the HtmlBlocks table.
/// </summary>
/// <param name="htmlBlockId">Object does not allow null.</param>
/// <param name="html">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @htmlBlockId, string @html ) { 
var mod = CreateForInsert();
mod.@htmlBlockIdColumnValue.Value = @htmlBlockId;
mod.@htmlColumnValue.Value = @html;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the HtmlBlocks table that match the specified conditions with the specified data.
/// </summary>
/// <param name="htmlBlockId">Object does not allow null.</param>
/// <param name="html">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @htmlBlockId, string @html, CommandConditions.HtmlBlocksTableCondition requiredCondition, params CommandConditions.HtmlBlocksTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@htmlBlockIdColumnValue.Value = @htmlBlockId;
mod.@htmlColumnValue.Value = @html;
mod.Execute();
}
/// <summary>
/// Updates rows in the HtmlBlocks table that match the specified conditions with the specified data.
/// </summary>
/// <param name="htmlBlockId">Object does not allow null.</param>
/// <param name="html">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @htmlBlockId, string @html, CommandConditions.HtmlBlocksTableCondition requiredCondition, params CommandConditions.HtmlBlocksTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@htmlBlockIdColumnValue.Value = @htmlBlockId;
mod.@htmlColumnValue.Value = @html;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.HtmlBlocksTableCondition requiredCondition, params CommandConditions.HtmlBlocksTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@HtmlBlocksTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.HtmlBlocksTableCondition requiredCondition, params CommandConditions.HtmlBlocksTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.HtmlBlocksTableCondition> conditions ) {
var delete = new InlineDelete( "HtmlBlocks" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.HtmlBlocksTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@HtmlBlocksTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.HtmlBlocksTableCondition> conditions;
private readonly DataValue<int> @htmlBlockIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the HtmlBlockId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @HtmlBlockId { get { return @htmlBlockIdColumnValue.Value; } set { @htmlBlockIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the HtmlBlockId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @HtmlBlockIdHasChanged { get { return @htmlBlockIdColumnValue.Changed; } }
private readonly DataValue<string> @htmlColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Html column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Html { get { return @htmlColumnValue.Value; } set { @htmlColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Html has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @HtmlHasChanged { get { return @htmlColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the HtmlBlocks table.
/// </summary>
public static @HtmlBlocksModification CreateForInsert() {
return new @HtmlBlocksModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the HtmlBlocks table.
/// </summary>
public static @HtmlBlocksModification CreateForUpdate( CommandConditions.HtmlBlocksTableCondition requiredCondition, params CommandConditions.HtmlBlocksTableCondition[] additionalConditions ) {
var mod = new @HtmlBlocksModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@HtmlBlocksTableEqualityConditions.@HtmlBlockId )
mod.@htmlBlockIdColumnValue.Value = ( condition as CommandConditions.@HtmlBlocksTableEqualityConditions.@HtmlBlockId ).Value;
else if( condition is CommandConditions.@HtmlBlocksTableEqualityConditions.@Html )
mod.@htmlColumnValue.Value = ( condition as CommandConditions.@HtmlBlocksTableEqualityConditions.@Html ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the HtmlBlocks table.
/// </summary>
public static @HtmlBlocksModification CreateForSingleRowUpdate( int @htmlBlockId, string @html ) {
var mod = new @HtmlBlocksModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.HtmlBlocksTableCondition>();
mod.conditions.Add( new CommandConditions.@HtmlBlocksTableEqualityConditions.@HtmlBlockId( @htmlBlockId ) );
mod.@htmlBlockIdColumnValue.Value = @htmlBlockId;
mod.@htmlColumnValue.Value = @html;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.HtmlBlocksTableCondition> getConditionList( CommandConditions.HtmlBlocksTableCondition requiredCondition, params CommandConditions.HtmlBlocksTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.HtmlBlocksTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @HtmlBlocksModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="htmlBlockId">Object does not allow null.</param>
/// <param name="html">Object does not allow null.</param>
public void SetAllData( int @htmlBlockId, string @html ) {
this.@htmlBlockIdColumnValue.Value = @htmlBlockId;
this.@htmlColumnValue.Value = @html;
}
/// <summary>
/// Executes this HtmlBlocks modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this HtmlBlocks modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "HtmlBlocks" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.HtmlBlocksTableCondition>();
conditions.Add( new CommandConditions.@HtmlBlocksTableEqualityConditions.@HtmlBlockId( @HtmlBlockId ) );
}
else {
var update = new InlineUpdate( "HtmlBlocks" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @htmlBlockIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "HtmlBlockId", new DbParameterValue( @HtmlBlockId, "Int" ) ) );
if( @htmlColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Html", new DbParameterValue( @Html, "NVarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@htmlBlockIdColumnValue.ClearChanged();
@htmlColumnValue.ClearChanged();
}
}
public partial class @MainSequenceModification {
/// <summary>
/// Inserts a row into the MainSequence table. Returns the value of the MainSequenceId column.
/// </summary>
public static int InsertRow(  ) { 
var mod = CreateForInsert();
mod.Execute();
return mod.MainSequenceId;
}
/// <summary>
/// Inserts a row into the MainSequence table. Returns the value of the MainSequenceId column.
/// </summary>
public static int InsertRowWithoutAdditionalLogic(  ) { 
var mod = CreateForInsert();
mod.ExecuteWithoutAdditionalLogic();
return mod.MainSequenceId;
}
/// <summary>
/// Updates rows in the MainSequence table that match the specified conditions with the specified data.
/// </summary>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( CommandConditions.MainSequenceTableCondition requiredCondition, params CommandConditions.MainSequenceTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.Execute();
}
/// <summary>
/// Updates rows in the MainSequence table that match the specified conditions with the specified data.
/// </summary>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( CommandConditions.MainSequenceTableCondition requiredCondition, params CommandConditions.MainSequenceTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.MainSequenceTableCondition requiredCondition, params CommandConditions.MainSequenceTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@MainSequenceTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.MainSequenceTableCondition requiredCondition, params CommandConditions.MainSequenceTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.MainSequenceTableCondition> conditions ) {
var delete = new InlineDelete( "MainSequence" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.MainSequenceTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@MainSequenceTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.MainSequenceTableCondition> conditions;
private readonly DataValue<int> @mainSequenceIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets the value for the MainSequenceId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @MainSequenceId { get { return @mainSequenceIdColumnValue.Value; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the MainSequence table.
/// </summary>
public static @MainSequenceModification CreateForInsert() {
return new @MainSequenceModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the MainSequence table.
/// </summary>
public static @MainSequenceModification CreateForUpdate( CommandConditions.MainSequenceTableCondition requiredCondition, params CommandConditions.MainSequenceTableCondition[] additionalConditions ) {
var mod = new @MainSequenceModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@MainSequenceTableEqualityConditions.@MainSequenceId )
mod.@mainSequenceIdColumnValue.Value = ( condition as CommandConditions.@MainSequenceTableEqualityConditions.@MainSequenceId ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.MainSequenceTableCondition> getConditionList( CommandConditions.MainSequenceTableCondition requiredCondition, params CommandConditions.MainSequenceTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.MainSequenceTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @MainSequenceModification() {}
/// <summary>
/// Executes this MainSequence modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this MainSequence modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "MainSequence" );
addColumnModifications( insert );
@mainSequenceIdColumnValue.Value = (System.Int32)Utility.ChangeType( insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection ), typeof( System.Int32 ) );
modType = ModificationType.Update;
conditions = new List<CommandConditions.MainSequenceTableCondition>();
conditions.Add( new CommandConditions.@MainSequenceTableEqualityConditions.@MainSequenceId( @MainSequenceId ) );
}
else {
var update = new InlineUpdate( "MainSequence" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@mainSequenceIdColumnValue.ClearChanged();
}
}
public partial class @MaintenanceWindowDaysModification {
/// <summary>
/// Inserts a row into the MaintenanceWindowDays table.
/// </summary>
/// <param name="maintenanceWindowDayId">Object does not allow null.</param>
/// <param name="day">Object does not allow null.</param>
public static void InsertRow( int @maintenanceWindowDayId, string @day ) { 
var mod = CreateForInsert();
mod.@maintenanceWindowDayIdColumnValue.Value = @maintenanceWindowDayId;
mod.@dayColumnValue.Value = @day;
mod.Execute();
}
/// <summary>
/// Inserts a row into the MaintenanceWindowDays table.
/// </summary>
/// <param name="maintenanceWindowDayId">Object does not allow null.</param>
/// <param name="day">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @maintenanceWindowDayId, string @day ) { 
var mod = CreateForInsert();
mod.@maintenanceWindowDayIdColumnValue.Value = @maintenanceWindowDayId;
mod.@dayColumnValue.Value = @day;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the MaintenanceWindowDays table that match the specified conditions with the specified data.
/// </summary>
/// <param name="maintenanceWindowDayId">Object does not allow null.</param>
/// <param name="day">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @maintenanceWindowDayId, string @day, CommandConditions.MaintenanceWindowDaysTableCondition requiredCondition, params CommandConditions.MaintenanceWindowDaysTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@maintenanceWindowDayIdColumnValue.Value = @maintenanceWindowDayId;
mod.@dayColumnValue.Value = @day;
mod.Execute();
}
/// <summary>
/// Updates rows in the MaintenanceWindowDays table that match the specified conditions with the specified data.
/// </summary>
/// <param name="maintenanceWindowDayId">Object does not allow null.</param>
/// <param name="day">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @maintenanceWindowDayId, string @day, CommandConditions.MaintenanceWindowDaysTableCondition requiredCondition, params CommandConditions.MaintenanceWindowDaysTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@maintenanceWindowDayIdColumnValue.Value = @maintenanceWindowDayId;
mod.@dayColumnValue.Value = @day;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.MaintenanceWindowDaysTableCondition requiredCondition, params CommandConditions.MaintenanceWindowDaysTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@MaintenanceWindowDaysTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.MaintenanceWindowDaysTableCondition requiredCondition, params CommandConditions.MaintenanceWindowDaysTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.MaintenanceWindowDaysTableCondition> conditions ) {
var delete = new InlineDelete( "MaintenanceWindowDays" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.MaintenanceWindowDaysTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@MaintenanceWindowDaysTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.MaintenanceWindowDaysTableCondition> conditions;
private readonly DataValue<int> @maintenanceWindowDayIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the MaintenanceWindowDayId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @MaintenanceWindowDayId { get { return @maintenanceWindowDayIdColumnValue.Value; } set { @maintenanceWindowDayIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the MaintenanceWindowDayId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @MaintenanceWindowDayIdHasChanged { get { return @maintenanceWindowDayIdColumnValue.Changed; } }
private readonly DataValue<string> @dayColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Day column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Day { get { return @dayColumnValue.Value; } set { @dayColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Day has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @DayHasChanged { get { return @dayColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the MaintenanceWindowDays table.
/// </summary>
public static @MaintenanceWindowDaysModification CreateForInsert() {
return new @MaintenanceWindowDaysModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the MaintenanceWindowDays table.
/// </summary>
public static @MaintenanceWindowDaysModification CreateForUpdate( CommandConditions.MaintenanceWindowDaysTableCondition requiredCondition, params CommandConditions.MaintenanceWindowDaysTableCondition[] additionalConditions ) {
var mod = new @MaintenanceWindowDaysModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@MaintenanceWindowDaysTableEqualityConditions.@MaintenanceWindowDayId )
mod.@maintenanceWindowDayIdColumnValue.Value = ( condition as CommandConditions.@MaintenanceWindowDaysTableEqualityConditions.@MaintenanceWindowDayId ).Value;
else if( condition is CommandConditions.@MaintenanceWindowDaysTableEqualityConditions.@Day )
mod.@dayColumnValue.Value = ( condition as CommandConditions.@MaintenanceWindowDaysTableEqualityConditions.@Day ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the MaintenanceWindowDays table.
/// </summary>
public static @MaintenanceWindowDaysModification CreateForSingleRowUpdate( int @maintenanceWindowDayId, string @day ) {
var mod = new @MaintenanceWindowDaysModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.MaintenanceWindowDaysTableCondition>();
mod.conditions.Add( new CommandConditions.@MaintenanceWindowDaysTableEqualityConditions.@MaintenanceWindowDayId( @maintenanceWindowDayId ) );
mod.@maintenanceWindowDayIdColumnValue.Value = @maintenanceWindowDayId;
mod.@dayColumnValue.Value = @day;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.MaintenanceWindowDaysTableCondition> getConditionList( CommandConditions.MaintenanceWindowDaysTableCondition requiredCondition, params CommandConditions.MaintenanceWindowDaysTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.MaintenanceWindowDaysTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @MaintenanceWindowDaysModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="maintenanceWindowDayId">Object does not allow null.</param>
/// <param name="day">Object does not allow null.</param>
public void SetAllData( int @maintenanceWindowDayId, string @day ) {
this.@maintenanceWindowDayIdColumnValue.Value = @maintenanceWindowDayId;
this.@dayColumnValue.Value = @day;
}
/// <summary>
/// Executes this MaintenanceWindowDays modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this MaintenanceWindowDays modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "MaintenanceWindowDays" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.MaintenanceWindowDaysTableCondition>();
conditions.Add( new CommandConditions.@MaintenanceWindowDaysTableEqualityConditions.@MaintenanceWindowDayId( @MaintenanceWindowDayId ) );
}
else {
var update = new InlineUpdate( "MaintenanceWindowDays" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @maintenanceWindowDayIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "MaintenanceWindowDayId", new DbParameterValue( @MaintenanceWindowDayId, "Int" ) ) );
if( @dayColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Day", new DbParameterValue( @Day, "NVarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@maintenanceWindowDayIdColumnValue.ClearChanged();
@dayColumnValue.ClearChanged();
}
}
public partial class @MaintenanceWindowsModification {
/// <summary>
/// Inserts a row into the MaintenanceWindows table.
/// </summary>
/// <param name="maintenanceWindowId">Object does not allow null.</param>
/// <param name="enabled">Object does not allow null.</param>
/// <param name="maintenanceWindowDayId">Object does not allow null.</param>
/// <param name="startTime">Object does not allow null.</param>
/// <param name="durationHours">Object does not allow null.</param>
public static void InsertRow( int @maintenanceWindowId, System.Boolean @enabled, int @maintenanceWindowDayId, System.TimeSpan @startTime, decimal @durationHours ) { 
var mod = CreateForInsert();
mod.@maintenanceWindowIdColumnValue.Value = @maintenanceWindowId;
mod.@enabledColumnValue.Value = @enabled;
mod.@maintenanceWindowDayIdColumnValue.Value = @maintenanceWindowDayId;
mod.@startTimeColumnValue.Value = @startTime;
mod.@durationHoursColumnValue.Value = @durationHours;
mod.Execute();
}
/// <summary>
/// Inserts a row into the MaintenanceWindows table.
/// </summary>
/// <param name="maintenanceWindowId">Object does not allow null.</param>
/// <param name="enabled">Object does not allow null.</param>
/// <param name="maintenanceWindowDayId">Object does not allow null.</param>
/// <param name="startTime">Object does not allow null.</param>
/// <param name="durationHours">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @maintenanceWindowId, System.Boolean @enabled, int @maintenanceWindowDayId, System.TimeSpan @startTime, decimal @durationHours ) { 
var mod = CreateForInsert();
mod.@maintenanceWindowIdColumnValue.Value = @maintenanceWindowId;
mod.@enabledColumnValue.Value = @enabled;
mod.@maintenanceWindowDayIdColumnValue.Value = @maintenanceWindowDayId;
mod.@startTimeColumnValue.Value = @startTime;
mod.@durationHoursColumnValue.Value = @durationHours;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the MaintenanceWindows table that match the specified conditions with the specified data.
/// </summary>
/// <param name="maintenanceWindowId">Object does not allow null.</param>
/// <param name="enabled">Object does not allow null.</param>
/// <param name="maintenanceWindowDayId">Object does not allow null.</param>
/// <param name="startTime">Object does not allow null.</param>
/// <param name="durationHours">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @maintenanceWindowId, System.Boolean @enabled, int @maintenanceWindowDayId, System.TimeSpan @startTime, decimal @durationHours, CommandConditions.MaintenanceWindowsTableCondition requiredCondition, params CommandConditions.MaintenanceWindowsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@maintenanceWindowIdColumnValue.Value = @maintenanceWindowId;
mod.@enabledColumnValue.Value = @enabled;
mod.@maintenanceWindowDayIdColumnValue.Value = @maintenanceWindowDayId;
mod.@startTimeColumnValue.Value = @startTime;
mod.@durationHoursColumnValue.Value = @durationHours;
mod.Execute();
}
/// <summary>
/// Updates rows in the MaintenanceWindows table that match the specified conditions with the specified data.
/// </summary>
/// <param name="maintenanceWindowId">Object does not allow null.</param>
/// <param name="enabled">Object does not allow null.</param>
/// <param name="maintenanceWindowDayId">Object does not allow null.</param>
/// <param name="startTime">Object does not allow null.</param>
/// <param name="durationHours">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @maintenanceWindowId, System.Boolean @enabled, int @maintenanceWindowDayId, System.TimeSpan @startTime, decimal @durationHours, CommandConditions.MaintenanceWindowsTableCondition requiredCondition, params CommandConditions.MaintenanceWindowsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@maintenanceWindowIdColumnValue.Value = @maintenanceWindowId;
mod.@enabledColumnValue.Value = @enabled;
mod.@maintenanceWindowDayIdColumnValue.Value = @maintenanceWindowDayId;
mod.@startTimeColumnValue.Value = @startTime;
mod.@durationHoursColumnValue.Value = @durationHours;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.MaintenanceWindowsTableCondition requiredCondition, params CommandConditions.MaintenanceWindowsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@MaintenanceWindowsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.MaintenanceWindowsTableCondition requiredCondition, params CommandConditions.MaintenanceWindowsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.MaintenanceWindowsTableCondition> conditions ) {
var delete = new InlineDelete( "MaintenanceWindows" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.MaintenanceWindowsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@MaintenanceWindowsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.MaintenanceWindowsTableCondition> conditions;
private readonly DataValue<int> @maintenanceWindowIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the MaintenanceWindowId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @MaintenanceWindowId { get { return @maintenanceWindowIdColumnValue.Value; } set { @maintenanceWindowIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the MaintenanceWindowId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @MaintenanceWindowIdHasChanged { get { return @maintenanceWindowIdColumnValue.Changed; } }
private readonly DataValue<System.Boolean> @enabledColumnValue = new DataValue<System.Boolean>();
/// <summary>
/// Gets or sets the value for the Enabled column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Boolean @Enabled { get { return @enabledColumnValue.Value; } set { @enabledColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Enabled has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EnabledHasChanged { get { return @enabledColumnValue.Changed; } }
private readonly DataValue<int> @maintenanceWindowDayIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the MaintenanceWindowDayId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @MaintenanceWindowDayId { get { return @maintenanceWindowDayIdColumnValue.Value; } set { @maintenanceWindowDayIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the MaintenanceWindowDayId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @MaintenanceWindowDayIdHasChanged { get { return @maintenanceWindowDayIdColumnValue.Changed; } }
private readonly DataValue<System.TimeSpan> @startTimeColumnValue = new DataValue<System.TimeSpan>();
/// <summary>
/// Gets or sets the value for the StartTime column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.TimeSpan @StartTime { get { return @startTimeColumnValue.Value; } set { @startTimeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the StartTime has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @StartTimeHasChanged { get { return @startTimeColumnValue.Changed; } }
private readonly DataValue<decimal> @durationHoursColumnValue = new DataValue<decimal>();
/// <summary>
/// Gets or sets the value for the DurationHours column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public decimal @DurationHours { get { return @durationHoursColumnValue.Value; } set { @durationHoursColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the DurationHours has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @DurationHoursHasChanged { get { return @durationHoursColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the MaintenanceWindows table.
/// </summary>
public static @MaintenanceWindowsModification CreateForInsert() {
return new @MaintenanceWindowsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the MaintenanceWindows table.
/// </summary>
public static @MaintenanceWindowsModification CreateForUpdate( CommandConditions.MaintenanceWindowsTableCondition requiredCondition, params CommandConditions.MaintenanceWindowsTableCondition[] additionalConditions ) {
var mod = new @MaintenanceWindowsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@MaintenanceWindowsTableEqualityConditions.@MaintenanceWindowId )
mod.@maintenanceWindowIdColumnValue.Value = ( condition as CommandConditions.@MaintenanceWindowsTableEqualityConditions.@MaintenanceWindowId ).Value;
else if( condition is CommandConditions.@MaintenanceWindowsTableEqualityConditions.@Enabled )
mod.@enabledColumnValue.Value = ( condition as CommandConditions.@MaintenanceWindowsTableEqualityConditions.@Enabled ).Value;
else if( condition is CommandConditions.@MaintenanceWindowsTableEqualityConditions.@MaintenanceWindowDayId )
mod.@maintenanceWindowDayIdColumnValue.Value = ( condition as CommandConditions.@MaintenanceWindowsTableEqualityConditions.@MaintenanceWindowDayId ).Value;
else if( condition is CommandConditions.@MaintenanceWindowsTableEqualityConditions.@StartTime )
mod.@startTimeColumnValue.Value = ( condition as CommandConditions.@MaintenanceWindowsTableEqualityConditions.@StartTime ).Value;
else if( condition is CommandConditions.@MaintenanceWindowsTableEqualityConditions.@DurationHours )
mod.@durationHoursColumnValue.Value = ( condition as CommandConditions.@MaintenanceWindowsTableEqualityConditions.@DurationHours ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the MaintenanceWindows table.
/// </summary>
public static @MaintenanceWindowsModification CreateForSingleRowUpdate( int @maintenanceWindowId, System.Boolean @enabled, int @maintenanceWindowDayId, System.TimeSpan @startTime, decimal @durationHours ) {
var mod = new @MaintenanceWindowsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.MaintenanceWindowsTableCondition>();
mod.conditions.Add( new CommandConditions.@MaintenanceWindowsTableEqualityConditions.@MaintenanceWindowId( @maintenanceWindowId ) );
mod.@maintenanceWindowIdColumnValue.Value = @maintenanceWindowId;
mod.@enabledColumnValue.Value = @enabled;
mod.@maintenanceWindowDayIdColumnValue.Value = @maintenanceWindowDayId;
mod.@startTimeColumnValue.Value = @startTime;
mod.@durationHoursColumnValue.Value = @durationHours;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.MaintenanceWindowsTableCondition> getConditionList( CommandConditions.MaintenanceWindowsTableCondition requiredCondition, params CommandConditions.MaintenanceWindowsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.MaintenanceWindowsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @MaintenanceWindowsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="maintenanceWindowId">Object does not allow null.</param>
/// <param name="enabled">Object does not allow null.</param>
/// <param name="maintenanceWindowDayId">Object does not allow null.</param>
/// <param name="startTime">Object does not allow null.</param>
/// <param name="durationHours">Object does not allow null.</param>
public void SetAllData( int @maintenanceWindowId, System.Boolean @enabled, int @maintenanceWindowDayId, System.TimeSpan @startTime, decimal @durationHours ) {
this.@maintenanceWindowIdColumnValue.Value = @maintenanceWindowId;
this.@enabledColumnValue.Value = @enabled;
this.@maintenanceWindowDayIdColumnValue.Value = @maintenanceWindowDayId;
this.@startTimeColumnValue.Value = @startTime;
this.@durationHoursColumnValue.Value = @durationHours;
}
/// <summary>
/// Executes this MaintenanceWindows modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this MaintenanceWindows modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "MaintenanceWindows" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.MaintenanceWindowsTableCondition>();
conditions.Add( new CommandConditions.@MaintenanceWindowsTableEqualityConditions.@MaintenanceWindowId( @MaintenanceWindowId ) );
}
else {
var update = new InlineUpdate( "MaintenanceWindows" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @maintenanceWindowIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "MaintenanceWindowId", new DbParameterValue( @MaintenanceWindowId, "Int" ) ) );
if( @enabledColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Enabled", new DbParameterValue( @Enabled, "Bit" ) ) );
if( @maintenanceWindowDayIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "MaintenanceWindowDayId", new DbParameterValue( @MaintenanceWindowDayId, "Int" ) ) );
if( @startTimeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "StartTime", new DbParameterValue( @StartTime, "Time" ) ) );
if( @durationHoursColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "DurationHours", new DbParameterValue( @DurationHours, "Decimal" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@maintenanceWindowIdColumnValue.ClearChanged();
@enabledColumnValue.ClearChanged();
@maintenanceWindowDayIdColumnValue.ClearChanged();
@startTimeColumnValue.ClearChanged();
@durationHoursColumnValue.ClearChanged();
}
}
public partial class @MediaFilesModification {
/// <summary>
/// Inserts a row into the MediaFiles table.
/// </summary>
/// <param name="mediaFileId">Object does not allow null.</param>
/// <param name="fileId">Object does not allow null.</param>
/// <param name="mediaFolderId">Object does not allow null.</param>
public static void InsertRow( int @mediaFileId, int @fileId, int @mediaFolderId ) { 
var mod = CreateForInsert();
mod.@mediaFileIdColumnValue.Value = @mediaFileId;
mod.@fileIdColumnValue.Value = @fileId;
mod.@mediaFolderIdColumnValue.Value = @mediaFolderId;
mod.Execute();
}
/// <summary>
/// Inserts a row into the MediaFiles table.
/// </summary>
/// <param name="mediaFileId">Object does not allow null.</param>
/// <param name="fileId">Object does not allow null.</param>
/// <param name="mediaFolderId">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @mediaFileId, int @fileId, int @mediaFolderId ) { 
var mod = CreateForInsert();
mod.@mediaFileIdColumnValue.Value = @mediaFileId;
mod.@fileIdColumnValue.Value = @fileId;
mod.@mediaFolderIdColumnValue.Value = @mediaFolderId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the MediaFiles table that match the specified conditions with the specified data.
/// </summary>
/// <param name="mediaFileId">Object does not allow null.</param>
/// <param name="fileId">Object does not allow null.</param>
/// <param name="mediaFolderId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @mediaFileId, int @fileId, int @mediaFolderId, CommandConditions.MediaFilesTableCondition requiredCondition, params CommandConditions.MediaFilesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@mediaFileIdColumnValue.Value = @mediaFileId;
mod.@fileIdColumnValue.Value = @fileId;
mod.@mediaFolderIdColumnValue.Value = @mediaFolderId;
mod.Execute();
}
/// <summary>
/// Updates rows in the MediaFiles table that match the specified conditions with the specified data.
/// </summary>
/// <param name="mediaFileId">Object does not allow null.</param>
/// <param name="fileId">Object does not allow null.</param>
/// <param name="mediaFolderId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @mediaFileId, int @fileId, int @mediaFolderId, CommandConditions.MediaFilesTableCondition requiredCondition, params CommandConditions.MediaFilesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@mediaFileIdColumnValue.Value = @mediaFileId;
mod.@fileIdColumnValue.Value = @fileId;
mod.@mediaFolderIdColumnValue.Value = @mediaFolderId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.MediaFilesTableCondition requiredCondition, params CommandConditions.MediaFilesTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@MediaFilesTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.MediaFilesTableCondition requiredCondition, params CommandConditions.MediaFilesTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.MediaFilesTableCondition> conditions ) {
var delete = new InlineDelete( "MediaFiles" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.MediaFilesTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@MediaFilesTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.MediaFilesTableCondition> conditions;
private readonly DataValue<int> @mediaFileIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the MediaFileId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @MediaFileId { get { return @mediaFileIdColumnValue.Value; } set { @mediaFileIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the MediaFileId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @MediaFileIdHasChanged { get { return @mediaFileIdColumnValue.Changed; } }
private readonly DataValue<int> @fileIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the FileId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @FileId { get { return @fileIdColumnValue.Value; } set { @fileIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the FileId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @FileIdHasChanged { get { return @fileIdColumnValue.Changed; } }
private readonly DataValue<int> @mediaFolderIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the MediaFolderId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @MediaFolderId { get { return @mediaFolderIdColumnValue.Value; } set { @mediaFolderIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the MediaFolderId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @MediaFolderIdHasChanged { get { return @mediaFolderIdColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the MediaFiles table.
/// </summary>
public static @MediaFilesModification CreateForInsert() {
return new @MediaFilesModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the MediaFiles table.
/// </summary>
public static @MediaFilesModification CreateForUpdate( CommandConditions.MediaFilesTableCondition requiredCondition, params CommandConditions.MediaFilesTableCondition[] additionalConditions ) {
var mod = new @MediaFilesModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@MediaFilesTableEqualityConditions.@MediaFileId )
mod.@mediaFileIdColumnValue.Value = ( condition as CommandConditions.@MediaFilesTableEqualityConditions.@MediaFileId ).Value;
else if( condition is CommandConditions.@MediaFilesTableEqualityConditions.@FileId )
mod.@fileIdColumnValue.Value = ( condition as CommandConditions.@MediaFilesTableEqualityConditions.@FileId ).Value;
else if( condition is CommandConditions.@MediaFilesTableEqualityConditions.@MediaFolderId )
mod.@mediaFolderIdColumnValue.Value = ( condition as CommandConditions.@MediaFilesTableEqualityConditions.@MediaFolderId ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the MediaFiles table.
/// </summary>
public static @MediaFilesModification CreateForSingleRowUpdate( int @mediaFileId, int @fileId, int @mediaFolderId ) {
var mod = new @MediaFilesModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.MediaFilesTableCondition>();
mod.conditions.Add( new CommandConditions.@MediaFilesTableEqualityConditions.@MediaFileId( @mediaFileId ) );
mod.@mediaFileIdColumnValue.Value = @mediaFileId;
mod.@fileIdColumnValue.Value = @fileId;
mod.@mediaFolderIdColumnValue.Value = @mediaFolderId;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.MediaFilesTableCondition> getConditionList( CommandConditions.MediaFilesTableCondition requiredCondition, params CommandConditions.MediaFilesTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.MediaFilesTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @MediaFilesModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="mediaFileId">Object does not allow null.</param>
/// <param name="fileId">Object does not allow null.</param>
/// <param name="mediaFolderId">Object does not allow null.</param>
public void SetAllData( int @mediaFileId, int @fileId, int @mediaFolderId ) {
this.@mediaFileIdColumnValue.Value = @mediaFileId;
this.@fileIdColumnValue.Value = @fileId;
this.@mediaFolderIdColumnValue.Value = @mediaFolderId;
}
/// <summary>
/// Executes this MediaFiles modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this MediaFiles modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "MediaFiles" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.MediaFilesTableCondition>();
conditions.Add( new CommandConditions.@MediaFilesTableEqualityConditions.@MediaFileId( @MediaFileId ) );
}
else {
var update = new InlineUpdate( "MediaFiles" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @mediaFileIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "MediaFileId", new DbParameterValue( @MediaFileId, "Int" ) ) );
if( @fileIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "FileId", new DbParameterValue( @FileId, "Int" ) ) );
if( @mediaFolderIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "MediaFolderId", new DbParameterValue( @MediaFolderId, "Int" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@mediaFileIdColumnValue.ClearChanged();
@fileIdColumnValue.ClearChanged();
@mediaFolderIdColumnValue.ClearChanged();
}
}
public partial class @MediaFoldersModification {
/// <summary>
/// Inserts a row into the MediaFolders table.
/// </summary>
/// <param name="mediaFolderId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
public static void InsertRow( int @mediaFolderId, string @name ) { 
var mod = CreateForInsert();
mod.@mediaFolderIdColumnValue.Value = @mediaFolderId;
mod.@nameColumnValue.Value = @name;
mod.Execute();
}
/// <summary>
/// Inserts a row into the MediaFolders table.
/// </summary>
/// <param name="mediaFolderId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @mediaFolderId, string @name ) { 
var mod = CreateForInsert();
mod.@mediaFolderIdColumnValue.Value = @mediaFolderId;
mod.@nameColumnValue.Value = @name;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the MediaFolders table that match the specified conditions with the specified data.
/// </summary>
/// <param name="mediaFolderId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @mediaFolderId, string @name, CommandConditions.MediaFoldersTableCondition requiredCondition, params CommandConditions.MediaFoldersTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@mediaFolderIdColumnValue.Value = @mediaFolderId;
mod.@nameColumnValue.Value = @name;
mod.Execute();
}
/// <summary>
/// Updates rows in the MediaFolders table that match the specified conditions with the specified data.
/// </summary>
/// <param name="mediaFolderId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @mediaFolderId, string @name, CommandConditions.MediaFoldersTableCondition requiredCondition, params CommandConditions.MediaFoldersTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@mediaFolderIdColumnValue.Value = @mediaFolderId;
mod.@nameColumnValue.Value = @name;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.MediaFoldersTableCondition requiredCondition, params CommandConditions.MediaFoldersTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@MediaFoldersTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.MediaFoldersTableCondition requiredCondition, params CommandConditions.MediaFoldersTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.MediaFoldersTableCondition> conditions ) {
var delete = new InlineDelete( "MediaFolders" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.MediaFoldersTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@MediaFoldersTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.MediaFoldersTableCondition> conditions;
private readonly DataValue<int> @mediaFolderIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the MediaFolderId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @MediaFolderId { get { return @mediaFolderIdColumnValue.Value; } set { @mediaFolderIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the MediaFolderId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @MediaFolderIdHasChanged { get { return @mediaFolderIdColumnValue.Changed; } }
private readonly DataValue<string> @nameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Name column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Name { get { return @nameColumnValue.Value; } set { @nameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Name has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @NameHasChanged { get { return @nameColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the MediaFolders table.
/// </summary>
public static @MediaFoldersModification CreateForInsert() {
return new @MediaFoldersModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the MediaFolders table.
/// </summary>
public static @MediaFoldersModification CreateForUpdate( CommandConditions.MediaFoldersTableCondition requiredCondition, params CommandConditions.MediaFoldersTableCondition[] additionalConditions ) {
var mod = new @MediaFoldersModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@MediaFoldersTableEqualityConditions.@MediaFolderId )
mod.@mediaFolderIdColumnValue.Value = ( condition as CommandConditions.@MediaFoldersTableEqualityConditions.@MediaFolderId ).Value;
else if( condition is CommandConditions.@MediaFoldersTableEqualityConditions.@Name )
mod.@nameColumnValue.Value = ( condition as CommandConditions.@MediaFoldersTableEqualityConditions.@Name ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the MediaFolders table.
/// </summary>
public static @MediaFoldersModification CreateForSingleRowUpdate( int @mediaFolderId, string @name ) {
var mod = new @MediaFoldersModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.MediaFoldersTableCondition>();
mod.conditions.Add( new CommandConditions.@MediaFoldersTableEqualityConditions.@MediaFolderId( @mediaFolderId ) );
mod.@mediaFolderIdColumnValue.Value = @mediaFolderId;
mod.@nameColumnValue.Value = @name;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.MediaFoldersTableCondition> getConditionList( CommandConditions.MediaFoldersTableCondition requiredCondition, params CommandConditions.MediaFoldersTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.MediaFoldersTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @MediaFoldersModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="mediaFolderId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
public void SetAllData( int @mediaFolderId, string @name ) {
this.@mediaFolderIdColumnValue.Value = @mediaFolderId;
this.@nameColumnValue.Value = @name;
}
/// <summary>
/// Executes this MediaFolders modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this MediaFolders modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "MediaFolders" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.MediaFoldersTableCondition>();
conditions.Add( new CommandConditions.@MediaFoldersTableEqualityConditions.@MediaFolderId( @MediaFolderId ) );
}
else {
var update = new InlineUpdate( "MediaFolders" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @mediaFolderIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "MediaFolderId", new DbParameterValue( @MediaFolderId, "Int" ) ) );
if( @nameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Name", new DbParameterValue( @Name, "NVarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@mediaFolderIdColumnValue.ClearChanged();
@nameColumnValue.ClearChanged();
}
}
public partial class @NotificationModification {
/// <summary>
/// Inserts a row into the Notification table. Returns the value of the NotificationID column.
/// </summary>
/// <param name="typeName">Object does not allow null.</param>
/// <param name="fromUser">Object does not allow null.</param>
/// <param name="toUser">Object does not allow null.</param>
/// <param name="emailBody">Object does not allow null.</param>
/// <param name="emailSubject">Object does not allow null.</param>
/// <param name="success">Object does not allow null.</param>
/// <param name="created">Object does not allow null.</param>
/// <param name="failureMsg">Object does not allow null.</param>
public static int InsertRow( string @typeName, string @fromUser, string @toUser, string @emailBody, string @emailSubject, System.Boolean @success, DateTime @created, string @failureMsg ) { 
var mod = CreateForInsert();
mod.@typeNameColumnValue.Value = @typeName;
mod.@fromUserColumnValue.Value = @fromUser;
mod.@toUserColumnValue.Value = @toUser;
mod.@emailBodyColumnValue.Value = @emailBody;
mod.@emailSubjectColumnValue.Value = @emailSubject;
mod.@successColumnValue.Value = @success;
mod.@createdColumnValue.Value = @created;
mod.@failureMsgColumnValue.Value = @failureMsg;
mod.Execute();
return mod.NotificationID;
}
/// <summary>
/// Inserts a row into the Notification table. Returns the value of the NotificationID column.
/// </summary>
/// <param name="typeName">Object does not allow null.</param>
/// <param name="fromUser">Object does not allow null.</param>
/// <param name="toUser">Object does not allow null.</param>
/// <param name="emailBody">Object does not allow null.</param>
/// <param name="emailSubject">Object does not allow null.</param>
/// <param name="success">Object does not allow null.</param>
/// <param name="created">Object does not allow null.</param>
/// <param name="failureMsg">Object does not allow null.</param>
public static int InsertRowWithoutAdditionalLogic( string @typeName, string @fromUser, string @toUser, string @emailBody, string @emailSubject, System.Boolean @success, DateTime @created, string @failureMsg ) { 
var mod = CreateForInsert();
mod.@typeNameColumnValue.Value = @typeName;
mod.@fromUserColumnValue.Value = @fromUser;
mod.@toUserColumnValue.Value = @toUser;
mod.@emailBodyColumnValue.Value = @emailBody;
mod.@emailSubjectColumnValue.Value = @emailSubject;
mod.@successColumnValue.Value = @success;
mod.@createdColumnValue.Value = @created;
mod.@failureMsgColumnValue.Value = @failureMsg;
mod.ExecuteWithoutAdditionalLogic();
return mod.NotificationID;
}
/// <summary>
/// Updates rows in the Notification table that match the specified conditions with the specified data.
/// </summary>
/// <param name="typeName">Object does not allow null.</param>
/// <param name="fromUser">Object does not allow null.</param>
/// <param name="toUser">Object does not allow null.</param>
/// <param name="emailBody">Object does not allow null.</param>
/// <param name="emailSubject">Object does not allow null.</param>
/// <param name="success">Object does not allow null.</param>
/// <param name="created">Object does not allow null.</param>
/// <param name="failureMsg">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( string @typeName, string @fromUser, string @toUser, string @emailBody, string @emailSubject, System.Boolean @success, DateTime @created, string @failureMsg, CommandConditions.NotificationTableCondition requiredCondition, params CommandConditions.NotificationTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@typeNameColumnValue.Value = @typeName;
mod.@fromUserColumnValue.Value = @fromUser;
mod.@toUserColumnValue.Value = @toUser;
mod.@emailBodyColumnValue.Value = @emailBody;
mod.@emailSubjectColumnValue.Value = @emailSubject;
mod.@successColumnValue.Value = @success;
mod.@createdColumnValue.Value = @created;
mod.@failureMsgColumnValue.Value = @failureMsg;
mod.Execute();
}
/// <summary>
/// Updates rows in the Notification table that match the specified conditions with the specified data.
/// </summary>
/// <param name="typeName">Object does not allow null.</param>
/// <param name="fromUser">Object does not allow null.</param>
/// <param name="toUser">Object does not allow null.</param>
/// <param name="emailBody">Object does not allow null.</param>
/// <param name="emailSubject">Object does not allow null.</param>
/// <param name="success">Object does not allow null.</param>
/// <param name="created">Object does not allow null.</param>
/// <param name="failureMsg">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( string @typeName, string @fromUser, string @toUser, string @emailBody, string @emailSubject, System.Boolean @success, DateTime @created, string @failureMsg, CommandConditions.NotificationTableCondition requiredCondition, params CommandConditions.NotificationTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@typeNameColumnValue.Value = @typeName;
mod.@fromUserColumnValue.Value = @fromUser;
mod.@toUserColumnValue.Value = @toUser;
mod.@emailBodyColumnValue.Value = @emailBody;
mod.@emailSubjectColumnValue.Value = @emailSubject;
mod.@successColumnValue.Value = @success;
mod.@createdColumnValue.Value = @created;
mod.@failureMsgColumnValue.Value = @failureMsg;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.NotificationTableCondition requiredCondition, params CommandConditions.NotificationTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@NotificationTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.NotificationTableCondition requiredCondition, params CommandConditions.NotificationTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.NotificationTableCondition> conditions ) {
var delete = new InlineDelete( "Notification" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.NotificationTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@NotificationTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.NotificationTableCondition> conditions;
private readonly DataValue<int> @notificationIDColumnValue = new DataValue<int>();
/// <summary>
/// Gets the value for the NotificationID column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @NotificationID { get { return @notificationIDColumnValue.Value; } }
private readonly DataValue<string> @typeNameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the TypeName column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @TypeName { get { return @typeNameColumnValue.Value; } set { @typeNameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the TypeName has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @TypeNameHasChanged { get { return @typeNameColumnValue.Changed; } }
private readonly DataValue<string> @fromUserColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the FromUser column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @FromUser { get { return @fromUserColumnValue.Value; } set { @fromUserColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the FromUser has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @FromUserHasChanged { get { return @fromUserColumnValue.Changed; } }
private readonly DataValue<string> @toUserColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the ToUser column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @ToUser { get { return @toUserColumnValue.Value; } set { @toUserColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ToUser has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ToUserHasChanged { get { return @toUserColumnValue.Changed; } }
private readonly DataValue<string> @emailBodyColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the EmailBody column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @EmailBody { get { return @emailBodyColumnValue.Value; } set { @emailBodyColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EmailBody has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EmailBodyHasChanged { get { return @emailBodyColumnValue.Changed; } }
private readonly DataValue<string> @emailSubjectColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the EmailSubject column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @EmailSubject { get { return @emailSubjectColumnValue.Value; } set { @emailSubjectColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EmailSubject has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EmailSubjectHasChanged { get { return @emailSubjectColumnValue.Changed; } }
private readonly DataValue<System.Boolean> @successColumnValue = new DataValue<System.Boolean>();
/// <summary>
/// Gets or sets the value for the Success column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Boolean @Success { get { return @successColumnValue.Value; } set { @successColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Success has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @SuccessHasChanged { get { return @successColumnValue.Changed; } }
private readonly DataValue<DateTime> @createdColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the Created column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @Created { get { return @createdColumnValue.Value; } set { @createdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Created has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @CreatedHasChanged { get { return @createdColumnValue.Changed; } }
private readonly DataValue<string> @failureMsgColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the FailureMsg column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @FailureMsg { get { return @failureMsgColumnValue.Value; } set { @failureMsgColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the FailureMsg has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @FailureMsgHasChanged { get { return @failureMsgColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the Notification table.
/// </summary>
public static @NotificationModification CreateForInsert() {
return new @NotificationModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the Notification table.
/// </summary>
public static @NotificationModification CreateForUpdate( CommandConditions.NotificationTableCondition requiredCondition, params CommandConditions.NotificationTableCondition[] additionalConditions ) {
var mod = new @NotificationModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@NotificationTableEqualityConditions.@NotificationID )
mod.@notificationIDColumnValue.Value = ( condition as CommandConditions.@NotificationTableEqualityConditions.@NotificationID ).Value;
else if( condition is CommandConditions.@NotificationTableEqualityConditions.@TypeName )
mod.@typeNameColumnValue.Value = ( condition as CommandConditions.@NotificationTableEqualityConditions.@TypeName ).Value;
else if( condition is CommandConditions.@NotificationTableEqualityConditions.@FromUser )
mod.@fromUserColumnValue.Value = ( condition as CommandConditions.@NotificationTableEqualityConditions.@FromUser ).Value;
else if( condition is CommandConditions.@NotificationTableEqualityConditions.@ToUser )
mod.@toUserColumnValue.Value = ( condition as CommandConditions.@NotificationTableEqualityConditions.@ToUser ).Value;
else if( condition is CommandConditions.@NotificationTableEqualityConditions.@EmailBody )
mod.@emailBodyColumnValue.Value = ( condition as CommandConditions.@NotificationTableEqualityConditions.@EmailBody ).Value;
else if( condition is CommandConditions.@NotificationTableEqualityConditions.@EmailSubject )
mod.@emailSubjectColumnValue.Value = ( condition as CommandConditions.@NotificationTableEqualityConditions.@EmailSubject ).Value;
else if( condition is CommandConditions.@NotificationTableEqualityConditions.@Success )
mod.@successColumnValue.Value = ( condition as CommandConditions.@NotificationTableEqualityConditions.@Success ).Value;
else if( condition is CommandConditions.@NotificationTableEqualityConditions.@Created )
mod.@createdColumnValue.Value = ( condition as CommandConditions.@NotificationTableEqualityConditions.@Created ).Value;
else if( condition is CommandConditions.@NotificationTableEqualityConditions.@FailureMsg )
mod.@failureMsgColumnValue.Value = ( condition as CommandConditions.@NotificationTableEqualityConditions.@FailureMsg ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the Notification table.
/// </summary>
public static @NotificationModification CreateForSingleRowUpdate( int @notificationID, string @typeName, string @fromUser, string @toUser, string @emailBody, string @emailSubject, System.Boolean @success, DateTime @created, string @failureMsg ) {
var mod = new @NotificationModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.NotificationTableCondition>();
mod.conditions.Add( new CommandConditions.@NotificationTableEqualityConditions.@NotificationID( @notificationID ) );
mod.@notificationIDColumnValue.Value = @notificationID;
mod.@typeNameColumnValue.Value = @typeName;
mod.@fromUserColumnValue.Value = @fromUser;
mod.@toUserColumnValue.Value = @toUser;
mod.@emailBodyColumnValue.Value = @emailBody;
mod.@emailSubjectColumnValue.Value = @emailSubject;
mod.@successColumnValue.Value = @success;
mod.@createdColumnValue.Value = @created;
mod.@failureMsgColumnValue.Value = @failureMsg;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.NotificationTableCondition> getConditionList( CommandConditions.NotificationTableCondition requiredCondition, params CommandConditions.NotificationTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.NotificationTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @NotificationModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="typeName">Object does not allow null.</param>
/// <param name="fromUser">Object does not allow null.</param>
/// <param name="toUser">Object does not allow null.</param>
/// <param name="emailBody">Object does not allow null.</param>
/// <param name="emailSubject">Object does not allow null.</param>
/// <param name="success">Object does not allow null.</param>
/// <param name="created">Object does not allow null.</param>
/// <param name="failureMsg">Object does not allow null.</param>
public void SetAllData( string @typeName, string @fromUser, string @toUser, string @emailBody, string @emailSubject, System.Boolean @success, DateTime @created, string @failureMsg ) {
this.@typeNameColumnValue.Value = @typeName;
this.@fromUserColumnValue.Value = @fromUser;
this.@toUserColumnValue.Value = @toUser;
this.@emailBodyColumnValue.Value = @emailBody;
this.@emailSubjectColumnValue.Value = @emailSubject;
this.@successColumnValue.Value = @success;
this.@createdColumnValue.Value = @created;
this.@failureMsgColumnValue.Value = @failureMsg;
}
/// <summary>
/// Executes this Notification modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this Notification modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "Notification" );
addColumnModifications( insert );
@notificationIDColumnValue.Value = (System.Int32)Utility.ChangeType( insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection ), typeof( System.Int32 ) );
modType = ModificationType.Update;
conditions = new List<CommandConditions.NotificationTableCondition>();
conditions.Add( new CommandConditions.@NotificationTableEqualityConditions.@NotificationID( @NotificationID ) );
}
else {
var update = new InlineUpdate( "Notification" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @typeNameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "TypeName", new DbParameterValue( @TypeName, "NVarChar" ) ) );
if( @fromUserColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "FromUser", new DbParameterValue( @FromUser, "NVarChar" ) ) );
if( @toUserColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ToUser", new DbParameterValue( @ToUser, "NVarChar" ) ) );
if( @emailBodyColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EmailBody", new DbParameterValue( @EmailBody, "NText" ) ) );
if( @emailSubjectColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EmailSubject", new DbParameterValue( @EmailSubject, "NVarChar" ) ) );
if( @successColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Success", new DbParameterValue( @Success, "Bit" ) ) );
if( @createdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Created", new DbParameterValue( @Created, "DateTime" ) ) );
if( @failureMsgColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "FailureMsg", new DbParameterValue( @FailureMsg, "NVarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@notificationIDColumnValue.ClearChanged();
@typeNameColumnValue.ClearChanged();
@fromUserColumnValue.ClearChanged();
@toUserColumnValue.ClearChanged();
@emailBodyColumnValue.ClearChanged();
@emailSubjectColumnValue.ClearChanged();
@successColumnValue.ClearChanged();
@createdColumnValue.ClearChanged();
@failureMsgColumnValue.ClearChanged();
}
}
public partial class @NotificationParameterModification {
/// <summary>
/// Inserts a row into the NotificationParameter table. Returns the value of the ParameterID column.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="dataType">Object does not allow null.</param>
/// <param name="protocol">Object does not allow null.</param>
/// <param name="defaultValue">Object does not allow null.</param>
public static int InsertRow( string @name, string @dataType, string @protocol, string @defaultValue ) { 
var mod = CreateForInsert();
mod.@nameColumnValue.Value = @name;
mod.@dataTypeColumnValue.Value = @dataType;
mod.@protocolColumnValue.Value = @protocol;
mod.@defaultValueColumnValue.Value = @defaultValue;
mod.Execute();
return mod.ParameterID;
}
/// <summary>
/// Inserts a row into the NotificationParameter table. Returns the value of the ParameterID column.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="dataType">Object does not allow null.</param>
/// <param name="protocol">Object does not allow null.</param>
/// <param name="defaultValue">Object does not allow null.</param>
public static int InsertRowWithoutAdditionalLogic( string @name, string @dataType, string @protocol, string @defaultValue ) { 
var mod = CreateForInsert();
mod.@nameColumnValue.Value = @name;
mod.@dataTypeColumnValue.Value = @dataType;
mod.@protocolColumnValue.Value = @protocol;
mod.@defaultValueColumnValue.Value = @defaultValue;
mod.ExecuteWithoutAdditionalLogic();
return mod.ParameterID;
}
/// <summary>
/// Updates rows in the NotificationParameter table that match the specified conditions with the specified data.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="dataType">Object does not allow null.</param>
/// <param name="protocol">Object does not allow null.</param>
/// <param name="defaultValue">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( string @name, string @dataType, string @protocol, string @defaultValue, CommandConditions.NotificationParameterTableCondition requiredCondition, params CommandConditions.NotificationParameterTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@nameColumnValue.Value = @name;
mod.@dataTypeColumnValue.Value = @dataType;
mod.@protocolColumnValue.Value = @protocol;
mod.@defaultValueColumnValue.Value = @defaultValue;
mod.Execute();
}
/// <summary>
/// Updates rows in the NotificationParameter table that match the specified conditions with the specified data.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="dataType">Object does not allow null.</param>
/// <param name="protocol">Object does not allow null.</param>
/// <param name="defaultValue">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( string @name, string @dataType, string @protocol, string @defaultValue, CommandConditions.NotificationParameterTableCondition requiredCondition, params CommandConditions.NotificationParameterTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@nameColumnValue.Value = @name;
mod.@dataTypeColumnValue.Value = @dataType;
mod.@protocolColumnValue.Value = @protocol;
mod.@defaultValueColumnValue.Value = @defaultValue;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.NotificationParameterTableCondition requiredCondition, params CommandConditions.NotificationParameterTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@NotificationParameterTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.NotificationParameterTableCondition requiredCondition, params CommandConditions.NotificationParameterTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.NotificationParameterTableCondition> conditions ) {
var delete = new InlineDelete( "NotificationParameter" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.NotificationParameterTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@NotificationParameterTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.NotificationParameterTableCondition> conditions;
private readonly DataValue<int> @parameterIDColumnValue = new DataValue<int>();
/// <summary>
/// Gets the value for the ParameterID column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @ParameterID { get { return @parameterIDColumnValue.Value; } }
private readonly DataValue<string> @nameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Name column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Name { get { return @nameColumnValue.Value; } set { @nameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Name has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @NameHasChanged { get { return @nameColumnValue.Changed; } }
private readonly DataValue<string> @dataTypeColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the DataType column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @DataType { get { return @dataTypeColumnValue.Value; } set { @dataTypeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the DataType has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @DataTypeHasChanged { get { return @dataTypeColumnValue.Changed; } }
private readonly DataValue<string> @protocolColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Protocol column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Protocol { get { return @protocolColumnValue.Value; } set { @protocolColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Protocol has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ProtocolHasChanged { get { return @protocolColumnValue.Changed; } }
private readonly DataValue<string> @defaultValueColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the DefaultValue column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @DefaultValue { get { return @defaultValueColumnValue.Value; } set { @defaultValueColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the DefaultValue has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @DefaultValueHasChanged { get { return @defaultValueColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the NotificationParameter table.
/// </summary>
public static @NotificationParameterModification CreateForInsert() {
return new @NotificationParameterModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the NotificationParameter table.
/// </summary>
public static @NotificationParameterModification CreateForUpdate( CommandConditions.NotificationParameterTableCondition requiredCondition, params CommandConditions.NotificationParameterTableCondition[] additionalConditions ) {
var mod = new @NotificationParameterModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@NotificationParameterTableEqualityConditions.@ParameterID )
mod.@parameterIDColumnValue.Value = ( condition as CommandConditions.@NotificationParameterTableEqualityConditions.@ParameterID ).Value;
else if( condition is CommandConditions.@NotificationParameterTableEqualityConditions.@Name )
mod.@nameColumnValue.Value = ( condition as CommandConditions.@NotificationParameterTableEqualityConditions.@Name ).Value;
else if( condition is CommandConditions.@NotificationParameterTableEqualityConditions.@DataType )
mod.@dataTypeColumnValue.Value = ( condition as CommandConditions.@NotificationParameterTableEqualityConditions.@DataType ).Value;
else if( condition is CommandConditions.@NotificationParameterTableEqualityConditions.@Protocol )
mod.@protocolColumnValue.Value = ( condition as CommandConditions.@NotificationParameterTableEqualityConditions.@Protocol ).Value;
else if( condition is CommandConditions.@NotificationParameterTableEqualityConditions.@DefaultValue )
mod.@defaultValueColumnValue.Value = ( condition as CommandConditions.@NotificationParameterTableEqualityConditions.@DefaultValue ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the NotificationParameter table.
/// </summary>
public static @NotificationParameterModification CreateForSingleRowUpdate( int @parameterID, string @name, string @dataType, string @protocol, string @defaultValue ) {
var mod = new @NotificationParameterModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.NotificationParameterTableCondition>();
mod.conditions.Add( new CommandConditions.@NotificationParameterTableEqualityConditions.@ParameterID( @parameterID ) );
mod.@parameterIDColumnValue.Value = @parameterID;
mod.@nameColumnValue.Value = @name;
mod.@dataTypeColumnValue.Value = @dataType;
mod.@protocolColumnValue.Value = @protocol;
mod.@defaultValueColumnValue.Value = @defaultValue;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.NotificationParameterTableCondition> getConditionList( CommandConditions.NotificationParameterTableCondition requiredCondition, params CommandConditions.NotificationParameterTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.NotificationParameterTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @NotificationParameterModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="dataType">Object does not allow null.</param>
/// <param name="protocol">Object does not allow null.</param>
/// <param name="defaultValue">Object does not allow null.</param>
public void SetAllData( string @name, string @dataType, string @protocol, string @defaultValue ) {
this.@nameColumnValue.Value = @name;
this.@dataTypeColumnValue.Value = @dataType;
this.@protocolColumnValue.Value = @protocol;
this.@defaultValueColumnValue.Value = @defaultValue;
}
/// <summary>
/// Executes this NotificationParameter modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this NotificationParameter modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "NotificationParameter" );
addColumnModifications( insert );
@parameterIDColumnValue.Value = (System.Int32)Utility.ChangeType( insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection ), typeof( System.Int32 ) );
modType = ModificationType.Update;
conditions = new List<CommandConditions.NotificationParameterTableCondition>();
conditions.Add( new CommandConditions.@NotificationParameterTableEqualityConditions.@ParameterID( @ParameterID ) );
}
else {
var update = new InlineUpdate( "NotificationParameter" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @nameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Name", new DbParameterValue( @Name, "NVarChar" ) ) );
if( @dataTypeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "DataType", new DbParameterValue( @DataType, "NVarChar" ) ) );
if( @protocolColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Protocol", new DbParameterValue( @Protocol, "NChar" ) ) );
if( @defaultValueColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "DefaultValue", new DbParameterValue( @DefaultValue, "NVarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@parameterIDColumnValue.ClearChanged();
@nameColumnValue.ClearChanged();
@dataTypeColumnValue.ClearChanged();
@protocolColumnValue.ClearChanged();
@defaultValueColumnValue.ClearChanged();
}
}
public partial class @NotificationTypeModification {
/// <summary>
/// Inserts a row into the NotificationType table. Returns the value of the TypeID column.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="lastModified">Object allows null.</param>
/// <param name="created">Object allows null.</param>
/// <param name="fromCode">Object does not allow null.</param>
/// <param name="toCode">Object does not allow null.</param>
/// <param name="protocol">Object does not allow null.</param>
/// <param name="subject">Object does not allow null.</param>
/// <param name="body">Object does not allow null.</param>
/// <param name="htmlBody">Object does not allow null.</param>
public static int InsertRow( string @name, System.DateTime? @lastModified, System.DateTime? @created, string @fromCode, string @toCode, string @protocol, string @subject, string @body, System.Boolean @htmlBody ) { 
var mod = CreateForInsert();
mod.@nameColumnValue.Value = @name;
mod.@lastModifiedColumnValue.Value = @lastModified;
mod.@createdColumnValue.Value = @created;
mod.@fromCodeColumnValue.Value = @fromCode;
mod.@toCodeColumnValue.Value = @toCode;
mod.@protocolColumnValue.Value = @protocol;
mod.@subjectColumnValue.Value = @subject;
mod.@bodyColumnValue.Value = @body;
mod.@htmlBodyColumnValue.Value = @htmlBody;
mod.Execute();
return mod.TypeID;
}
/// <summary>
/// Inserts a row into the NotificationType table. Returns the value of the TypeID column.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="lastModified">Object allows null.</param>
/// <param name="created">Object allows null.</param>
/// <param name="fromCode">Object does not allow null.</param>
/// <param name="toCode">Object does not allow null.</param>
/// <param name="protocol">Object does not allow null.</param>
/// <param name="subject">Object does not allow null.</param>
/// <param name="body">Object does not allow null.</param>
/// <param name="htmlBody">Object does not allow null.</param>
public static int InsertRowWithoutAdditionalLogic( string @name, System.DateTime? @lastModified, System.DateTime? @created, string @fromCode, string @toCode, string @protocol, string @subject, string @body, System.Boolean @htmlBody ) { 
var mod = CreateForInsert();
mod.@nameColumnValue.Value = @name;
mod.@lastModifiedColumnValue.Value = @lastModified;
mod.@createdColumnValue.Value = @created;
mod.@fromCodeColumnValue.Value = @fromCode;
mod.@toCodeColumnValue.Value = @toCode;
mod.@protocolColumnValue.Value = @protocol;
mod.@subjectColumnValue.Value = @subject;
mod.@bodyColumnValue.Value = @body;
mod.@htmlBodyColumnValue.Value = @htmlBody;
mod.ExecuteWithoutAdditionalLogic();
return mod.TypeID;
}
/// <summary>
/// Updates rows in the NotificationType table that match the specified conditions with the specified data.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="lastModified">Object allows null.</param>
/// <param name="created">Object allows null.</param>
/// <param name="fromCode">Object does not allow null.</param>
/// <param name="toCode">Object does not allow null.</param>
/// <param name="protocol">Object does not allow null.</param>
/// <param name="subject">Object does not allow null.</param>
/// <param name="body">Object does not allow null.</param>
/// <param name="htmlBody">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( string @name, System.DateTime? @lastModified, System.DateTime? @created, string @fromCode, string @toCode, string @protocol, string @subject, string @body, System.Boolean @htmlBody, CommandConditions.NotificationTypeTableCondition requiredCondition, params CommandConditions.NotificationTypeTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@nameColumnValue.Value = @name;
mod.@lastModifiedColumnValue.Value = @lastModified;
mod.@createdColumnValue.Value = @created;
mod.@fromCodeColumnValue.Value = @fromCode;
mod.@toCodeColumnValue.Value = @toCode;
mod.@protocolColumnValue.Value = @protocol;
mod.@subjectColumnValue.Value = @subject;
mod.@bodyColumnValue.Value = @body;
mod.@htmlBodyColumnValue.Value = @htmlBody;
mod.Execute();
}
/// <summary>
/// Updates rows in the NotificationType table that match the specified conditions with the specified data.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="lastModified">Object allows null.</param>
/// <param name="created">Object allows null.</param>
/// <param name="fromCode">Object does not allow null.</param>
/// <param name="toCode">Object does not allow null.</param>
/// <param name="protocol">Object does not allow null.</param>
/// <param name="subject">Object does not allow null.</param>
/// <param name="body">Object does not allow null.</param>
/// <param name="htmlBody">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( string @name, System.DateTime? @lastModified, System.DateTime? @created, string @fromCode, string @toCode, string @protocol, string @subject, string @body, System.Boolean @htmlBody, CommandConditions.NotificationTypeTableCondition requiredCondition, params CommandConditions.NotificationTypeTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@nameColumnValue.Value = @name;
mod.@lastModifiedColumnValue.Value = @lastModified;
mod.@createdColumnValue.Value = @created;
mod.@fromCodeColumnValue.Value = @fromCode;
mod.@toCodeColumnValue.Value = @toCode;
mod.@protocolColumnValue.Value = @protocol;
mod.@subjectColumnValue.Value = @subject;
mod.@bodyColumnValue.Value = @body;
mod.@htmlBodyColumnValue.Value = @htmlBody;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.NotificationTypeTableCondition requiredCondition, params CommandConditions.NotificationTypeTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@NotificationTypeTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.NotificationTypeTableCondition requiredCondition, params CommandConditions.NotificationTypeTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.NotificationTypeTableCondition> conditions ) {
var delete = new InlineDelete( "NotificationType" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.NotificationTypeTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@NotificationTypeTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.NotificationTypeTableCondition> conditions;
private readonly DataValue<int> @typeIDColumnValue = new DataValue<int>();
/// <summary>
/// Gets the value for the TypeID column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @TypeID { get { return @typeIDColumnValue.Value; } }
private readonly DataValue<string> @nameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Name column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Name { get { return @nameColumnValue.Value; } set { @nameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Name has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @NameHasChanged { get { return @nameColumnValue.Changed; } }
private readonly DataValue<System.DateTime?> @lastModifiedColumnValue = new DataValue<System.DateTime?>();
/// <summary>
/// Gets or sets the value for the LastModified column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.DateTime? @LastModified { get { return @lastModifiedColumnValue.Value; } set { @lastModifiedColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LastModified has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LastModifiedHasChanged { get { return @lastModifiedColumnValue.Changed; } }
private readonly DataValue<System.DateTime?> @createdColumnValue = new DataValue<System.DateTime?>();
/// <summary>
/// Gets or sets the value for the Created column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.DateTime? @Created { get { return @createdColumnValue.Value; } set { @createdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Created has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @CreatedHasChanged { get { return @createdColumnValue.Changed; } }
private readonly DataValue<string> @fromCodeColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the FromCode column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @FromCode { get { return @fromCodeColumnValue.Value; } set { @fromCodeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the FromCode has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @FromCodeHasChanged { get { return @fromCodeColumnValue.Changed; } }
private readonly DataValue<string> @toCodeColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the ToCode column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @ToCode { get { return @toCodeColumnValue.Value; } set { @toCodeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ToCode has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ToCodeHasChanged { get { return @toCodeColumnValue.Changed; } }
private readonly DataValue<string> @protocolColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Protocol column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Protocol { get { return @protocolColumnValue.Value; } set { @protocolColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Protocol has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ProtocolHasChanged { get { return @protocolColumnValue.Changed; } }
private readonly DataValue<string> @subjectColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Subject column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Subject { get { return @subjectColumnValue.Value; } set { @subjectColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Subject has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @SubjectHasChanged { get { return @subjectColumnValue.Changed; } }
private readonly DataValue<string> @bodyColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Body column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Body { get { return @bodyColumnValue.Value; } set { @bodyColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Body has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @BodyHasChanged { get { return @bodyColumnValue.Changed; } }
private readonly DataValue<System.Boolean> @htmlBodyColumnValue = new DataValue<System.Boolean>();
/// <summary>
/// Gets or sets the value for the HtmlBody column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Boolean @HtmlBody { get { return @htmlBodyColumnValue.Value; } set { @htmlBodyColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the HtmlBody has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @HtmlBodyHasChanged { get { return @htmlBodyColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the NotificationType table.
/// </summary>
public static @NotificationTypeModification CreateForInsert() {
return new @NotificationTypeModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the NotificationType table.
/// </summary>
public static @NotificationTypeModification CreateForUpdate( CommandConditions.NotificationTypeTableCondition requiredCondition, params CommandConditions.NotificationTypeTableCondition[] additionalConditions ) {
var mod = new @NotificationTypeModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@NotificationTypeTableEqualityConditions.@TypeID )
mod.@typeIDColumnValue.Value = ( condition as CommandConditions.@NotificationTypeTableEqualityConditions.@TypeID ).Value;
else if( condition is CommandConditions.@NotificationTypeTableEqualityConditions.@Name )
mod.@nameColumnValue.Value = ( condition as CommandConditions.@NotificationTypeTableEqualityConditions.@Name ).Value;
else if( condition is CommandConditions.@NotificationTypeTableEqualityConditions.@LastModified )
mod.@lastModifiedColumnValue.Value = ( condition as CommandConditions.@NotificationTypeTableEqualityConditions.@LastModified ).Value;
else if( condition is CommandConditions.@NotificationTypeTableEqualityConditions.@Created )
mod.@createdColumnValue.Value = ( condition as CommandConditions.@NotificationTypeTableEqualityConditions.@Created ).Value;
else if( condition is CommandConditions.@NotificationTypeTableEqualityConditions.@FromCode )
mod.@fromCodeColumnValue.Value = ( condition as CommandConditions.@NotificationTypeTableEqualityConditions.@FromCode ).Value;
else if( condition is CommandConditions.@NotificationTypeTableEqualityConditions.@ToCode )
mod.@toCodeColumnValue.Value = ( condition as CommandConditions.@NotificationTypeTableEqualityConditions.@ToCode ).Value;
else if( condition is CommandConditions.@NotificationTypeTableEqualityConditions.@Protocol )
mod.@protocolColumnValue.Value = ( condition as CommandConditions.@NotificationTypeTableEqualityConditions.@Protocol ).Value;
else if( condition is CommandConditions.@NotificationTypeTableEqualityConditions.@Subject )
mod.@subjectColumnValue.Value = ( condition as CommandConditions.@NotificationTypeTableEqualityConditions.@Subject ).Value;
else if( condition is CommandConditions.@NotificationTypeTableEqualityConditions.@Body )
mod.@bodyColumnValue.Value = ( condition as CommandConditions.@NotificationTypeTableEqualityConditions.@Body ).Value;
else if( condition is CommandConditions.@NotificationTypeTableEqualityConditions.@HtmlBody )
mod.@htmlBodyColumnValue.Value = ( condition as CommandConditions.@NotificationTypeTableEqualityConditions.@HtmlBody ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the NotificationType table.
/// </summary>
public static @NotificationTypeModification CreateForSingleRowUpdate( int @typeID, string @name, System.DateTime? @lastModified, System.DateTime? @created, string @fromCode, string @toCode, string @protocol, string @subject, string @body, System.Boolean @htmlBody ) {
var mod = new @NotificationTypeModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.NotificationTypeTableCondition>();
mod.conditions.Add( new CommandConditions.@NotificationTypeTableEqualityConditions.@TypeID( @typeID ) );
mod.@typeIDColumnValue.Value = @typeID;
mod.@nameColumnValue.Value = @name;
mod.@lastModifiedColumnValue.Value = @lastModified;
mod.@createdColumnValue.Value = @created;
mod.@fromCodeColumnValue.Value = @fromCode;
mod.@toCodeColumnValue.Value = @toCode;
mod.@protocolColumnValue.Value = @protocol;
mod.@subjectColumnValue.Value = @subject;
mod.@bodyColumnValue.Value = @body;
mod.@htmlBodyColumnValue.Value = @htmlBody;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.NotificationTypeTableCondition> getConditionList( CommandConditions.NotificationTypeTableCondition requiredCondition, params CommandConditions.NotificationTypeTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.NotificationTypeTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @NotificationTypeModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="lastModified">Object allows null.</param>
/// <param name="created">Object allows null.</param>
/// <param name="fromCode">Object does not allow null.</param>
/// <param name="toCode">Object does not allow null.</param>
/// <param name="protocol">Object does not allow null.</param>
/// <param name="subject">Object does not allow null.</param>
/// <param name="body">Object does not allow null.</param>
/// <param name="htmlBody">Object does not allow null.</param>
public void SetAllData( string @name, System.DateTime? @lastModified, System.DateTime? @created, string @fromCode, string @toCode, string @protocol, string @subject, string @body, System.Boolean @htmlBody ) {
this.@nameColumnValue.Value = @name;
this.@lastModifiedColumnValue.Value = @lastModified;
this.@createdColumnValue.Value = @created;
this.@fromCodeColumnValue.Value = @fromCode;
this.@toCodeColumnValue.Value = @toCode;
this.@protocolColumnValue.Value = @protocol;
this.@subjectColumnValue.Value = @subject;
this.@bodyColumnValue.Value = @body;
this.@htmlBodyColumnValue.Value = @htmlBody;
}
/// <summary>
/// Executes this NotificationType modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this NotificationType modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "NotificationType" );
addColumnModifications( insert );
@typeIDColumnValue.Value = (System.Int32)Utility.ChangeType( insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection ), typeof( System.Int32 ) );
modType = ModificationType.Update;
conditions = new List<CommandConditions.NotificationTypeTableCondition>();
conditions.Add( new CommandConditions.@NotificationTypeTableEqualityConditions.@TypeID( @TypeID ) );
}
else {
var update = new InlineUpdate( "NotificationType" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @nameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Name", new DbParameterValue( @Name, "NVarChar" ) ) );
if( @lastModifiedColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LastModified", new DbParameterValue( @LastModified, "DateTime" ) ) );
if( @createdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Created", new DbParameterValue( @Created, "DateTime" ) ) );
if( @fromCodeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "FromCode", new DbParameterValue( @FromCode, "NVarChar" ) ) );
if( @toCodeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ToCode", new DbParameterValue( @ToCode, "NVarChar" ) ) );
if( @protocolColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Protocol", new DbParameterValue( @Protocol, "NVarChar" ) ) );
if( @subjectColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Subject", new DbParameterValue( @Subject, "NVarChar" ) ) );
if( @bodyColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Body", new DbParameterValue( @Body, "NVarChar" ) ) );
if( @htmlBodyColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "HtmlBody", new DbParameterValue( @HtmlBody, "Bit" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@typeIDColumnValue.ClearChanged();
@nameColumnValue.ClearChanged();
@lastModifiedColumnValue.ClearChanged();
@createdColumnValue.ClearChanged();
@fromCodeColumnValue.ClearChanged();
@toCodeColumnValue.ClearChanged();
@protocolColumnValue.ClearChanged();
@subjectColumnValue.ClearChanged();
@bodyColumnValue.ClearChanged();
@htmlBodyColumnValue.ClearChanged();
}
}
public partial class @OrderRanksModification {
/// <summary>
/// Inserts a row into the OrderRanks table.
/// </summary>
/// <param name="orderRankId">Object does not allow null.</param>
/// <param name="rank">Object does not allow null.</param>
public static void InsertRow( int @orderRankId, int @rank ) { 
var mod = CreateForInsert();
mod.@orderRankIdColumnValue.Value = @orderRankId;
mod.@rankColumnValue.Value = @rank;
mod.Execute();
}
/// <summary>
/// Inserts a row into the OrderRanks table.
/// </summary>
/// <param name="orderRankId">Object does not allow null.</param>
/// <param name="rank">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @orderRankId, int @rank ) { 
var mod = CreateForInsert();
mod.@orderRankIdColumnValue.Value = @orderRankId;
mod.@rankColumnValue.Value = @rank;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the OrderRanks table that match the specified conditions with the specified data.
/// </summary>
/// <param name="orderRankId">Object does not allow null.</param>
/// <param name="rank">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @orderRankId, int @rank, CommandConditions.OrderRanksTableCondition requiredCondition, params CommandConditions.OrderRanksTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@orderRankIdColumnValue.Value = @orderRankId;
mod.@rankColumnValue.Value = @rank;
mod.Execute();
}
/// <summary>
/// Updates rows in the OrderRanks table that match the specified conditions with the specified data.
/// </summary>
/// <param name="orderRankId">Object does not allow null.</param>
/// <param name="rank">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @orderRankId, int @rank, CommandConditions.OrderRanksTableCondition requiredCondition, params CommandConditions.OrderRanksTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@orderRankIdColumnValue.Value = @orderRankId;
mod.@rankColumnValue.Value = @rank;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.OrderRanksTableCondition requiredCondition, params CommandConditions.OrderRanksTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@OrderRanksTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.OrderRanksTableCondition requiredCondition, params CommandConditions.OrderRanksTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.OrderRanksTableCondition> conditions ) {
var delete = new InlineDelete( "OrderRanks" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.OrderRanksTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@OrderRanksTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.OrderRanksTableCondition> conditions;
private readonly DataValue<int> @orderRankIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the OrderRankId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @OrderRankId { get { return @orderRankIdColumnValue.Value; } set { @orderRankIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the OrderRankId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @OrderRankIdHasChanged { get { return @orderRankIdColumnValue.Changed; } }
private readonly DataValue<int> @rankColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the Rank column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @Rank { get { return @rankColumnValue.Value; } set { @rankColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Rank has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @RankHasChanged { get { return @rankColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the OrderRanks table.
/// </summary>
public static @OrderRanksModification CreateForInsert() {
return new @OrderRanksModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the OrderRanks table.
/// </summary>
public static @OrderRanksModification CreateForUpdate( CommandConditions.OrderRanksTableCondition requiredCondition, params CommandConditions.OrderRanksTableCondition[] additionalConditions ) {
var mod = new @OrderRanksModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@OrderRanksTableEqualityConditions.@OrderRankId )
mod.@orderRankIdColumnValue.Value = ( condition as CommandConditions.@OrderRanksTableEqualityConditions.@OrderRankId ).Value;
else if( condition is CommandConditions.@OrderRanksTableEqualityConditions.@Rank )
mod.@rankColumnValue.Value = ( condition as CommandConditions.@OrderRanksTableEqualityConditions.@Rank ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the OrderRanks table.
/// </summary>
public static @OrderRanksModification CreateForSingleRowUpdate( int @orderRankId, int @rank ) {
var mod = new @OrderRanksModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.OrderRanksTableCondition>();
mod.conditions.Add( new CommandConditions.@OrderRanksTableEqualityConditions.@OrderRankId( @orderRankId ) );
mod.@orderRankIdColumnValue.Value = @orderRankId;
mod.@rankColumnValue.Value = @rank;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.OrderRanksTableCondition> getConditionList( CommandConditions.OrderRanksTableCondition requiredCondition, params CommandConditions.OrderRanksTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.OrderRanksTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @OrderRanksModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="orderRankId">Object does not allow null.</param>
/// <param name="rank">Object does not allow null.</param>
public void SetAllData( int @orderRankId, int @rank ) {
this.@orderRankIdColumnValue.Value = @orderRankId;
this.@rankColumnValue.Value = @rank;
}
/// <summary>
/// Executes this OrderRanks modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this OrderRanks modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "OrderRanks" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.OrderRanksTableCondition>();
conditions.Add( new CommandConditions.@OrderRanksTableEqualityConditions.@OrderRankId( @OrderRankId ) );
}
else {
var update = new InlineUpdate( "OrderRanks" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @orderRankIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "OrderRankId", new DbParameterValue( @OrderRankId, "Int" ) ) );
if( @rankColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Rank", new DbParameterValue( @Rank, "Int" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@orderRankIdColumnValue.ClearChanged();
@rankColumnValue.ClearChanged();
}
}
public partial class @OrganizationsModification {
/// <summary>
/// Inserts a row into the Organizations table.
/// </summary>
/// <param name="organizationId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="disabledEndDate">Object allows null.</param>
public static void InsertRow( int @organizationId, string @name, System.DateTime? @disabledEndDate ) { 
var mod = CreateForInsert();
mod.@organizationIdColumnValue.Value = @organizationId;
mod.@nameColumnValue.Value = @name;
mod.@disabledEndDateColumnValue.Value = @disabledEndDate;
mod.Execute();
}
/// <summary>
/// Inserts a row into the Organizations table.
/// </summary>
/// <param name="organizationId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="disabledEndDate">Object allows null.</param>
public static void InsertRowWithoutAdditionalLogic( int @organizationId, string @name, System.DateTime? @disabledEndDate ) { 
var mod = CreateForInsert();
mod.@organizationIdColumnValue.Value = @organizationId;
mod.@nameColumnValue.Value = @name;
mod.@disabledEndDateColumnValue.Value = @disabledEndDate;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the Organizations table that match the specified conditions with the specified data.
/// </summary>
/// <param name="organizationId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="disabledEndDate">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @organizationId, string @name, System.DateTime? @disabledEndDate, CommandConditions.OrganizationsTableCondition requiredCondition, params CommandConditions.OrganizationsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@organizationIdColumnValue.Value = @organizationId;
mod.@nameColumnValue.Value = @name;
mod.@disabledEndDateColumnValue.Value = @disabledEndDate;
mod.Execute();
}
/// <summary>
/// Updates rows in the Organizations table that match the specified conditions with the specified data.
/// </summary>
/// <param name="organizationId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="disabledEndDate">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @organizationId, string @name, System.DateTime? @disabledEndDate, CommandConditions.OrganizationsTableCondition requiredCondition, params CommandConditions.OrganizationsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@organizationIdColumnValue.Value = @organizationId;
mod.@nameColumnValue.Value = @name;
mod.@disabledEndDateColumnValue.Value = @disabledEndDate;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.OrganizationsTableCondition requiredCondition, params CommandConditions.OrganizationsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@OrganizationsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.OrganizationsTableCondition requiredCondition, params CommandConditions.OrganizationsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.OrganizationsTableCondition> conditions ) {
var delete = new InlineDelete( "Organizations" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.OrganizationsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@OrganizationsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.OrganizationsTableCondition> conditions;
private readonly DataValue<int> @organizationIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the OrganizationId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @OrganizationId { get { return @organizationIdColumnValue.Value; } set { @organizationIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the OrganizationId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @OrganizationIdHasChanged { get { return @organizationIdColumnValue.Changed; } }
private readonly DataValue<string> @nameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Name column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Name { get { return @nameColumnValue.Value; } set { @nameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Name has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @NameHasChanged { get { return @nameColumnValue.Changed; } }
private readonly DataValue<System.DateTime?> @disabledEndDateColumnValue = new DataValue<System.DateTime?>();
/// <summary>
/// Gets or sets the value for the DisabledEndDate column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.DateTime? @DisabledEndDate { get { return @disabledEndDateColumnValue.Value; } set { @disabledEndDateColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the DisabledEndDate has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @DisabledEndDateHasChanged { get { return @disabledEndDateColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the Organizations table.
/// </summary>
public static @OrganizationsModification CreateForInsert() {
return new @OrganizationsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the Organizations table.
/// </summary>
public static @OrganizationsModification CreateForUpdate( CommandConditions.OrganizationsTableCondition requiredCondition, params CommandConditions.OrganizationsTableCondition[] additionalConditions ) {
var mod = new @OrganizationsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@OrganizationsTableEqualityConditions.@OrganizationId )
mod.@organizationIdColumnValue.Value = ( condition as CommandConditions.@OrganizationsTableEqualityConditions.@OrganizationId ).Value;
else if( condition is CommandConditions.@OrganizationsTableEqualityConditions.@Name )
mod.@nameColumnValue.Value = ( condition as CommandConditions.@OrganizationsTableEqualityConditions.@Name ).Value;
else if( condition is CommandConditions.@OrganizationsTableEqualityConditions.@DisabledEndDate )
mod.@disabledEndDateColumnValue.Value = ( condition as CommandConditions.@OrganizationsTableEqualityConditions.@DisabledEndDate ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the Organizations table.
/// </summary>
public static @OrganizationsModification CreateForSingleRowUpdate( int @organizationId, string @name, System.DateTime? @disabledEndDate ) {
var mod = new @OrganizationsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.OrganizationsTableCondition>();
mod.conditions.Add( new CommandConditions.@OrganizationsTableEqualityConditions.@OrganizationId( @organizationId ) );
mod.@organizationIdColumnValue.Value = @organizationId;
mod.@nameColumnValue.Value = @name;
mod.@disabledEndDateColumnValue.Value = @disabledEndDate;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.OrganizationsTableCondition> getConditionList( CommandConditions.OrganizationsTableCondition requiredCondition, params CommandConditions.OrganizationsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.OrganizationsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @OrganizationsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="organizationId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="disabledEndDate">Object allows null.</param>
public void SetAllData( int @organizationId, string @name, System.DateTime? @disabledEndDate ) {
this.@organizationIdColumnValue.Value = @organizationId;
this.@nameColumnValue.Value = @name;
this.@disabledEndDateColumnValue.Value = @disabledEndDate;
}
/// <summary>
/// Executes this Organizations modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this Organizations modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "Organizations" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.OrganizationsTableCondition>();
conditions.Add( new CommandConditions.@OrganizationsTableEqualityConditions.@OrganizationId( @OrganizationId ) );
}
else {
var update = new InlineUpdate( "Organizations" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @organizationIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "OrganizationId", new DbParameterValue( @OrganizationId, "Int" ) ) );
if( @nameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Name", new DbParameterValue( @Name, "NVarChar" ) ) );
if( @disabledEndDateColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "DisabledEndDate", new DbParameterValue( @DisabledEndDate, "Date" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@organizationIdColumnValue.ClearChanged();
@nameColumnValue.ClearChanged();
@disabledEndDateColumnValue.ClearChanged();
}
}
public partial class @PasswordResetQuestionsModification {
/// <summary>
/// Inserts a row into the PasswordResetQuestions table.
/// </summary>
/// <param name="passwordResetQuestionId">Object does not allow null.</param>
/// <param name="question">Object does not allow null.</param>
public static void InsertRow( int @passwordResetQuestionId, string @question ) { 
var mod = CreateForInsert();
mod.@passwordResetQuestionIdColumnValue.Value = @passwordResetQuestionId;
mod.@questionColumnValue.Value = @question;
mod.Execute();
}
/// <summary>
/// Inserts a row into the PasswordResetQuestions table.
/// </summary>
/// <param name="passwordResetQuestionId">Object does not allow null.</param>
/// <param name="question">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @passwordResetQuestionId, string @question ) { 
var mod = CreateForInsert();
mod.@passwordResetQuestionIdColumnValue.Value = @passwordResetQuestionId;
mod.@questionColumnValue.Value = @question;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the PasswordResetQuestions table that match the specified conditions with the specified data.
/// </summary>
/// <param name="passwordResetQuestionId">Object does not allow null.</param>
/// <param name="question">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @passwordResetQuestionId, string @question, CommandConditions.PasswordResetQuestionsTableCondition requiredCondition, params CommandConditions.PasswordResetQuestionsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@passwordResetQuestionIdColumnValue.Value = @passwordResetQuestionId;
mod.@questionColumnValue.Value = @question;
mod.Execute();
}
/// <summary>
/// Updates rows in the PasswordResetQuestions table that match the specified conditions with the specified data.
/// </summary>
/// <param name="passwordResetQuestionId">Object does not allow null.</param>
/// <param name="question">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @passwordResetQuestionId, string @question, CommandConditions.PasswordResetQuestionsTableCondition requiredCondition, params CommandConditions.PasswordResetQuestionsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@passwordResetQuestionIdColumnValue.Value = @passwordResetQuestionId;
mod.@questionColumnValue.Value = @question;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.PasswordResetQuestionsTableCondition requiredCondition, params CommandConditions.PasswordResetQuestionsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@PasswordResetQuestionsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.PasswordResetQuestionsTableCondition requiredCondition, params CommandConditions.PasswordResetQuestionsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.PasswordResetQuestionsTableCondition> conditions ) {
var delete = new InlineDelete( "PasswordResetQuestions" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.PasswordResetQuestionsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@PasswordResetQuestionsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.PasswordResetQuestionsTableCondition> conditions;
private readonly DataValue<int> @passwordResetQuestionIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the PasswordResetQuestionId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @PasswordResetQuestionId { get { return @passwordResetQuestionIdColumnValue.Value; } set { @passwordResetQuestionIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PasswordResetQuestionId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PasswordResetQuestionIdHasChanged { get { return @passwordResetQuestionIdColumnValue.Changed; } }
private readonly DataValue<string> @questionColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Question column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Question { get { return @questionColumnValue.Value; } set { @questionColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Question has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @QuestionHasChanged { get { return @questionColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the PasswordResetQuestions table.
/// </summary>
public static @PasswordResetQuestionsModification CreateForInsert() {
return new @PasswordResetQuestionsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the PasswordResetQuestions table.
/// </summary>
public static @PasswordResetQuestionsModification CreateForUpdate( CommandConditions.PasswordResetQuestionsTableCondition requiredCondition, params CommandConditions.PasswordResetQuestionsTableCondition[] additionalConditions ) {
var mod = new @PasswordResetQuestionsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@PasswordResetQuestionsTableEqualityConditions.@PasswordResetQuestionId )
mod.@passwordResetQuestionIdColumnValue.Value = ( condition as CommandConditions.@PasswordResetQuestionsTableEqualityConditions.@PasswordResetQuestionId ).Value;
else if( condition is CommandConditions.@PasswordResetQuestionsTableEqualityConditions.@Question )
mod.@questionColumnValue.Value = ( condition as CommandConditions.@PasswordResetQuestionsTableEqualityConditions.@Question ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the PasswordResetQuestions table.
/// </summary>
public static @PasswordResetQuestionsModification CreateForSingleRowUpdate( int @passwordResetQuestionId, string @question ) {
var mod = new @PasswordResetQuestionsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.PasswordResetQuestionsTableCondition>();
mod.conditions.Add( new CommandConditions.@PasswordResetQuestionsTableEqualityConditions.@PasswordResetQuestionId( @passwordResetQuestionId ) );
mod.@passwordResetQuestionIdColumnValue.Value = @passwordResetQuestionId;
mod.@questionColumnValue.Value = @question;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.PasswordResetQuestionsTableCondition> getConditionList( CommandConditions.PasswordResetQuestionsTableCondition requiredCondition, params CommandConditions.PasswordResetQuestionsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.PasswordResetQuestionsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @PasswordResetQuestionsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="passwordResetQuestionId">Object does not allow null.</param>
/// <param name="question">Object does not allow null.</param>
public void SetAllData( int @passwordResetQuestionId, string @question ) {
this.@passwordResetQuestionIdColumnValue.Value = @passwordResetQuestionId;
this.@questionColumnValue.Value = @question;
}
/// <summary>
/// Executes this PasswordResetQuestions modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this PasswordResetQuestions modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "PasswordResetQuestions" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.PasswordResetQuestionsTableCondition>();
conditions.Add( new CommandConditions.@PasswordResetQuestionsTableEqualityConditions.@PasswordResetQuestionId( @PasswordResetQuestionId ) );
}
else {
var update = new InlineUpdate( "PasswordResetQuestions" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @passwordResetQuestionIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PasswordResetQuestionId", new DbParameterValue( @PasswordResetQuestionId, "Int" ) ) );
if( @questionColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Question", new DbParameterValue( @Question, "NVarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@passwordResetQuestionIdColumnValue.ClearChanged();
@questionColumnValue.ClearChanged();
}
}
public partial class @PatientAuditRequestModification {
/// <summary>
/// Inserts a row into the PatientAuditRequest table. Returns the value of the PatientAuditID column.
/// </summary>
/// <param name="encKV">Object does not allow null.</param>
/// <param name="encIV">Object does not allow null.</param>
/// <param name="dateRequested">Object does not allow null.</param>
/// <param name="auditStatus">Object does not allow null.</param>
/// <param name="lastModifiedDate">Object does not allow null.</param>
/// <param name="lastModifiedUser">Object allows null.</param>
/// <param name="patientUserID">Object does not allow null.</param>
/// <param name="elysiumID">Object does not allow null.</param>
/// <param name="billableAmount">Object does not allow null.</param>
/// <param name="paymentConfirmed">Object allows null.</param>
public static int InsertRow( string @encKV, System.Byte[] @encIV, DateTime @dateRequested, string @auditStatus, DateTime @lastModifiedDate, System.Guid? @lastModifiedUser, System.Byte[] @patientUserID, string @elysiumID, decimal @billableAmount, System.DateTime? @paymentConfirmed ) { 
var mod = CreateForInsert();
mod.@encKVColumnValue.Value = @encKV;
mod.@encIVColumnValue.Value = @encIV;
mod.@dateRequestedColumnValue.Value = @dateRequested;
mod.@auditStatusColumnValue.Value = @auditStatus;
mod.@lastModifiedDateColumnValue.Value = @lastModifiedDate;
mod.@lastModifiedUserColumnValue.Value = @lastModifiedUser;
mod.@patientUserIDColumnValue.Value = @patientUserID;
mod.@elysiumIDColumnValue.Value = @elysiumID;
mod.@billableAmountColumnValue.Value = @billableAmount;
mod.@paymentConfirmedColumnValue.Value = @paymentConfirmed;
mod.Execute();
return mod.PatientAuditID;
}
/// <summary>
/// Inserts a row into the PatientAuditRequest table. Returns the value of the PatientAuditID column.
/// </summary>
/// <param name="encKV">Object does not allow null.</param>
/// <param name="encIV">Object does not allow null.</param>
/// <param name="dateRequested">Object does not allow null.</param>
/// <param name="auditStatus">Object does not allow null.</param>
/// <param name="lastModifiedDate">Object does not allow null.</param>
/// <param name="lastModifiedUser">Object allows null.</param>
/// <param name="patientUserID">Object does not allow null.</param>
/// <param name="elysiumID">Object does not allow null.</param>
/// <param name="billableAmount">Object does not allow null.</param>
/// <param name="paymentConfirmed">Object allows null.</param>
public static int InsertRowWithoutAdditionalLogic( string @encKV, System.Byte[] @encIV, DateTime @dateRequested, string @auditStatus, DateTime @lastModifiedDate, System.Guid? @lastModifiedUser, System.Byte[] @patientUserID, string @elysiumID, decimal @billableAmount, System.DateTime? @paymentConfirmed ) { 
var mod = CreateForInsert();
mod.@encKVColumnValue.Value = @encKV;
mod.@encIVColumnValue.Value = @encIV;
mod.@dateRequestedColumnValue.Value = @dateRequested;
mod.@auditStatusColumnValue.Value = @auditStatus;
mod.@lastModifiedDateColumnValue.Value = @lastModifiedDate;
mod.@lastModifiedUserColumnValue.Value = @lastModifiedUser;
mod.@patientUserIDColumnValue.Value = @patientUserID;
mod.@elysiumIDColumnValue.Value = @elysiumID;
mod.@billableAmountColumnValue.Value = @billableAmount;
mod.@paymentConfirmedColumnValue.Value = @paymentConfirmed;
mod.ExecuteWithoutAdditionalLogic();
return mod.PatientAuditID;
}
/// <summary>
/// Updates rows in the PatientAuditRequest table that match the specified conditions with the specified data.
/// </summary>
/// <param name="encKV">Object does not allow null.</param>
/// <param name="encIV">Object does not allow null.</param>
/// <param name="dateRequested">Object does not allow null.</param>
/// <param name="auditStatus">Object does not allow null.</param>
/// <param name="lastModifiedDate">Object does not allow null.</param>
/// <param name="lastModifiedUser">Object allows null.</param>
/// <param name="patientUserID">Object does not allow null.</param>
/// <param name="elysiumID">Object does not allow null.</param>
/// <param name="billableAmount">Object does not allow null.</param>
/// <param name="paymentConfirmed">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( string @encKV, System.Byte[] @encIV, DateTime @dateRequested, string @auditStatus, DateTime @lastModifiedDate, System.Guid? @lastModifiedUser, System.Byte[] @patientUserID, string @elysiumID, decimal @billableAmount, System.DateTime? @paymentConfirmed, CommandConditions.PatientAuditRequestTableCondition requiredCondition, params CommandConditions.PatientAuditRequestTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@encKVColumnValue.Value = @encKV;
mod.@encIVColumnValue.Value = @encIV;
mod.@dateRequestedColumnValue.Value = @dateRequested;
mod.@auditStatusColumnValue.Value = @auditStatus;
mod.@lastModifiedDateColumnValue.Value = @lastModifiedDate;
mod.@lastModifiedUserColumnValue.Value = @lastModifiedUser;
mod.@patientUserIDColumnValue.Value = @patientUserID;
mod.@elysiumIDColumnValue.Value = @elysiumID;
mod.@billableAmountColumnValue.Value = @billableAmount;
mod.@paymentConfirmedColumnValue.Value = @paymentConfirmed;
mod.Execute();
}
/// <summary>
/// Updates rows in the PatientAuditRequest table that match the specified conditions with the specified data.
/// </summary>
/// <param name="encKV">Object does not allow null.</param>
/// <param name="encIV">Object does not allow null.</param>
/// <param name="dateRequested">Object does not allow null.</param>
/// <param name="auditStatus">Object does not allow null.</param>
/// <param name="lastModifiedDate">Object does not allow null.</param>
/// <param name="lastModifiedUser">Object allows null.</param>
/// <param name="patientUserID">Object does not allow null.</param>
/// <param name="elysiumID">Object does not allow null.</param>
/// <param name="billableAmount">Object does not allow null.</param>
/// <param name="paymentConfirmed">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( string @encKV, System.Byte[] @encIV, DateTime @dateRequested, string @auditStatus, DateTime @lastModifiedDate, System.Guid? @lastModifiedUser, System.Byte[] @patientUserID, string @elysiumID, decimal @billableAmount, System.DateTime? @paymentConfirmed, CommandConditions.PatientAuditRequestTableCondition requiredCondition, params CommandConditions.PatientAuditRequestTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@encKVColumnValue.Value = @encKV;
mod.@encIVColumnValue.Value = @encIV;
mod.@dateRequestedColumnValue.Value = @dateRequested;
mod.@auditStatusColumnValue.Value = @auditStatus;
mod.@lastModifiedDateColumnValue.Value = @lastModifiedDate;
mod.@lastModifiedUserColumnValue.Value = @lastModifiedUser;
mod.@patientUserIDColumnValue.Value = @patientUserID;
mod.@elysiumIDColumnValue.Value = @elysiumID;
mod.@billableAmountColumnValue.Value = @billableAmount;
mod.@paymentConfirmedColumnValue.Value = @paymentConfirmed;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.PatientAuditRequestTableCondition requiredCondition, params CommandConditions.PatientAuditRequestTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@PatientAuditRequestTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.PatientAuditRequestTableCondition requiredCondition, params CommandConditions.PatientAuditRequestTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.PatientAuditRequestTableCondition> conditions ) {
var delete = new InlineDelete( "PatientAuditRequest" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.PatientAuditRequestTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@PatientAuditRequestTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.PatientAuditRequestTableCondition> conditions;
private readonly DataValue<int> @patientAuditIDColumnValue = new DataValue<int>();
/// <summary>
/// Gets the value for the PatientAuditID column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @PatientAuditID { get { return @patientAuditIDColumnValue.Value; } }
private readonly DataValue<string> @encKVColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the EncKV column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @EncKV { get { return @encKVColumnValue.Value; } set { @encKVColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EncKV has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EncKVHasChanged { get { return @encKVColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @encIVColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the EncIV column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @EncIV { get { return @encIVColumnValue.Value; } set { @encIVColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EncIV has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EncIVHasChanged { get { return @encIVColumnValue.Changed; } }
private readonly DataValue<DateTime> @dateRequestedColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the DateRequested column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @DateRequested { get { return @dateRequestedColumnValue.Value; } set { @dateRequestedColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the DateRequested has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @DateRequestedHasChanged { get { return @dateRequestedColumnValue.Changed; } }
private readonly DataValue<string> @auditStatusColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the AuditStatus column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @AuditStatus { get { return @auditStatusColumnValue.Value; } set { @auditStatusColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the AuditStatus has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @AuditStatusHasChanged { get { return @auditStatusColumnValue.Changed; } }
private readonly DataValue<DateTime> @lastModifiedDateColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the LastModifiedDate column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @LastModifiedDate { get { return @lastModifiedDateColumnValue.Value; } set { @lastModifiedDateColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LastModifiedDate has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LastModifiedDateHasChanged { get { return @lastModifiedDateColumnValue.Changed; } }
private readonly DataValue<System.Guid?> @lastModifiedUserColumnValue = new DataValue<System.Guid?>();
/// <summary>
/// Gets or sets the value for the LastModifiedUser column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.Guid? @LastModifiedUser { get { return @lastModifiedUserColumnValue.Value; } set { @lastModifiedUserColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LastModifiedUser has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LastModifiedUserHasChanged { get { return @lastModifiedUserColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @patientUserIDColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the PatientUserID column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @PatientUserID { get { return @patientUserIDColumnValue.Value; } set { @patientUserIDColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PatientUserID has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PatientUserIDHasChanged { get { return @patientUserIDColumnValue.Changed; } }
private readonly DataValue<string> @elysiumIDColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the ElysiumID column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @ElysiumID { get { return @elysiumIDColumnValue.Value; } set { @elysiumIDColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ElysiumID has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ElysiumIDHasChanged { get { return @elysiumIDColumnValue.Changed; } }
private readonly DataValue<decimal> @billableAmountColumnValue = new DataValue<decimal>();
/// <summary>
/// Gets or sets the value for the BillableAmount column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public decimal @BillableAmount { get { return @billableAmountColumnValue.Value; } set { @billableAmountColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the BillableAmount has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @BillableAmountHasChanged { get { return @billableAmountColumnValue.Changed; } }
private readonly DataValue<System.DateTime?> @paymentConfirmedColumnValue = new DataValue<System.DateTime?>();
/// <summary>
/// Gets or sets the value for the PaymentConfirmed column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.DateTime? @PaymentConfirmed { get { return @paymentConfirmedColumnValue.Value; } set { @paymentConfirmedColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PaymentConfirmed has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PaymentConfirmedHasChanged { get { return @paymentConfirmedColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the PatientAuditRequest table.
/// </summary>
public static @PatientAuditRequestModification CreateForInsert() {
return new @PatientAuditRequestModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the PatientAuditRequest table.
/// </summary>
public static @PatientAuditRequestModification CreateForUpdate( CommandConditions.PatientAuditRequestTableCondition requiredCondition, params CommandConditions.PatientAuditRequestTableCondition[] additionalConditions ) {
var mod = new @PatientAuditRequestModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@PatientAuditRequestTableEqualityConditions.@PatientAuditID )
mod.@patientAuditIDColumnValue.Value = ( condition as CommandConditions.@PatientAuditRequestTableEqualityConditions.@PatientAuditID ).Value;
else if( condition is CommandConditions.@PatientAuditRequestTableEqualityConditions.@EncKV )
mod.@encKVColumnValue.Value = ( condition as CommandConditions.@PatientAuditRequestTableEqualityConditions.@EncKV ).Value;
else if( condition is CommandConditions.@PatientAuditRequestTableEqualityConditions.@EncIV )
mod.@encIVColumnValue.Value = ( condition as CommandConditions.@PatientAuditRequestTableEqualityConditions.@EncIV ).Value;
else if( condition is CommandConditions.@PatientAuditRequestTableEqualityConditions.@DateRequested )
mod.@dateRequestedColumnValue.Value = ( condition as CommandConditions.@PatientAuditRequestTableEqualityConditions.@DateRequested ).Value;
else if( condition is CommandConditions.@PatientAuditRequestTableEqualityConditions.@AuditStatus )
mod.@auditStatusColumnValue.Value = ( condition as CommandConditions.@PatientAuditRequestTableEqualityConditions.@AuditStatus ).Value;
else if( condition is CommandConditions.@PatientAuditRequestTableEqualityConditions.@LastModifiedDate )
mod.@lastModifiedDateColumnValue.Value = ( condition as CommandConditions.@PatientAuditRequestTableEqualityConditions.@LastModifiedDate ).Value;
else if( condition is CommandConditions.@PatientAuditRequestTableEqualityConditions.@LastModifiedUser )
mod.@lastModifiedUserColumnValue.Value = ( condition as CommandConditions.@PatientAuditRequestTableEqualityConditions.@LastModifiedUser ).Value;
else if( condition is CommandConditions.@PatientAuditRequestTableEqualityConditions.@PatientUserID )
mod.@patientUserIDColumnValue.Value = ( condition as CommandConditions.@PatientAuditRequestTableEqualityConditions.@PatientUserID ).Value;
else if( condition is CommandConditions.@PatientAuditRequestTableEqualityConditions.@ElysiumID )
mod.@elysiumIDColumnValue.Value = ( condition as CommandConditions.@PatientAuditRequestTableEqualityConditions.@ElysiumID ).Value;
else if( condition is CommandConditions.@PatientAuditRequestTableEqualityConditions.@BillableAmount )
mod.@billableAmountColumnValue.Value = ( condition as CommandConditions.@PatientAuditRequestTableEqualityConditions.@BillableAmount ).Value;
else if( condition is CommandConditions.@PatientAuditRequestTableEqualityConditions.@PaymentConfirmed )
mod.@paymentConfirmedColumnValue.Value = ( condition as CommandConditions.@PatientAuditRequestTableEqualityConditions.@PaymentConfirmed ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the PatientAuditRequest table.
/// </summary>
public static @PatientAuditRequestModification CreateForSingleRowUpdate( int @patientAuditID, string @encKV, System.Byte[] @encIV, DateTime @dateRequested, string @auditStatus, DateTime @lastModifiedDate, System.Guid? @lastModifiedUser, System.Byte[] @patientUserID, string @elysiumID, decimal @billableAmount, System.DateTime? @paymentConfirmed ) {
var mod = new @PatientAuditRequestModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.PatientAuditRequestTableCondition>();
mod.conditions.Add( new CommandConditions.@PatientAuditRequestTableEqualityConditions.@PatientAuditID( @patientAuditID ) );
mod.@patientAuditIDColumnValue.Value = @patientAuditID;
mod.@encKVColumnValue.Value = @encKV;
mod.@encIVColumnValue.Value = @encIV;
mod.@dateRequestedColumnValue.Value = @dateRequested;
mod.@auditStatusColumnValue.Value = @auditStatus;
mod.@lastModifiedDateColumnValue.Value = @lastModifiedDate;
mod.@lastModifiedUserColumnValue.Value = @lastModifiedUser;
mod.@patientUserIDColumnValue.Value = @patientUserID;
mod.@elysiumIDColumnValue.Value = @elysiumID;
mod.@billableAmountColumnValue.Value = @billableAmount;
mod.@paymentConfirmedColumnValue.Value = @paymentConfirmed;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.PatientAuditRequestTableCondition> getConditionList( CommandConditions.PatientAuditRequestTableCondition requiredCondition, params CommandConditions.PatientAuditRequestTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.PatientAuditRequestTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @PatientAuditRequestModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="encKV">Object does not allow null.</param>
/// <param name="encIV">Object does not allow null.</param>
/// <param name="dateRequested">Object does not allow null.</param>
/// <param name="auditStatus">Object does not allow null.</param>
/// <param name="lastModifiedDate">Object does not allow null.</param>
/// <param name="lastModifiedUser">Object allows null.</param>
/// <param name="patientUserID">Object does not allow null.</param>
/// <param name="elysiumID">Object does not allow null.</param>
/// <param name="billableAmount">Object does not allow null.</param>
/// <param name="paymentConfirmed">Object allows null.</param>
public void SetAllData( string @encKV, System.Byte[] @encIV, DateTime @dateRequested, string @auditStatus, DateTime @lastModifiedDate, System.Guid? @lastModifiedUser, System.Byte[] @patientUserID, string @elysiumID, decimal @billableAmount, System.DateTime? @paymentConfirmed ) {
this.@encKVColumnValue.Value = @encKV;
this.@encIVColumnValue.Value = @encIV;
this.@dateRequestedColumnValue.Value = @dateRequested;
this.@auditStatusColumnValue.Value = @auditStatus;
this.@lastModifiedDateColumnValue.Value = @lastModifiedDate;
this.@lastModifiedUserColumnValue.Value = @lastModifiedUser;
this.@patientUserIDColumnValue.Value = @patientUserID;
this.@elysiumIDColumnValue.Value = @elysiumID;
this.@billableAmountColumnValue.Value = @billableAmount;
this.@paymentConfirmedColumnValue.Value = @paymentConfirmed;
}
/// <summary>
/// Executes this PatientAuditRequest modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this PatientAuditRequest modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "PatientAuditRequest" );
addColumnModifications( insert );
@patientAuditIDColumnValue.Value = (System.Int32)Utility.ChangeType( insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection ), typeof( System.Int32 ) );
modType = ModificationType.Update;
conditions = new List<CommandConditions.PatientAuditRequestTableCondition>();
conditions.Add( new CommandConditions.@PatientAuditRequestTableEqualityConditions.@PatientAuditID( @PatientAuditID ) );
}
else {
var update = new InlineUpdate( "PatientAuditRequest" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @encKVColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EncKV", new DbParameterValue( @EncKV, "NVarChar" ) ) );
if( @encIVColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EncIV", new DbParameterValue( @EncIV, "VarBinary" ) ) );
if( @dateRequestedColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "DateRequested", new DbParameterValue( @DateRequested, "DateTime" ) ) );
if( @auditStatusColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "AuditStatus", new DbParameterValue( @AuditStatus, "NVarChar" ) ) );
if( @lastModifiedDateColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LastModifiedDate", new DbParameterValue( @LastModifiedDate, "DateTime" ) ) );
if( @lastModifiedUserColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LastModifiedUser", new DbParameterValue( @LastModifiedUser, "UniqueIdentifier" ) ) );
if( @patientUserIDColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PatientUserID", new DbParameterValue( @PatientUserID, "VarBinary" ) ) );
if( @elysiumIDColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ElysiumID", new DbParameterValue( @ElysiumID, "NVarChar" ) ) );
if( @billableAmountColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "BillableAmount", new DbParameterValue( @BillableAmount, "Decimal" ) ) );
if( @paymentConfirmedColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PaymentConfirmed", new DbParameterValue( @PaymentConfirmed, "DateTime" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@patientAuditIDColumnValue.ClearChanged();
@encKVColumnValue.ClearChanged();
@encIVColumnValue.ClearChanged();
@dateRequestedColumnValue.ClearChanged();
@auditStatusColumnValue.ClearChanged();
@lastModifiedDateColumnValue.ClearChanged();
@lastModifiedUserColumnValue.ClearChanged();
@patientUserIDColumnValue.ClearChanged();
@elysiumIDColumnValue.ClearChanged();
@billableAmountColumnValue.ClearChanged();
@paymentConfirmedColumnValue.ClearChanged();
}
}
public partial class @PatientConsentServiceCacheModification {
/// <summary>
/// Inserts a row into the PatientConsentServiceCache table.
/// </summary>
/// <param name="patientConsentServiceCacheId">Object does not allow null.</param>
/// <param name="iv">Object does not allow null.</param>
/// <param name="patientConsentServiceCacheDateId">Object does not allow null.</param>
/// <param name="workgroupId">Object does not allow null.</param>
/// <param name="consentTypeId">Object does not allow null.</param>
public static void InsertRow( int @patientConsentServiceCacheId, System.Byte[] @iv, int @patientConsentServiceCacheDateId, System.Byte[] @workgroupId, System.Byte[] @consentTypeId ) { 
var mod = CreateForInsert();
mod.@patientConsentServiceCacheIdColumnValue.Value = @patientConsentServiceCacheId;
mod.@ivColumnValue.Value = @iv;
mod.@patientConsentServiceCacheDateIdColumnValue.Value = @patientConsentServiceCacheDateId;
mod.@workgroupIdColumnValue.Value = @workgroupId;
mod.@consentTypeIdColumnValue.Value = @consentTypeId;
mod.Execute();
}
/// <summary>
/// Inserts a row into the PatientConsentServiceCache table.
/// </summary>
/// <param name="patientConsentServiceCacheId">Object does not allow null.</param>
/// <param name="iv">Object does not allow null.</param>
/// <param name="patientConsentServiceCacheDateId">Object does not allow null.</param>
/// <param name="workgroupId">Object does not allow null.</param>
/// <param name="consentTypeId">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @patientConsentServiceCacheId, System.Byte[] @iv, int @patientConsentServiceCacheDateId, System.Byte[] @workgroupId, System.Byte[] @consentTypeId ) { 
var mod = CreateForInsert();
mod.@patientConsentServiceCacheIdColumnValue.Value = @patientConsentServiceCacheId;
mod.@ivColumnValue.Value = @iv;
mod.@patientConsentServiceCacheDateIdColumnValue.Value = @patientConsentServiceCacheDateId;
mod.@workgroupIdColumnValue.Value = @workgroupId;
mod.@consentTypeIdColumnValue.Value = @consentTypeId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the PatientConsentServiceCache table that match the specified conditions with the specified data.
/// </summary>
/// <param name="patientConsentServiceCacheId">Object does not allow null.</param>
/// <param name="iv">Object does not allow null.</param>
/// <param name="patientConsentServiceCacheDateId">Object does not allow null.</param>
/// <param name="workgroupId">Object does not allow null.</param>
/// <param name="consentTypeId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @patientConsentServiceCacheId, System.Byte[] @iv, int @patientConsentServiceCacheDateId, System.Byte[] @workgroupId, System.Byte[] @consentTypeId, CommandConditions.PatientConsentServiceCacheTableCondition requiredCondition, params CommandConditions.PatientConsentServiceCacheTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@patientConsentServiceCacheIdColumnValue.Value = @patientConsentServiceCacheId;
mod.@ivColumnValue.Value = @iv;
mod.@patientConsentServiceCacheDateIdColumnValue.Value = @patientConsentServiceCacheDateId;
mod.@workgroupIdColumnValue.Value = @workgroupId;
mod.@consentTypeIdColumnValue.Value = @consentTypeId;
mod.Execute();
}
/// <summary>
/// Updates rows in the PatientConsentServiceCache table that match the specified conditions with the specified data.
/// </summary>
/// <param name="patientConsentServiceCacheId">Object does not allow null.</param>
/// <param name="iv">Object does not allow null.</param>
/// <param name="patientConsentServiceCacheDateId">Object does not allow null.</param>
/// <param name="workgroupId">Object does not allow null.</param>
/// <param name="consentTypeId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @patientConsentServiceCacheId, System.Byte[] @iv, int @patientConsentServiceCacheDateId, System.Byte[] @workgroupId, System.Byte[] @consentTypeId, CommandConditions.PatientConsentServiceCacheTableCondition requiredCondition, params CommandConditions.PatientConsentServiceCacheTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@patientConsentServiceCacheIdColumnValue.Value = @patientConsentServiceCacheId;
mod.@ivColumnValue.Value = @iv;
mod.@patientConsentServiceCacheDateIdColumnValue.Value = @patientConsentServiceCacheDateId;
mod.@workgroupIdColumnValue.Value = @workgroupId;
mod.@consentTypeIdColumnValue.Value = @consentTypeId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.PatientConsentServiceCacheTableCondition requiredCondition, params CommandConditions.PatientConsentServiceCacheTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@PatientConsentServiceCacheTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.PatientConsentServiceCacheTableCondition requiredCondition, params CommandConditions.PatientConsentServiceCacheTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.PatientConsentServiceCacheTableCondition> conditions ) {
var delete = new InlineDelete( "PatientConsentServiceCache" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.PatientConsentServiceCacheTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@PatientConsentServiceCacheTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.PatientConsentServiceCacheTableCondition> conditions;
private readonly DataValue<int> @patientConsentServiceCacheIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the PatientConsentServiceCacheId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @PatientConsentServiceCacheId { get { return @patientConsentServiceCacheIdColumnValue.Value; } set { @patientConsentServiceCacheIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PatientConsentServiceCacheId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PatientConsentServiceCacheIdHasChanged { get { return @patientConsentServiceCacheIdColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @ivColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the Iv column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @Iv { get { return @ivColumnValue.Value; } set { @ivColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Iv has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @IvHasChanged { get { return @ivColumnValue.Changed; } }
private readonly DataValue<int> @patientConsentServiceCacheDateIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the PatientConsentServiceCacheDateId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @PatientConsentServiceCacheDateId { get { return @patientConsentServiceCacheDateIdColumnValue.Value; } set { @patientConsentServiceCacheDateIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PatientConsentServiceCacheDateId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PatientConsentServiceCacheDateIdHasChanged { get { return @patientConsentServiceCacheDateIdColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @workgroupIdColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the WorkgroupId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @WorkgroupId { get { return @workgroupIdColumnValue.Value; } set { @workgroupIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the WorkgroupId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @WorkgroupIdHasChanged { get { return @workgroupIdColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @consentTypeIdColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the ConsentTypeId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @ConsentTypeId { get { return @consentTypeIdColumnValue.Value; } set { @consentTypeIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ConsentTypeId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ConsentTypeIdHasChanged { get { return @consentTypeIdColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the PatientConsentServiceCache table.
/// </summary>
public static @PatientConsentServiceCacheModification CreateForInsert() {
return new @PatientConsentServiceCacheModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the PatientConsentServiceCache table.
/// </summary>
public static @PatientConsentServiceCacheModification CreateForUpdate( CommandConditions.PatientConsentServiceCacheTableCondition requiredCondition, params CommandConditions.PatientConsentServiceCacheTableCondition[] additionalConditions ) {
var mod = new @PatientConsentServiceCacheModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@PatientConsentServiceCacheTableEqualityConditions.@PatientConsentServiceCacheId )
mod.@patientConsentServiceCacheIdColumnValue.Value = ( condition as CommandConditions.@PatientConsentServiceCacheTableEqualityConditions.@PatientConsentServiceCacheId ).Value;
else if( condition is CommandConditions.@PatientConsentServiceCacheTableEqualityConditions.@Iv )
mod.@ivColumnValue.Value = ( condition as CommandConditions.@PatientConsentServiceCacheTableEqualityConditions.@Iv ).Value;
else if( condition is CommandConditions.@PatientConsentServiceCacheTableEqualityConditions.@PatientConsentServiceCacheDateId )
mod.@patientConsentServiceCacheDateIdColumnValue.Value = ( condition as CommandConditions.@PatientConsentServiceCacheTableEqualityConditions.@PatientConsentServiceCacheDateId ).Value;
else if( condition is CommandConditions.@PatientConsentServiceCacheTableEqualityConditions.@WorkgroupId )
mod.@workgroupIdColumnValue.Value = ( condition as CommandConditions.@PatientConsentServiceCacheTableEqualityConditions.@WorkgroupId ).Value;
else if( condition is CommandConditions.@PatientConsentServiceCacheTableEqualityConditions.@ConsentTypeId )
mod.@consentTypeIdColumnValue.Value = ( condition as CommandConditions.@PatientConsentServiceCacheTableEqualityConditions.@ConsentTypeId ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the PatientConsentServiceCache table.
/// </summary>
public static @PatientConsentServiceCacheModification CreateForSingleRowUpdate( int @patientConsentServiceCacheId, System.Byte[] @iv, int @patientConsentServiceCacheDateId, System.Byte[] @workgroupId, System.Byte[] @consentTypeId ) {
var mod = new @PatientConsentServiceCacheModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.PatientConsentServiceCacheTableCondition>();
mod.conditions.Add( new CommandConditions.@PatientConsentServiceCacheTableEqualityConditions.@PatientConsentServiceCacheId( @patientConsentServiceCacheId ) );
mod.@patientConsentServiceCacheIdColumnValue.Value = @patientConsentServiceCacheId;
mod.@ivColumnValue.Value = @iv;
mod.@patientConsentServiceCacheDateIdColumnValue.Value = @patientConsentServiceCacheDateId;
mod.@workgroupIdColumnValue.Value = @workgroupId;
mod.@consentTypeIdColumnValue.Value = @consentTypeId;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.PatientConsentServiceCacheTableCondition> getConditionList( CommandConditions.PatientConsentServiceCacheTableCondition requiredCondition, params CommandConditions.PatientConsentServiceCacheTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.PatientConsentServiceCacheTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @PatientConsentServiceCacheModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="patientConsentServiceCacheId">Object does not allow null.</param>
/// <param name="iv">Object does not allow null.</param>
/// <param name="patientConsentServiceCacheDateId">Object does not allow null.</param>
/// <param name="workgroupId">Object does not allow null.</param>
/// <param name="consentTypeId">Object does not allow null.</param>
public void SetAllData( int @patientConsentServiceCacheId, System.Byte[] @iv, int @patientConsentServiceCacheDateId, System.Byte[] @workgroupId, System.Byte[] @consentTypeId ) {
this.@patientConsentServiceCacheIdColumnValue.Value = @patientConsentServiceCacheId;
this.@ivColumnValue.Value = @iv;
this.@patientConsentServiceCacheDateIdColumnValue.Value = @patientConsentServiceCacheDateId;
this.@workgroupIdColumnValue.Value = @workgroupId;
this.@consentTypeIdColumnValue.Value = @consentTypeId;
}
/// <summary>
/// Executes this PatientConsentServiceCache modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this PatientConsentServiceCache modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "PatientConsentServiceCache" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.PatientConsentServiceCacheTableCondition>();
conditions.Add( new CommandConditions.@PatientConsentServiceCacheTableEqualityConditions.@PatientConsentServiceCacheId( @PatientConsentServiceCacheId ) );
}
else {
var update = new InlineUpdate( "PatientConsentServiceCache" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @patientConsentServiceCacheIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PatientConsentServiceCacheId", new DbParameterValue( @PatientConsentServiceCacheId, "Int" ) ) );
if( @ivColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Iv", new DbParameterValue( @Iv, "Binary" ) ) );
if( @patientConsentServiceCacheDateIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PatientConsentServiceCacheDateId", new DbParameterValue( @PatientConsentServiceCacheDateId, "Int" ) ) );
if( @workgroupIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "WorkgroupId", new DbParameterValue( @WorkgroupId, "Binary" ) ) );
if( @consentTypeIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ConsentTypeId", new DbParameterValue( @ConsentTypeId, "Binary" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@patientConsentServiceCacheIdColumnValue.ClearChanged();
@ivColumnValue.ClearChanged();
@patientConsentServiceCacheDateIdColumnValue.ClearChanged();
@workgroupIdColumnValue.ClearChanged();
@consentTypeIdColumnValue.ClearChanged();
}
}
public partial class @PatientConsentServiceCacheDatesModification {
/// <summary>
/// Inserts a row into the PatientConsentServiceCacheDates table.
/// </summary>
/// <param name="patientConsentServiceCacheDateId">Object does not allow null.</param>
/// <param name="elysiumId">Object does not allow null.</param>
/// <param name="lastRequestedDate">Object allows null.</param>
/// <param name="goodfor">Object allows null.</param>
public static void InsertRow( int @patientConsentServiceCacheDateId, string @elysiumId, System.DateTime? @lastRequestedDate, System.DateTime? @goodfor ) { 
var mod = CreateForInsert();
mod.@patientConsentServiceCacheDateIdColumnValue.Value = @patientConsentServiceCacheDateId;
mod.@elysiumIdColumnValue.Value = @elysiumId;
mod.@lastRequestedDateColumnValue.Value = @lastRequestedDate;
mod.@goodforColumnValue.Value = @goodfor;
mod.Execute();
}
/// <summary>
/// Inserts a row into the PatientConsentServiceCacheDates table.
/// </summary>
/// <param name="patientConsentServiceCacheDateId">Object does not allow null.</param>
/// <param name="elysiumId">Object does not allow null.</param>
/// <param name="lastRequestedDate">Object allows null.</param>
/// <param name="goodfor">Object allows null.</param>
public static void InsertRowWithoutAdditionalLogic( int @patientConsentServiceCacheDateId, string @elysiumId, System.DateTime? @lastRequestedDate, System.DateTime? @goodfor ) { 
var mod = CreateForInsert();
mod.@patientConsentServiceCacheDateIdColumnValue.Value = @patientConsentServiceCacheDateId;
mod.@elysiumIdColumnValue.Value = @elysiumId;
mod.@lastRequestedDateColumnValue.Value = @lastRequestedDate;
mod.@goodforColumnValue.Value = @goodfor;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the PatientConsentServiceCacheDates table that match the specified conditions with the specified data.
/// </summary>
/// <param name="patientConsentServiceCacheDateId">Object does not allow null.</param>
/// <param name="elysiumId">Object does not allow null.</param>
/// <param name="lastRequestedDate">Object allows null.</param>
/// <param name="goodfor">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @patientConsentServiceCacheDateId, string @elysiumId, System.DateTime? @lastRequestedDate, System.DateTime? @goodfor, CommandConditions.PatientConsentServiceCacheDatesTableCondition requiredCondition, params CommandConditions.PatientConsentServiceCacheDatesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@patientConsentServiceCacheDateIdColumnValue.Value = @patientConsentServiceCacheDateId;
mod.@elysiumIdColumnValue.Value = @elysiumId;
mod.@lastRequestedDateColumnValue.Value = @lastRequestedDate;
mod.@goodforColumnValue.Value = @goodfor;
mod.Execute();
}
/// <summary>
/// Updates rows in the PatientConsentServiceCacheDates table that match the specified conditions with the specified data.
/// </summary>
/// <param name="patientConsentServiceCacheDateId">Object does not allow null.</param>
/// <param name="elysiumId">Object does not allow null.</param>
/// <param name="lastRequestedDate">Object allows null.</param>
/// <param name="goodfor">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @patientConsentServiceCacheDateId, string @elysiumId, System.DateTime? @lastRequestedDate, System.DateTime? @goodfor, CommandConditions.PatientConsentServiceCacheDatesTableCondition requiredCondition, params CommandConditions.PatientConsentServiceCacheDatesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@patientConsentServiceCacheDateIdColumnValue.Value = @patientConsentServiceCacheDateId;
mod.@elysiumIdColumnValue.Value = @elysiumId;
mod.@lastRequestedDateColumnValue.Value = @lastRequestedDate;
mod.@goodforColumnValue.Value = @goodfor;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.PatientConsentServiceCacheDatesTableCondition requiredCondition, params CommandConditions.PatientConsentServiceCacheDatesTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@PatientConsentServiceCacheDatesTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.PatientConsentServiceCacheDatesTableCondition requiredCondition, params CommandConditions.PatientConsentServiceCacheDatesTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.PatientConsentServiceCacheDatesTableCondition> conditions ) {
var delete = new InlineDelete( "PatientConsentServiceCacheDates" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.PatientConsentServiceCacheDatesTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@PatientConsentServiceCacheDatesTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.PatientConsentServiceCacheDatesTableCondition> conditions;
private readonly DataValue<int> @patientConsentServiceCacheDateIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the PatientConsentServiceCacheDateId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @PatientConsentServiceCacheDateId { get { return @patientConsentServiceCacheDateIdColumnValue.Value; } set { @patientConsentServiceCacheDateIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PatientConsentServiceCacheDateId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PatientConsentServiceCacheDateIdHasChanged { get { return @patientConsentServiceCacheDateIdColumnValue.Changed; } }
private readonly DataValue<string> @elysiumIdColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the ElysiumId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @ElysiumId { get { return @elysiumIdColumnValue.Value; } set { @elysiumIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ElysiumId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ElysiumIdHasChanged { get { return @elysiumIdColumnValue.Changed; } }
private readonly DataValue<System.DateTime?> @lastRequestedDateColumnValue = new DataValue<System.DateTime?>();
/// <summary>
/// Gets or sets the value for the LastRequestedDate column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.DateTime? @LastRequestedDate { get { return @lastRequestedDateColumnValue.Value; } set { @lastRequestedDateColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LastRequestedDate has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LastRequestedDateHasChanged { get { return @lastRequestedDateColumnValue.Changed; } }
private readonly DataValue<System.DateTime?> @goodforColumnValue = new DataValue<System.DateTime?>();
/// <summary>
/// Gets or sets the value for the Goodfor column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.DateTime? @Goodfor { get { return @goodforColumnValue.Value; } set { @goodforColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Goodfor has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @GoodforHasChanged { get { return @goodforColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the PatientConsentServiceCacheDates table.
/// </summary>
public static @PatientConsentServiceCacheDatesModification CreateForInsert() {
return new @PatientConsentServiceCacheDatesModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the PatientConsentServiceCacheDates table.
/// </summary>
public static @PatientConsentServiceCacheDatesModification CreateForUpdate( CommandConditions.PatientConsentServiceCacheDatesTableCondition requiredCondition, params CommandConditions.PatientConsentServiceCacheDatesTableCondition[] additionalConditions ) {
var mod = new @PatientConsentServiceCacheDatesModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@PatientConsentServiceCacheDatesTableEqualityConditions.@PatientConsentServiceCacheDateId )
mod.@patientConsentServiceCacheDateIdColumnValue.Value = ( condition as CommandConditions.@PatientConsentServiceCacheDatesTableEqualityConditions.@PatientConsentServiceCacheDateId ).Value;
else if( condition is CommandConditions.@PatientConsentServiceCacheDatesTableEqualityConditions.@ElysiumId )
mod.@elysiumIdColumnValue.Value = ( condition as CommandConditions.@PatientConsentServiceCacheDatesTableEqualityConditions.@ElysiumId ).Value;
else if( condition is CommandConditions.@PatientConsentServiceCacheDatesTableEqualityConditions.@LastRequestedDate )
mod.@lastRequestedDateColumnValue.Value = ( condition as CommandConditions.@PatientConsentServiceCacheDatesTableEqualityConditions.@LastRequestedDate ).Value;
else if( condition is CommandConditions.@PatientConsentServiceCacheDatesTableEqualityConditions.@Goodfor )
mod.@goodforColumnValue.Value = ( condition as CommandConditions.@PatientConsentServiceCacheDatesTableEqualityConditions.@Goodfor ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the PatientConsentServiceCacheDates table.
/// </summary>
public static @PatientConsentServiceCacheDatesModification CreateForSingleRowUpdate( int @patientConsentServiceCacheDateId, string @elysiumId, System.DateTime? @lastRequestedDate, System.DateTime? @goodfor ) {
var mod = new @PatientConsentServiceCacheDatesModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.PatientConsentServiceCacheDatesTableCondition>();
mod.conditions.Add( new CommandConditions.@PatientConsentServiceCacheDatesTableEqualityConditions.@PatientConsentServiceCacheDateId( @patientConsentServiceCacheDateId ) );
mod.@patientConsentServiceCacheDateIdColumnValue.Value = @patientConsentServiceCacheDateId;
mod.@elysiumIdColumnValue.Value = @elysiumId;
mod.@lastRequestedDateColumnValue.Value = @lastRequestedDate;
mod.@goodforColumnValue.Value = @goodfor;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.PatientConsentServiceCacheDatesTableCondition> getConditionList( CommandConditions.PatientConsentServiceCacheDatesTableCondition requiredCondition, params CommandConditions.PatientConsentServiceCacheDatesTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.PatientConsentServiceCacheDatesTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @PatientConsentServiceCacheDatesModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="patientConsentServiceCacheDateId">Object does not allow null.</param>
/// <param name="elysiumId">Object does not allow null.</param>
/// <param name="lastRequestedDate">Object allows null.</param>
/// <param name="goodfor">Object allows null.</param>
public void SetAllData( int @patientConsentServiceCacheDateId, string @elysiumId, System.DateTime? @lastRequestedDate, System.DateTime? @goodfor ) {
this.@patientConsentServiceCacheDateIdColumnValue.Value = @patientConsentServiceCacheDateId;
this.@elysiumIdColumnValue.Value = @elysiumId;
this.@lastRequestedDateColumnValue.Value = @lastRequestedDate;
this.@goodforColumnValue.Value = @goodfor;
}
/// <summary>
/// Executes this PatientConsentServiceCacheDates modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this PatientConsentServiceCacheDates modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "PatientConsentServiceCacheDates" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.PatientConsentServiceCacheDatesTableCondition>();
conditions.Add( new CommandConditions.@PatientConsentServiceCacheDatesTableEqualityConditions.@PatientConsentServiceCacheDateId( @PatientConsentServiceCacheDateId ) );
}
else {
var update = new InlineUpdate( "PatientConsentServiceCacheDates" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @patientConsentServiceCacheDateIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PatientConsentServiceCacheDateId", new DbParameterValue( @PatientConsentServiceCacheDateId, "Int" ) ) );
if( @elysiumIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ElysiumId", new DbParameterValue( @ElysiumId, "NVarChar" ) ) );
if( @lastRequestedDateColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LastRequestedDate", new DbParameterValue( @LastRequestedDate, "Date" ) ) );
if( @goodforColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Goodfor", new DbParameterValue( @Goodfor, "Date" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@patientConsentServiceCacheDateIdColumnValue.ClearChanged();
@elysiumIdColumnValue.ClearChanged();
@lastRequestedDateColumnValue.ClearChanged();
@goodforColumnValue.ClearChanged();
}
}
public partial class @PatientInfoModification {
/// <summary>
/// Inserts a row into the PatientInfo table.
/// </summary>
/// <param name="userID">Object does not allow null.</param>
/// <param name="encKV">Object does not allow null.</param>
/// <param name="encIV">Object does not allow null.</param>
/// <param name="firstName">Object does not allow null.</param>
/// <param name="middleName">Object does not allow null.</param>
/// <param name="lastName">Object does not allow null.</param>
/// <param name="address1">Object does not allow null.</param>
/// <param name="address2">Object does not allow null.</param>
/// <param name="city">Object does not allow null.</param>
/// <param name="state">Object does not allow null.</param>
/// <param name="zipCode">Object does not allow null.</param>
/// <param name="email">Object does not allow null.</param>
/// <param name="phone">Object does not allow null.</param>
/// <param name="gender">Object does not allow null.</param>
/// <param name="dOB">Object does not allow null.</param>
/// <param name="elysiumID">Object does not allow null.</param>
/// <param name="phrStatusId">Object does not allow null.</param>
/// <param name="signupComplete">Object does not allow null.</param>
/// <param name="tfaMethodId">Object does not allow null.</param>
/// <param name="forcePasswordExpired">Object does not allow null.</param>
/// <param name="signupDate">Object allows null.</param>
public static void InsertRow( System.Guid @userID, string @encKV, System.Byte[] @encIV, System.Byte[] @firstName, System.Byte[] @middleName, System.Byte[] @lastName, System.Byte[] @address1, System.Byte[] @address2, System.Byte[] @city, System.Byte[] @state, System.Byte[] @zipCode, System.Byte[] @email, System.Byte[] @phone, System.Byte[] @gender, System.Byte[] @dOB, System.Byte[] @elysiumID, int @phrStatusId, System.Boolean @signupComplete, int @tfaMethodId, System.Boolean @forcePasswordExpired, System.DateTime? @signupDate ) { 
var mod = CreateForInsert();
mod.@userIDColumnValue.Value = @userID;
mod.@encKVColumnValue.Value = @encKV;
mod.@encIVColumnValue.Value = @encIV;
mod.@firstNameColumnValue.Value = @firstName;
mod.@middleNameColumnValue.Value = @middleName;
mod.@lastNameColumnValue.Value = @lastName;
mod.@address1ColumnValue.Value = @address1;
mod.@address2ColumnValue.Value = @address2;
mod.@cityColumnValue.Value = @city;
mod.@stateColumnValue.Value = @state;
mod.@zipCodeColumnValue.Value = @zipCode;
mod.@emailColumnValue.Value = @email;
mod.@phoneColumnValue.Value = @phone;
mod.@genderColumnValue.Value = @gender;
mod.@dOBColumnValue.Value = @dOB;
mod.@elysiumIDColumnValue.Value = @elysiumID;
mod.@phrStatusIdColumnValue.Value = @phrStatusId;
mod.@signupCompleteColumnValue.Value = @signupComplete;
mod.@tfaMethodIdColumnValue.Value = @tfaMethodId;
mod.@forcePasswordExpiredColumnValue.Value = @forcePasswordExpired;
mod.@signupDateColumnValue.Value = @signupDate;
mod.Execute();
}
/// <summary>
/// Inserts a row into the PatientInfo table.
/// </summary>
/// <param name="userID">Object does not allow null.</param>
/// <param name="encKV">Object does not allow null.</param>
/// <param name="encIV">Object does not allow null.</param>
/// <param name="firstName">Object does not allow null.</param>
/// <param name="middleName">Object does not allow null.</param>
/// <param name="lastName">Object does not allow null.</param>
/// <param name="address1">Object does not allow null.</param>
/// <param name="address2">Object does not allow null.</param>
/// <param name="city">Object does not allow null.</param>
/// <param name="state">Object does not allow null.</param>
/// <param name="zipCode">Object does not allow null.</param>
/// <param name="email">Object does not allow null.</param>
/// <param name="phone">Object does not allow null.</param>
/// <param name="gender">Object does not allow null.</param>
/// <param name="dOB">Object does not allow null.</param>
/// <param name="elysiumID">Object does not allow null.</param>
/// <param name="phrStatusId">Object does not allow null.</param>
/// <param name="signupComplete">Object does not allow null.</param>
/// <param name="tfaMethodId">Object does not allow null.</param>
/// <param name="forcePasswordExpired">Object does not allow null.</param>
/// <param name="signupDate">Object allows null.</param>
public static void InsertRowWithoutAdditionalLogic( System.Guid @userID, string @encKV, System.Byte[] @encIV, System.Byte[] @firstName, System.Byte[] @middleName, System.Byte[] @lastName, System.Byte[] @address1, System.Byte[] @address2, System.Byte[] @city, System.Byte[] @state, System.Byte[] @zipCode, System.Byte[] @email, System.Byte[] @phone, System.Byte[] @gender, System.Byte[] @dOB, System.Byte[] @elysiumID, int @phrStatusId, System.Boolean @signupComplete, int @tfaMethodId, System.Boolean @forcePasswordExpired, System.DateTime? @signupDate ) { 
var mod = CreateForInsert();
mod.@userIDColumnValue.Value = @userID;
mod.@encKVColumnValue.Value = @encKV;
mod.@encIVColumnValue.Value = @encIV;
mod.@firstNameColumnValue.Value = @firstName;
mod.@middleNameColumnValue.Value = @middleName;
mod.@lastNameColumnValue.Value = @lastName;
mod.@address1ColumnValue.Value = @address1;
mod.@address2ColumnValue.Value = @address2;
mod.@cityColumnValue.Value = @city;
mod.@stateColumnValue.Value = @state;
mod.@zipCodeColumnValue.Value = @zipCode;
mod.@emailColumnValue.Value = @email;
mod.@phoneColumnValue.Value = @phone;
mod.@genderColumnValue.Value = @gender;
mod.@dOBColumnValue.Value = @dOB;
mod.@elysiumIDColumnValue.Value = @elysiumID;
mod.@phrStatusIdColumnValue.Value = @phrStatusId;
mod.@signupCompleteColumnValue.Value = @signupComplete;
mod.@tfaMethodIdColumnValue.Value = @tfaMethodId;
mod.@forcePasswordExpiredColumnValue.Value = @forcePasswordExpired;
mod.@signupDateColumnValue.Value = @signupDate;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the PatientInfo table that match the specified conditions with the specified data.
/// </summary>
/// <param name="userID">Object does not allow null.</param>
/// <param name="encKV">Object does not allow null.</param>
/// <param name="encIV">Object does not allow null.</param>
/// <param name="firstName">Object does not allow null.</param>
/// <param name="middleName">Object does not allow null.</param>
/// <param name="lastName">Object does not allow null.</param>
/// <param name="address1">Object does not allow null.</param>
/// <param name="address2">Object does not allow null.</param>
/// <param name="city">Object does not allow null.</param>
/// <param name="state">Object does not allow null.</param>
/// <param name="zipCode">Object does not allow null.</param>
/// <param name="email">Object does not allow null.</param>
/// <param name="phone">Object does not allow null.</param>
/// <param name="gender">Object does not allow null.</param>
/// <param name="dOB">Object does not allow null.</param>
/// <param name="elysiumID">Object does not allow null.</param>
/// <param name="phrStatusId">Object does not allow null.</param>
/// <param name="signupComplete">Object does not allow null.</param>
/// <param name="tfaMethodId">Object does not allow null.</param>
/// <param name="forcePasswordExpired">Object does not allow null.</param>
/// <param name="signupDate">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( System.Guid @userID, string @encKV, System.Byte[] @encIV, System.Byte[] @firstName, System.Byte[] @middleName, System.Byte[] @lastName, System.Byte[] @address1, System.Byte[] @address2, System.Byte[] @city, System.Byte[] @state, System.Byte[] @zipCode, System.Byte[] @email, System.Byte[] @phone, System.Byte[] @gender, System.Byte[] @dOB, System.Byte[] @elysiumID, int @phrStatusId, System.Boolean @signupComplete, int @tfaMethodId, System.Boolean @forcePasswordExpired, System.DateTime? @signupDate, CommandConditions.PatientInfoTableCondition requiredCondition, params CommandConditions.PatientInfoTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@userIDColumnValue.Value = @userID;
mod.@encKVColumnValue.Value = @encKV;
mod.@encIVColumnValue.Value = @encIV;
mod.@firstNameColumnValue.Value = @firstName;
mod.@middleNameColumnValue.Value = @middleName;
mod.@lastNameColumnValue.Value = @lastName;
mod.@address1ColumnValue.Value = @address1;
mod.@address2ColumnValue.Value = @address2;
mod.@cityColumnValue.Value = @city;
mod.@stateColumnValue.Value = @state;
mod.@zipCodeColumnValue.Value = @zipCode;
mod.@emailColumnValue.Value = @email;
mod.@phoneColumnValue.Value = @phone;
mod.@genderColumnValue.Value = @gender;
mod.@dOBColumnValue.Value = @dOB;
mod.@elysiumIDColumnValue.Value = @elysiumID;
mod.@phrStatusIdColumnValue.Value = @phrStatusId;
mod.@signupCompleteColumnValue.Value = @signupComplete;
mod.@tfaMethodIdColumnValue.Value = @tfaMethodId;
mod.@forcePasswordExpiredColumnValue.Value = @forcePasswordExpired;
mod.@signupDateColumnValue.Value = @signupDate;
mod.Execute();
}
/// <summary>
/// Updates rows in the PatientInfo table that match the specified conditions with the specified data.
/// </summary>
/// <param name="userID">Object does not allow null.</param>
/// <param name="encKV">Object does not allow null.</param>
/// <param name="encIV">Object does not allow null.</param>
/// <param name="firstName">Object does not allow null.</param>
/// <param name="middleName">Object does not allow null.</param>
/// <param name="lastName">Object does not allow null.</param>
/// <param name="address1">Object does not allow null.</param>
/// <param name="address2">Object does not allow null.</param>
/// <param name="city">Object does not allow null.</param>
/// <param name="state">Object does not allow null.</param>
/// <param name="zipCode">Object does not allow null.</param>
/// <param name="email">Object does not allow null.</param>
/// <param name="phone">Object does not allow null.</param>
/// <param name="gender">Object does not allow null.</param>
/// <param name="dOB">Object does not allow null.</param>
/// <param name="elysiumID">Object does not allow null.</param>
/// <param name="phrStatusId">Object does not allow null.</param>
/// <param name="signupComplete">Object does not allow null.</param>
/// <param name="tfaMethodId">Object does not allow null.</param>
/// <param name="forcePasswordExpired">Object does not allow null.</param>
/// <param name="signupDate">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( System.Guid @userID, string @encKV, System.Byte[] @encIV, System.Byte[] @firstName, System.Byte[] @middleName, System.Byte[] @lastName, System.Byte[] @address1, System.Byte[] @address2, System.Byte[] @city, System.Byte[] @state, System.Byte[] @zipCode, System.Byte[] @email, System.Byte[] @phone, System.Byte[] @gender, System.Byte[] @dOB, System.Byte[] @elysiumID, int @phrStatusId, System.Boolean @signupComplete, int @tfaMethodId, System.Boolean @forcePasswordExpired, System.DateTime? @signupDate, CommandConditions.PatientInfoTableCondition requiredCondition, params CommandConditions.PatientInfoTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@userIDColumnValue.Value = @userID;
mod.@encKVColumnValue.Value = @encKV;
mod.@encIVColumnValue.Value = @encIV;
mod.@firstNameColumnValue.Value = @firstName;
mod.@middleNameColumnValue.Value = @middleName;
mod.@lastNameColumnValue.Value = @lastName;
mod.@address1ColumnValue.Value = @address1;
mod.@address2ColumnValue.Value = @address2;
mod.@cityColumnValue.Value = @city;
mod.@stateColumnValue.Value = @state;
mod.@zipCodeColumnValue.Value = @zipCode;
mod.@emailColumnValue.Value = @email;
mod.@phoneColumnValue.Value = @phone;
mod.@genderColumnValue.Value = @gender;
mod.@dOBColumnValue.Value = @dOB;
mod.@elysiumIDColumnValue.Value = @elysiumID;
mod.@phrStatusIdColumnValue.Value = @phrStatusId;
mod.@signupCompleteColumnValue.Value = @signupComplete;
mod.@tfaMethodIdColumnValue.Value = @tfaMethodId;
mod.@forcePasswordExpiredColumnValue.Value = @forcePasswordExpired;
mod.@signupDateColumnValue.Value = @signupDate;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.PatientInfoTableCondition requiredCondition, params CommandConditions.PatientInfoTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@PatientInfoTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.PatientInfoTableCondition requiredCondition, params CommandConditions.PatientInfoTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.PatientInfoTableCondition> conditions ) {
var delete = new InlineDelete( "PatientInfo" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.PatientInfoTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@PatientInfoTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.PatientInfoTableCondition> conditions;
private readonly DataValue<System.Guid> @userIDColumnValue = new DataValue<System.Guid>();
/// <summary>
/// Gets or sets the value for the UserID column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Guid @UserID { get { return @userIDColumnValue.Value; } set { @userIDColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the UserID has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @UserIDHasChanged { get { return @userIDColumnValue.Changed; } }
private readonly DataValue<string> @encKVColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the EncKV column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @EncKV { get { return @encKVColumnValue.Value; } set { @encKVColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EncKV has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EncKVHasChanged { get { return @encKVColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @encIVColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the EncIV column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @EncIV { get { return @encIVColumnValue.Value; } set { @encIVColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EncIV has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EncIVHasChanged { get { return @encIVColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @firstNameColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the FirstName column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @FirstName { get { return @firstNameColumnValue.Value; } set { @firstNameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the FirstName has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @FirstNameHasChanged { get { return @firstNameColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @middleNameColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the MiddleName column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @MiddleName { get { return @middleNameColumnValue.Value; } set { @middleNameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the MiddleName has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @MiddleNameHasChanged { get { return @middleNameColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @lastNameColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the LastName column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @LastName { get { return @lastNameColumnValue.Value; } set { @lastNameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LastName has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LastNameHasChanged { get { return @lastNameColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @address1ColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the Address1 column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @Address1 { get { return @address1ColumnValue.Value; } set { @address1ColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Address1 has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @Address1HasChanged { get { return @address1ColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @address2ColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the Address2 column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @Address2 { get { return @address2ColumnValue.Value; } set { @address2ColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Address2 has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @Address2HasChanged { get { return @address2ColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @cityColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the City column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @City { get { return @cityColumnValue.Value; } set { @cityColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the City has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @CityHasChanged { get { return @cityColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @stateColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the State column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @State { get { return @stateColumnValue.Value; } set { @stateColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the State has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @StateHasChanged { get { return @stateColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @zipCodeColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the ZipCode column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @ZipCode { get { return @zipCodeColumnValue.Value; } set { @zipCodeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ZipCode has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ZipCodeHasChanged { get { return @zipCodeColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @emailColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the Email column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @Email { get { return @emailColumnValue.Value; } set { @emailColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Email has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EmailHasChanged { get { return @emailColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @phoneColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the Phone column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @Phone { get { return @phoneColumnValue.Value; } set { @phoneColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Phone has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PhoneHasChanged { get { return @phoneColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @genderColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the Gender column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @Gender { get { return @genderColumnValue.Value; } set { @genderColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Gender has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @GenderHasChanged { get { return @genderColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @dOBColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the DOB column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @DOB { get { return @dOBColumnValue.Value; } set { @dOBColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the DOB has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @DOBHasChanged { get { return @dOBColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @elysiumIDColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the ElysiumID column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @ElysiumID { get { return @elysiumIDColumnValue.Value; } set { @elysiumIDColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ElysiumID has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ElysiumIDHasChanged { get { return @elysiumIDColumnValue.Changed; } }
private readonly DataValue<int> @phrStatusIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the PhrStatusId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @PhrStatusId { get { return @phrStatusIdColumnValue.Value; } set { @phrStatusIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PhrStatusId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PhrStatusIdHasChanged { get { return @phrStatusIdColumnValue.Changed; } }
private readonly DataValue<System.Boolean> @signupCompleteColumnValue = new DataValue<System.Boolean>();
/// <summary>
/// Gets or sets the value for the SignupComplete column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Boolean @SignupComplete { get { return @signupCompleteColumnValue.Value; } set { @signupCompleteColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the SignupComplete has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @SignupCompleteHasChanged { get { return @signupCompleteColumnValue.Changed; } }
private readonly DataValue<int> @tfaMethodIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the TfaMethodId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @TfaMethodId { get { return @tfaMethodIdColumnValue.Value; } set { @tfaMethodIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the TfaMethodId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @TfaMethodIdHasChanged { get { return @tfaMethodIdColumnValue.Changed; } }
private readonly DataValue<System.Boolean> @forcePasswordExpiredColumnValue = new DataValue<System.Boolean>();
/// <summary>
/// Gets or sets the value for the ForcePasswordExpired column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Boolean @ForcePasswordExpired { get { return @forcePasswordExpiredColumnValue.Value; } set { @forcePasswordExpiredColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ForcePasswordExpired has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ForcePasswordExpiredHasChanged { get { return @forcePasswordExpiredColumnValue.Changed; } }
private readonly DataValue<System.DateTime?> @signupDateColumnValue = new DataValue<System.DateTime?>();
/// <summary>
/// Gets or sets the value for the SignupDate column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.DateTime? @SignupDate { get { return @signupDateColumnValue.Value; } set { @signupDateColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the SignupDate has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @SignupDateHasChanged { get { return @signupDateColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the PatientInfo table.
/// </summary>
public static @PatientInfoModification CreateForInsert() {
return new @PatientInfoModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the PatientInfo table.
/// </summary>
public static @PatientInfoModification CreateForUpdate( CommandConditions.PatientInfoTableCondition requiredCondition, params CommandConditions.PatientInfoTableCondition[] additionalConditions ) {
var mod = new @PatientInfoModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@PatientInfoTableEqualityConditions.@UserID )
mod.@userIDColumnValue.Value = ( condition as CommandConditions.@PatientInfoTableEqualityConditions.@UserID ).Value;
else if( condition is CommandConditions.@PatientInfoTableEqualityConditions.@EncKV )
mod.@encKVColumnValue.Value = ( condition as CommandConditions.@PatientInfoTableEqualityConditions.@EncKV ).Value;
else if( condition is CommandConditions.@PatientInfoTableEqualityConditions.@EncIV )
mod.@encIVColumnValue.Value = ( condition as CommandConditions.@PatientInfoTableEqualityConditions.@EncIV ).Value;
else if( condition is CommandConditions.@PatientInfoTableEqualityConditions.@FirstName )
mod.@firstNameColumnValue.Value = ( condition as CommandConditions.@PatientInfoTableEqualityConditions.@FirstName ).Value;
else if( condition is CommandConditions.@PatientInfoTableEqualityConditions.@MiddleName )
mod.@middleNameColumnValue.Value = ( condition as CommandConditions.@PatientInfoTableEqualityConditions.@MiddleName ).Value;
else if( condition is CommandConditions.@PatientInfoTableEqualityConditions.@LastName )
mod.@lastNameColumnValue.Value = ( condition as CommandConditions.@PatientInfoTableEqualityConditions.@LastName ).Value;
else if( condition is CommandConditions.@PatientInfoTableEqualityConditions.@Address1 )
mod.@address1ColumnValue.Value = ( condition as CommandConditions.@PatientInfoTableEqualityConditions.@Address1 ).Value;
else if( condition is CommandConditions.@PatientInfoTableEqualityConditions.@Address2 )
mod.@address2ColumnValue.Value = ( condition as CommandConditions.@PatientInfoTableEqualityConditions.@Address2 ).Value;
else if( condition is CommandConditions.@PatientInfoTableEqualityConditions.@City )
mod.@cityColumnValue.Value = ( condition as CommandConditions.@PatientInfoTableEqualityConditions.@City ).Value;
else if( condition is CommandConditions.@PatientInfoTableEqualityConditions.@State )
mod.@stateColumnValue.Value = ( condition as CommandConditions.@PatientInfoTableEqualityConditions.@State ).Value;
else if( condition is CommandConditions.@PatientInfoTableEqualityConditions.@ZipCode )
mod.@zipCodeColumnValue.Value = ( condition as CommandConditions.@PatientInfoTableEqualityConditions.@ZipCode ).Value;
else if( condition is CommandConditions.@PatientInfoTableEqualityConditions.@Email )
mod.@emailColumnValue.Value = ( condition as CommandConditions.@PatientInfoTableEqualityConditions.@Email ).Value;
else if( condition is CommandConditions.@PatientInfoTableEqualityConditions.@Phone )
mod.@phoneColumnValue.Value = ( condition as CommandConditions.@PatientInfoTableEqualityConditions.@Phone ).Value;
else if( condition is CommandConditions.@PatientInfoTableEqualityConditions.@Gender )
mod.@genderColumnValue.Value = ( condition as CommandConditions.@PatientInfoTableEqualityConditions.@Gender ).Value;
else if( condition is CommandConditions.@PatientInfoTableEqualityConditions.@DOB )
mod.@dOBColumnValue.Value = ( condition as CommandConditions.@PatientInfoTableEqualityConditions.@DOB ).Value;
else if( condition is CommandConditions.@PatientInfoTableEqualityConditions.@ElysiumID )
mod.@elysiumIDColumnValue.Value = ( condition as CommandConditions.@PatientInfoTableEqualityConditions.@ElysiumID ).Value;
else if( condition is CommandConditions.@PatientInfoTableEqualityConditions.@PhrStatusId )
mod.@phrStatusIdColumnValue.Value = ( condition as CommandConditions.@PatientInfoTableEqualityConditions.@PhrStatusId ).Value;
else if( condition is CommandConditions.@PatientInfoTableEqualityConditions.@SignupComplete )
mod.@signupCompleteColumnValue.Value = ( condition as CommandConditions.@PatientInfoTableEqualityConditions.@SignupComplete ).Value;
else if( condition is CommandConditions.@PatientInfoTableEqualityConditions.@TfaMethodId )
mod.@tfaMethodIdColumnValue.Value = ( condition as CommandConditions.@PatientInfoTableEqualityConditions.@TfaMethodId ).Value;
else if( condition is CommandConditions.@PatientInfoTableEqualityConditions.@ForcePasswordExpired )
mod.@forcePasswordExpiredColumnValue.Value = ( condition as CommandConditions.@PatientInfoTableEqualityConditions.@ForcePasswordExpired ).Value;
else if( condition is CommandConditions.@PatientInfoTableEqualityConditions.@SignupDate )
mod.@signupDateColumnValue.Value = ( condition as CommandConditions.@PatientInfoTableEqualityConditions.@SignupDate ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the PatientInfo table.
/// </summary>
public static @PatientInfoModification CreateForSingleRowUpdate( System.Guid @userID, string @encKV, System.Byte[] @encIV, System.Byte[] @firstName, System.Byte[] @middleName, System.Byte[] @lastName, System.Byte[] @address1, System.Byte[] @address2, System.Byte[] @city, System.Byte[] @state, System.Byte[] @zipCode, System.Byte[] @email, System.Byte[] @phone, System.Byte[] @gender, System.Byte[] @dOB, System.Byte[] @elysiumID, int @phrStatusId, System.Boolean @signupComplete, int @tfaMethodId, System.Boolean @forcePasswordExpired, System.DateTime? @signupDate ) {
var mod = new @PatientInfoModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.PatientInfoTableCondition>();
mod.conditions.Add( new CommandConditions.@PatientInfoTableEqualityConditions.@UserID( @userID ) );
mod.@userIDColumnValue.Value = @userID;
mod.@encKVColumnValue.Value = @encKV;
mod.@encIVColumnValue.Value = @encIV;
mod.@firstNameColumnValue.Value = @firstName;
mod.@middleNameColumnValue.Value = @middleName;
mod.@lastNameColumnValue.Value = @lastName;
mod.@address1ColumnValue.Value = @address1;
mod.@address2ColumnValue.Value = @address2;
mod.@cityColumnValue.Value = @city;
mod.@stateColumnValue.Value = @state;
mod.@zipCodeColumnValue.Value = @zipCode;
mod.@emailColumnValue.Value = @email;
mod.@phoneColumnValue.Value = @phone;
mod.@genderColumnValue.Value = @gender;
mod.@dOBColumnValue.Value = @dOB;
mod.@elysiumIDColumnValue.Value = @elysiumID;
mod.@phrStatusIdColumnValue.Value = @phrStatusId;
mod.@signupCompleteColumnValue.Value = @signupComplete;
mod.@tfaMethodIdColumnValue.Value = @tfaMethodId;
mod.@forcePasswordExpiredColumnValue.Value = @forcePasswordExpired;
mod.@signupDateColumnValue.Value = @signupDate;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.PatientInfoTableCondition> getConditionList( CommandConditions.PatientInfoTableCondition requiredCondition, params CommandConditions.PatientInfoTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.PatientInfoTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @PatientInfoModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="userID">Object does not allow null.</param>
/// <param name="encKV">Object does not allow null.</param>
/// <param name="encIV">Object does not allow null.</param>
/// <param name="firstName">Object does not allow null.</param>
/// <param name="middleName">Object does not allow null.</param>
/// <param name="lastName">Object does not allow null.</param>
/// <param name="address1">Object does not allow null.</param>
/// <param name="address2">Object does not allow null.</param>
/// <param name="city">Object does not allow null.</param>
/// <param name="state">Object does not allow null.</param>
/// <param name="zipCode">Object does not allow null.</param>
/// <param name="email">Object does not allow null.</param>
/// <param name="phone">Object does not allow null.</param>
/// <param name="gender">Object does not allow null.</param>
/// <param name="dOB">Object does not allow null.</param>
/// <param name="elysiumID">Object does not allow null.</param>
/// <param name="phrStatusId">Object does not allow null.</param>
/// <param name="signupComplete">Object does not allow null.</param>
/// <param name="tfaMethodId">Object does not allow null.</param>
/// <param name="forcePasswordExpired">Object does not allow null.</param>
/// <param name="signupDate">Object allows null.</param>
public void SetAllData( System.Guid @userID, string @encKV, System.Byte[] @encIV, System.Byte[] @firstName, System.Byte[] @middleName, System.Byte[] @lastName, System.Byte[] @address1, System.Byte[] @address2, System.Byte[] @city, System.Byte[] @state, System.Byte[] @zipCode, System.Byte[] @email, System.Byte[] @phone, System.Byte[] @gender, System.Byte[] @dOB, System.Byte[] @elysiumID, int @phrStatusId, System.Boolean @signupComplete, int @tfaMethodId, System.Boolean @forcePasswordExpired, System.DateTime? @signupDate ) {
this.@userIDColumnValue.Value = @userID;
this.@encKVColumnValue.Value = @encKV;
this.@encIVColumnValue.Value = @encIV;
this.@firstNameColumnValue.Value = @firstName;
this.@middleNameColumnValue.Value = @middleName;
this.@lastNameColumnValue.Value = @lastName;
this.@address1ColumnValue.Value = @address1;
this.@address2ColumnValue.Value = @address2;
this.@cityColumnValue.Value = @city;
this.@stateColumnValue.Value = @state;
this.@zipCodeColumnValue.Value = @zipCode;
this.@emailColumnValue.Value = @email;
this.@phoneColumnValue.Value = @phone;
this.@genderColumnValue.Value = @gender;
this.@dOBColumnValue.Value = @dOB;
this.@elysiumIDColumnValue.Value = @elysiumID;
this.@phrStatusIdColumnValue.Value = @phrStatusId;
this.@signupCompleteColumnValue.Value = @signupComplete;
this.@tfaMethodIdColumnValue.Value = @tfaMethodId;
this.@forcePasswordExpiredColumnValue.Value = @forcePasswordExpired;
this.@signupDateColumnValue.Value = @signupDate;
}
/// <summary>
/// Executes this PatientInfo modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this PatientInfo modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "PatientInfo" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.PatientInfoTableCondition>();
conditions.Add( new CommandConditions.@PatientInfoTableEqualityConditions.@UserID( @UserID ) );
}
else {
var update = new InlineUpdate( "PatientInfo" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @userIDColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "UserID", new DbParameterValue( @UserID, "UniqueIdentifier" ) ) );
if( @encKVColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EncKV", new DbParameterValue( @EncKV, "NVarChar" ) ) );
if( @encIVColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EncIV", new DbParameterValue( @EncIV, "VarBinary" ) ) );
if( @firstNameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "FirstName", new DbParameterValue( @FirstName, "VarBinary" ) ) );
if( @middleNameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "MiddleName", new DbParameterValue( @MiddleName, "VarBinary" ) ) );
if( @lastNameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LastName", new DbParameterValue( @LastName, "VarBinary" ) ) );
if( @address1ColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Address1", new DbParameterValue( @Address1, "VarBinary" ) ) );
if( @address2ColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Address2", new DbParameterValue( @Address2, "VarBinary" ) ) );
if( @cityColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "City", new DbParameterValue( @City, "VarBinary" ) ) );
if( @stateColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "State", new DbParameterValue( @State, "VarBinary" ) ) );
if( @zipCodeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ZipCode", new DbParameterValue( @ZipCode, "VarBinary" ) ) );
if( @emailColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Email", new DbParameterValue( @Email, "VarBinary" ) ) );
if( @phoneColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Phone", new DbParameterValue( @Phone, "VarBinary" ) ) );
if( @genderColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Gender", new DbParameterValue( @Gender, "VarBinary" ) ) );
if( @dOBColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "DOB", new DbParameterValue( @DOB, "VarBinary" ) ) );
if( @elysiumIDColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ElysiumID", new DbParameterValue( @ElysiumID, "VarBinary" ) ) );
if( @phrStatusIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PhrStatusId", new DbParameterValue( @PhrStatusId, "Int" ) ) );
if( @signupCompleteColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "SignupComplete", new DbParameterValue( @SignupComplete, "Bit" ) ) );
if( @tfaMethodIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "TfaMethodId", new DbParameterValue( @TfaMethodId, "Int" ) ) );
if( @forcePasswordExpiredColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ForcePasswordExpired", new DbParameterValue( @ForcePasswordExpired, "Bit" ) ) );
if( @signupDateColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "SignupDate", new DbParameterValue( @SignupDate, "DateTime2" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@userIDColumnValue.ClearChanged();
@encKVColumnValue.ClearChanged();
@encIVColumnValue.ClearChanged();
@firstNameColumnValue.ClearChanged();
@middleNameColumnValue.ClearChanged();
@lastNameColumnValue.ClearChanged();
@address1ColumnValue.ClearChanged();
@address2ColumnValue.ClearChanged();
@cityColumnValue.ClearChanged();
@stateColumnValue.ClearChanged();
@zipCodeColumnValue.ClearChanged();
@emailColumnValue.ClearChanged();
@phoneColumnValue.ClearChanged();
@genderColumnValue.ClearChanged();
@dOBColumnValue.ClearChanged();
@elysiumIDColumnValue.ClearChanged();
@phrStatusIdColumnValue.ClearChanged();
@signupCompleteColumnValue.ClearChanged();
@tfaMethodIdColumnValue.ClearChanged();
@forcePasswordExpiredColumnValue.ClearChanged();
@signupDateColumnValue.ClearChanged();
}
}
public partial class @PatientPortalConsentHistoryModification {
/// <summary>
/// Inserts a row into the PatientPortalConsentHistory table.
/// </summary>
/// <param name="patientPortalConsentHistoryId">Object does not allow null.</param>
/// <param name="iv">Object does not allow null.</param>
/// <param name="elysiumId">Object does not allow null.</param>
/// <param name="workgroupId">Object does not allow null.</param>
/// <param name="consentTypeId">Object does not allow null.</param>
/// <param name="updatedByPatientDateTime">Object does not allow null.</param>
public static void InsertRow( int @patientPortalConsentHistoryId, System.Byte[] @iv, string @elysiumId, System.Byte[] @workgroupId, System.Byte[] @consentTypeId, DateTime @updatedByPatientDateTime ) { 
var mod = CreateForInsert();
mod.@patientPortalConsentHistoryIdColumnValue.Value = @patientPortalConsentHistoryId;
mod.@ivColumnValue.Value = @iv;
mod.@elysiumIdColumnValue.Value = @elysiumId;
mod.@workgroupIdColumnValue.Value = @workgroupId;
mod.@consentTypeIdColumnValue.Value = @consentTypeId;
mod.@updatedByPatientDateTimeColumnValue.Value = @updatedByPatientDateTime;
mod.Execute();
}
/// <summary>
/// Inserts a row into the PatientPortalConsentHistory table.
/// </summary>
/// <param name="patientPortalConsentHistoryId">Object does not allow null.</param>
/// <param name="iv">Object does not allow null.</param>
/// <param name="elysiumId">Object does not allow null.</param>
/// <param name="workgroupId">Object does not allow null.</param>
/// <param name="consentTypeId">Object does not allow null.</param>
/// <param name="updatedByPatientDateTime">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @patientPortalConsentHistoryId, System.Byte[] @iv, string @elysiumId, System.Byte[] @workgroupId, System.Byte[] @consentTypeId, DateTime @updatedByPatientDateTime ) { 
var mod = CreateForInsert();
mod.@patientPortalConsentHistoryIdColumnValue.Value = @patientPortalConsentHistoryId;
mod.@ivColumnValue.Value = @iv;
mod.@elysiumIdColumnValue.Value = @elysiumId;
mod.@workgroupIdColumnValue.Value = @workgroupId;
mod.@consentTypeIdColumnValue.Value = @consentTypeId;
mod.@updatedByPatientDateTimeColumnValue.Value = @updatedByPatientDateTime;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the PatientPortalConsentHistory table that match the specified conditions with the specified data.
/// </summary>
/// <param name="patientPortalConsentHistoryId">Object does not allow null.</param>
/// <param name="iv">Object does not allow null.</param>
/// <param name="elysiumId">Object does not allow null.</param>
/// <param name="workgroupId">Object does not allow null.</param>
/// <param name="consentTypeId">Object does not allow null.</param>
/// <param name="updatedByPatientDateTime">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @patientPortalConsentHistoryId, System.Byte[] @iv, string @elysiumId, System.Byte[] @workgroupId, System.Byte[] @consentTypeId, DateTime @updatedByPatientDateTime, CommandConditions.PatientPortalConsentHistoryTableCondition requiredCondition, params CommandConditions.PatientPortalConsentHistoryTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@patientPortalConsentHistoryIdColumnValue.Value = @patientPortalConsentHistoryId;
mod.@ivColumnValue.Value = @iv;
mod.@elysiumIdColumnValue.Value = @elysiumId;
mod.@workgroupIdColumnValue.Value = @workgroupId;
mod.@consentTypeIdColumnValue.Value = @consentTypeId;
mod.@updatedByPatientDateTimeColumnValue.Value = @updatedByPatientDateTime;
mod.Execute();
}
/// <summary>
/// Updates rows in the PatientPortalConsentHistory table that match the specified conditions with the specified data.
/// </summary>
/// <param name="patientPortalConsentHistoryId">Object does not allow null.</param>
/// <param name="iv">Object does not allow null.</param>
/// <param name="elysiumId">Object does not allow null.</param>
/// <param name="workgroupId">Object does not allow null.</param>
/// <param name="consentTypeId">Object does not allow null.</param>
/// <param name="updatedByPatientDateTime">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @patientPortalConsentHistoryId, System.Byte[] @iv, string @elysiumId, System.Byte[] @workgroupId, System.Byte[] @consentTypeId, DateTime @updatedByPatientDateTime, CommandConditions.PatientPortalConsentHistoryTableCondition requiredCondition, params CommandConditions.PatientPortalConsentHistoryTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@patientPortalConsentHistoryIdColumnValue.Value = @patientPortalConsentHistoryId;
mod.@ivColumnValue.Value = @iv;
mod.@elysiumIdColumnValue.Value = @elysiumId;
mod.@workgroupIdColumnValue.Value = @workgroupId;
mod.@consentTypeIdColumnValue.Value = @consentTypeId;
mod.@updatedByPatientDateTimeColumnValue.Value = @updatedByPatientDateTime;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.PatientPortalConsentHistoryTableCondition requiredCondition, params CommandConditions.PatientPortalConsentHistoryTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@PatientPortalConsentHistoryTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.PatientPortalConsentHistoryTableCondition requiredCondition, params CommandConditions.PatientPortalConsentHistoryTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.PatientPortalConsentHistoryTableCondition> conditions ) {
var delete = new InlineDelete( "PatientPortalConsentHistory" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.PatientPortalConsentHistoryTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@PatientPortalConsentHistoryTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.PatientPortalConsentHistoryTableCondition> conditions;
private readonly DataValue<int> @patientPortalConsentHistoryIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the PatientPortalConsentHistoryId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @PatientPortalConsentHistoryId { get { return @patientPortalConsentHistoryIdColumnValue.Value; } set { @patientPortalConsentHistoryIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PatientPortalConsentHistoryId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PatientPortalConsentHistoryIdHasChanged { get { return @patientPortalConsentHistoryIdColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @ivColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the Iv column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @Iv { get { return @ivColumnValue.Value; } set { @ivColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Iv has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @IvHasChanged { get { return @ivColumnValue.Changed; } }
private readonly DataValue<string> @elysiumIdColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the ElysiumId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @ElysiumId { get { return @elysiumIdColumnValue.Value; } set { @elysiumIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ElysiumId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ElysiumIdHasChanged { get { return @elysiumIdColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @workgroupIdColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the WorkgroupId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @WorkgroupId { get { return @workgroupIdColumnValue.Value; } set { @workgroupIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the WorkgroupId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @WorkgroupIdHasChanged { get { return @workgroupIdColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @consentTypeIdColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the ConsentTypeId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @ConsentTypeId { get { return @consentTypeIdColumnValue.Value; } set { @consentTypeIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ConsentTypeId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ConsentTypeIdHasChanged { get { return @consentTypeIdColumnValue.Changed; } }
private readonly DataValue<DateTime> @updatedByPatientDateTimeColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the UpdatedByPatientDateTime column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @UpdatedByPatientDateTime { get { return @updatedByPatientDateTimeColumnValue.Value; } set { @updatedByPatientDateTimeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the UpdatedByPatientDateTime has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @UpdatedByPatientDateTimeHasChanged { get { return @updatedByPatientDateTimeColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the PatientPortalConsentHistory table.
/// </summary>
public static @PatientPortalConsentHistoryModification CreateForInsert() {
return new @PatientPortalConsentHistoryModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the PatientPortalConsentHistory table.
/// </summary>
public static @PatientPortalConsentHistoryModification CreateForUpdate( CommandConditions.PatientPortalConsentHistoryTableCondition requiredCondition, params CommandConditions.PatientPortalConsentHistoryTableCondition[] additionalConditions ) {
var mod = new @PatientPortalConsentHistoryModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@PatientPortalConsentHistoryTableEqualityConditions.@PatientPortalConsentHistoryId )
mod.@patientPortalConsentHistoryIdColumnValue.Value = ( condition as CommandConditions.@PatientPortalConsentHistoryTableEqualityConditions.@PatientPortalConsentHistoryId ).Value;
else if( condition is CommandConditions.@PatientPortalConsentHistoryTableEqualityConditions.@Iv )
mod.@ivColumnValue.Value = ( condition as CommandConditions.@PatientPortalConsentHistoryTableEqualityConditions.@Iv ).Value;
else if( condition is CommandConditions.@PatientPortalConsentHistoryTableEqualityConditions.@ElysiumId )
mod.@elysiumIdColumnValue.Value = ( condition as CommandConditions.@PatientPortalConsentHistoryTableEqualityConditions.@ElysiumId ).Value;
else if( condition is CommandConditions.@PatientPortalConsentHistoryTableEqualityConditions.@WorkgroupId )
mod.@workgroupIdColumnValue.Value = ( condition as CommandConditions.@PatientPortalConsentHistoryTableEqualityConditions.@WorkgroupId ).Value;
else if( condition is CommandConditions.@PatientPortalConsentHistoryTableEqualityConditions.@ConsentTypeId )
mod.@consentTypeIdColumnValue.Value = ( condition as CommandConditions.@PatientPortalConsentHistoryTableEqualityConditions.@ConsentTypeId ).Value;
else if( condition is CommandConditions.@PatientPortalConsentHistoryTableEqualityConditions.@UpdatedByPatientDateTime )
mod.@updatedByPatientDateTimeColumnValue.Value = ( condition as CommandConditions.@PatientPortalConsentHistoryTableEqualityConditions.@UpdatedByPatientDateTime ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the PatientPortalConsentHistory table.
/// </summary>
public static @PatientPortalConsentHistoryModification CreateForSingleRowUpdate( int @patientPortalConsentHistoryId, System.Byte[] @iv, string @elysiumId, System.Byte[] @workgroupId, System.Byte[] @consentTypeId, DateTime @updatedByPatientDateTime ) {
var mod = new @PatientPortalConsentHistoryModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.PatientPortalConsentHistoryTableCondition>();
mod.conditions.Add( new CommandConditions.@PatientPortalConsentHistoryTableEqualityConditions.@PatientPortalConsentHistoryId( @patientPortalConsentHistoryId ) );
mod.@patientPortalConsentHistoryIdColumnValue.Value = @patientPortalConsentHistoryId;
mod.@ivColumnValue.Value = @iv;
mod.@elysiumIdColumnValue.Value = @elysiumId;
mod.@workgroupIdColumnValue.Value = @workgroupId;
mod.@consentTypeIdColumnValue.Value = @consentTypeId;
mod.@updatedByPatientDateTimeColumnValue.Value = @updatedByPatientDateTime;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.PatientPortalConsentHistoryTableCondition> getConditionList( CommandConditions.PatientPortalConsentHistoryTableCondition requiredCondition, params CommandConditions.PatientPortalConsentHistoryTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.PatientPortalConsentHistoryTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @PatientPortalConsentHistoryModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="patientPortalConsentHistoryId">Object does not allow null.</param>
/// <param name="iv">Object does not allow null.</param>
/// <param name="elysiumId">Object does not allow null.</param>
/// <param name="workgroupId">Object does not allow null.</param>
/// <param name="consentTypeId">Object does not allow null.</param>
/// <param name="updatedByPatientDateTime">Object does not allow null.</param>
public void SetAllData( int @patientPortalConsentHistoryId, System.Byte[] @iv, string @elysiumId, System.Byte[] @workgroupId, System.Byte[] @consentTypeId, DateTime @updatedByPatientDateTime ) {
this.@patientPortalConsentHistoryIdColumnValue.Value = @patientPortalConsentHistoryId;
this.@ivColumnValue.Value = @iv;
this.@elysiumIdColumnValue.Value = @elysiumId;
this.@workgroupIdColumnValue.Value = @workgroupId;
this.@consentTypeIdColumnValue.Value = @consentTypeId;
this.@updatedByPatientDateTimeColumnValue.Value = @updatedByPatientDateTime;
}
/// <summary>
/// Executes this PatientPortalConsentHistory modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this PatientPortalConsentHistory modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "PatientPortalConsentHistory" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.PatientPortalConsentHistoryTableCondition>();
conditions.Add( new CommandConditions.@PatientPortalConsentHistoryTableEqualityConditions.@PatientPortalConsentHistoryId( @PatientPortalConsentHistoryId ) );
}
else {
var update = new InlineUpdate( "PatientPortalConsentHistory" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @patientPortalConsentHistoryIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PatientPortalConsentHistoryId", new DbParameterValue( @PatientPortalConsentHistoryId, "Int" ) ) );
if( @ivColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Iv", new DbParameterValue( @Iv, "Binary" ) ) );
if( @elysiumIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ElysiumId", new DbParameterValue( @ElysiumId, "NVarChar" ) ) );
if( @workgroupIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "WorkgroupId", new DbParameterValue( @WorkgroupId, "Binary" ) ) );
if( @consentTypeIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ConsentTypeId", new DbParameterValue( @ConsentTypeId, "Binary" ) ) );
if( @updatedByPatientDateTimeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "UpdatedByPatientDateTime", new DbParameterValue( @UpdatedByPatientDateTime, "DateTime2" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@patientPortalConsentHistoryIdColumnValue.ClearChanged();
@ivColumnValue.ClearChanged();
@elysiumIdColumnValue.ClearChanged();
@workgroupIdColumnValue.ClearChanged();
@consentTypeIdColumnValue.ClearChanged();
@updatedByPatientDateTimeColumnValue.ClearChanged();
}
}
public partial class @PaymentModification {
/// <summary>
/// Inserts a row into the Payment table. Returns the value of the PaymentID column.
/// </summary>
/// <param name="userID">Object allows null.</param>
/// <param name="paymentTypeID">Object allows null.</param>
/// <param name="paymentMethodID">Object allows null.</param>
/// <param name="total">Object allows null.</param>
/// <param name="created">Object allows null.</param>
/// <param name="lastModified">Object allows null.</param>
public static int InsertRow( System.Guid? @userID, System.Int32? @paymentTypeID, System.Int32? @paymentMethodID, System.Single? @total, System.DateTime? @created, System.DateTime? @lastModified ) { 
var mod = CreateForInsert();
mod.@userIDColumnValue.Value = @userID;
mod.@paymentTypeIDColumnValue.Value = @paymentTypeID;
mod.@paymentMethodIDColumnValue.Value = @paymentMethodID;
mod.@totalColumnValue.Value = @total;
mod.@createdColumnValue.Value = @created;
mod.@lastModifiedColumnValue.Value = @lastModified;
mod.Execute();
return mod.PaymentID;
}
/// <summary>
/// Inserts a row into the Payment table. Returns the value of the PaymentID column.
/// </summary>
/// <param name="userID">Object allows null.</param>
/// <param name="paymentTypeID">Object allows null.</param>
/// <param name="paymentMethodID">Object allows null.</param>
/// <param name="total">Object allows null.</param>
/// <param name="created">Object allows null.</param>
/// <param name="lastModified">Object allows null.</param>
public static int InsertRowWithoutAdditionalLogic( System.Guid? @userID, System.Int32? @paymentTypeID, System.Int32? @paymentMethodID, System.Single? @total, System.DateTime? @created, System.DateTime? @lastModified ) { 
var mod = CreateForInsert();
mod.@userIDColumnValue.Value = @userID;
mod.@paymentTypeIDColumnValue.Value = @paymentTypeID;
mod.@paymentMethodIDColumnValue.Value = @paymentMethodID;
mod.@totalColumnValue.Value = @total;
mod.@createdColumnValue.Value = @created;
mod.@lastModifiedColumnValue.Value = @lastModified;
mod.ExecuteWithoutAdditionalLogic();
return mod.PaymentID;
}
/// <summary>
/// Updates rows in the Payment table that match the specified conditions with the specified data.
/// </summary>
/// <param name="userID">Object allows null.</param>
/// <param name="paymentTypeID">Object allows null.</param>
/// <param name="paymentMethodID">Object allows null.</param>
/// <param name="total">Object allows null.</param>
/// <param name="created">Object allows null.</param>
/// <param name="lastModified">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( System.Guid? @userID, System.Int32? @paymentTypeID, System.Int32? @paymentMethodID, System.Single? @total, System.DateTime? @created, System.DateTime? @lastModified, CommandConditions.PaymentTableCondition requiredCondition, params CommandConditions.PaymentTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@userIDColumnValue.Value = @userID;
mod.@paymentTypeIDColumnValue.Value = @paymentTypeID;
mod.@paymentMethodIDColumnValue.Value = @paymentMethodID;
mod.@totalColumnValue.Value = @total;
mod.@createdColumnValue.Value = @created;
mod.@lastModifiedColumnValue.Value = @lastModified;
mod.Execute();
}
/// <summary>
/// Updates rows in the Payment table that match the specified conditions with the specified data.
/// </summary>
/// <param name="userID">Object allows null.</param>
/// <param name="paymentTypeID">Object allows null.</param>
/// <param name="paymentMethodID">Object allows null.</param>
/// <param name="total">Object allows null.</param>
/// <param name="created">Object allows null.</param>
/// <param name="lastModified">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( System.Guid? @userID, System.Int32? @paymentTypeID, System.Int32? @paymentMethodID, System.Single? @total, System.DateTime? @created, System.DateTime? @lastModified, CommandConditions.PaymentTableCondition requiredCondition, params CommandConditions.PaymentTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@userIDColumnValue.Value = @userID;
mod.@paymentTypeIDColumnValue.Value = @paymentTypeID;
mod.@paymentMethodIDColumnValue.Value = @paymentMethodID;
mod.@totalColumnValue.Value = @total;
mod.@createdColumnValue.Value = @created;
mod.@lastModifiedColumnValue.Value = @lastModified;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.PaymentTableCondition requiredCondition, params CommandConditions.PaymentTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@PaymentTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.PaymentTableCondition requiredCondition, params CommandConditions.PaymentTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.PaymentTableCondition> conditions ) {
var delete = new InlineDelete( "Payment" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.PaymentTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@PaymentTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.PaymentTableCondition> conditions;
private readonly DataValue<int> @paymentIDColumnValue = new DataValue<int>();
/// <summary>
/// Gets the value for the PaymentID column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @PaymentID { get { return @paymentIDColumnValue.Value; } }
private readonly DataValue<System.Guid?> @userIDColumnValue = new DataValue<System.Guid?>();
/// <summary>
/// Gets or sets the value for the UserID column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.Guid? @UserID { get { return @userIDColumnValue.Value; } set { @userIDColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the UserID has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @UserIDHasChanged { get { return @userIDColumnValue.Changed; } }
private readonly DataValue<System.Int32?> @paymentTypeIDColumnValue = new DataValue<System.Int32?>();
/// <summary>
/// Gets or sets the value for the PaymentTypeID column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.Int32? @PaymentTypeID { get { return @paymentTypeIDColumnValue.Value; } set { @paymentTypeIDColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PaymentTypeID has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PaymentTypeIDHasChanged { get { return @paymentTypeIDColumnValue.Changed; } }
private readonly DataValue<System.Int32?> @paymentMethodIDColumnValue = new DataValue<System.Int32?>();
/// <summary>
/// Gets or sets the value for the PaymentMethodID column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.Int32? @PaymentMethodID { get { return @paymentMethodIDColumnValue.Value; } set { @paymentMethodIDColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PaymentMethodID has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PaymentMethodIDHasChanged { get { return @paymentMethodIDColumnValue.Changed; } }
private readonly DataValue<System.Single?> @totalColumnValue = new DataValue<System.Single?>();
/// <summary>
/// Gets or sets the value for the Total column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.Single? @Total { get { return @totalColumnValue.Value; } set { @totalColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Total has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @TotalHasChanged { get { return @totalColumnValue.Changed; } }
private readonly DataValue<System.DateTime?> @createdColumnValue = new DataValue<System.DateTime?>();
/// <summary>
/// Gets or sets the value for the Created column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.DateTime? @Created { get { return @createdColumnValue.Value; } set { @createdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Created has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @CreatedHasChanged { get { return @createdColumnValue.Changed; } }
private readonly DataValue<System.DateTime?> @lastModifiedColumnValue = new DataValue<System.DateTime?>();
/// <summary>
/// Gets or sets the value for the LastModified column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.DateTime? @LastModified { get { return @lastModifiedColumnValue.Value; } set { @lastModifiedColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LastModified has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LastModifiedHasChanged { get { return @lastModifiedColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the Payment table.
/// </summary>
public static @PaymentModification CreateForInsert() {
return new @PaymentModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the Payment table.
/// </summary>
public static @PaymentModification CreateForUpdate( CommandConditions.PaymentTableCondition requiredCondition, params CommandConditions.PaymentTableCondition[] additionalConditions ) {
var mod = new @PaymentModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@PaymentTableEqualityConditions.@PaymentID )
mod.@paymentIDColumnValue.Value = ( condition as CommandConditions.@PaymentTableEqualityConditions.@PaymentID ).Value;
else if( condition is CommandConditions.@PaymentTableEqualityConditions.@UserID )
mod.@userIDColumnValue.Value = ( condition as CommandConditions.@PaymentTableEqualityConditions.@UserID ).Value;
else if( condition is CommandConditions.@PaymentTableEqualityConditions.@PaymentTypeID )
mod.@paymentTypeIDColumnValue.Value = ( condition as CommandConditions.@PaymentTableEqualityConditions.@PaymentTypeID ).Value;
else if( condition is CommandConditions.@PaymentTableEqualityConditions.@PaymentMethodID )
mod.@paymentMethodIDColumnValue.Value = ( condition as CommandConditions.@PaymentTableEqualityConditions.@PaymentMethodID ).Value;
else if( condition is CommandConditions.@PaymentTableEqualityConditions.@Total )
mod.@totalColumnValue.Value = ( condition as CommandConditions.@PaymentTableEqualityConditions.@Total ).Value;
else if( condition is CommandConditions.@PaymentTableEqualityConditions.@Created )
mod.@createdColumnValue.Value = ( condition as CommandConditions.@PaymentTableEqualityConditions.@Created ).Value;
else if( condition is CommandConditions.@PaymentTableEqualityConditions.@LastModified )
mod.@lastModifiedColumnValue.Value = ( condition as CommandConditions.@PaymentTableEqualityConditions.@LastModified ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the Payment table.
/// </summary>
public static @PaymentModification CreateForSingleRowUpdate( int @paymentID, System.Guid? @userID, System.Int32? @paymentTypeID, System.Int32? @paymentMethodID, System.Single? @total, System.DateTime? @created, System.DateTime? @lastModified ) {
var mod = new @PaymentModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.PaymentTableCondition>();
mod.conditions.Add( new CommandConditions.@PaymentTableEqualityConditions.@PaymentID( @paymentID ) );
mod.@paymentIDColumnValue.Value = @paymentID;
mod.@userIDColumnValue.Value = @userID;
mod.@paymentTypeIDColumnValue.Value = @paymentTypeID;
mod.@paymentMethodIDColumnValue.Value = @paymentMethodID;
mod.@totalColumnValue.Value = @total;
mod.@createdColumnValue.Value = @created;
mod.@lastModifiedColumnValue.Value = @lastModified;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.PaymentTableCondition> getConditionList( CommandConditions.PaymentTableCondition requiredCondition, params CommandConditions.PaymentTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.PaymentTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @PaymentModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="userID">Object allows null.</param>
/// <param name="paymentTypeID">Object allows null.</param>
/// <param name="paymentMethodID">Object allows null.</param>
/// <param name="total">Object allows null.</param>
/// <param name="created">Object allows null.</param>
/// <param name="lastModified">Object allows null.</param>
public void SetAllData( System.Guid? @userID, System.Int32? @paymentTypeID, System.Int32? @paymentMethodID, System.Single? @total, System.DateTime? @created, System.DateTime? @lastModified ) {
this.@userIDColumnValue.Value = @userID;
this.@paymentTypeIDColumnValue.Value = @paymentTypeID;
this.@paymentMethodIDColumnValue.Value = @paymentMethodID;
this.@totalColumnValue.Value = @total;
this.@createdColumnValue.Value = @created;
this.@lastModifiedColumnValue.Value = @lastModified;
}
/// <summary>
/// Executes this Payment modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this Payment modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "Payment" );
addColumnModifications( insert );
@paymentIDColumnValue.Value = (System.Int32)Utility.ChangeType( insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection ), typeof( System.Int32 ) );
modType = ModificationType.Update;
conditions = new List<CommandConditions.PaymentTableCondition>();
conditions.Add( new CommandConditions.@PaymentTableEqualityConditions.@PaymentID( @PaymentID ) );
}
else {
var update = new InlineUpdate( "Payment" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @userIDColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "UserID", new DbParameterValue( @UserID, "UniqueIdentifier" ) ) );
if( @paymentTypeIDColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PaymentTypeID", new DbParameterValue( @PaymentTypeID, "Int" ) ) );
if( @paymentMethodIDColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PaymentMethodID", new DbParameterValue( @PaymentMethodID, "Int" ) ) );
if( @totalColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Total", new DbParameterValue( @Total, "Real" ) ) );
if( @createdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Created", new DbParameterValue( @Created, "DateTime" ) ) );
if( @lastModifiedColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LastModified", new DbParameterValue( @LastModified, "DateTime" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@paymentIDColumnValue.ClearChanged();
@userIDColumnValue.ClearChanged();
@paymentTypeIDColumnValue.ClearChanged();
@paymentMethodIDColumnValue.ClearChanged();
@totalColumnValue.ClearChanged();
@createdColumnValue.ClearChanged();
@lastModifiedColumnValue.ClearChanged();
}
}
public partial class @PaymentMethodModification {
/// <summary>
/// Inserts a row into the PaymentMethod table. Returns the value of the MethodID column.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="enabled">Object allows null.</param>
/// <param name="created">Object allows null.</param>
/// <param name="lastModified">Object allows null.</param>
public static int InsertRow( string @name, System.Boolean? @enabled, System.DateTime? @created, System.DateTime? @lastModified ) { 
var mod = CreateForInsert();
mod.@nameColumnValue.Value = @name;
mod.@enabledColumnValue.Value = @enabled;
mod.@createdColumnValue.Value = @created;
mod.@lastModifiedColumnValue.Value = @lastModified;
mod.Execute();
return mod.MethodID;
}
/// <summary>
/// Inserts a row into the PaymentMethod table. Returns the value of the MethodID column.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="enabled">Object allows null.</param>
/// <param name="created">Object allows null.</param>
/// <param name="lastModified">Object allows null.</param>
public static int InsertRowWithoutAdditionalLogic( string @name, System.Boolean? @enabled, System.DateTime? @created, System.DateTime? @lastModified ) { 
var mod = CreateForInsert();
mod.@nameColumnValue.Value = @name;
mod.@enabledColumnValue.Value = @enabled;
mod.@createdColumnValue.Value = @created;
mod.@lastModifiedColumnValue.Value = @lastModified;
mod.ExecuteWithoutAdditionalLogic();
return mod.MethodID;
}
/// <summary>
/// Updates rows in the PaymentMethod table that match the specified conditions with the specified data.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="enabled">Object allows null.</param>
/// <param name="created">Object allows null.</param>
/// <param name="lastModified">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( string @name, System.Boolean? @enabled, System.DateTime? @created, System.DateTime? @lastModified, CommandConditions.PaymentMethodTableCondition requiredCondition, params CommandConditions.PaymentMethodTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@nameColumnValue.Value = @name;
mod.@enabledColumnValue.Value = @enabled;
mod.@createdColumnValue.Value = @created;
mod.@lastModifiedColumnValue.Value = @lastModified;
mod.Execute();
}
/// <summary>
/// Updates rows in the PaymentMethod table that match the specified conditions with the specified data.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="enabled">Object allows null.</param>
/// <param name="created">Object allows null.</param>
/// <param name="lastModified">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( string @name, System.Boolean? @enabled, System.DateTime? @created, System.DateTime? @lastModified, CommandConditions.PaymentMethodTableCondition requiredCondition, params CommandConditions.PaymentMethodTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@nameColumnValue.Value = @name;
mod.@enabledColumnValue.Value = @enabled;
mod.@createdColumnValue.Value = @created;
mod.@lastModifiedColumnValue.Value = @lastModified;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.PaymentMethodTableCondition requiredCondition, params CommandConditions.PaymentMethodTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@PaymentMethodTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.PaymentMethodTableCondition requiredCondition, params CommandConditions.PaymentMethodTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.PaymentMethodTableCondition> conditions ) {
var delete = new InlineDelete( "PaymentMethod" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.PaymentMethodTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@PaymentMethodTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.PaymentMethodTableCondition> conditions;
private readonly DataValue<int> @methodIDColumnValue = new DataValue<int>();
/// <summary>
/// Gets the value for the MethodID column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @MethodID { get { return @methodIDColumnValue.Value; } }
private readonly DataValue<string> @nameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Name column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Name { get { return @nameColumnValue.Value; } set { @nameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Name has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @NameHasChanged { get { return @nameColumnValue.Changed; } }
private readonly DataValue<System.Boolean?> @enabledColumnValue = new DataValue<System.Boolean?>();
/// <summary>
/// Gets or sets the value for the Enabled column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.Boolean? @Enabled { get { return @enabledColumnValue.Value; } set { @enabledColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Enabled has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EnabledHasChanged { get { return @enabledColumnValue.Changed; } }
private readonly DataValue<System.DateTime?> @createdColumnValue = new DataValue<System.DateTime?>();
/// <summary>
/// Gets or sets the value for the Created column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.DateTime? @Created { get { return @createdColumnValue.Value; } set { @createdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Created has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @CreatedHasChanged { get { return @createdColumnValue.Changed; } }
private readonly DataValue<System.DateTime?> @lastModifiedColumnValue = new DataValue<System.DateTime?>();
/// <summary>
/// Gets or sets the value for the LastModified column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.DateTime? @LastModified { get { return @lastModifiedColumnValue.Value; } set { @lastModifiedColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LastModified has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LastModifiedHasChanged { get { return @lastModifiedColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the PaymentMethod table.
/// </summary>
public static @PaymentMethodModification CreateForInsert() {
return new @PaymentMethodModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the PaymentMethod table.
/// </summary>
public static @PaymentMethodModification CreateForUpdate( CommandConditions.PaymentMethodTableCondition requiredCondition, params CommandConditions.PaymentMethodTableCondition[] additionalConditions ) {
var mod = new @PaymentMethodModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@PaymentMethodTableEqualityConditions.@MethodID )
mod.@methodIDColumnValue.Value = ( condition as CommandConditions.@PaymentMethodTableEqualityConditions.@MethodID ).Value;
else if( condition is CommandConditions.@PaymentMethodTableEqualityConditions.@Name )
mod.@nameColumnValue.Value = ( condition as CommandConditions.@PaymentMethodTableEqualityConditions.@Name ).Value;
else if( condition is CommandConditions.@PaymentMethodTableEqualityConditions.@Enabled )
mod.@enabledColumnValue.Value = ( condition as CommandConditions.@PaymentMethodTableEqualityConditions.@Enabled ).Value;
else if( condition is CommandConditions.@PaymentMethodTableEqualityConditions.@Created )
mod.@createdColumnValue.Value = ( condition as CommandConditions.@PaymentMethodTableEqualityConditions.@Created ).Value;
else if( condition is CommandConditions.@PaymentMethodTableEqualityConditions.@LastModified )
mod.@lastModifiedColumnValue.Value = ( condition as CommandConditions.@PaymentMethodTableEqualityConditions.@LastModified ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the PaymentMethod table.
/// </summary>
public static @PaymentMethodModification CreateForSingleRowUpdate( int @methodID, string @name, System.Boolean? @enabled, System.DateTime? @created, System.DateTime? @lastModified ) {
var mod = new @PaymentMethodModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.PaymentMethodTableCondition>();
mod.conditions.Add( new CommandConditions.@PaymentMethodTableEqualityConditions.@MethodID( @methodID ) );
mod.@methodIDColumnValue.Value = @methodID;
mod.@nameColumnValue.Value = @name;
mod.@enabledColumnValue.Value = @enabled;
mod.@createdColumnValue.Value = @created;
mod.@lastModifiedColumnValue.Value = @lastModified;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.PaymentMethodTableCondition> getConditionList( CommandConditions.PaymentMethodTableCondition requiredCondition, params CommandConditions.PaymentMethodTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.PaymentMethodTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @PaymentMethodModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="enabled">Object allows null.</param>
/// <param name="created">Object allows null.</param>
/// <param name="lastModified">Object allows null.</param>
public void SetAllData( string @name, System.Boolean? @enabled, System.DateTime? @created, System.DateTime? @lastModified ) {
this.@nameColumnValue.Value = @name;
this.@enabledColumnValue.Value = @enabled;
this.@createdColumnValue.Value = @created;
this.@lastModifiedColumnValue.Value = @lastModified;
}
/// <summary>
/// Executes this PaymentMethod modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this PaymentMethod modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "PaymentMethod" );
addColumnModifications( insert );
@methodIDColumnValue.Value = (System.Int32)Utility.ChangeType( insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection ), typeof( System.Int32 ) );
modType = ModificationType.Update;
conditions = new List<CommandConditions.PaymentMethodTableCondition>();
conditions.Add( new CommandConditions.@PaymentMethodTableEqualityConditions.@MethodID( @MethodID ) );
}
else {
var update = new InlineUpdate( "PaymentMethod" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @nameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Name", new DbParameterValue( @Name, "NVarChar" ) ) );
if( @enabledColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Enabled", new DbParameterValue( @Enabled, "Bit" ) ) );
if( @createdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Created", new DbParameterValue( @Created, "DateTime" ) ) );
if( @lastModifiedColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LastModified", new DbParameterValue( @LastModified, "DateTime" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@methodIDColumnValue.ClearChanged();
@nameColumnValue.ClearChanged();
@enabledColumnValue.ClearChanged();
@createdColumnValue.ClearChanged();
@lastModifiedColumnValue.ClearChanged();
}
}
public partial class @PaymentTypeModification {
/// <summary>
/// Inserts a row into the PaymentType table. Returns the value of the TypeID column.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="price">Object allows null.</param>
/// <param name="created">Object allows null.</param>
/// <param name="lastUpdated">Object allows null.</param>
public static int InsertRow( string @name, System.Single? @price, System.DateTime? @created, System.DateTime? @lastUpdated ) { 
var mod = CreateForInsert();
mod.@nameColumnValue.Value = @name;
mod.@priceColumnValue.Value = @price;
mod.@createdColumnValue.Value = @created;
mod.@lastUpdatedColumnValue.Value = @lastUpdated;
mod.Execute();
return mod.TypeID;
}
/// <summary>
/// Inserts a row into the PaymentType table. Returns the value of the TypeID column.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="price">Object allows null.</param>
/// <param name="created">Object allows null.</param>
/// <param name="lastUpdated">Object allows null.</param>
public static int InsertRowWithoutAdditionalLogic( string @name, System.Single? @price, System.DateTime? @created, System.DateTime? @lastUpdated ) { 
var mod = CreateForInsert();
mod.@nameColumnValue.Value = @name;
mod.@priceColumnValue.Value = @price;
mod.@createdColumnValue.Value = @created;
mod.@lastUpdatedColumnValue.Value = @lastUpdated;
mod.ExecuteWithoutAdditionalLogic();
return mod.TypeID;
}
/// <summary>
/// Updates rows in the PaymentType table that match the specified conditions with the specified data.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="price">Object allows null.</param>
/// <param name="created">Object allows null.</param>
/// <param name="lastUpdated">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( string @name, System.Single? @price, System.DateTime? @created, System.DateTime? @lastUpdated, CommandConditions.PaymentTypeTableCondition requiredCondition, params CommandConditions.PaymentTypeTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@nameColumnValue.Value = @name;
mod.@priceColumnValue.Value = @price;
mod.@createdColumnValue.Value = @created;
mod.@lastUpdatedColumnValue.Value = @lastUpdated;
mod.Execute();
}
/// <summary>
/// Updates rows in the PaymentType table that match the specified conditions with the specified data.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="price">Object allows null.</param>
/// <param name="created">Object allows null.</param>
/// <param name="lastUpdated">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( string @name, System.Single? @price, System.DateTime? @created, System.DateTime? @lastUpdated, CommandConditions.PaymentTypeTableCondition requiredCondition, params CommandConditions.PaymentTypeTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@nameColumnValue.Value = @name;
mod.@priceColumnValue.Value = @price;
mod.@createdColumnValue.Value = @created;
mod.@lastUpdatedColumnValue.Value = @lastUpdated;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.PaymentTypeTableCondition requiredCondition, params CommandConditions.PaymentTypeTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@PaymentTypeTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.PaymentTypeTableCondition requiredCondition, params CommandConditions.PaymentTypeTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.PaymentTypeTableCondition> conditions ) {
var delete = new InlineDelete( "PaymentType" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.PaymentTypeTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@PaymentTypeTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.PaymentTypeTableCondition> conditions;
private readonly DataValue<int> @typeIDColumnValue = new DataValue<int>();
/// <summary>
/// Gets the value for the TypeID column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @TypeID { get { return @typeIDColumnValue.Value; } }
private readonly DataValue<string> @nameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Name column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Name { get { return @nameColumnValue.Value; } set { @nameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Name has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @NameHasChanged { get { return @nameColumnValue.Changed; } }
private readonly DataValue<System.Single?> @priceColumnValue = new DataValue<System.Single?>();
/// <summary>
/// Gets or sets the value for the Price column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.Single? @Price { get { return @priceColumnValue.Value; } set { @priceColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Price has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PriceHasChanged { get { return @priceColumnValue.Changed; } }
private readonly DataValue<System.DateTime?> @createdColumnValue = new DataValue<System.DateTime?>();
/// <summary>
/// Gets or sets the value for the Created column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.DateTime? @Created { get { return @createdColumnValue.Value; } set { @createdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Created has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @CreatedHasChanged { get { return @createdColumnValue.Changed; } }
private readonly DataValue<System.DateTime?> @lastUpdatedColumnValue = new DataValue<System.DateTime?>();
/// <summary>
/// Gets or sets the value for the LastUpdated column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.DateTime? @LastUpdated { get { return @lastUpdatedColumnValue.Value; } set { @lastUpdatedColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LastUpdated has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LastUpdatedHasChanged { get { return @lastUpdatedColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the PaymentType table.
/// </summary>
public static @PaymentTypeModification CreateForInsert() {
return new @PaymentTypeModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the PaymentType table.
/// </summary>
public static @PaymentTypeModification CreateForUpdate( CommandConditions.PaymentTypeTableCondition requiredCondition, params CommandConditions.PaymentTypeTableCondition[] additionalConditions ) {
var mod = new @PaymentTypeModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@PaymentTypeTableEqualityConditions.@TypeID )
mod.@typeIDColumnValue.Value = ( condition as CommandConditions.@PaymentTypeTableEqualityConditions.@TypeID ).Value;
else if( condition is CommandConditions.@PaymentTypeTableEqualityConditions.@Name )
mod.@nameColumnValue.Value = ( condition as CommandConditions.@PaymentTypeTableEqualityConditions.@Name ).Value;
else if( condition is CommandConditions.@PaymentTypeTableEqualityConditions.@Price )
mod.@priceColumnValue.Value = ( condition as CommandConditions.@PaymentTypeTableEqualityConditions.@Price ).Value;
else if( condition is CommandConditions.@PaymentTypeTableEqualityConditions.@Created )
mod.@createdColumnValue.Value = ( condition as CommandConditions.@PaymentTypeTableEqualityConditions.@Created ).Value;
else if( condition is CommandConditions.@PaymentTypeTableEqualityConditions.@LastUpdated )
mod.@lastUpdatedColumnValue.Value = ( condition as CommandConditions.@PaymentTypeTableEqualityConditions.@LastUpdated ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the PaymentType table.
/// </summary>
public static @PaymentTypeModification CreateForSingleRowUpdate( int @typeID, string @name, System.Single? @price, System.DateTime? @created, System.DateTime? @lastUpdated ) {
var mod = new @PaymentTypeModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.PaymentTypeTableCondition>();
mod.conditions.Add( new CommandConditions.@PaymentTypeTableEqualityConditions.@TypeID( @typeID ) );
mod.@typeIDColumnValue.Value = @typeID;
mod.@nameColumnValue.Value = @name;
mod.@priceColumnValue.Value = @price;
mod.@createdColumnValue.Value = @created;
mod.@lastUpdatedColumnValue.Value = @lastUpdated;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.PaymentTypeTableCondition> getConditionList( CommandConditions.PaymentTypeTableCondition requiredCondition, params CommandConditions.PaymentTypeTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.PaymentTypeTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @PaymentTypeModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="price">Object allows null.</param>
/// <param name="created">Object allows null.</param>
/// <param name="lastUpdated">Object allows null.</param>
public void SetAllData( string @name, System.Single? @price, System.DateTime? @created, System.DateTime? @lastUpdated ) {
this.@nameColumnValue.Value = @name;
this.@priceColumnValue.Value = @price;
this.@createdColumnValue.Value = @created;
this.@lastUpdatedColumnValue.Value = @lastUpdated;
}
/// <summary>
/// Executes this PaymentType modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this PaymentType modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "PaymentType" );
addColumnModifications( insert );
@typeIDColumnValue.Value = (System.Int32)Utility.ChangeType( insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection ), typeof( System.Int32 ) );
modType = ModificationType.Update;
conditions = new List<CommandConditions.PaymentTypeTableCondition>();
conditions.Add( new CommandConditions.@PaymentTypeTableEqualityConditions.@TypeID( @TypeID ) );
}
else {
var update = new InlineUpdate( "PaymentType" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @nameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Name", new DbParameterValue( @Name, "NVarChar" ) ) );
if( @priceColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Price", new DbParameterValue( @Price, "Real" ) ) );
if( @createdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Created", new DbParameterValue( @Created, "DateTime" ) ) );
if( @lastUpdatedColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LastUpdated", new DbParameterValue( @LastUpdated, "DateTime" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@typeIDColumnValue.ClearChanged();
@nameColumnValue.ClearChanged();
@priceColumnValue.ClearChanged();
@createdColumnValue.ClearChanged();
@lastUpdatedColumnValue.ClearChanged();
}
}
public partial class @PerfLogModification {
/// <summary>
/// Inserts a row into the PerfLog table. Returns the value of the PerfLogID column.
/// </summary>
/// <param name="tStamp">Object does not allow null.</param>
/// <param name="category">Object does not allow null.</param>
/// <param name="code">Object does not allow null.</param>
/// <param name="elapsedTime">Object does not allow null.</param>
/// <param name="units">Object does not allow null.</param>
/// <param name="isTest">Object does not allow null.</param>
/// <param name="factor1">Object allows null.</param>
public static int InsertRow( DateTime @tStamp, string @category, string @code, decimal @elapsedTime, string @units, System.Boolean @isTest, System.Decimal? @factor1 ) { 
var mod = CreateForInsert();
mod.@tStampColumnValue.Value = @tStamp;
mod.@categoryColumnValue.Value = @category;
mod.@codeColumnValue.Value = @code;
mod.@elapsedTimeColumnValue.Value = @elapsedTime;
mod.@unitsColumnValue.Value = @units;
mod.@isTestColumnValue.Value = @isTest;
mod.@factor1ColumnValue.Value = @factor1;
mod.Execute();
return mod.PerfLogID;
}
/// <summary>
/// Inserts a row into the PerfLog table. Returns the value of the PerfLogID column.
/// </summary>
/// <param name="tStamp">Object does not allow null.</param>
/// <param name="category">Object does not allow null.</param>
/// <param name="code">Object does not allow null.</param>
/// <param name="elapsedTime">Object does not allow null.</param>
/// <param name="units">Object does not allow null.</param>
/// <param name="isTest">Object does not allow null.</param>
/// <param name="factor1">Object allows null.</param>
public static int InsertRowWithoutAdditionalLogic( DateTime @tStamp, string @category, string @code, decimal @elapsedTime, string @units, System.Boolean @isTest, System.Decimal? @factor1 ) { 
var mod = CreateForInsert();
mod.@tStampColumnValue.Value = @tStamp;
mod.@categoryColumnValue.Value = @category;
mod.@codeColumnValue.Value = @code;
mod.@elapsedTimeColumnValue.Value = @elapsedTime;
mod.@unitsColumnValue.Value = @units;
mod.@isTestColumnValue.Value = @isTest;
mod.@factor1ColumnValue.Value = @factor1;
mod.ExecuteWithoutAdditionalLogic();
return mod.PerfLogID;
}
/// <summary>
/// Updates rows in the PerfLog table that match the specified conditions with the specified data.
/// </summary>
/// <param name="tStamp">Object does not allow null.</param>
/// <param name="category">Object does not allow null.</param>
/// <param name="code">Object does not allow null.</param>
/// <param name="elapsedTime">Object does not allow null.</param>
/// <param name="units">Object does not allow null.</param>
/// <param name="isTest">Object does not allow null.</param>
/// <param name="factor1">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( DateTime @tStamp, string @category, string @code, decimal @elapsedTime, string @units, System.Boolean @isTest, System.Decimal? @factor1, CommandConditions.PerfLogTableCondition requiredCondition, params CommandConditions.PerfLogTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@tStampColumnValue.Value = @tStamp;
mod.@categoryColumnValue.Value = @category;
mod.@codeColumnValue.Value = @code;
mod.@elapsedTimeColumnValue.Value = @elapsedTime;
mod.@unitsColumnValue.Value = @units;
mod.@isTestColumnValue.Value = @isTest;
mod.@factor1ColumnValue.Value = @factor1;
mod.Execute();
}
/// <summary>
/// Updates rows in the PerfLog table that match the specified conditions with the specified data.
/// </summary>
/// <param name="tStamp">Object does not allow null.</param>
/// <param name="category">Object does not allow null.</param>
/// <param name="code">Object does not allow null.</param>
/// <param name="elapsedTime">Object does not allow null.</param>
/// <param name="units">Object does not allow null.</param>
/// <param name="isTest">Object does not allow null.</param>
/// <param name="factor1">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( DateTime @tStamp, string @category, string @code, decimal @elapsedTime, string @units, System.Boolean @isTest, System.Decimal? @factor1, CommandConditions.PerfLogTableCondition requiredCondition, params CommandConditions.PerfLogTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@tStampColumnValue.Value = @tStamp;
mod.@categoryColumnValue.Value = @category;
mod.@codeColumnValue.Value = @code;
mod.@elapsedTimeColumnValue.Value = @elapsedTime;
mod.@unitsColumnValue.Value = @units;
mod.@isTestColumnValue.Value = @isTest;
mod.@factor1ColumnValue.Value = @factor1;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.PerfLogTableCondition requiredCondition, params CommandConditions.PerfLogTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@PerfLogTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.PerfLogTableCondition requiredCondition, params CommandConditions.PerfLogTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.PerfLogTableCondition> conditions ) {
var delete = new InlineDelete( "PerfLog" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.PerfLogTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@PerfLogTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.PerfLogTableCondition> conditions;
private readonly DataValue<int> @perfLogIDColumnValue = new DataValue<int>();
/// <summary>
/// Gets the value for the PerfLogID column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @PerfLogID { get { return @perfLogIDColumnValue.Value; } }
private readonly DataValue<DateTime> @tStampColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the TStamp column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @TStamp { get { return @tStampColumnValue.Value; } set { @tStampColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the TStamp has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @TStampHasChanged { get { return @tStampColumnValue.Changed; } }
private readonly DataValue<string> @categoryColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Category column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Category { get { return @categoryColumnValue.Value; } set { @categoryColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Category has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @CategoryHasChanged { get { return @categoryColumnValue.Changed; } }
private readonly DataValue<string> @codeColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Code column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Code { get { return @codeColumnValue.Value; } set { @codeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Code has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @CodeHasChanged { get { return @codeColumnValue.Changed; } }
private readonly DataValue<decimal> @elapsedTimeColumnValue = new DataValue<decimal>();
/// <summary>
/// Gets or sets the value for the ElapsedTime column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public decimal @ElapsedTime { get { return @elapsedTimeColumnValue.Value; } set { @elapsedTimeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ElapsedTime has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ElapsedTimeHasChanged { get { return @elapsedTimeColumnValue.Changed; } }
private readonly DataValue<string> @unitsColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Units column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Units { get { return @unitsColumnValue.Value; } set { @unitsColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Units has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @UnitsHasChanged { get { return @unitsColumnValue.Changed; } }
private readonly DataValue<System.Boolean> @isTestColumnValue = new DataValue<System.Boolean>();
/// <summary>
/// Gets or sets the value for the IsTest column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Boolean @IsTest { get { return @isTestColumnValue.Value; } set { @isTestColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the IsTest has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @IsTestHasChanged { get { return @isTestColumnValue.Changed; } }
private readonly DataValue<System.Decimal?> @factor1ColumnValue = new DataValue<System.Decimal?>();
/// <summary>
/// Gets or sets the value for the Factor1 column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.Decimal? @Factor1 { get { return @factor1ColumnValue.Value; } set { @factor1ColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Factor1 has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @Factor1HasChanged { get { return @factor1ColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the PerfLog table.
/// </summary>
public static @PerfLogModification CreateForInsert() {
return new @PerfLogModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the PerfLog table.
/// </summary>
public static @PerfLogModification CreateForUpdate( CommandConditions.PerfLogTableCondition requiredCondition, params CommandConditions.PerfLogTableCondition[] additionalConditions ) {
var mod = new @PerfLogModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@PerfLogTableEqualityConditions.@PerfLogID )
mod.@perfLogIDColumnValue.Value = ( condition as CommandConditions.@PerfLogTableEqualityConditions.@PerfLogID ).Value;
else if( condition is CommandConditions.@PerfLogTableEqualityConditions.@TStamp )
mod.@tStampColumnValue.Value = ( condition as CommandConditions.@PerfLogTableEqualityConditions.@TStamp ).Value;
else if( condition is CommandConditions.@PerfLogTableEqualityConditions.@Category )
mod.@categoryColumnValue.Value = ( condition as CommandConditions.@PerfLogTableEqualityConditions.@Category ).Value;
else if( condition is CommandConditions.@PerfLogTableEqualityConditions.@Code )
mod.@codeColumnValue.Value = ( condition as CommandConditions.@PerfLogTableEqualityConditions.@Code ).Value;
else if( condition is CommandConditions.@PerfLogTableEqualityConditions.@ElapsedTime )
mod.@elapsedTimeColumnValue.Value = ( condition as CommandConditions.@PerfLogTableEqualityConditions.@ElapsedTime ).Value;
else if( condition is CommandConditions.@PerfLogTableEqualityConditions.@Units )
mod.@unitsColumnValue.Value = ( condition as CommandConditions.@PerfLogTableEqualityConditions.@Units ).Value;
else if( condition is CommandConditions.@PerfLogTableEqualityConditions.@IsTest )
mod.@isTestColumnValue.Value = ( condition as CommandConditions.@PerfLogTableEqualityConditions.@IsTest ).Value;
else if( condition is CommandConditions.@PerfLogTableEqualityConditions.@Factor1 )
mod.@factor1ColumnValue.Value = ( condition as CommandConditions.@PerfLogTableEqualityConditions.@Factor1 ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the PerfLog table.
/// </summary>
public static @PerfLogModification CreateForSingleRowUpdate( int @perfLogID, DateTime @tStamp, string @category, string @code, decimal @elapsedTime, string @units, System.Boolean @isTest, System.Decimal? @factor1 ) {
var mod = new @PerfLogModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.PerfLogTableCondition>();
mod.conditions.Add( new CommandConditions.@PerfLogTableEqualityConditions.@PerfLogID( @perfLogID ) );
mod.@perfLogIDColumnValue.Value = @perfLogID;
mod.@tStampColumnValue.Value = @tStamp;
mod.@categoryColumnValue.Value = @category;
mod.@codeColumnValue.Value = @code;
mod.@elapsedTimeColumnValue.Value = @elapsedTime;
mod.@unitsColumnValue.Value = @units;
mod.@isTestColumnValue.Value = @isTest;
mod.@factor1ColumnValue.Value = @factor1;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.PerfLogTableCondition> getConditionList( CommandConditions.PerfLogTableCondition requiredCondition, params CommandConditions.PerfLogTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.PerfLogTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @PerfLogModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="tStamp">Object does not allow null.</param>
/// <param name="category">Object does not allow null.</param>
/// <param name="code">Object does not allow null.</param>
/// <param name="elapsedTime">Object does not allow null.</param>
/// <param name="units">Object does not allow null.</param>
/// <param name="isTest">Object does not allow null.</param>
/// <param name="factor1">Object allows null.</param>
public void SetAllData( DateTime @tStamp, string @category, string @code, decimal @elapsedTime, string @units, System.Boolean @isTest, System.Decimal? @factor1 ) {
this.@tStampColumnValue.Value = @tStamp;
this.@categoryColumnValue.Value = @category;
this.@codeColumnValue.Value = @code;
this.@elapsedTimeColumnValue.Value = @elapsedTime;
this.@unitsColumnValue.Value = @units;
this.@isTestColumnValue.Value = @isTest;
this.@factor1ColumnValue.Value = @factor1;
}
/// <summary>
/// Executes this PerfLog modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this PerfLog modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "PerfLog" );
addColumnModifications( insert );
@perfLogIDColumnValue.Value = (System.Int32)Utility.ChangeType( insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection ), typeof( System.Int32 ) );
modType = ModificationType.Update;
conditions = new List<CommandConditions.PerfLogTableCondition>();
conditions.Add( new CommandConditions.@PerfLogTableEqualityConditions.@PerfLogID( @PerfLogID ) );
}
else {
var update = new InlineUpdate( "PerfLog" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @tStampColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "TStamp", new DbParameterValue( @TStamp, "DateTime" ) ) );
if( @categoryColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Category", new DbParameterValue( @Category, "NVarChar" ) ) );
if( @codeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Code", new DbParameterValue( @Code, "NVarChar" ) ) );
if( @elapsedTimeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ElapsedTime", new DbParameterValue( @ElapsedTime, "Decimal" ) ) );
if( @unitsColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Units", new DbParameterValue( @Units, "NVarChar" ) ) );
if( @isTestColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "IsTest", new DbParameterValue( @IsTest, "Bit" ) ) );
if( @factor1ColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Factor1", new DbParameterValue( @Factor1, "Decimal" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@perfLogIDColumnValue.ClearChanged();
@tStampColumnValue.ClearChanged();
@categoryColumnValue.ClearChanged();
@codeColumnValue.ClearChanged();
@elapsedTimeColumnValue.ClearChanged();
@unitsColumnValue.ClearChanged();
@isTestColumnValue.ClearChanged();
@factor1ColumnValue.ClearChanged();
}
}
public partial class @PhrStatusesModification {
/// <summary>
/// Inserts a row into the PhrStatuses table.
/// </summary>
/// <param name="phrStatusId">Object does not allow null.</param>
/// <param name="phrStatus">Object does not allow null.</param>
public static void InsertRow( int @phrStatusId, string @phrStatus ) { 
var mod = CreateForInsert();
mod.@phrStatusIdColumnValue.Value = @phrStatusId;
mod.@phrStatusColumnValue.Value = @phrStatus;
mod.Execute();
}
/// <summary>
/// Inserts a row into the PhrStatuses table.
/// </summary>
/// <param name="phrStatusId">Object does not allow null.</param>
/// <param name="phrStatus">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @phrStatusId, string @phrStatus ) { 
var mod = CreateForInsert();
mod.@phrStatusIdColumnValue.Value = @phrStatusId;
mod.@phrStatusColumnValue.Value = @phrStatus;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the PhrStatuses table that match the specified conditions with the specified data.
/// </summary>
/// <param name="phrStatusId">Object does not allow null.</param>
/// <param name="phrStatus">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @phrStatusId, string @phrStatus, CommandConditions.PhrStatusesTableCondition requiredCondition, params CommandConditions.PhrStatusesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@phrStatusIdColumnValue.Value = @phrStatusId;
mod.@phrStatusColumnValue.Value = @phrStatus;
mod.Execute();
}
/// <summary>
/// Updates rows in the PhrStatuses table that match the specified conditions with the specified data.
/// </summary>
/// <param name="phrStatusId">Object does not allow null.</param>
/// <param name="phrStatus">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @phrStatusId, string @phrStatus, CommandConditions.PhrStatusesTableCondition requiredCondition, params CommandConditions.PhrStatusesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@phrStatusIdColumnValue.Value = @phrStatusId;
mod.@phrStatusColumnValue.Value = @phrStatus;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.PhrStatusesTableCondition requiredCondition, params CommandConditions.PhrStatusesTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@PhrStatusesTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.PhrStatusesTableCondition requiredCondition, params CommandConditions.PhrStatusesTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.PhrStatusesTableCondition> conditions ) {
var delete = new InlineDelete( "PhrStatuses" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.PhrStatusesTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@PhrStatusesTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.PhrStatusesTableCondition> conditions;
private readonly DataValue<int> @phrStatusIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the PhrStatusId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @PhrStatusId { get { return @phrStatusIdColumnValue.Value; } set { @phrStatusIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PhrStatusId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PhrStatusIdHasChanged { get { return @phrStatusIdColumnValue.Changed; } }
private readonly DataValue<string> @phrStatusColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the PhrStatus column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @PhrStatus { get { return @phrStatusColumnValue.Value; } set { @phrStatusColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PhrStatus has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PhrStatusHasChanged { get { return @phrStatusColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the PhrStatuses table.
/// </summary>
public static @PhrStatusesModification CreateForInsert() {
return new @PhrStatusesModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the PhrStatuses table.
/// </summary>
public static @PhrStatusesModification CreateForUpdate( CommandConditions.PhrStatusesTableCondition requiredCondition, params CommandConditions.PhrStatusesTableCondition[] additionalConditions ) {
var mod = new @PhrStatusesModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@PhrStatusesTableEqualityConditions.@PhrStatusId )
mod.@phrStatusIdColumnValue.Value = ( condition as CommandConditions.@PhrStatusesTableEqualityConditions.@PhrStatusId ).Value;
else if( condition is CommandConditions.@PhrStatusesTableEqualityConditions.@PhrStatus )
mod.@phrStatusColumnValue.Value = ( condition as CommandConditions.@PhrStatusesTableEqualityConditions.@PhrStatus ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the PhrStatuses table.
/// </summary>
public static @PhrStatusesModification CreateForSingleRowUpdate( int @phrStatusId, string @phrStatus ) {
var mod = new @PhrStatusesModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.PhrStatusesTableCondition>();
mod.conditions.Add( new CommandConditions.@PhrStatusesTableEqualityConditions.@PhrStatusId( @phrStatusId ) );
mod.@phrStatusIdColumnValue.Value = @phrStatusId;
mod.@phrStatusColumnValue.Value = @phrStatus;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.PhrStatusesTableCondition> getConditionList( CommandConditions.PhrStatusesTableCondition requiredCondition, params CommandConditions.PhrStatusesTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.PhrStatusesTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @PhrStatusesModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="phrStatusId">Object does not allow null.</param>
/// <param name="phrStatus">Object does not allow null.</param>
public void SetAllData( int @phrStatusId, string @phrStatus ) {
this.@phrStatusIdColumnValue.Value = @phrStatusId;
this.@phrStatusColumnValue.Value = @phrStatus;
}
/// <summary>
/// Executes this PhrStatuses modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this PhrStatuses modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "PhrStatuses" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.PhrStatusesTableCondition>();
conditions.Add( new CommandConditions.@PhrStatusesTableEqualityConditions.@PhrStatusId( @PhrStatusId ) );
}
else {
var update = new InlineUpdate( "PhrStatuses" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @phrStatusIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PhrStatusId", new DbParameterValue( @PhrStatusId, "Int" ) ) );
if( @phrStatusColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PhrStatus", new DbParameterValue( @PhrStatus, "VarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@phrStatusIdColumnValue.ClearChanged();
@phrStatusColumnValue.ClearChanged();
}
}
public partial class @PhysicianModification {
/// <summary>
/// Inserts a row into the Physician table. Returns the value of the PhysicianID column.
/// </summary>
/// <param name="externalID">Object does not allow null.</param>
/// <param name="specialtyID">Object does not allow null.</param>
/// <param name="workGroupID">Object does not allow null.</param>
/// <param name="firstName">Object does not allow null.</param>
/// <param name="lastName">Object does not allow null.</param>
/// <param name="middleInitial">Object does not allow null.</param>
/// <param name="company">Object does not allow null.</param>
/// <param name="address">Object does not allow null.</param>
/// <param name="city">Object does not allow null.</param>
/// <param name="state">Object does not allow null.</param>
/// <param name="zip">Object does not allow null.</param>
/// <param name="phone">Object does not allow null.</param>
/// <param name="lastUpdated">Object does not allow null.</param>
/// <param name="created">Object does not allow null.</param>
/// <param name="hidden">Object does not allow null.</param>
/// <param name="providerNPI">Object does not allow null.</param>
/// <param name="workgroupLocationId">Object allows null.</param>
public static int InsertRow( string @externalID, int @specialtyID, int @workGroupID, string @firstName, string @lastName, string @middleInitial, string @company, string @address, string @city, string @state, string @zip, string @phone, DateTime @lastUpdated, DateTime @created, System.Boolean @hidden, string @providerNPI, System.Int32? @workgroupLocationId ) { 
var mod = CreateForInsert();
mod.@externalIDColumnValue.Value = @externalID;
mod.@specialtyIDColumnValue.Value = @specialtyID;
mod.@workGroupIDColumnValue.Value = @workGroupID;
mod.@firstNameColumnValue.Value = @firstName;
mod.@lastNameColumnValue.Value = @lastName;
mod.@middleInitialColumnValue.Value = @middleInitial;
mod.@companyColumnValue.Value = @company;
mod.@addressColumnValue.Value = @address;
mod.@cityColumnValue.Value = @city;
mod.@stateColumnValue.Value = @state;
mod.@zipColumnValue.Value = @zip;
mod.@phoneColumnValue.Value = @phone;
mod.@lastUpdatedColumnValue.Value = @lastUpdated;
mod.@createdColumnValue.Value = @created;
mod.@hiddenColumnValue.Value = @hidden;
mod.@providerNPIColumnValue.Value = @providerNPI;
mod.@workgroupLocationIdColumnValue.Value = @workgroupLocationId;
mod.Execute();
return mod.PhysicianID;
}
/// <summary>
/// Inserts a row into the Physician table. Returns the value of the PhysicianID column.
/// </summary>
/// <param name="externalID">Object does not allow null.</param>
/// <param name="specialtyID">Object does not allow null.</param>
/// <param name="workGroupID">Object does not allow null.</param>
/// <param name="firstName">Object does not allow null.</param>
/// <param name="lastName">Object does not allow null.</param>
/// <param name="middleInitial">Object does not allow null.</param>
/// <param name="company">Object does not allow null.</param>
/// <param name="address">Object does not allow null.</param>
/// <param name="city">Object does not allow null.</param>
/// <param name="state">Object does not allow null.</param>
/// <param name="zip">Object does not allow null.</param>
/// <param name="phone">Object does not allow null.</param>
/// <param name="lastUpdated">Object does not allow null.</param>
/// <param name="created">Object does not allow null.</param>
/// <param name="hidden">Object does not allow null.</param>
/// <param name="providerNPI">Object does not allow null.</param>
/// <param name="workgroupLocationId">Object allows null.</param>
public static int InsertRowWithoutAdditionalLogic( string @externalID, int @specialtyID, int @workGroupID, string @firstName, string @lastName, string @middleInitial, string @company, string @address, string @city, string @state, string @zip, string @phone, DateTime @lastUpdated, DateTime @created, System.Boolean @hidden, string @providerNPI, System.Int32? @workgroupLocationId ) { 
var mod = CreateForInsert();
mod.@externalIDColumnValue.Value = @externalID;
mod.@specialtyIDColumnValue.Value = @specialtyID;
mod.@workGroupIDColumnValue.Value = @workGroupID;
mod.@firstNameColumnValue.Value = @firstName;
mod.@lastNameColumnValue.Value = @lastName;
mod.@middleInitialColumnValue.Value = @middleInitial;
mod.@companyColumnValue.Value = @company;
mod.@addressColumnValue.Value = @address;
mod.@cityColumnValue.Value = @city;
mod.@stateColumnValue.Value = @state;
mod.@zipColumnValue.Value = @zip;
mod.@phoneColumnValue.Value = @phone;
mod.@lastUpdatedColumnValue.Value = @lastUpdated;
mod.@createdColumnValue.Value = @created;
mod.@hiddenColumnValue.Value = @hidden;
mod.@providerNPIColumnValue.Value = @providerNPI;
mod.@workgroupLocationIdColumnValue.Value = @workgroupLocationId;
mod.ExecuteWithoutAdditionalLogic();
return mod.PhysicianID;
}
/// <summary>
/// Updates rows in the Physician table that match the specified conditions with the specified data.
/// </summary>
/// <param name="externalID">Object does not allow null.</param>
/// <param name="specialtyID">Object does not allow null.</param>
/// <param name="workGroupID">Object does not allow null.</param>
/// <param name="firstName">Object does not allow null.</param>
/// <param name="lastName">Object does not allow null.</param>
/// <param name="middleInitial">Object does not allow null.</param>
/// <param name="company">Object does not allow null.</param>
/// <param name="address">Object does not allow null.</param>
/// <param name="city">Object does not allow null.</param>
/// <param name="state">Object does not allow null.</param>
/// <param name="zip">Object does not allow null.</param>
/// <param name="phone">Object does not allow null.</param>
/// <param name="lastUpdated">Object does not allow null.</param>
/// <param name="created">Object does not allow null.</param>
/// <param name="hidden">Object does not allow null.</param>
/// <param name="providerNPI">Object does not allow null.</param>
/// <param name="workgroupLocationId">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( string @externalID, int @specialtyID, int @workGroupID, string @firstName, string @lastName, string @middleInitial, string @company, string @address, string @city, string @state, string @zip, string @phone, DateTime @lastUpdated, DateTime @created, System.Boolean @hidden, string @providerNPI, System.Int32? @workgroupLocationId, CommandConditions.PhysicianTableCondition requiredCondition, params CommandConditions.PhysicianTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@externalIDColumnValue.Value = @externalID;
mod.@specialtyIDColumnValue.Value = @specialtyID;
mod.@workGroupIDColumnValue.Value = @workGroupID;
mod.@firstNameColumnValue.Value = @firstName;
mod.@lastNameColumnValue.Value = @lastName;
mod.@middleInitialColumnValue.Value = @middleInitial;
mod.@companyColumnValue.Value = @company;
mod.@addressColumnValue.Value = @address;
mod.@cityColumnValue.Value = @city;
mod.@stateColumnValue.Value = @state;
mod.@zipColumnValue.Value = @zip;
mod.@phoneColumnValue.Value = @phone;
mod.@lastUpdatedColumnValue.Value = @lastUpdated;
mod.@createdColumnValue.Value = @created;
mod.@hiddenColumnValue.Value = @hidden;
mod.@providerNPIColumnValue.Value = @providerNPI;
mod.@workgroupLocationIdColumnValue.Value = @workgroupLocationId;
mod.Execute();
}
/// <summary>
/// Updates rows in the Physician table that match the specified conditions with the specified data.
/// </summary>
/// <param name="externalID">Object does not allow null.</param>
/// <param name="specialtyID">Object does not allow null.</param>
/// <param name="workGroupID">Object does not allow null.</param>
/// <param name="firstName">Object does not allow null.</param>
/// <param name="lastName">Object does not allow null.</param>
/// <param name="middleInitial">Object does not allow null.</param>
/// <param name="company">Object does not allow null.</param>
/// <param name="address">Object does not allow null.</param>
/// <param name="city">Object does not allow null.</param>
/// <param name="state">Object does not allow null.</param>
/// <param name="zip">Object does not allow null.</param>
/// <param name="phone">Object does not allow null.</param>
/// <param name="lastUpdated">Object does not allow null.</param>
/// <param name="created">Object does not allow null.</param>
/// <param name="hidden">Object does not allow null.</param>
/// <param name="providerNPI">Object does not allow null.</param>
/// <param name="workgroupLocationId">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( string @externalID, int @specialtyID, int @workGroupID, string @firstName, string @lastName, string @middleInitial, string @company, string @address, string @city, string @state, string @zip, string @phone, DateTime @lastUpdated, DateTime @created, System.Boolean @hidden, string @providerNPI, System.Int32? @workgroupLocationId, CommandConditions.PhysicianTableCondition requiredCondition, params CommandConditions.PhysicianTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@externalIDColumnValue.Value = @externalID;
mod.@specialtyIDColumnValue.Value = @specialtyID;
mod.@workGroupIDColumnValue.Value = @workGroupID;
mod.@firstNameColumnValue.Value = @firstName;
mod.@lastNameColumnValue.Value = @lastName;
mod.@middleInitialColumnValue.Value = @middleInitial;
mod.@companyColumnValue.Value = @company;
mod.@addressColumnValue.Value = @address;
mod.@cityColumnValue.Value = @city;
mod.@stateColumnValue.Value = @state;
mod.@zipColumnValue.Value = @zip;
mod.@phoneColumnValue.Value = @phone;
mod.@lastUpdatedColumnValue.Value = @lastUpdated;
mod.@createdColumnValue.Value = @created;
mod.@hiddenColumnValue.Value = @hidden;
mod.@providerNPIColumnValue.Value = @providerNPI;
mod.@workgroupLocationIdColumnValue.Value = @workgroupLocationId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.PhysicianTableCondition requiredCondition, params CommandConditions.PhysicianTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@PhysicianTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.PhysicianTableCondition requiredCondition, params CommandConditions.PhysicianTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.PhysicianTableCondition> conditions ) {
var delete = new InlineDelete( "Physician" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.PhysicianTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@PhysicianTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.PhysicianTableCondition> conditions;
private readonly DataValue<int> @physicianIDColumnValue = new DataValue<int>();
/// <summary>
/// Gets the value for the PhysicianID column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @PhysicianID { get { return @physicianIDColumnValue.Value; } }
private readonly DataValue<string> @externalIDColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the ExternalID column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @ExternalID { get { return @externalIDColumnValue.Value; } set { @externalIDColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ExternalID has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ExternalIDHasChanged { get { return @externalIDColumnValue.Changed; } }
private readonly DataValue<int> @specialtyIDColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the SpecialtyID column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @SpecialtyID { get { return @specialtyIDColumnValue.Value; } set { @specialtyIDColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the SpecialtyID has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @SpecialtyIDHasChanged { get { return @specialtyIDColumnValue.Changed; } }
private readonly DataValue<int> @workGroupIDColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the WorkGroupID column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @WorkGroupID { get { return @workGroupIDColumnValue.Value; } set { @workGroupIDColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the WorkGroupID has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @WorkGroupIDHasChanged { get { return @workGroupIDColumnValue.Changed; } }
private readonly DataValue<string> @firstNameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the FirstName column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @FirstName { get { return @firstNameColumnValue.Value; } set { @firstNameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the FirstName has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @FirstNameHasChanged { get { return @firstNameColumnValue.Changed; } }
private readonly DataValue<string> @lastNameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the LastName column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @LastName { get { return @lastNameColumnValue.Value; } set { @lastNameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LastName has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LastNameHasChanged { get { return @lastNameColumnValue.Changed; } }
private readonly DataValue<string> @middleInitialColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the MiddleInitial column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @MiddleInitial { get { return @middleInitialColumnValue.Value; } set { @middleInitialColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the MiddleInitial has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @MiddleInitialHasChanged { get { return @middleInitialColumnValue.Changed; } }
private readonly DataValue<string> @companyColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Company column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Company { get { return @companyColumnValue.Value; } set { @companyColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Company has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @CompanyHasChanged { get { return @companyColumnValue.Changed; } }
private readonly DataValue<string> @addressColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Address column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Address { get { return @addressColumnValue.Value; } set { @addressColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Address has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @AddressHasChanged { get { return @addressColumnValue.Changed; } }
private readonly DataValue<string> @cityColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the City column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @City { get { return @cityColumnValue.Value; } set { @cityColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the City has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @CityHasChanged { get { return @cityColumnValue.Changed; } }
private readonly DataValue<string> @stateColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the State column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @State { get { return @stateColumnValue.Value; } set { @stateColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the State has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @StateHasChanged { get { return @stateColumnValue.Changed; } }
private readonly DataValue<string> @zipColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Zip column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Zip { get { return @zipColumnValue.Value; } set { @zipColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Zip has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ZipHasChanged { get { return @zipColumnValue.Changed; } }
private readonly DataValue<string> @phoneColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Phone column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Phone { get { return @phoneColumnValue.Value; } set { @phoneColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Phone has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PhoneHasChanged { get { return @phoneColumnValue.Changed; } }
private readonly DataValue<DateTime> @lastUpdatedColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the LastUpdated column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @LastUpdated { get { return @lastUpdatedColumnValue.Value; } set { @lastUpdatedColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LastUpdated has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LastUpdatedHasChanged { get { return @lastUpdatedColumnValue.Changed; } }
private readonly DataValue<DateTime> @createdColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the Created column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @Created { get { return @createdColumnValue.Value; } set { @createdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Created has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @CreatedHasChanged { get { return @createdColumnValue.Changed; } }
private readonly DataValue<System.Boolean> @hiddenColumnValue = new DataValue<System.Boolean>();
/// <summary>
/// Gets or sets the value for the Hidden column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Boolean @Hidden { get { return @hiddenColumnValue.Value; } set { @hiddenColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Hidden has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @HiddenHasChanged { get { return @hiddenColumnValue.Changed; } }
private readonly DataValue<string> @providerNPIColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the ProviderNPI column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @ProviderNPI { get { return @providerNPIColumnValue.Value; } set { @providerNPIColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ProviderNPI has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ProviderNPIHasChanged { get { return @providerNPIColumnValue.Changed; } }
private readonly DataValue<System.Int32?> @workgroupLocationIdColumnValue = new DataValue<System.Int32?>();
/// <summary>
/// Gets or sets the value for the WorkgroupLocationId column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.Int32? @WorkgroupLocationId { get { return @workgroupLocationIdColumnValue.Value; } set { @workgroupLocationIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the WorkgroupLocationId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @WorkgroupLocationIdHasChanged { get { return @workgroupLocationIdColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the Physician table.
/// </summary>
public static @PhysicianModification CreateForInsert() {
return new @PhysicianModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the Physician table.
/// </summary>
public static @PhysicianModification CreateForUpdate( CommandConditions.PhysicianTableCondition requiredCondition, params CommandConditions.PhysicianTableCondition[] additionalConditions ) {
var mod = new @PhysicianModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@PhysicianTableEqualityConditions.@PhysicianID )
mod.@physicianIDColumnValue.Value = ( condition as CommandConditions.@PhysicianTableEqualityConditions.@PhysicianID ).Value;
else if( condition is CommandConditions.@PhysicianTableEqualityConditions.@ExternalID )
mod.@externalIDColumnValue.Value = ( condition as CommandConditions.@PhysicianTableEqualityConditions.@ExternalID ).Value;
else if( condition is CommandConditions.@PhysicianTableEqualityConditions.@SpecialtyID )
mod.@specialtyIDColumnValue.Value = ( condition as CommandConditions.@PhysicianTableEqualityConditions.@SpecialtyID ).Value;
else if( condition is CommandConditions.@PhysicianTableEqualityConditions.@WorkGroupID )
mod.@workGroupIDColumnValue.Value = ( condition as CommandConditions.@PhysicianTableEqualityConditions.@WorkGroupID ).Value;
else if( condition is CommandConditions.@PhysicianTableEqualityConditions.@FirstName )
mod.@firstNameColumnValue.Value = ( condition as CommandConditions.@PhysicianTableEqualityConditions.@FirstName ).Value;
else if( condition is CommandConditions.@PhysicianTableEqualityConditions.@LastName )
mod.@lastNameColumnValue.Value = ( condition as CommandConditions.@PhysicianTableEqualityConditions.@LastName ).Value;
else if( condition is CommandConditions.@PhysicianTableEqualityConditions.@MiddleInitial )
mod.@middleInitialColumnValue.Value = ( condition as CommandConditions.@PhysicianTableEqualityConditions.@MiddleInitial ).Value;
else if( condition is CommandConditions.@PhysicianTableEqualityConditions.@Company )
mod.@companyColumnValue.Value = ( condition as CommandConditions.@PhysicianTableEqualityConditions.@Company ).Value;
else if( condition is CommandConditions.@PhysicianTableEqualityConditions.@Address )
mod.@addressColumnValue.Value = ( condition as CommandConditions.@PhysicianTableEqualityConditions.@Address ).Value;
else if( condition is CommandConditions.@PhysicianTableEqualityConditions.@City )
mod.@cityColumnValue.Value = ( condition as CommandConditions.@PhysicianTableEqualityConditions.@City ).Value;
else if( condition is CommandConditions.@PhysicianTableEqualityConditions.@State )
mod.@stateColumnValue.Value = ( condition as CommandConditions.@PhysicianTableEqualityConditions.@State ).Value;
else if( condition is CommandConditions.@PhysicianTableEqualityConditions.@Zip )
mod.@zipColumnValue.Value = ( condition as CommandConditions.@PhysicianTableEqualityConditions.@Zip ).Value;
else if( condition is CommandConditions.@PhysicianTableEqualityConditions.@Phone )
mod.@phoneColumnValue.Value = ( condition as CommandConditions.@PhysicianTableEqualityConditions.@Phone ).Value;
else if( condition is CommandConditions.@PhysicianTableEqualityConditions.@LastUpdated )
mod.@lastUpdatedColumnValue.Value = ( condition as CommandConditions.@PhysicianTableEqualityConditions.@LastUpdated ).Value;
else if( condition is CommandConditions.@PhysicianTableEqualityConditions.@Created )
mod.@createdColumnValue.Value = ( condition as CommandConditions.@PhysicianTableEqualityConditions.@Created ).Value;
else if( condition is CommandConditions.@PhysicianTableEqualityConditions.@Hidden )
mod.@hiddenColumnValue.Value = ( condition as CommandConditions.@PhysicianTableEqualityConditions.@Hidden ).Value;
else if( condition is CommandConditions.@PhysicianTableEqualityConditions.@ProviderNPI )
mod.@providerNPIColumnValue.Value = ( condition as CommandConditions.@PhysicianTableEqualityConditions.@ProviderNPI ).Value;
else if( condition is CommandConditions.@PhysicianTableEqualityConditions.@WorkgroupLocationId )
mod.@workgroupLocationIdColumnValue.Value = ( condition as CommandConditions.@PhysicianTableEqualityConditions.@WorkgroupLocationId ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the Physician table.
/// </summary>
public static @PhysicianModification CreateForSingleRowUpdate( int @physicianID, string @externalID, int @specialtyID, int @workGroupID, string @firstName, string @lastName, string @middleInitial, string @company, string @address, string @city, string @state, string @zip, string @phone, DateTime @lastUpdated, DateTime @created, System.Boolean @hidden, string @providerNPI, System.Int32? @workgroupLocationId ) {
var mod = new @PhysicianModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.PhysicianTableCondition>();
mod.conditions.Add( new CommandConditions.@PhysicianTableEqualityConditions.@PhysicianID( @physicianID ) );
mod.@physicianIDColumnValue.Value = @physicianID;
mod.@externalIDColumnValue.Value = @externalID;
mod.@specialtyIDColumnValue.Value = @specialtyID;
mod.@workGroupIDColumnValue.Value = @workGroupID;
mod.@firstNameColumnValue.Value = @firstName;
mod.@lastNameColumnValue.Value = @lastName;
mod.@middleInitialColumnValue.Value = @middleInitial;
mod.@companyColumnValue.Value = @company;
mod.@addressColumnValue.Value = @address;
mod.@cityColumnValue.Value = @city;
mod.@stateColumnValue.Value = @state;
mod.@zipColumnValue.Value = @zip;
mod.@phoneColumnValue.Value = @phone;
mod.@lastUpdatedColumnValue.Value = @lastUpdated;
mod.@createdColumnValue.Value = @created;
mod.@hiddenColumnValue.Value = @hidden;
mod.@providerNPIColumnValue.Value = @providerNPI;
mod.@workgroupLocationIdColumnValue.Value = @workgroupLocationId;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.PhysicianTableCondition> getConditionList( CommandConditions.PhysicianTableCondition requiredCondition, params CommandConditions.PhysicianTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.PhysicianTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @PhysicianModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="externalID">Object does not allow null.</param>
/// <param name="specialtyID">Object does not allow null.</param>
/// <param name="workGroupID">Object does not allow null.</param>
/// <param name="firstName">Object does not allow null.</param>
/// <param name="lastName">Object does not allow null.</param>
/// <param name="middleInitial">Object does not allow null.</param>
/// <param name="company">Object does not allow null.</param>
/// <param name="address">Object does not allow null.</param>
/// <param name="city">Object does not allow null.</param>
/// <param name="state">Object does not allow null.</param>
/// <param name="zip">Object does not allow null.</param>
/// <param name="phone">Object does not allow null.</param>
/// <param name="lastUpdated">Object does not allow null.</param>
/// <param name="created">Object does not allow null.</param>
/// <param name="hidden">Object does not allow null.</param>
/// <param name="providerNPI">Object does not allow null.</param>
/// <param name="workgroupLocationId">Object allows null.</param>
public void SetAllData( string @externalID, int @specialtyID, int @workGroupID, string @firstName, string @lastName, string @middleInitial, string @company, string @address, string @city, string @state, string @zip, string @phone, DateTime @lastUpdated, DateTime @created, System.Boolean @hidden, string @providerNPI, System.Int32? @workgroupLocationId ) {
this.@externalIDColumnValue.Value = @externalID;
this.@specialtyIDColumnValue.Value = @specialtyID;
this.@workGroupIDColumnValue.Value = @workGroupID;
this.@firstNameColumnValue.Value = @firstName;
this.@lastNameColumnValue.Value = @lastName;
this.@middleInitialColumnValue.Value = @middleInitial;
this.@companyColumnValue.Value = @company;
this.@addressColumnValue.Value = @address;
this.@cityColumnValue.Value = @city;
this.@stateColumnValue.Value = @state;
this.@zipColumnValue.Value = @zip;
this.@phoneColumnValue.Value = @phone;
this.@lastUpdatedColumnValue.Value = @lastUpdated;
this.@createdColumnValue.Value = @created;
this.@hiddenColumnValue.Value = @hidden;
this.@providerNPIColumnValue.Value = @providerNPI;
this.@workgroupLocationIdColumnValue.Value = @workgroupLocationId;
}
/// <summary>
/// Executes this Physician modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this Physician modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "Physician" );
addColumnModifications( insert );
@physicianIDColumnValue.Value = (System.Int32)Utility.ChangeType( insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection ), typeof( System.Int32 ) );
modType = ModificationType.Update;
conditions = new List<CommandConditions.PhysicianTableCondition>();
conditions.Add( new CommandConditions.@PhysicianTableEqualityConditions.@PhysicianID( @PhysicianID ) );
}
else {
var update = new InlineUpdate( "Physician" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @externalIDColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ExternalID", new DbParameterValue( @ExternalID, "NVarChar" ) ) );
if( @specialtyIDColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "SpecialtyID", new DbParameterValue( @SpecialtyID, "Int" ) ) );
if( @workGroupIDColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "WorkGroupID", new DbParameterValue( @WorkGroupID, "Int" ) ) );
if( @firstNameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "FirstName", new DbParameterValue( @FirstName, "NVarChar" ) ) );
if( @lastNameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LastName", new DbParameterValue( @LastName, "NVarChar" ) ) );
if( @middleInitialColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "MiddleInitial", new DbParameterValue( @MiddleInitial, "NVarChar" ) ) );
if( @companyColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Company", new DbParameterValue( @Company, "NVarChar" ) ) );
if( @addressColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Address", new DbParameterValue( @Address, "NVarChar" ) ) );
if( @cityColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "City", new DbParameterValue( @City, "NVarChar" ) ) );
if( @stateColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "State", new DbParameterValue( @State, "NVarChar" ) ) );
if( @zipColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Zip", new DbParameterValue( @Zip, "NVarChar" ) ) );
if( @phoneColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Phone", new DbParameterValue( @Phone, "NVarChar" ) ) );
if( @lastUpdatedColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LastUpdated", new DbParameterValue( @LastUpdated, "DateTime" ) ) );
if( @createdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Created", new DbParameterValue( @Created, "DateTime" ) ) );
if( @hiddenColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Hidden", new DbParameterValue( @Hidden, "Bit" ) ) );
if( @providerNPIColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ProviderNPI", new DbParameterValue( @ProviderNPI, "NVarChar" ) ) );
if( @workgroupLocationIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "WorkgroupLocationId", new DbParameterValue( @WorkgroupLocationId, "Int" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@physicianIDColumnValue.ClearChanged();
@externalIDColumnValue.ClearChanged();
@specialtyIDColumnValue.ClearChanged();
@workGroupIDColumnValue.ClearChanged();
@firstNameColumnValue.ClearChanged();
@lastNameColumnValue.ClearChanged();
@middleInitialColumnValue.ClearChanged();
@companyColumnValue.ClearChanged();
@addressColumnValue.ClearChanged();
@cityColumnValue.ClearChanged();
@stateColumnValue.ClearChanged();
@zipColumnValue.ClearChanged();
@phoneColumnValue.ClearChanged();
@lastUpdatedColumnValue.ClearChanged();
@createdColumnValue.ClearChanged();
@hiddenColumnValue.ClearChanged();
@providerNPIColumnValue.ClearChanged();
@workgroupLocationIdColumnValue.ClearChanged();
}
}
public partial class @PreviousPasswordsModification {
/// <summary>
/// Inserts a row into the PreviousPasswords table.
/// </summary>
/// <param name="previousPasswordId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="salt">Object does not allow null.</param>
/// <param name="password">Object does not allow null.</param>
/// <param name="date">Object does not allow null.</param>
public static void InsertRow( int @previousPasswordId, int @userId, int @salt, System.Byte[] @password, DateTime @date ) { 
var mod = CreateForInsert();
mod.@previousPasswordIdColumnValue.Value = @previousPasswordId;
mod.@userIdColumnValue.Value = @userId;
mod.@saltColumnValue.Value = @salt;
mod.@passwordColumnValue.Value = @password;
mod.@dateColumnValue.Value = @date;
mod.Execute();
}
/// <summary>
/// Inserts a row into the PreviousPasswords table.
/// </summary>
/// <param name="previousPasswordId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="salt">Object does not allow null.</param>
/// <param name="password">Object does not allow null.</param>
/// <param name="date">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @previousPasswordId, int @userId, int @salt, System.Byte[] @password, DateTime @date ) { 
var mod = CreateForInsert();
mod.@previousPasswordIdColumnValue.Value = @previousPasswordId;
mod.@userIdColumnValue.Value = @userId;
mod.@saltColumnValue.Value = @salt;
mod.@passwordColumnValue.Value = @password;
mod.@dateColumnValue.Value = @date;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the PreviousPasswords table that match the specified conditions with the specified data.
/// </summary>
/// <param name="previousPasswordId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="salt">Object does not allow null.</param>
/// <param name="password">Object does not allow null.</param>
/// <param name="date">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @previousPasswordId, int @userId, int @salt, System.Byte[] @password, DateTime @date, CommandConditions.PreviousPasswordsTableCondition requiredCondition, params CommandConditions.PreviousPasswordsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@previousPasswordIdColumnValue.Value = @previousPasswordId;
mod.@userIdColumnValue.Value = @userId;
mod.@saltColumnValue.Value = @salt;
mod.@passwordColumnValue.Value = @password;
mod.@dateColumnValue.Value = @date;
mod.Execute();
}
/// <summary>
/// Updates rows in the PreviousPasswords table that match the specified conditions with the specified data.
/// </summary>
/// <param name="previousPasswordId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="salt">Object does not allow null.</param>
/// <param name="password">Object does not allow null.</param>
/// <param name="date">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @previousPasswordId, int @userId, int @salt, System.Byte[] @password, DateTime @date, CommandConditions.PreviousPasswordsTableCondition requiredCondition, params CommandConditions.PreviousPasswordsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@previousPasswordIdColumnValue.Value = @previousPasswordId;
mod.@userIdColumnValue.Value = @userId;
mod.@saltColumnValue.Value = @salt;
mod.@passwordColumnValue.Value = @password;
mod.@dateColumnValue.Value = @date;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.PreviousPasswordsTableCondition requiredCondition, params CommandConditions.PreviousPasswordsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@PreviousPasswordsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.PreviousPasswordsTableCondition requiredCondition, params CommandConditions.PreviousPasswordsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.PreviousPasswordsTableCondition> conditions ) {
var delete = new InlineDelete( "PreviousPasswords" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.PreviousPasswordsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@PreviousPasswordsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.PreviousPasswordsTableCondition> conditions;
private readonly DataValue<int> @previousPasswordIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the PreviousPasswordId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @PreviousPasswordId { get { return @previousPasswordIdColumnValue.Value; } set { @previousPasswordIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PreviousPasswordId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PreviousPasswordIdHasChanged { get { return @previousPasswordIdColumnValue.Changed; } }
private readonly DataValue<int> @userIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the UserId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @UserId { get { return @userIdColumnValue.Value; } set { @userIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the UserId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @UserIdHasChanged { get { return @userIdColumnValue.Changed; } }
private readonly DataValue<int> @saltColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the Salt column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @Salt { get { return @saltColumnValue.Value; } set { @saltColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Salt has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @SaltHasChanged { get { return @saltColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @passwordColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the Password column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @Password { get { return @passwordColumnValue.Value; } set { @passwordColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Password has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PasswordHasChanged { get { return @passwordColumnValue.Changed; } }
private readonly DataValue<DateTime> @dateColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the Date column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @Date { get { return @dateColumnValue.Value; } set { @dateColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Date has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @DateHasChanged { get { return @dateColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the PreviousPasswords table.
/// </summary>
public static @PreviousPasswordsModification CreateForInsert() {
return new @PreviousPasswordsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the PreviousPasswords table.
/// </summary>
public static @PreviousPasswordsModification CreateForUpdate( CommandConditions.PreviousPasswordsTableCondition requiredCondition, params CommandConditions.PreviousPasswordsTableCondition[] additionalConditions ) {
var mod = new @PreviousPasswordsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@PreviousPasswordsTableEqualityConditions.@PreviousPasswordId )
mod.@previousPasswordIdColumnValue.Value = ( condition as CommandConditions.@PreviousPasswordsTableEqualityConditions.@PreviousPasswordId ).Value;
else if( condition is CommandConditions.@PreviousPasswordsTableEqualityConditions.@UserId )
mod.@userIdColumnValue.Value = ( condition as CommandConditions.@PreviousPasswordsTableEqualityConditions.@UserId ).Value;
else if( condition is CommandConditions.@PreviousPasswordsTableEqualityConditions.@Salt )
mod.@saltColumnValue.Value = ( condition as CommandConditions.@PreviousPasswordsTableEqualityConditions.@Salt ).Value;
else if( condition is CommandConditions.@PreviousPasswordsTableEqualityConditions.@Password )
mod.@passwordColumnValue.Value = ( condition as CommandConditions.@PreviousPasswordsTableEqualityConditions.@Password ).Value;
else if( condition is CommandConditions.@PreviousPasswordsTableEqualityConditions.@Date )
mod.@dateColumnValue.Value = ( condition as CommandConditions.@PreviousPasswordsTableEqualityConditions.@Date ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the PreviousPasswords table.
/// </summary>
public static @PreviousPasswordsModification CreateForSingleRowUpdate( int @previousPasswordId, int @userId, int @salt, System.Byte[] @password, DateTime @date ) {
var mod = new @PreviousPasswordsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.PreviousPasswordsTableCondition>();
mod.conditions.Add( new CommandConditions.@PreviousPasswordsTableEqualityConditions.@PreviousPasswordId( @previousPasswordId ) );
mod.@previousPasswordIdColumnValue.Value = @previousPasswordId;
mod.@userIdColumnValue.Value = @userId;
mod.@saltColumnValue.Value = @salt;
mod.@passwordColumnValue.Value = @password;
mod.@dateColumnValue.Value = @date;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.PreviousPasswordsTableCondition> getConditionList( CommandConditions.PreviousPasswordsTableCondition requiredCondition, params CommandConditions.PreviousPasswordsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.PreviousPasswordsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @PreviousPasswordsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="previousPasswordId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="salt">Object does not allow null.</param>
/// <param name="password">Object does not allow null.</param>
/// <param name="date">Object does not allow null.</param>
public void SetAllData( int @previousPasswordId, int @userId, int @salt, System.Byte[] @password, DateTime @date ) {
this.@previousPasswordIdColumnValue.Value = @previousPasswordId;
this.@userIdColumnValue.Value = @userId;
this.@saltColumnValue.Value = @salt;
this.@passwordColumnValue.Value = @password;
this.@dateColumnValue.Value = @date;
}
/// <summary>
/// Executes this PreviousPasswords modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this PreviousPasswords modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "PreviousPasswords" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.PreviousPasswordsTableCondition>();
conditions.Add( new CommandConditions.@PreviousPasswordsTableEqualityConditions.@PreviousPasswordId( @PreviousPasswordId ) );
}
else {
var update = new InlineUpdate( "PreviousPasswords" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @previousPasswordIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PreviousPasswordId", new DbParameterValue( @PreviousPasswordId, "Int" ) ) );
if( @userIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( @UserId, "Int" ) ) );
if( @saltColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Salt", new DbParameterValue( @Salt, "Int" ) ) );
if( @passwordColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Password", new DbParameterValue( @Password, "Binary" ) ) );
if( @dateColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Date", new DbParameterValue( @Date, "DateTime2" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@previousPasswordIdColumnValue.ClearChanged();
@userIdColumnValue.ClearChanged();
@saltColumnValue.ClearChanged();
@passwordColumnValue.ClearChanged();
@dateColumnValue.ClearChanged();
}
}
public partial class @ProviderModification {
/// <summary>
/// Inserts a row into the Provider table. Returns the value of the ProviderID column.
/// </summary>
/// <param name="typeID">Object allows null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="namespace">Object does not allow null.</param>
/// <param name="isEnabled">Object allows null.</param>
/// <param name="isCurrent">Object allows null.</param>
/// <param name="lastModified">Object allows null.</param>
/// <param name="created">Object allows null.</param>
public static int InsertRow( System.Int32? @typeID, string @name, string @namespace, System.Boolean? @isEnabled, System.Boolean? @isCurrent, System.DateTime? @lastModified, System.DateTime? @created ) { 
var mod = CreateForInsert();
mod.@typeIDColumnValue.Value = @typeID;
mod.@nameColumnValue.Value = @name;
mod.@namespaceColumnValue.Value = @namespace;
mod.@isEnabledColumnValue.Value = @isEnabled;
mod.@isCurrentColumnValue.Value = @isCurrent;
mod.@lastModifiedColumnValue.Value = @lastModified;
mod.@createdColumnValue.Value = @created;
mod.Execute();
return mod.ProviderID;
}
/// <summary>
/// Inserts a row into the Provider table. Returns the value of the ProviderID column.
/// </summary>
/// <param name="typeID">Object allows null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="namespace">Object does not allow null.</param>
/// <param name="isEnabled">Object allows null.</param>
/// <param name="isCurrent">Object allows null.</param>
/// <param name="lastModified">Object allows null.</param>
/// <param name="created">Object allows null.</param>
public static int InsertRowWithoutAdditionalLogic( System.Int32? @typeID, string @name, string @namespace, System.Boolean? @isEnabled, System.Boolean? @isCurrent, System.DateTime? @lastModified, System.DateTime? @created ) { 
var mod = CreateForInsert();
mod.@typeIDColumnValue.Value = @typeID;
mod.@nameColumnValue.Value = @name;
mod.@namespaceColumnValue.Value = @namespace;
mod.@isEnabledColumnValue.Value = @isEnabled;
mod.@isCurrentColumnValue.Value = @isCurrent;
mod.@lastModifiedColumnValue.Value = @lastModified;
mod.@createdColumnValue.Value = @created;
mod.ExecuteWithoutAdditionalLogic();
return mod.ProviderID;
}
/// <summary>
/// Updates rows in the Provider table that match the specified conditions with the specified data.
/// </summary>
/// <param name="typeID">Object allows null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="namespace">Object does not allow null.</param>
/// <param name="isEnabled">Object allows null.</param>
/// <param name="isCurrent">Object allows null.</param>
/// <param name="lastModified">Object allows null.</param>
/// <param name="created">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( System.Int32? @typeID, string @name, string @namespace, System.Boolean? @isEnabled, System.Boolean? @isCurrent, System.DateTime? @lastModified, System.DateTime? @created, CommandConditions.ProviderTableCondition requiredCondition, params CommandConditions.ProviderTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@typeIDColumnValue.Value = @typeID;
mod.@nameColumnValue.Value = @name;
mod.@namespaceColumnValue.Value = @namespace;
mod.@isEnabledColumnValue.Value = @isEnabled;
mod.@isCurrentColumnValue.Value = @isCurrent;
mod.@lastModifiedColumnValue.Value = @lastModified;
mod.@createdColumnValue.Value = @created;
mod.Execute();
}
/// <summary>
/// Updates rows in the Provider table that match the specified conditions with the specified data.
/// </summary>
/// <param name="typeID">Object allows null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="namespace">Object does not allow null.</param>
/// <param name="isEnabled">Object allows null.</param>
/// <param name="isCurrent">Object allows null.</param>
/// <param name="lastModified">Object allows null.</param>
/// <param name="created">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( System.Int32? @typeID, string @name, string @namespace, System.Boolean? @isEnabled, System.Boolean? @isCurrent, System.DateTime? @lastModified, System.DateTime? @created, CommandConditions.ProviderTableCondition requiredCondition, params CommandConditions.ProviderTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@typeIDColumnValue.Value = @typeID;
mod.@nameColumnValue.Value = @name;
mod.@namespaceColumnValue.Value = @namespace;
mod.@isEnabledColumnValue.Value = @isEnabled;
mod.@isCurrentColumnValue.Value = @isCurrent;
mod.@lastModifiedColumnValue.Value = @lastModified;
mod.@createdColumnValue.Value = @created;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.ProviderTableCondition requiredCondition, params CommandConditions.ProviderTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@ProviderTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.ProviderTableCondition requiredCondition, params CommandConditions.ProviderTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.ProviderTableCondition> conditions ) {
var delete = new InlineDelete( "Provider" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.ProviderTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@ProviderTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.ProviderTableCondition> conditions;
private readonly DataValue<int> @providerIDColumnValue = new DataValue<int>();
/// <summary>
/// Gets the value for the ProviderID column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @ProviderID { get { return @providerIDColumnValue.Value; } }
private readonly DataValue<System.Int32?> @typeIDColumnValue = new DataValue<System.Int32?>();
/// <summary>
/// Gets or sets the value for the TypeID column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.Int32? @TypeID { get { return @typeIDColumnValue.Value; } set { @typeIDColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the TypeID has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @TypeIDHasChanged { get { return @typeIDColumnValue.Changed; } }
private readonly DataValue<string> @nameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Name column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Name { get { return @nameColumnValue.Value; } set { @nameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Name has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @NameHasChanged { get { return @nameColumnValue.Changed; } }
private readonly DataValue<string> @namespaceColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Namespace column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Namespace { get { return @namespaceColumnValue.Value; } set { @namespaceColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Namespace has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @NamespaceHasChanged { get { return @namespaceColumnValue.Changed; } }
private readonly DataValue<System.Boolean?> @isEnabledColumnValue = new DataValue<System.Boolean?>();
/// <summary>
/// Gets or sets the value for the IsEnabled column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.Boolean? @IsEnabled { get { return @isEnabledColumnValue.Value; } set { @isEnabledColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the IsEnabled has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @IsEnabledHasChanged { get { return @isEnabledColumnValue.Changed; } }
private readonly DataValue<System.Boolean?> @isCurrentColumnValue = new DataValue<System.Boolean?>();
/// <summary>
/// Gets or sets the value for the IsCurrent column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.Boolean? @IsCurrent { get { return @isCurrentColumnValue.Value; } set { @isCurrentColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the IsCurrent has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @IsCurrentHasChanged { get { return @isCurrentColumnValue.Changed; } }
private readonly DataValue<System.DateTime?> @lastModifiedColumnValue = new DataValue<System.DateTime?>();
/// <summary>
/// Gets or sets the value for the LastModified column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.DateTime? @LastModified { get { return @lastModifiedColumnValue.Value; } set { @lastModifiedColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LastModified has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LastModifiedHasChanged { get { return @lastModifiedColumnValue.Changed; } }
private readonly DataValue<System.DateTime?> @createdColumnValue = new DataValue<System.DateTime?>();
/// <summary>
/// Gets or sets the value for the Created column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.DateTime? @Created { get { return @createdColumnValue.Value; } set { @createdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Created has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @CreatedHasChanged { get { return @createdColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the Provider table.
/// </summary>
public static @ProviderModification CreateForInsert() {
return new @ProviderModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the Provider table.
/// </summary>
public static @ProviderModification CreateForUpdate( CommandConditions.ProviderTableCondition requiredCondition, params CommandConditions.ProviderTableCondition[] additionalConditions ) {
var mod = new @ProviderModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@ProviderTableEqualityConditions.@ProviderID )
mod.@providerIDColumnValue.Value = ( condition as CommandConditions.@ProviderTableEqualityConditions.@ProviderID ).Value;
else if( condition is CommandConditions.@ProviderTableEqualityConditions.@TypeID )
mod.@typeIDColumnValue.Value = ( condition as CommandConditions.@ProviderTableEqualityConditions.@TypeID ).Value;
else if( condition is CommandConditions.@ProviderTableEqualityConditions.@Name )
mod.@nameColumnValue.Value = ( condition as CommandConditions.@ProviderTableEqualityConditions.@Name ).Value;
else if( condition is CommandConditions.@ProviderTableEqualityConditions.@Namespace )
mod.@namespaceColumnValue.Value = ( condition as CommandConditions.@ProviderTableEqualityConditions.@Namespace ).Value;
else if( condition is CommandConditions.@ProviderTableEqualityConditions.@IsEnabled )
mod.@isEnabledColumnValue.Value = ( condition as CommandConditions.@ProviderTableEqualityConditions.@IsEnabled ).Value;
else if( condition is CommandConditions.@ProviderTableEqualityConditions.@IsCurrent )
mod.@isCurrentColumnValue.Value = ( condition as CommandConditions.@ProviderTableEqualityConditions.@IsCurrent ).Value;
else if( condition is CommandConditions.@ProviderTableEqualityConditions.@LastModified )
mod.@lastModifiedColumnValue.Value = ( condition as CommandConditions.@ProviderTableEqualityConditions.@LastModified ).Value;
else if( condition is CommandConditions.@ProviderTableEqualityConditions.@Created )
mod.@createdColumnValue.Value = ( condition as CommandConditions.@ProviderTableEqualityConditions.@Created ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the Provider table.
/// </summary>
public static @ProviderModification CreateForSingleRowUpdate( int @providerID, System.Int32? @typeID, string @name, string @namespace, System.Boolean? @isEnabled, System.Boolean? @isCurrent, System.DateTime? @lastModified, System.DateTime? @created ) {
var mod = new @ProviderModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.ProviderTableCondition>();
mod.conditions.Add( new CommandConditions.@ProviderTableEqualityConditions.@ProviderID( @providerID ) );
mod.@providerIDColumnValue.Value = @providerID;
mod.@typeIDColumnValue.Value = @typeID;
mod.@nameColumnValue.Value = @name;
mod.@namespaceColumnValue.Value = @namespace;
mod.@isEnabledColumnValue.Value = @isEnabled;
mod.@isCurrentColumnValue.Value = @isCurrent;
mod.@lastModifiedColumnValue.Value = @lastModified;
mod.@createdColumnValue.Value = @created;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.ProviderTableCondition> getConditionList( CommandConditions.ProviderTableCondition requiredCondition, params CommandConditions.ProviderTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.ProviderTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @ProviderModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="typeID">Object allows null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="namespace">Object does not allow null.</param>
/// <param name="isEnabled">Object allows null.</param>
/// <param name="isCurrent">Object allows null.</param>
/// <param name="lastModified">Object allows null.</param>
/// <param name="created">Object allows null.</param>
public void SetAllData( System.Int32? @typeID, string @name, string @namespace, System.Boolean? @isEnabled, System.Boolean? @isCurrent, System.DateTime? @lastModified, System.DateTime? @created ) {
this.@typeIDColumnValue.Value = @typeID;
this.@nameColumnValue.Value = @name;
this.@namespaceColumnValue.Value = @namespace;
this.@isEnabledColumnValue.Value = @isEnabled;
this.@isCurrentColumnValue.Value = @isCurrent;
this.@lastModifiedColumnValue.Value = @lastModified;
this.@createdColumnValue.Value = @created;
}
/// <summary>
/// Executes this Provider modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this Provider modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "Provider" );
addColumnModifications( insert );
@providerIDColumnValue.Value = (System.Int32)Utility.ChangeType( insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection ), typeof( System.Int32 ) );
modType = ModificationType.Update;
conditions = new List<CommandConditions.ProviderTableCondition>();
conditions.Add( new CommandConditions.@ProviderTableEqualityConditions.@ProviderID( @ProviderID ) );
}
else {
var update = new InlineUpdate( "Provider" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @typeIDColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "TypeID", new DbParameterValue( @TypeID, "Int" ) ) );
if( @nameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Name", new DbParameterValue( @Name, "NVarChar" ) ) );
if( @namespaceColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Namespace", new DbParameterValue( @Namespace, "NVarChar" ) ) );
if( @isEnabledColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "IsEnabled", new DbParameterValue( @IsEnabled, "Bit" ) ) );
if( @isCurrentColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "IsCurrent", new DbParameterValue( @IsCurrent, "Bit" ) ) );
if( @lastModifiedColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LastModified", new DbParameterValue( @LastModified, "DateTime" ) ) );
if( @createdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Created", new DbParameterValue( @Created, "DateTime" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@providerIDColumnValue.ClearChanged();
@typeIDColumnValue.ClearChanged();
@nameColumnValue.ClearChanged();
@namespaceColumnValue.ClearChanged();
@isEnabledColumnValue.ClearChanged();
@isCurrentColumnValue.ClearChanged();
@lastModifiedColumnValue.ClearChanged();
@createdColumnValue.ClearChanged();
}
}
public partial class @ProviderPortalUsersModification {
/// <summary>
/// Inserts a row into the ProviderPortalUsers table.
/// </summary>
/// <param name="providerPortalUserId">Object does not allow null.</param>
/// <param name="rhioUserName">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="nationalProviderIdentifier">Object does not allow null.</param>
public static void InsertRow( int @providerPortalUserId, string @rhioUserName, int @userId, string @nationalProviderIdentifier ) { 
var mod = CreateForInsert();
mod.@providerPortalUserIdColumnValue.Value = @providerPortalUserId;
mod.@rhioUserNameColumnValue.Value = @rhioUserName;
mod.@userIdColumnValue.Value = @userId;
mod.@nationalProviderIdentifierColumnValue.Value = @nationalProviderIdentifier;
mod.Execute();
}
/// <summary>
/// Inserts a row into the ProviderPortalUsers table.
/// </summary>
/// <param name="providerPortalUserId">Object does not allow null.</param>
/// <param name="rhioUserName">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="nationalProviderIdentifier">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @providerPortalUserId, string @rhioUserName, int @userId, string @nationalProviderIdentifier ) { 
var mod = CreateForInsert();
mod.@providerPortalUserIdColumnValue.Value = @providerPortalUserId;
mod.@rhioUserNameColumnValue.Value = @rhioUserName;
mod.@userIdColumnValue.Value = @userId;
mod.@nationalProviderIdentifierColumnValue.Value = @nationalProviderIdentifier;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the ProviderPortalUsers table that match the specified conditions with the specified data.
/// </summary>
/// <param name="providerPortalUserId">Object does not allow null.</param>
/// <param name="rhioUserName">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="nationalProviderIdentifier">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @providerPortalUserId, string @rhioUserName, int @userId, string @nationalProviderIdentifier, CommandConditions.ProviderPortalUsersTableCondition requiredCondition, params CommandConditions.ProviderPortalUsersTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@providerPortalUserIdColumnValue.Value = @providerPortalUserId;
mod.@rhioUserNameColumnValue.Value = @rhioUserName;
mod.@userIdColumnValue.Value = @userId;
mod.@nationalProviderIdentifierColumnValue.Value = @nationalProviderIdentifier;
mod.Execute();
}
/// <summary>
/// Updates rows in the ProviderPortalUsers table that match the specified conditions with the specified data.
/// </summary>
/// <param name="providerPortalUserId">Object does not allow null.</param>
/// <param name="rhioUserName">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="nationalProviderIdentifier">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @providerPortalUserId, string @rhioUserName, int @userId, string @nationalProviderIdentifier, CommandConditions.ProviderPortalUsersTableCondition requiredCondition, params CommandConditions.ProviderPortalUsersTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@providerPortalUserIdColumnValue.Value = @providerPortalUserId;
mod.@rhioUserNameColumnValue.Value = @rhioUserName;
mod.@userIdColumnValue.Value = @userId;
mod.@nationalProviderIdentifierColumnValue.Value = @nationalProviderIdentifier;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.ProviderPortalUsersTableCondition requiredCondition, params CommandConditions.ProviderPortalUsersTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@ProviderPortalUsersTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.ProviderPortalUsersTableCondition requiredCondition, params CommandConditions.ProviderPortalUsersTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.ProviderPortalUsersTableCondition> conditions ) {
var delete = new InlineDelete( "ProviderPortalUsers" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.ProviderPortalUsersTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@ProviderPortalUsersTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.ProviderPortalUsersTableCondition> conditions;
private readonly DataValue<int> @providerPortalUserIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the ProviderPortalUserId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @ProviderPortalUserId { get { return @providerPortalUserIdColumnValue.Value; } set { @providerPortalUserIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ProviderPortalUserId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ProviderPortalUserIdHasChanged { get { return @providerPortalUserIdColumnValue.Changed; } }
private readonly DataValue<string> @rhioUserNameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the RhioUserName column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @RhioUserName { get { return @rhioUserNameColumnValue.Value; } set { @rhioUserNameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the RhioUserName has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @RhioUserNameHasChanged { get { return @rhioUserNameColumnValue.Changed; } }
private readonly DataValue<int> @userIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the UserId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @UserId { get { return @userIdColumnValue.Value; } set { @userIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the UserId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @UserIdHasChanged { get { return @userIdColumnValue.Changed; } }
private readonly DataValue<string> @nationalProviderIdentifierColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the NationalProviderIdentifier column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @NationalProviderIdentifier { get { return @nationalProviderIdentifierColumnValue.Value; } set { @nationalProviderIdentifierColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the NationalProviderIdentifier has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @NationalProviderIdentifierHasChanged { get { return @nationalProviderIdentifierColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the ProviderPortalUsers table.
/// </summary>
public static @ProviderPortalUsersModification CreateForInsert() {
return new @ProviderPortalUsersModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the ProviderPortalUsers table.
/// </summary>
public static @ProviderPortalUsersModification CreateForUpdate( CommandConditions.ProviderPortalUsersTableCondition requiredCondition, params CommandConditions.ProviderPortalUsersTableCondition[] additionalConditions ) {
var mod = new @ProviderPortalUsersModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@ProviderPortalUsersTableEqualityConditions.@ProviderPortalUserId )
mod.@providerPortalUserIdColumnValue.Value = ( condition as CommandConditions.@ProviderPortalUsersTableEqualityConditions.@ProviderPortalUserId ).Value;
else if( condition is CommandConditions.@ProviderPortalUsersTableEqualityConditions.@RhioUserName )
mod.@rhioUserNameColumnValue.Value = ( condition as CommandConditions.@ProviderPortalUsersTableEqualityConditions.@RhioUserName ).Value;
else if( condition is CommandConditions.@ProviderPortalUsersTableEqualityConditions.@UserId )
mod.@userIdColumnValue.Value = ( condition as CommandConditions.@ProviderPortalUsersTableEqualityConditions.@UserId ).Value;
else if( condition is CommandConditions.@ProviderPortalUsersTableEqualityConditions.@NationalProviderIdentifier )
mod.@nationalProviderIdentifierColumnValue.Value = ( condition as CommandConditions.@ProviderPortalUsersTableEqualityConditions.@NationalProviderIdentifier ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the ProviderPortalUsers table.
/// </summary>
public static @ProviderPortalUsersModification CreateForSingleRowUpdate( int @providerPortalUserId, string @rhioUserName, int @userId, string @nationalProviderIdentifier ) {
var mod = new @ProviderPortalUsersModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.ProviderPortalUsersTableCondition>();
mod.conditions.Add( new CommandConditions.@ProviderPortalUsersTableEqualityConditions.@ProviderPortalUserId( @providerPortalUserId ) );
mod.@providerPortalUserIdColumnValue.Value = @providerPortalUserId;
mod.@rhioUserNameColumnValue.Value = @rhioUserName;
mod.@userIdColumnValue.Value = @userId;
mod.@nationalProviderIdentifierColumnValue.Value = @nationalProviderIdentifier;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.ProviderPortalUsersTableCondition> getConditionList( CommandConditions.ProviderPortalUsersTableCondition requiredCondition, params CommandConditions.ProviderPortalUsersTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.ProviderPortalUsersTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @ProviderPortalUsersModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="providerPortalUserId">Object does not allow null.</param>
/// <param name="rhioUserName">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="nationalProviderIdentifier">Object does not allow null.</param>
public void SetAllData( int @providerPortalUserId, string @rhioUserName, int @userId, string @nationalProviderIdentifier ) {
this.@providerPortalUserIdColumnValue.Value = @providerPortalUserId;
this.@rhioUserNameColumnValue.Value = @rhioUserName;
this.@userIdColumnValue.Value = @userId;
this.@nationalProviderIdentifierColumnValue.Value = @nationalProviderIdentifier;
}
/// <summary>
/// Executes this ProviderPortalUsers modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this ProviderPortalUsers modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "ProviderPortalUsers" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.ProviderPortalUsersTableCondition>();
conditions.Add( new CommandConditions.@ProviderPortalUsersTableEqualityConditions.@ProviderPortalUserId( @ProviderPortalUserId ) );
}
else {
var update = new InlineUpdate( "ProviderPortalUsers" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @providerPortalUserIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ProviderPortalUserId", new DbParameterValue( @ProviderPortalUserId, "Int" ) ) );
if( @rhioUserNameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "RhioUserName", new DbParameterValue( @RhioUserName, "NVarChar" ) ) );
if( @userIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( @UserId, "Int" ) ) );
if( @nationalProviderIdentifierColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "NationalProviderIdentifier", new DbParameterValue( @NationalProviderIdentifier, "NVarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@providerPortalUserIdColumnValue.ClearChanged();
@rhioUserNameColumnValue.ClearChanged();
@userIdColumnValue.ClearChanged();
@nationalProviderIdentifierColumnValue.ClearChanged();
}
}
public partial class @ProviderPortalUsersToCareZonesModification {
/// <summary>
/// Inserts a row into the ProviderPortalUsersToCareZones table. Returns the value of the ProviderPortalUsersToCareZonesId column.
/// </summary>
/// <param name="providerPortalUserId">Object does not allow null.</param>
/// <param name="careZoneId">Object does not allow null.</param>
public static int InsertRow( int @providerPortalUserId, int @careZoneId ) { 
var mod = CreateForInsert();
mod.@providerPortalUserIdColumnValue.Value = @providerPortalUserId;
mod.@careZoneIdColumnValue.Value = @careZoneId;
mod.Execute();
return mod.ProviderPortalUsersToCareZonesId;
}
/// <summary>
/// Inserts a row into the ProviderPortalUsersToCareZones table. Returns the value of the ProviderPortalUsersToCareZonesId column.
/// </summary>
/// <param name="providerPortalUserId">Object does not allow null.</param>
/// <param name="careZoneId">Object does not allow null.</param>
public static int InsertRowWithoutAdditionalLogic( int @providerPortalUserId, int @careZoneId ) { 
var mod = CreateForInsert();
mod.@providerPortalUserIdColumnValue.Value = @providerPortalUserId;
mod.@careZoneIdColumnValue.Value = @careZoneId;
mod.ExecuteWithoutAdditionalLogic();
return mod.ProviderPortalUsersToCareZonesId;
}
/// <summary>
/// Updates rows in the ProviderPortalUsersToCareZones table that match the specified conditions with the specified data.
/// </summary>
/// <param name="providerPortalUserId">Object does not allow null.</param>
/// <param name="careZoneId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @providerPortalUserId, int @careZoneId, CommandConditions.ProviderPortalUsersToCareZonesTableCondition requiredCondition, params CommandConditions.ProviderPortalUsersToCareZonesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@providerPortalUserIdColumnValue.Value = @providerPortalUserId;
mod.@careZoneIdColumnValue.Value = @careZoneId;
mod.Execute();
}
/// <summary>
/// Updates rows in the ProviderPortalUsersToCareZones table that match the specified conditions with the specified data.
/// </summary>
/// <param name="providerPortalUserId">Object does not allow null.</param>
/// <param name="careZoneId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @providerPortalUserId, int @careZoneId, CommandConditions.ProviderPortalUsersToCareZonesTableCondition requiredCondition, params CommandConditions.ProviderPortalUsersToCareZonesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@providerPortalUserIdColumnValue.Value = @providerPortalUserId;
mod.@careZoneIdColumnValue.Value = @careZoneId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.ProviderPortalUsersToCareZonesTableCondition requiredCondition, params CommandConditions.ProviderPortalUsersToCareZonesTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@ProviderPortalUsersToCareZonesTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.ProviderPortalUsersToCareZonesTableCondition requiredCondition, params CommandConditions.ProviderPortalUsersToCareZonesTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.ProviderPortalUsersToCareZonesTableCondition> conditions ) {
var delete = new InlineDelete( "ProviderPortalUsersToCareZones" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.ProviderPortalUsersToCareZonesTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@ProviderPortalUsersToCareZonesTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.ProviderPortalUsersToCareZonesTableCondition> conditions;
private readonly DataValue<int> @providerPortalUsersToCareZonesIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets the value for the ProviderPortalUsersToCareZonesId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @ProviderPortalUsersToCareZonesId { get { return @providerPortalUsersToCareZonesIdColumnValue.Value; } }
private readonly DataValue<int> @providerPortalUserIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the ProviderPortalUserId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @ProviderPortalUserId { get { return @providerPortalUserIdColumnValue.Value; } set { @providerPortalUserIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ProviderPortalUserId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ProviderPortalUserIdHasChanged { get { return @providerPortalUserIdColumnValue.Changed; } }
private readonly DataValue<int> @careZoneIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the CareZoneId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @CareZoneId { get { return @careZoneIdColumnValue.Value; } set { @careZoneIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the CareZoneId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @CareZoneIdHasChanged { get { return @careZoneIdColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the ProviderPortalUsersToCareZones table.
/// </summary>
public static @ProviderPortalUsersToCareZonesModification CreateForInsert() {
return new @ProviderPortalUsersToCareZonesModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the ProviderPortalUsersToCareZones table.
/// </summary>
public static @ProviderPortalUsersToCareZonesModification CreateForUpdate( CommandConditions.ProviderPortalUsersToCareZonesTableCondition requiredCondition, params CommandConditions.ProviderPortalUsersToCareZonesTableCondition[] additionalConditions ) {
var mod = new @ProviderPortalUsersToCareZonesModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@ProviderPortalUsersToCareZonesTableEqualityConditions.@ProviderPortalUsersToCareZonesId )
mod.@providerPortalUsersToCareZonesIdColumnValue.Value = ( condition as CommandConditions.@ProviderPortalUsersToCareZonesTableEqualityConditions.@ProviderPortalUsersToCareZonesId ).Value;
else if( condition is CommandConditions.@ProviderPortalUsersToCareZonesTableEqualityConditions.@ProviderPortalUserId )
mod.@providerPortalUserIdColumnValue.Value = ( condition as CommandConditions.@ProviderPortalUsersToCareZonesTableEqualityConditions.@ProviderPortalUserId ).Value;
else if( condition is CommandConditions.@ProviderPortalUsersToCareZonesTableEqualityConditions.@CareZoneId )
mod.@careZoneIdColumnValue.Value = ( condition as CommandConditions.@ProviderPortalUsersToCareZonesTableEqualityConditions.@CareZoneId ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the ProviderPortalUsersToCareZones table.
/// </summary>
public static @ProviderPortalUsersToCareZonesModification CreateForSingleRowUpdate( int @providerPortalUsersToCareZonesId, int @providerPortalUserId, int @careZoneId ) {
var mod = new @ProviderPortalUsersToCareZonesModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.ProviderPortalUsersToCareZonesTableCondition>();
mod.conditions.Add( new CommandConditions.@ProviderPortalUsersToCareZonesTableEqualityConditions.@ProviderPortalUsersToCareZonesId( @providerPortalUsersToCareZonesId ) );
mod.@providerPortalUsersToCareZonesIdColumnValue.Value = @providerPortalUsersToCareZonesId;
mod.@providerPortalUserIdColumnValue.Value = @providerPortalUserId;
mod.@careZoneIdColumnValue.Value = @careZoneId;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.ProviderPortalUsersToCareZonesTableCondition> getConditionList( CommandConditions.ProviderPortalUsersToCareZonesTableCondition requiredCondition, params CommandConditions.ProviderPortalUsersToCareZonesTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.ProviderPortalUsersToCareZonesTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @ProviderPortalUsersToCareZonesModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="providerPortalUserId">Object does not allow null.</param>
/// <param name="careZoneId">Object does not allow null.</param>
public void SetAllData( int @providerPortalUserId, int @careZoneId ) {
this.@providerPortalUserIdColumnValue.Value = @providerPortalUserId;
this.@careZoneIdColumnValue.Value = @careZoneId;
}
/// <summary>
/// Executes this ProviderPortalUsersToCareZones modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this ProviderPortalUsersToCareZones modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "ProviderPortalUsersToCareZones" );
addColumnModifications( insert );
@providerPortalUsersToCareZonesIdColumnValue.Value = (System.Int32)Utility.ChangeType( insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection ), typeof( System.Int32 ) );
modType = ModificationType.Update;
conditions = new List<CommandConditions.ProviderPortalUsersToCareZonesTableCondition>();
conditions.Add( new CommandConditions.@ProviderPortalUsersToCareZonesTableEqualityConditions.@ProviderPortalUsersToCareZonesId( @ProviderPortalUsersToCareZonesId ) );
}
else {
var update = new InlineUpdate( "ProviderPortalUsersToCareZones" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @providerPortalUserIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ProviderPortalUserId", new DbParameterValue( @ProviderPortalUserId, "Int" ) ) );
if( @careZoneIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "CareZoneId", new DbParameterValue( @CareZoneId, "Int" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@providerPortalUsersToCareZonesIdColumnValue.ClearChanged();
@providerPortalUserIdColumnValue.ClearChanged();
@careZoneIdColumnValue.ClearChanged();
}
}
public partial class @ProviderPortalUsersToNewCareZonesModification {
/// <summary>
/// Inserts a row into the ProviderPortalUsersToNewCareZones table.
/// </summary>
/// <param name="providerPortalUserId">Object does not allow null.</param>
/// <param name="careZoneId">Object does not allow null.</param>
public static void InsertRow( int @providerPortalUserId, int @careZoneId ) { 
var mod = CreateForInsert();
mod.@providerPortalUserIdColumnValue.Value = @providerPortalUserId;
mod.@careZoneIdColumnValue.Value = @careZoneId;
mod.Execute();
}
/// <summary>
/// Inserts a row into the ProviderPortalUsersToNewCareZones table.
/// </summary>
/// <param name="providerPortalUserId">Object does not allow null.</param>
/// <param name="careZoneId">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @providerPortalUserId, int @careZoneId ) { 
var mod = CreateForInsert();
mod.@providerPortalUserIdColumnValue.Value = @providerPortalUserId;
mod.@careZoneIdColumnValue.Value = @careZoneId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the ProviderPortalUsersToNewCareZones table that match the specified conditions with the specified data.
/// </summary>
/// <param name="providerPortalUserId">Object does not allow null.</param>
/// <param name="careZoneId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @providerPortalUserId, int @careZoneId, CommandConditions.ProviderPortalUsersToNewCareZonesTableCondition requiredCondition, params CommandConditions.ProviderPortalUsersToNewCareZonesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@providerPortalUserIdColumnValue.Value = @providerPortalUserId;
mod.@careZoneIdColumnValue.Value = @careZoneId;
mod.Execute();
}
/// <summary>
/// Updates rows in the ProviderPortalUsersToNewCareZones table that match the specified conditions with the specified data.
/// </summary>
/// <param name="providerPortalUserId">Object does not allow null.</param>
/// <param name="careZoneId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @providerPortalUserId, int @careZoneId, CommandConditions.ProviderPortalUsersToNewCareZonesTableCondition requiredCondition, params CommandConditions.ProviderPortalUsersToNewCareZonesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@providerPortalUserIdColumnValue.Value = @providerPortalUserId;
mod.@careZoneIdColumnValue.Value = @careZoneId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.ProviderPortalUsersToNewCareZonesTableCondition requiredCondition, params CommandConditions.ProviderPortalUsersToNewCareZonesTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@ProviderPortalUsersToNewCareZonesTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.ProviderPortalUsersToNewCareZonesTableCondition requiredCondition, params CommandConditions.ProviderPortalUsersToNewCareZonesTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.ProviderPortalUsersToNewCareZonesTableCondition> conditions ) {
var delete = new InlineDelete( "ProviderPortalUsersToNewCareZones" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.ProviderPortalUsersToNewCareZonesTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@ProviderPortalUsersToNewCareZonesTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.ProviderPortalUsersToNewCareZonesTableCondition> conditions;
private readonly DataValue<int> @providerPortalUserIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the ProviderPortalUserId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @ProviderPortalUserId { get { return @providerPortalUserIdColumnValue.Value; } set { @providerPortalUserIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ProviderPortalUserId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ProviderPortalUserIdHasChanged { get { return @providerPortalUserIdColumnValue.Changed; } }
private readonly DataValue<int> @careZoneIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the CareZoneId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @CareZoneId { get { return @careZoneIdColumnValue.Value; } set { @careZoneIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the CareZoneId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @CareZoneIdHasChanged { get { return @careZoneIdColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the ProviderPortalUsersToNewCareZones table.
/// </summary>
public static @ProviderPortalUsersToNewCareZonesModification CreateForInsert() {
return new @ProviderPortalUsersToNewCareZonesModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the ProviderPortalUsersToNewCareZones table.
/// </summary>
public static @ProviderPortalUsersToNewCareZonesModification CreateForUpdate( CommandConditions.ProviderPortalUsersToNewCareZonesTableCondition requiredCondition, params CommandConditions.ProviderPortalUsersToNewCareZonesTableCondition[] additionalConditions ) {
var mod = new @ProviderPortalUsersToNewCareZonesModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@ProviderPortalUsersToNewCareZonesTableEqualityConditions.@ProviderPortalUserId )
mod.@providerPortalUserIdColumnValue.Value = ( condition as CommandConditions.@ProviderPortalUsersToNewCareZonesTableEqualityConditions.@ProviderPortalUserId ).Value;
else if( condition is CommandConditions.@ProviderPortalUsersToNewCareZonesTableEqualityConditions.@CareZoneId )
mod.@careZoneIdColumnValue.Value = ( condition as CommandConditions.@ProviderPortalUsersToNewCareZonesTableEqualityConditions.@CareZoneId ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the ProviderPortalUsersToNewCareZones table.
/// </summary>
public static @ProviderPortalUsersToNewCareZonesModification CreateForSingleRowUpdate( int @providerPortalUserId, int @careZoneId ) {
var mod = new @ProviderPortalUsersToNewCareZonesModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.ProviderPortalUsersToNewCareZonesTableCondition>();
mod.conditions.Add( new CommandConditions.@ProviderPortalUsersToNewCareZonesTableEqualityConditions.@ProviderPortalUserId( @providerPortalUserId ) );
mod.conditions.Add( new CommandConditions.@ProviderPortalUsersToNewCareZonesTableEqualityConditions.@CareZoneId( @careZoneId ) );
mod.@providerPortalUserIdColumnValue.Value = @providerPortalUserId;
mod.@careZoneIdColumnValue.Value = @careZoneId;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.ProviderPortalUsersToNewCareZonesTableCondition> getConditionList( CommandConditions.ProviderPortalUsersToNewCareZonesTableCondition requiredCondition, params CommandConditions.ProviderPortalUsersToNewCareZonesTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.ProviderPortalUsersToNewCareZonesTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @ProviderPortalUsersToNewCareZonesModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="providerPortalUserId">Object does not allow null.</param>
/// <param name="careZoneId">Object does not allow null.</param>
public void SetAllData( int @providerPortalUserId, int @careZoneId ) {
this.@providerPortalUserIdColumnValue.Value = @providerPortalUserId;
this.@careZoneIdColumnValue.Value = @careZoneId;
}
/// <summary>
/// Executes this ProviderPortalUsersToNewCareZones modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this ProviderPortalUsersToNewCareZones modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "ProviderPortalUsersToNewCareZones" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.ProviderPortalUsersToNewCareZonesTableCondition>();
conditions.Add( new CommandConditions.@ProviderPortalUsersToNewCareZonesTableEqualityConditions.@ProviderPortalUserId( @ProviderPortalUserId ) );
conditions.Add( new CommandConditions.@ProviderPortalUsersToNewCareZonesTableEqualityConditions.@CareZoneId( @CareZoneId ) );
}
else {
var update = new InlineUpdate( "ProviderPortalUsersToNewCareZones" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @providerPortalUserIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ProviderPortalUserId", new DbParameterValue( @ProviderPortalUserId, "Int" ) ) );
if( @careZoneIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "CareZoneId", new DbParameterValue( @CareZoneId, "Int" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@providerPortalUserIdColumnValue.ClearChanged();
@careZoneIdColumnValue.ClearChanged();
}
}
public partial class @ProviderTypeModification {
/// <summary>
/// Inserts a row into the ProviderType table. Returns the value of the TypeID column.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="lastModified">Object allows null.</param>
/// <param name="created">Object allows null.</param>
public static int InsertRow( string @name, System.DateTime? @lastModified, System.DateTime? @created ) { 
var mod = CreateForInsert();
mod.@nameColumnValue.Value = @name;
mod.@lastModifiedColumnValue.Value = @lastModified;
mod.@createdColumnValue.Value = @created;
mod.Execute();
return mod.TypeID;
}
/// <summary>
/// Inserts a row into the ProviderType table. Returns the value of the TypeID column.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="lastModified">Object allows null.</param>
/// <param name="created">Object allows null.</param>
public static int InsertRowWithoutAdditionalLogic( string @name, System.DateTime? @lastModified, System.DateTime? @created ) { 
var mod = CreateForInsert();
mod.@nameColumnValue.Value = @name;
mod.@lastModifiedColumnValue.Value = @lastModified;
mod.@createdColumnValue.Value = @created;
mod.ExecuteWithoutAdditionalLogic();
return mod.TypeID;
}
/// <summary>
/// Updates rows in the ProviderType table that match the specified conditions with the specified data.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="lastModified">Object allows null.</param>
/// <param name="created">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( string @name, System.DateTime? @lastModified, System.DateTime? @created, CommandConditions.ProviderTypeTableCondition requiredCondition, params CommandConditions.ProviderTypeTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@nameColumnValue.Value = @name;
mod.@lastModifiedColumnValue.Value = @lastModified;
mod.@createdColumnValue.Value = @created;
mod.Execute();
}
/// <summary>
/// Updates rows in the ProviderType table that match the specified conditions with the specified data.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="lastModified">Object allows null.</param>
/// <param name="created">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( string @name, System.DateTime? @lastModified, System.DateTime? @created, CommandConditions.ProviderTypeTableCondition requiredCondition, params CommandConditions.ProviderTypeTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@nameColumnValue.Value = @name;
mod.@lastModifiedColumnValue.Value = @lastModified;
mod.@createdColumnValue.Value = @created;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.ProviderTypeTableCondition requiredCondition, params CommandConditions.ProviderTypeTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@ProviderTypeTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.ProviderTypeTableCondition requiredCondition, params CommandConditions.ProviderTypeTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.ProviderTypeTableCondition> conditions ) {
var delete = new InlineDelete( "ProviderType" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.ProviderTypeTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@ProviderTypeTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.ProviderTypeTableCondition> conditions;
private readonly DataValue<int> @typeIDColumnValue = new DataValue<int>();
/// <summary>
/// Gets the value for the TypeID column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @TypeID { get { return @typeIDColumnValue.Value; } }
private readonly DataValue<string> @nameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Name column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Name { get { return @nameColumnValue.Value; } set { @nameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Name has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @NameHasChanged { get { return @nameColumnValue.Changed; } }
private readonly DataValue<System.DateTime?> @lastModifiedColumnValue = new DataValue<System.DateTime?>();
/// <summary>
/// Gets or sets the value for the LastModified column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.DateTime? @LastModified { get { return @lastModifiedColumnValue.Value; } set { @lastModifiedColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LastModified has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LastModifiedHasChanged { get { return @lastModifiedColumnValue.Changed; } }
private readonly DataValue<System.DateTime?> @createdColumnValue = new DataValue<System.DateTime?>();
/// <summary>
/// Gets or sets the value for the Created column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.DateTime? @Created { get { return @createdColumnValue.Value; } set { @createdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Created has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @CreatedHasChanged { get { return @createdColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the ProviderType table.
/// </summary>
public static @ProviderTypeModification CreateForInsert() {
return new @ProviderTypeModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the ProviderType table.
/// </summary>
public static @ProviderTypeModification CreateForUpdate( CommandConditions.ProviderTypeTableCondition requiredCondition, params CommandConditions.ProviderTypeTableCondition[] additionalConditions ) {
var mod = new @ProviderTypeModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@ProviderTypeTableEqualityConditions.@TypeID )
mod.@typeIDColumnValue.Value = ( condition as CommandConditions.@ProviderTypeTableEqualityConditions.@TypeID ).Value;
else if( condition is CommandConditions.@ProviderTypeTableEqualityConditions.@Name )
mod.@nameColumnValue.Value = ( condition as CommandConditions.@ProviderTypeTableEqualityConditions.@Name ).Value;
else if( condition is CommandConditions.@ProviderTypeTableEqualityConditions.@LastModified )
mod.@lastModifiedColumnValue.Value = ( condition as CommandConditions.@ProviderTypeTableEqualityConditions.@LastModified ).Value;
else if( condition is CommandConditions.@ProviderTypeTableEqualityConditions.@Created )
mod.@createdColumnValue.Value = ( condition as CommandConditions.@ProviderTypeTableEqualityConditions.@Created ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the ProviderType table.
/// </summary>
public static @ProviderTypeModification CreateForSingleRowUpdate( int @typeID, string @name, System.DateTime? @lastModified, System.DateTime? @created ) {
var mod = new @ProviderTypeModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.ProviderTypeTableCondition>();
mod.conditions.Add( new CommandConditions.@ProviderTypeTableEqualityConditions.@TypeID( @typeID ) );
mod.@typeIDColumnValue.Value = @typeID;
mod.@nameColumnValue.Value = @name;
mod.@lastModifiedColumnValue.Value = @lastModified;
mod.@createdColumnValue.Value = @created;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.ProviderTypeTableCondition> getConditionList( CommandConditions.ProviderTypeTableCondition requiredCondition, params CommandConditions.ProviderTypeTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.ProviderTypeTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @ProviderTypeModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="lastModified">Object allows null.</param>
/// <param name="created">Object allows null.</param>
public void SetAllData( string @name, System.DateTime? @lastModified, System.DateTime? @created ) {
this.@nameColumnValue.Value = @name;
this.@lastModifiedColumnValue.Value = @lastModified;
this.@createdColumnValue.Value = @created;
}
/// <summary>
/// Executes this ProviderType modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this ProviderType modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "ProviderType" );
addColumnModifications( insert );
@typeIDColumnValue.Value = (System.Int32)Utility.ChangeType( insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection ), typeof( System.Int32 ) );
modType = ModificationType.Update;
conditions = new List<CommandConditions.ProviderTypeTableCondition>();
conditions.Add( new CommandConditions.@ProviderTypeTableEqualityConditions.@TypeID( @TypeID ) );
}
else {
var update = new InlineUpdate( "ProviderType" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @nameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Name", new DbParameterValue( @Name, "NVarChar" ) ) );
if( @lastModifiedColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LastModified", new DbParameterValue( @LastModified, "DateTime" ) ) );
if( @createdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Created", new DbParameterValue( @Created, "DateTime" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@typeIDColumnValue.ClearChanged();
@nameColumnValue.ClearChanged();
@lastModifiedColumnValue.ClearChanged();
@createdColumnValue.ClearChanged();
}
}
public partial class @RolesModification {
/// <summary>
/// Inserts a row into the Roles table. Returns the value of the RoleId column.
/// </summary>
/// <param name="roleName">Object does not allow null.</param>
public static int InsertRow( string @roleName ) { 
var mod = CreateForInsert();
mod.@roleNameColumnValue.Value = @roleName;
mod.Execute();
return mod.RoleId;
}
/// <summary>
/// Inserts a row into the Roles table. Returns the value of the RoleId column.
/// </summary>
/// <param name="roleName">Object does not allow null.</param>
public static int InsertRowWithoutAdditionalLogic( string @roleName ) { 
var mod = CreateForInsert();
mod.@roleNameColumnValue.Value = @roleName;
mod.ExecuteWithoutAdditionalLogic();
return mod.RoleId;
}
/// <summary>
/// Updates rows in the Roles table that match the specified conditions with the specified data.
/// </summary>
/// <param name="roleName">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( string @roleName, CommandConditions.RolesTableCondition requiredCondition, params CommandConditions.RolesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@roleNameColumnValue.Value = @roleName;
mod.Execute();
}
/// <summary>
/// Updates rows in the Roles table that match the specified conditions with the specified data.
/// </summary>
/// <param name="roleName">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( string @roleName, CommandConditions.RolesTableCondition requiredCondition, params CommandConditions.RolesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@roleNameColumnValue.Value = @roleName;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.RolesTableCondition requiredCondition, params CommandConditions.RolesTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@RolesTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.RolesTableCondition requiredCondition, params CommandConditions.RolesTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.RolesTableCondition> conditions ) {
var delete = new InlineDelete( "Roles" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.RolesTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@RolesTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.RolesTableCondition> conditions;
private readonly DataValue<int> @roleIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets the value for the RoleId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @RoleId { get { return @roleIdColumnValue.Value; } }
private readonly DataValue<string> @roleNameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the RoleName column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @RoleName { get { return @roleNameColumnValue.Value; } set { @roleNameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the RoleName has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @RoleNameHasChanged { get { return @roleNameColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the Roles table.
/// </summary>
public static @RolesModification CreateForInsert() {
return new @RolesModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the Roles table.
/// </summary>
public static @RolesModification CreateForUpdate( CommandConditions.RolesTableCondition requiredCondition, params CommandConditions.RolesTableCondition[] additionalConditions ) {
var mod = new @RolesModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@RolesTableEqualityConditions.@RoleId )
mod.@roleIdColumnValue.Value = ( condition as CommandConditions.@RolesTableEqualityConditions.@RoleId ).Value;
else if( condition is CommandConditions.@RolesTableEqualityConditions.@RoleName )
mod.@roleNameColumnValue.Value = ( condition as CommandConditions.@RolesTableEqualityConditions.@RoleName ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the Roles table.
/// </summary>
public static @RolesModification CreateForSingleRowUpdate( int @roleId, string @roleName ) {
var mod = new @RolesModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.RolesTableCondition>();
mod.conditions.Add( new CommandConditions.@RolesTableEqualityConditions.@RoleId( @roleId ) );
mod.@roleIdColumnValue.Value = @roleId;
mod.@roleNameColumnValue.Value = @roleName;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.RolesTableCondition> getConditionList( CommandConditions.RolesTableCondition requiredCondition, params CommandConditions.RolesTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.RolesTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @RolesModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="roleName">Object does not allow null.</param>
public void SetAllData( string @roleName ) {
this.@roleNameColumnValue.Value = @roleName;
}
/// <summary>
/// Executes this Roles modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this Roles modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "Roles" );
addColumnModifications( insert );
@roleIdColumnValue.Value = (System.Int32)Utility.ChangeType( insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection ), typeof( System.Int32 ) );
modType = ModificationType.Update;
conditions = new List<CommandConditions.RolesTableCondition>();
conditions.Add( new CommandConditions.@RolesTableEqualityConditions.@RoleId( @RoleId ) );
}
else {
var update = new InlineUpdate( "Roles" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @roleNameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "RoleName", new DbParameterValue( @RoleName, "NVarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@roleIdColumnValue.ClearChanged();
@roleNameColumnValue.ClearChanged();
}
}
public partial class @SalesforceContactsModification {
/// <summary>
/// Inserts a row into the SalesforceContacts table.
/// </summary>
/// <param name="salesforceContactId">Object does not allow null.</param>
/// <param name="personalDirectAddress">Object does not allow null.</param>
/// <param name="title">Object does not allow null.</param>
/// <param name="firstName">Object does not allow null.</param>
/// <param name="lastName">Object does not allow null.</param>
/// <param name="phoneNumber">Object does not allow null.</param>
/// <param name="salesforceOrganizationId">Object does not allow null.</param>
/// <param name="isVhrUser">Object does not allow null.</param>
public static void InsertRow( int @salesforceContactId, string @personalDirectAddress, string @title, string @firstName, string @lastName, string @phoneNumber, int @salesforceOrganizationId, System.Boolean @isVhrUser ) { 
var mod = CreateForInsert();
mod.@salesforceContactIdColumnValue.Value = @salesforceContactId;
mod.@personalDirectAddressColumnValue.Value = @personalDirectAddress;
mod.@titleColumnValue.Value = @title;
mod.@firstNameColumnValue.Value = @firstName;
mod.@lastNameColumnValue.Value = @lastName;
mod.@phoneNumberColumnValue.Value = @phoneNumber;
mod.@salesforceOrganizationIdColumnValue.Value = @salesforceOrganizationId;
mod.@isVhrUserColumnValue.Value = @isVhrUser;
mod.Execute();
}
/// <summary>
/// Inserts a row into the SalesforceContacts table.
/// </summary>
/// <param name="salesforceContactId">Object does not allow null.</param>
/// <param name="personalDirectAddress">Object does not allow null.</param>
/// <param name="title">Object does not allow null.</param>
/// <param name="firstName">Object does not allow null.</param>
/// <param name="lastName">Object does not allow null.</param>
/// <param name="phoneNumber">Object does not allow null.</param>
/// <param name="salesforceOrganizationId">Object does not allow null.</param>
/// <param name="isVhrUser">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @salesforceContactId, string @personalDirectAddress, string @title, string @firstName, string @lastName, string @phoneNumber, int @salesforceOrganizationId, System.Boolean @isVhrUser ) { 
var mod = CreateForInsert();
mod.@salesforceContactIdColumnValue.Value = @salesforceContactId;
mod.@personalDirectAddressColumnValue.Value = @personalDirectAddress;
mod.@titleColumnValue.Value = @title;
mod.@firstNameColumnValue.Value = @firstName;
mod.@lastNameColumnValue.Value = @lastName;
mod.@phoneNumberColumnValue.Value = @phoneNumber;
mod.@salesforceOrganizationIdColumnValue.Value = @salesforceOrganizationId;
mod.@isVhrUserColumnValue.Value = @isVhrUser;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the SalesforceContacts table that match the specified conditions with the specified data.
/// </summary>
/// <param name="salesforceContactId">Object does not allow null.</param>
/// <param name="personalDirectAddress">Object does not allow null.</param>
/// <param name="title">Object does not allow null.</param>
/// <param name="firstName">Object does not allow null.</param>
/// <param name="lastName">Object does not allow null.</param>
/// <param name="phoneNumber">Object does not allow null.</param>
/// <param name="salesforceOrganizationId">Object does not allow null.</param>
/// <param name="isVhrUser">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @salesforceContactId, string @personalDirectAddress, string @title, string @firstName, string @lastName, string @phoneNumber, int @salesforceOrganizationId, System.Boolean @isVhrUser, CommandConditions.SalesforceContactsTableCondition requiredCondition, params CommandConditions.SalesforceContactsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@salesforceContactIdColumnValue.Value = @salesforceContactId;
mod.@personalDirectAddressColumnValue.Value = @personalDirectAddress;
mod.@titleColumnValue.Value = @title;
mod.@firstNameColumnValue.Value = @firstName;
mod.@lastNameColumnValue.Value = @lastName;
mod.@phoneNumberColumnValue.Value = @phoneNumber;
mod.@salesforceOrganizationIdColumnValue.Value = @salesforceOrganizationId;
mod.@isVhrUserColumnValue.Value = @isVhrUser;
mod.Execute();
}
/// <summary>
/// Updates rows in the SalesforceContacts table that match the specified conditions with the specified data.
/// </summary>
/// <param name="salesforceContactId">Object does not allow null.</param>
/// <param name="personalDirectAddress">Object does not allow null.</param>
/// <param name="title">Object does not allow null.</param>
/// <param name="firstName">Object does not allow null.</param>
/// <param name="lastName">Object does not allow null.</param>
/// <param name="phoneNumber">Object does not allow null.</param>
/// <param name="salesforceOrganizationId">Object does not allow null.</param>
/// <param name="isVhrUser">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @salesforceContactId, string @personalDirectAddress, string @title, string @firstName, string @lastName, string @phoneNumber, int @salesforceOrganizationId, System.Boolean @isVhrUser, CommandConditions.SalesforceContactsTableCondition requiredCondition, params CommandConditions.SalesforceContactsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@salesforceContactIdColumnValue.Value = @salesforceContactId;
mod.@personalDirectAddressColumnValue.Value = @personalDirectAddress;
mod.@titleColumnValue.Value = @title;
mod.@firstNameColumnValue.Value = @firstName;
mod.@lastNameColumnValue.Value = @lastName;
mod.@phoneNumberColumnValue.Value = @phoneNumber;
mod.@salesforceOrganizationIdColumnValue.Value = @salesforceOrganizationId;
mod.@isVhrUserColumnValue.Value = @isVhrUser;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.SalesforceContactsTableCondition requiredCondition, params CommandConditions.SalesforceContactsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@SalesforceContactsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.SalesforceContactsTableCondition requiredCondition, params CommandConditions.SalesforceContactsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.SalesforceContactsTableCondition> conditions ) {
var delete = new InlineDelete( "SalesforceContacts" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.SalesforceContactsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@SalesforceContactsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.SalesforceContactsTableCondition> conditions;
private readonly DataValue<int> @salesforceContactIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the SalesforceContactId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @SalesforceContactId { get { return @salesforceContactIdColumnValue.Value; } set { @salesforceContactIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the SalesforceContactId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @SalesforceContactIdHasChanged { get { return @salesforceContactIdColumnValue.Changed; } }
private readonly DataValue<string> @personalDirectAddressColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the PersonalDirectAddress column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @PersonalDirectAddress { get { return @personalDirectAddressColumnValue.Value; } set { @personalDirectAddressColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PersonalDirectAddress has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PersonalDirectAddressHasChanged { get { return @personalDirectAddressColumnValue.Changed; } }
private readonly DataValue<string> @titleColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Title column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Title { get { return @titleColumnValue.Value; } set { @titleColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Title has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @TitleHasChanged { get { return @titleColumnValue.Changed; } }
private readonly DataValue<string> @firstNameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the FirstName column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @FirstName { get { return @firstNameColumnValue.Value; } set { @firstNameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the FirstName has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @FirstNameHasChanged { get { return @firstNameColumnValue.Changed; } }
private readonly DataValue<string> @lastNameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the LastName column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @LastName { get { return @lastNameColumnValue.Value; } set { @lastNameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LastName has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LastNameHasChanged { get { return @lastNameColumnValue.Changed; } }
private readonly DataValue<string> @phoneNumberColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the PhoneNumber column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @PhoneNumber { get { return @phoneNumberColumnValue.Value; } set { @phoneNumberColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PhoneNumber has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PhoneNumberHasChanged { get { return @phoneNumberColumnValue.Changed; } }
private readonly DataValue<int> @salesforceOrganizationIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the SalesforceOrganizationId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @SalesforceOrganizationId { get { return @salesforceOrganizationIdColumnValue.Value; } set { @salesforceOrganizationIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the SalesforceOrganizationId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @SalesforceOrganizationIdHasChanged { get { return @salesforceOrganizationIdColumnValue.Changed; } }
private readonly DataValue<System.Boolean> @isVhrUserColumnValue = new DataValue<System.Boolean>();
/// <summary>
/// Gets or sets the value for the IsVhrUser column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Boolean @IsVhrUser { get { return @isVhrUserColumnValue.Value; } set { @isVhrUserColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the IsVhrUser has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @IsVhrUserHasChanged { get { return @isVhrUserColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the SalesforceContacts table.
/// </summary>
public static @SalesforceContactsModification CreateForInsert() {
return new @SalesforceContactsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the SalesforceContacts table.
/// </summary>
public static @SalesforceContactsModification CreateForUpdate( CommandConditions.SalesforceContactsTableCondition requiredCondition, params CommandConditions.SalesforceContactsTableCondition[] additionalConditions ) {
var mod = new @SalesforceContactsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@SalesforceContactsTableEqualityConditions.@SalesforceContactId )
mod.@salesforceContactIdColumnValue.Value = ( condition as CommandConditions.@SalesforceContactsTableEqualityConditions.@SalesforceContactId ).Value;
else if( condition is CommandConditions.@SalesforceContactsTableEqualityConditions.@PersonalDirectAddress )
mod.@personalDirectAddressColumnValue.Value = ( condition as CommandConditions.@SalesforceContactsTableEqualityConditions.@PersonalDirectAddress ).Value;
else if( condition is CommandConditions.@SalesforceContactsTableEqualityConditions.@Title )
mod.@titleColumnValue.Value = ( condition as CommandConditions.@SalesforceContactsTableEqualityConditions.@Title ).Value;
else if( condition is CommandConditions.@SalesforceContactsTableEqualityConditions.@FirstName )
mod.@firstNameColumnValue.Value = ( condition as CommandConditions.@SalesforceContactsTableEqualityConditions.@FirstName ).Value;
else if( condition is CommandConditions.@SalesforceContactsTableEqualityConditions.@LastName )
mod.@lastNameColumnValue.Value = ( condition as CommandConditions.@SalesforceContactsTableEqualityConditions.@LastName ).Value;
else if( condition is CommandConditions.@SalesforceContactsTableEqualityConditions.@PhoneNumber )
mod.@phoneNumberColumnValue.Value = ( condition as CommandConditions.@SalesforceContactsTableEqualityConditions.@PhoneNumber ).Value;
else if( condition is CommandConditions.@SalesforceContactsTableEqualityConditions.@SalesforceOrganizationId )
mod.@salesforceOrganizationIdColumnValue.Value = ( condition as CommandConditions.@SalesforceContactsTableEqualityConditions.@SalesforceOrganizationId ).Value;
else if( condition is CommandConditions.@SalesforceContactsTableEqualityConditions.@IsVhrUser )
mod.@isVhrUserColumnValue.Value = ( condition as CommandConditions.@SalesforceContactsTableEqualityConditions.@IsVhrUser ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the SalesforceContacts table.
/// </summary>
public static @SalesforceContactsModification CreateForSingleRowUpdate( int @salesforceContactId, string @personalDirectAddress, string @title, string @firstName, string @lastName, string @phoneNumber, int @salesforceOrganizationId, System.Boolean @isVhrUser ) {
var mod = new @SalesforceContactsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.SalesforceContactsTableCondition>();
mod.conditions.Add( new CommandConditions.@SalesforceContactsTableEqualityConditions.@SalesforceContactId( @salesforceContactId ) );
mod.@salesforceContactIdColumnValue.Value = @salesforceContactId;
mod.@personalDirectAddressColumnValue.Value = @personalDirectAddress;
mod.@titleColumnValue.Value = @title;
mod.@firstNameColumnValue.Value = @firstName;
mod.@lastNameColumnValue.Value = @lastName;
mod.@phoneNumberColumnValue.Value = @phoneNumber;
mod.@salesforceOrganizationIdColumnValue.Value = @salesforceOrganizationId;
mod.@isVhrUserColumnValue.Value = @isVhrUser;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.SalesforceContactsTableCondition> getConditionList( CommandConditions.SalesforceContactsTableCondition requiredCondition, params CommandConditions.SalesforceContactsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.SalesforceContactsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @SalesforceContactsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="salesforceContactId">Object does not allow null.</param>
/// <param name="personalDirectAddress">Object does not allow null.</param>
/// <param name="title">Object does not allow null.</param>
/// <param name="firstName">Object does not allow null.</param>
/// <param name="lastName">Object does not allow null.</param>
/// <param name="phoneNumber">Object does not allow null.</param>
/// <param name="salesforceOrganizationId">Object does not allow null.</param>
/// <param name="isVhrUser">Object does not allow null.</param>
public void SetAllData( int @salesforceContactId, string @personalDirectAddress, string @title, string @firstName, string @lastName, string @phoneNumber, int @salesforceOrganizationId, System.Boolean @isVhrUser ) {
this.@salesforceContactIdColumnValue.Value = @salesforceContactId;
this.@personalDirectAddressColumnValue.Value = @personalDirectAddress;
this.@titleColumnValue.Value = @title;
this.@firstNameColumnValue.Value = @firstName;
this.@lastNameColumnValue.Value = @lastName;
this.@phoneNumberColumnValue.Value = @phoneNumber;
this.@salesforceOrganizationIdColumnValue.Value = @salesforceOrganizationId;
this.@isVhrUserColumnValue.Value = @isVhrUser;
}
/// <summary>
/// Executes this SalesforceContacts modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this SalesforceContacts modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "SalesforceContacts" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.SalesforceContactsTableCondition>();
conditions.Add( new CommandConditions.@SalesforceContactsTableEqualityConditions.@SalesforceContactId( @SalesforceContactId ) );
}
else {
var update = new InlineUpdate( "SalesforceContacts" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @salesforceContactIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "SalesforceContactId", new DbParameterValue( @SalesforceContactId, "Int" ) ) );
if( @personalDirectAddressColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PersonalDirectAddress", new DbParameterValue( @PersonalDirectAddress, "NVarChar" ) ) );
if( @titleColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Title", new DbParameterValue( @Title, "NVarChar" ) ) );
if( @firstNameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "FirstName", new DbParameterValue( @FirstName, "NVarChar" ) ) );
if( @lastNameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LastName", new DbParameterValue( @LastName, "NVarChar" ) ) );
if( @phoneNumberColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PhoneNumber", new DbParameterValue( @PhoneNumber, "NVarChar" ) ) );
if( @salesforceOrganizationIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "SalesforceOrganizationId", new DbParameterValue( @SalesforceOrganizationId, "Int" ) ) );
if( @isVhrUserColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "IsVhrUser", new DbParameterValue( @IsVhrUser, "Bit" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@salesforceContactIdColumnValue.ClearChanged();
@personalDirectAddressColumnValue.ClearChanged();
@titleColumnValue.ClearChanged();
@firstNameColumnValue.ClearChanged();
@lastNameColumnValue.ClearChanged();
@phoneNumberColumnValue.ClearChanged();
@salesforceOrganizationIdColumnValue.ClearChanged();
@isVhrUserColumnValue.ClearChanged();
}
}
public partial class @SalesforceOrganizationsModification {
/// <summary>
/// Inserts a row into the SalesforceOrganizations table.
/// </summary>
/// <param name="salesforceOrganizationId">Object does not allow null.</param>
/// <param name="organizationName">Object does not allow null.</param>
/// <param name="parentOrganizationId">Object allows null.</param>
/// <param name="directAddress">Object does not allow null.</param>
/// <param name="phoneNumber">Object does not allow null.</param>
/// <param name="street">Object does not allow null.</param>
/// <param name="street2">Object does not allow null.</param>
/// <param name="city">Object does not allow null.</param>
/// <param name="stateId">Object does not allow null.</param>
/// <param name="zipCode">Object does not allow null.</param>
public static void InsertRow( int @salesforceOrganizationId, string @organizationName, System.Int32? @parentOrganizationId, string @directAddress, string @phoneNumber, string @street, string @street2, string @city, int @stateId, string @zipCode ) { 
var mod = CreateForInsert();
mod.@salesforceOrganizationIdColumnValue.Value = @salesforceOrganizationId;
mod.@organizationNameColumnValue.Value = @organizationName;
mod.@parentOrganizationIdColumnValue.Value = @parentOrganizationId;
mod.@directAddressColumnValue.Value = @directAddress;
mod.@phoneNumberColumnValue.Value = @phoneNumber;
mod.@streetColumnValue.Value = @street;
mod.@street2ColumnValue.Value = @street2;
mod.@cityColumnValue.Value = @city;
mod.@stateIdColumnValue.Value = @stateId;
mod.@zipCodeColumnValue.Value = @zipCode;
mod.Execute();
}
/// <summary>
/// Inserts a row into the SalesforceOrganizations table.
/// </summary>
/// <param name="salesforceOrganizationId">Object does not allow null.</param>
/// <param name="organizationName">Object does not allow null.</param>
/// <param name="parentOrganizationId">Object allows null.</param>
/// <param name="directAddress">Object does not allow null.</param>
/// <param name="phoneNumber">Object does not allow null.</param>
/// <param name="street">Object does not allow null.</param>
/// <param name="street2">Object does not allow null.</param>
/// <param name="city">Object does not allow null.</param>
/// <param name="stateId">Object does not allow null.</param>
/// <param name="zipCode">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @salesforceOrganizationId, string @organizationName, System.Int32? @parentOrganizationId, string @directAddress, string @phoneNumber, string @street, string @street2, string @city, int @stateId, string @zipCode ) { 
var mod = CreateForInsert();
mod.@salesforceOrganizationIdColumnValue.Value = @salesforceOrganizationId;
mod.@organizationNameColumnValue.Value = @organizationName;
mod.@parentOrganizationIdColumnValue.Value = @parentOrganizationId;
mod.@directAddressColumnValue.Value = @directAddress;
mod.@phoneNumberColumnValue.Value = @phoneNumber;
mod.@streetColumnValue.Value = @street;
mod.@street2ColumnValue.Value = @street2;
mod.@cityColumnValue.Value = @city;
mod.@stateIdColumnValue.Value = @stateId;
mod.@zipCodeColumnValue.Value = @zipCode;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the SalesforceOrganizations table that match the specified conditions with the specified data.
/// </summary>
/// <param name="salesforceOrganizationId">Object does not allow null.</param>
/// <param name="organizationName">Object does not allow null.</param>
/// <param name="parentOrganizationId">Object allows null.</param>
/// <param name="directAddress">Object does not allow null.</param>
/// <param name="phoneNumber">Object does not allow null.</param>
/// <param name="street">Object does not allow null.</param>
/// <param name="street2">Object does not allow null.</param>
/// <param name="city">Object does not allow null.</param>
/// <param name="stateId">Object does not allow null.</param>
/// <param name="zipCode">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @salesforceOrganizationId, string @organizationName, System.Int32? @parentOrganizationId, string @directAddress, string @phoneNumber, string @street, string @street2, string @city, int @stateId, string @zipCode, CommandConditions.SalesforceOrganizationsTableCondition requiredCondition, params CommandConditions.SalesforceOrganizationsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@salesforceOrganizationIdColumnValue.Value = @salesforceOrganizationId;
mod.@organizationNameColumnValue.Value = @organizationName;
mod.@parentOrganizationIdColumnValue.Value = @parentOrganizationId;
mod.@directAddressColumnValue.Value = @directAddress;
mod.@phoneNumberColumnValue.Value = @phoneNumber;
mod.@streetColumnValue.Value = @street;
mod.@street2ColumnValue.Value = @street2;
mod.@cityColumnValue.Value = @city;
mod.@stateIdColumnValue.Value = @stateId;
mod.@zipCodeColumnValue.Value = @zipCode;
mod.Execute();
}
/// <summary>
/// Updates rows in the SalesforceOrganizations table that match the specified conditions with the specified data.
/// </summary>
/// <param name="salesforceOrganizationId">Object does not allow null.</param>
/// <param name="organizationName">Object does not allow null.</param>
/// <param name="parentOrganizationId">Object allows null.</param>
/// <param name="directAddress">Object does not allow null.</param>
/// <param name="phoneNumber">Object does not allow null.</param>
/// <param name="street">Object does not allow null.</param>
/// <param name="street2">Object does not allow null.</param>
/// <param name="city">Object does not allow null.</param>
/// <param name="stateId">Object does not allow null.</param>
/// <param name="zipCode">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @salesforceOrganizationId, string @organizationName, System.Int32? @parentOrganizationId, string @directAddress, string @phoneNumber, string @street, string @street2, string @city, int @stateId, string @zipCode, CommandConditions.SalesforceOrganizationsTableCondition requiredCondition, params CommandConditions.SalesforceOrganizationsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@salesforceOrganizationIdColumnValue.Value = @salesforceOrganizationId;
mod.@organizationNameColumnValue.Value = @organizationName;
mod.@parentOrganizationIdColumnValue.Value = @parentOrganizationId;
mod.@directAddressColumnValue.Value = @directAddress;
mod.@phoneNumberColumnValue.Value = @phoneNumber;
mod.@streetColumnValue.Value = @street;
mod.@street2ColumnValue.Value = @street2;
mod.@cityColumnValue.Value = @city;
mod.@stateIdColumnValue.Value = @stateId;
mod.@zipCodeColumnValue.Value = @zipCode;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.SalesforceOrganizationsTableCondition requiredCondition, params CommandConditions.SalesforceOrganizationsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@SalesforceOrganizationsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.SalesforceOrganizationsTableCondition requiredCondition, params CommandConditions.SalesforceOrganizationsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.SalesforceOrganizationsTableCondition> conditions ) {
var delete = new InlineDelete( "SalesforceOrganizations" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.SalesforceOrganizationsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@SalesforceOrganizationsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.SalesforceOrganizationsTableCondition> conditions;
private readonly DataValue<int> @salesforceOrganizationIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the SalesforceOrganizationId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @SalesforceOrganizationId { get { return @salesforceOrganizationIdColumnValue.Value; } set { @salesforceOrganizationIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the SalesforceOrganizationId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @SalesforceOrganizationIdHasChanged { get { return @salesforceOrganizationIdColumnValue.Changed; } }
private readonly DataValue<string> @organizationNameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the OrganizationName column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @OrganizationName { get { return @organizationNameColumnValue.Value; } set { @organizationNameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the OrganizationName has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @OrganizationNameHasChanged { get { return @organizationNameColumnValue.Changed; } }
private readonly DataValue<System.Int32?> @parentOrganizationIdColumnValue = new DataValue<System.Int32?>();
/// <summary>
/// Gets or sets the value for the ParentOrganizationId column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.Int32? @ParentOrganizationId { get { return @parentOrganizationIdColumnValue.Value; } set { @parentOrganizationIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ParentOrganizationId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ParentOrganizationIdHasChanged { get { return @parentOrganizationIdColumnValue.Changed; } }
private readonly DataValue<string> @directAddressColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the DirectAddress column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @DirectAddress { get { return @directAddressColumnValue.Value; } set { @directAddressColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the DirectAddress has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @DirectAddressHasChanged { get { return @directAddressColumnValue.Changed; } }
private readonly DataValue<string> @phoneNumberColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the PhoneNumber column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @PhoneNumber { get { return @phoneNumberColumnValue.Value; } set { @phoneNumberColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PhoneNumber has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PhoneNumberHasChanged { get { return @phoneNumberColumnValue.Changed; } }
private readonly DataValue<string> @streetColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Street column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Street { get { return @streetColumnValue.Value; } set { @streetColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Street has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @StreetHasChanged { get { return @streetColumnValue.Changed; } }
private readonly DataValue<string> @street2ColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Street2 column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Street2 { get { return @street2ColumnValue.Value; } set { @street2ColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Street2 has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @Street2HasChanged { get { return @street2ColumnValue.Changed; } }
private readonly DataValue<string> @cityColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the City column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @City { get { return @cityColumnValue.Value; } set { @cityColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the City has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @CityHasChanged { get { return @cityColumnValue.Changed; } }
private readonly DataValue<int> @stateIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the StateId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @StateId { get { return @stateIdColumnValue.Value; } set { @stateIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the StateId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @StateIdHasChanged { get { return @stateIdColumnValue.Changed; } }
private readonly DataValue<string> @zipCodeColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the ZipCode column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @ZipCode { get { return @zipCodeColumnValue.Value; } set { @zipCodeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ZipCode has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ZipCodeHasChanged { get { return @zipCodeColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the SalesforceOrganizations table.
/// </summary>
public static @SalesforceOrganizationsModification CreateForInsert() {
return new @SalesforceOrganizationsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the SalesforceOrganizations table.
/// </summary>
public static @SalesforceOrganizationsModification CreateForUpdate( CommandConditions.SalesforceOrganizationsTableCondition requiredCondition, params CommandConditions.SalesforceOrganizationsTableCondition[] additionalConditions ) {
var mod = new @SalesforceOrganizationsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@SalesforceOrganizationsTableEqualityConditions.@SalesforceOrganizationId )
mod.@salesforceOrganizationIdColumnValue.Value = ( condition as CommandConditions.@SalesforceOrganizationsTableEqualityConditions.@SalesforceOrganizationId ).Value;
else if( condition is CommandConditions.@SalesforceOrganizationsTableEqualityConditions.@OrganizationName )
mod.@organizationNameColumnValue.Value = ( condition as CommandConditions.@SalesforceOrganizationsTableEqualityConditions.@OrganizationName ).Value;
else if( condition is CommandConditions.@SalesforceOrganizationsTableEqualityConditions.@ParentOrganizationId )
mod.@parentOrganizationIdColumnValue.Value = ( condition as CommandConditions.@SalesforceOrganizationsTableEqualityConditions.@ParentOrganizationId ).Value;
else if( condition is CommandConditions.@SalesforceOrganizationsTableEqualityConditions.@DirectAddress )
mod.@directAddressColumnValue.Value = ( condition as CommandConditions.@SalesforceOrganizationsTableEqualityConditions.@DirectAddress ).Value;
else if( condition is CommandConditions.@SalesforceOrganizationsTableEqualityConditions.@PhoneNumber )
mod.@phoneNumberColumnValue.Value = ( condition as CommandConditions.@SalesforceOrganizationsTableEqualityConditions.@PhoneNumber ).Value;
else if( condition is CommandConditions.@SalesforceOrganizationsTableEqualityConditions.@Street )
mod.@streetColumnValue.Value = ( condition as CommandConditions.@SalesforceOrganizationsTableEqualityConditions.@Street ).Value;
else if( condition is CommandConditions.@SalesforceOrganizationsTableEqualityConditions.@Street2 )
mod.@street2ColumnValue.Value = ( condition as CommandConditions.@SalesforceOrganizationsTableEqualityConditions.@Street2 ).Value;
else if( condition is CommandConditions.@SalesforceOrganizationsTableEqualityConditions.@City )
mod.@cityColumnValue.Value = ( condition as CommandConditions.@SalesforceOrganizationsTableEqualityConditions.@City ).Value;
else if( condition is CommandConditions.@SalesforceOrganizationsTableEqualityConditions.@StateId )
mod.@stateIdColumnValue.Value = ( condition as CommandConditions.@SalesforceOrganizationsTableEqualityConditions.@StateId ).Value;
else if( condition is CommandConditions.@SalesforceOrganizationsTableEqualityConditions.@ZipCode )
mod.@zipCodeColumnValue.Value = ( condition as CommandConditions.@SalesforceOrganizationsTableEqualityConditions.@ZipCode ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the SalesforceOrganizations table.
/// </summary>
public static @SalesforceOrganizationsModification CreateForSingleRowUpdate( int @salesforceOrganizationId, string @organizationName, System.Int32? @parentOrganizationId, string @directAddress, string @phoneNumber, string @street, string @street2, string @city, int @stateId, string @zipCode ) {
var mod = new @SalesforceOrganizationsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.SalesforceOrganizationsTableCondition>();
mod.conditions.Add( new CommandConditions.@SalesforceOrganizationsTableEqualityConditions.@SalesforceOrganizationId( @salesforceOrganizationId ) );
mod.@salesforceOrganizationIdColumnValue.Value = @salesforceOrganizationId;
mod.@organizationNameColumnValue.Value = @organizationName;
mod.@parentOrganizationIdColumnValue.Value = @parentOrganizationId;
mod.@directAddressColumnValue.Value = @directAddress;
mod.@phoneNumberColumnValue.Value = @phoneNumber;
mod.@streetColumnValue.Value = @street;
mod.@street2ColumnValue.Value = @street2;
mod.@cityColumnValue.Value = @city;
mod.@stateIdColumnValue.Value = @stateId;
mod.@zipCodeColumnValue.Value = @zipCode;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.SalesforceOrganizationsTableCondition> getConditionList( CommandConditions.SalesforceOrganizationsTableCondition requiredCondition, params CommandConditions.SalesforceOrganizationsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.SalesforceOrganizationsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @SalesforceOrganizationsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="salesforceOrganizationId">Object does not allow null.</param>
/// <param name="organizationName">Object does not allow null.</param>
/// <param name="parentOrganizationId">Object allows null.</param>
/// <param name="directAddress">Object does not allow null.</param>
/// <param name="phoneNumber">Object does not allow null.</param>
/// <param name="street">Object does not allow null.</param>
/// <param name="street2">Object does not allow null.</param>
/// <param name="city">Object does not allow null.</param>
/// <param name="stateId">Object does not allow null.</param>
/// <param name="zipCode">Object does not allow null.</param>
public void SetAllData( int @salesforceOrganizationId, string @organizationName, System.Int32? @parentOrganizationId, string @directAddress, string @phoneNumber, string @street, string @street2, string @city, int @stateId, string @zipCode ) {
this.@salesforceOrganizationIdColumnValue.Value = @salesforceOrganizationId;
this.@organizationNameColumnValue.Value = @organizationName;
this.@parentOrganizationIdColumnValue.Value = @parentOrganizationId;
this.@directAddressColumnValue.Value = @directAddress;
this.@phoneNumberColumnValue.Value = @phoneNumber;
this.@streetColumnValue.Value = @street;
this.@street2ColumnValue.Value = @street2;
this.@cityColumnValue.Value = @city;
this.@stateIdColumnValue.Value = @stateId;
this.@zipCodeColumnValue.Value = @zipCode;
}
/// <summary>
/// Executes this SalesforceOrganizations modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this SalesforceOrganizations modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "SalesforceOrganizations" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.SalesforceOrganizationsTableCondition>();
conditions.Add( new CommandConditions.@SalesforceOrganizationsTableEqualityConditions.@SalesforceOrganizationId( @SalesforceOrganizationId ) );
}
else {
var update = new InlineUpdate( "SalesforceOrganizations" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @salesforceOrganizationIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "SalesforceOrganizationId", new DbParameterValue( @SalesforceOrganizationId, "Int" ) ) );
if( @organizationNameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "OrganizationName", new DbParameterValue( @OrganizationName, "NVarChar" ) ) );
if( @parentOrganizationIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ParentOrganizationId", new DbParameterValue( @ParentOrganizationId, "Int" ) ) );
if( @directAddressColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "DirectAddress", new DbParameterValue( @DirectAddress, "NVarChar" ) ) );
if( @phoneNumberColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PhoneNumber", new DbParameterValue( @PhoneNumber, "NVarChar" ) ) );
if( @streetColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Street", new DbParameterValue( @Street, "NVarChar" ) ) );
if( @street2ColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Street2", new DbParameterValue( @Street2, "NVarChar" ) ) );
if( @cityColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "City", new DbParameterValue( @City, "NVarChar" ) ) );
if( @stateIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "StateId", new DbParameterValue( @StateId, "Int" ) ) );
if( @zipCodeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ZipCode", new DbParameterValue( @ZipCode, "VarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@salesforceOrganizationIdColumnValue.ClearChanged();
@organizationNameColumnValue.ClearChanged();
@parentOrganizationIdColumnValue.ClearChanged();
@directAddressColumnValue.ClearChanged();
@phoneNumberColumnValue.ClearChanged();
@streetColumnValue.ClearChanged();
@street2ColumnValue.ClearChanged();
@cityColumnValue.ClearChanged();
@stateIdColumnValue.ClearChanged();
@zipCodeColumnValue.ClearChanged();
}
}
public partial class @ScanAttachFileModification {
/// <summary>
/// Inserts a row into the ScanAttachFile table.
/// </summary>
/// <param name="fileID">Object does not allow null.</param>
/// <param name="encKV">Object does not allow null.</param>
/// <param name="encIV">Object does not allow null.</param>
/// <param name="elysiumID">Object does not allow null.</param>
/// <param name="category">Object does not allow null.</param>
/// <param name="fileStatus">Object does not allow null.</param>
/// <param name="dateUploaded">Object does not allow null.</param>
/// <param name="dateUpdated">Object does not allow null.</param>
/// <param name="suggestedFileName">Object does not allow null.</param>
/// <param name="fileMimeType">Object does not allow null.</param>
/// <param name="fileBytesEncrypted">Object allows null.</param>
/// <param name="patientUserID">Object does not allow null.</param>
public static void InsertRow( System.Guid @fileID, string @encKV, System.Byte[] @encIV, string @elysiumID, string @category, string @fileStatus, DateTime @dateUploaded, DateTime @dateUpdated, string @suggestedFileName, string @fileMimeType, System.Byte[] @fileBytesEncrypted, System.Byte[] @patientUserID ) { 
var mod = CreateForInsert();
mod.@fileIDColumnValue.Value = @fileID;
mod.@encKVColumnValue.Value = @encKV;
mod.@encIVColumnValue.Value = @encIV;
mod.@elysiumIDColumnValue.Value = @elysiumID;
mod.@categoryColumnValue.Value = @category;
mod.@fileStatusColumnValue.Value = @fileStatus;
mod.@dateUploadedColumnValue.Value = @dateUploaded;
mod.@dateUpdatedColumnValue.Value = @dateUpdated;
mod.@suggestedFileNameColumnValue.Value = @suggestedFileName;
mod.@fileMimeTypeColumnValue.Value = @fileMimeType;
mod.@fileBytesEncryptedColumnValue.Value = @fileBytesEncrypted;
mod.@patientUserIDColumnValue.Value = @patientUserID;
mod.Execute();
}
/// <summary>
/// Inserts a row into the ScanAttachFile table.
/// </summary>
/// <param name="fileID">Object does not allow null.</param>
/// <param name="encKV">Object does not allow null.</param>
/// <param name="encIV">Object does not allow null.</param>
/// <param name="elysiumID">Object does not allow null.</param>
/// <param name="category">Object does not allow null.</param>
/// <param name="fileStatus">Object does not allow null.</param>
/// <param name="dateUploaded">Object does not allow null.</param>
/// <param name="dateUpdated">Object does not allow null.</param>
/// <param name="suggestedFileName">Object does not allow null.</param>
/// <param name="fileMimeType">Object does not allow null.</param>
/// <param name="fileBytesEncrypted">Object allows null.</param>
/// <param name="patientUserID">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( System.Guid @fileID, string @encKV, System.Byte[] @encIV, string @elysiumID, string @category, string @fileStatus, DateTime @dateUploaded, DateTime @dateUpdated, string @suggestedFileName, string @fileMimeType, System.Byte[] @fileBytesEncrypted, System.Byte[] @patientUserID ) { 
var mod = CreateForInsert();
mod.@fileIDColumnValue.Value = @fileID;
mod.@encKVColumnValue.Value = @encKV;
mod.@encIVColumnValue.Value = @encIV;
mod.@elysiumIDColumnValue.Value = @elysiumID;
mod.@categoryColumnValue.Value = @category;
mod.@fileStatusColumnValue.Value = @fileStatus;
mod.@dateUploadedColumnValue.Value = @dateUploaded;
mod.@dateUpdatedColumnValue.Value = @dateUpdated;
mod.@suggestedFileNameColumnValue.Value = @suggestedFileName;
mod.@fileMimeTypeColumnValue.Value = @fileMimeType;
mod.@fileBytesEncryptedColumnValue.Value = @fileBytesEncrypted;
mod.@patientUserIDColumnValue.Value = @patientUserID;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the ScanAttachFile table that match the specified conditions with the specified data.
/// </summary>
/// <param name="fileID">Object does not allow null.</param>
/// <param name="encKV">Object does not allow null.</param>
/// <param name="encIV">Object does not allow null.</param>
/// <param name="elysiumID">Object does not allow null.</param>
/// <param name="category">Object does not allow null.</param>
/// <param name="fileStatus">Object does not allow null.</param>
/// <param name="dateUploaded">Object does not allow null.</param>
/// <param name="dateUpdated">Object does not allow null.</param>
/// <param name="suggestedFileName">Object does not allow null.</param>
/// <param name="fileMimeType">Object does not allow null.</param>
/// <param name="fileBytesEncrypted">Object allows null.</param>
/// <param name="patientUserID">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( System.Guid @fileID, string @encKV, System.Byte[] @encIV, string @elysiumID, string @category, string @fileStatus, DateTime @dateUploaded, DateTime @dateUpdated, string @suggestedFileName, string @fileMimeType, System.Byte[] @fileBytesEncrypted, System.Byte[] @patientUserID, CommandConditions.ScanAttachFileTableCondition requiredCondition, params CommandConditions.ScanAttachFileTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@fileIDColumnValue.Value = @fileID;
mod.@encKVColumnValue.Value = @encKV;
mod.@encIVColumnValue.Value = @encIV;
mod.@elysiumIDColumnValue.Value = @elysiumID;
mod.@categoryColumnValue.Value = @category;
mod.@fileStatusColumnValue.Value = @fileStatus;
mod.@dateUploadedColumnValue.Value = @dateUploaded;
mod.@dateUpdatedColumnValue.Value = @dateUpdated;
mod.@suggestedFileNameColumnValue.Value = @suggestedFileName;
mod.@fileMimeTypeColumnValue.Value = @fileMimeType;
mod.@fileBytesEncryptedColumnValue.Value = @fileBytesEncrypted;
mod.@patientUserIDColumnValue.Value = @patientUserID;
mod.Execute();
}
/// <summary>
/// Updates rows in the ScanAttachFile table that match the specified conditions with the specified data.
/// </summary>
/// <param name="fileID">Object does not allow null.</param>
/// <param name="encKV">Object does not allow null.</param>
/// <param name="encIV">Object does not allow null.</param>
/// <param name="elysiumID">Object does not allow null.</param>
/// <param name="category">Object does not allow null.</param>
/// <param name="fileStatus">Object does not allow null.</param>
/// <param name="dateUploaded">Object does not allow null.</param>
/// <param name="dateUpdated">Object does not allow null.</param>
/// <param name="suggestedFileName">Object does not allow null.</param>
/// <param name="fileMimeType">Object does not allow null.</param>
/// <param name="fileBytesEncrypted">Object allows null.</param>
/// <param name="patientUserID">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( System.Guid @fileID, string @encKV, System.Byte[] @encIV, string @elysiumID, string @category, string @fileStatus, DateTime @dateUploaded, DateTime @dateUpdated, string @suggestedFileName, string @fileMimeType, System.Byte[] @fileBytesEncrypted, System.Byte[] @patientUserID, CommandConditions.ScanAttachFileTableCondition requiredCondition, params CommandConditions.ScanAttachFileTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@fileIDColumnValue.Value = @fileID;
mod.@encKVColumnValue.Value = @encKV;
mod.@encIVColumnValue.Value = @encIV;
mod.@elysiumIDColumnValue.Value = @elysiumID;
mod.@categoryColumnValue.Value = @category;
mod.@fileStatusColumnValue.Value = @fileStatus;
mod.@dateUploadedColumnValue.Value = @dateUploaded;
mod.@dateUpdatedColumnValue.Value = @dateUpdated;
mod.@suggestedFileNameColumnValue.Value = @suggestedFileName;
mod.@fileMimeTypeColumnValue.Value = @fileMimeType;
mod.@fileBytesEncryptedColumnValue.Value = @fileBytesEncrypted;
mod.@patientUserIDColumnValue.Value = @patientUserID;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.ScanAttachFileTableCondition requiredCondition, params CommandConditions.ScanAttachFileTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@ScanAttachFileTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.ScanAttachFileTableCondition requiredCondition, params CommandConditions.ScanAttachFileTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.ScanAttachFileTableCondition> conditions ) {
var delete = new InlineDelete( "ScanAttachFile" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.ScanAttachFileTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@ScanAttachFileTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.ScanAttachFileTableCondition> conditions;
private readonly DataValue<System.Guid> @fileIDColumnValue = new DataValue<System.Guid>();
/// <summary>
/// Gets or sets the value for the FileID column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Guid @FileID { get { return @fileIDColumnValue.Value; } set { @fileIDColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the FileID has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @FileIDHasChanged { get { return @fileIDColumnValue.Changed; } }
private readonly DataValue<string> @encKVColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the EncKV column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @EncKV { get { return @encKVColumnValue.Value; } set { @encKVColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EncKV has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EncKVHasChanged { get { return @encKVColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @encIVColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the EncIV column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @EncIV { get { return @encIVColumnValue.Value; } set { @encIVColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EncIV has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EncIVHasChanged { get { return @encIVColumnValue.Changed; } }
private readonly DataValue<string> @elysiumIDColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the ElysiumID column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @ElysiumID { get { return @elysiumIDColumnValue.Value; } set { @elysiumIDColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ElysiumID has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ElysiumIDHasChanged { get { return @elysiumIDColumnValue.Changed; } }
private readonly DataValue<string> @categoryColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Category column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Category { get { return @categoryColumnValue.Value; } set { @categoryColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Category has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @CategoryHasChanged { get { return @categoryColumnValue.Changed; } }
private readonly DataValue<string> @fileStatusColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the FileStatus column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @FileStatus { get { return @fileStatusColumnValue.Value; } set { @fileStatusColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the FileStatus has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @FileStatusHasChanged { get { return @fileStatusColumnValue.Changed; } }
private readonly DataValue<DateTime> @dateUploadedColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the DateUploaded column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @DateUploaded { get { return @dateUploadedColumnValue.Value; } set { @dateUploadedColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the DateUploaded has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @DateUploadedHasChanged { get { return @dateUploadedColumnValue.Changed; } }
private readonly DataValue<DateTime> @dateUpdatedColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the DateUpdated column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @DateUpdated { get { return @dateUpdatedColumnValue.Value; } set { @dateUpdatedColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the DateUpdated has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @DateUpdatedHasChanged { get { return @dateUpdatedColumnValue.Changed; } }
private readonly DataValue<string> @suggestedFileNameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the SuggestedFileName column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @SuggestedFileName { get { return @suggestedFileNameColumnValue.Value; } set { @suggestedFileNameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the SuggestedFileName has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @SuggestedFileNameHasChanged { get { return @suggestedFileNameColumnValue.Changed; } }
private readonly DataValue<string> @fileMimeTypeColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the FileMimeType column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @FileMimeType { get { return @fileMimeTypeColumnValue.Value; } set { @fileMimeTypeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the FileMimeType has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @FileMimeTypeHasChanged { get { return @fileMimeTypeColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @fileBytesEncryptedColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the FileBytesEncrypted column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.Byte[] @FileBytesEncrypted { get { return @fileBytesEncryptedColumnValue.Value; } set { @fileBytesEncryptedColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the FileBytesEncrypted has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @FileBytesEncryptedHasChanged { get { return @fileBytesEncryptedColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @patientUserIDColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the PatientUserID column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @PatientUserID { get { return @patientUserIDColumnValue.Value; } set { @patientUserIDColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PatientUserID has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PatientUserIDHasChanged { get { return @patientUserIDColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the ScanAttachFile table.
/// </summary>
public static @ScanAttachFileModification CreateForInsert() {
return new @ScanAttachFileModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the ScanAttachFile table.
/// </summary>
public static @ScanAttachFileModification CreateForUpdate( CommandConditions.ScanAttachFileTableCondition requiredCondition, params CommandConditions.ScanAttachFileTableCondition[] additionalConditions ) {
var mod = new @ScanAttachFileModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@ScanAttachFileTableEqualityConditions.@FileID )
mod.@fileIDColumnValue.Value = ( condition as CommandConditions.@ScanAttachFileTableEqualityConditions.@FileID ).Value;
else if( condition is CommandConditions.@ScanAttachFileTableEqualityConditions.@EncKV )
mod.@encKVColumnValue.Value = ( condition as CommandConditions.@ScanAttachFileTableEqualityConditions.@EncKV ).Value;
else if( condition is CommandConditions.@ScanAttachFileTableEqualityConditions.@EncIV )
mod.@encIVColumnValue.Value = ( condition as CommandConditions.@ScanAttachFileTableEqualityConditions.@EncIV ).Value;
else if( condition is CommandConditions.@ScanAttachFileTableEqualityConditions.@ElysiumID )
mod.@elysiumIDColumnValue.Value = ( condition as CommandConditions.@ScanAttachFileTableEqualityConditions.@ElysiumID ).Value;
else if( condition is CommandConditions.@ScanAttachFileTableEqualityConditions.@Category )
mod.@categoryColumnValue.Value = ( condition as CommandConditions.@ScanAttachFileTableEqualityConditions.@Category ).Value;
else if( condition is CommandConditions.@ScanAttachFileTableEqualityConditions.@FileStatus )
mod.@fileStatusColumnValue.Value = ( condition as CommandConditions.@ScanAttachFileTableEqualityConditions.@FileStatus ).Value;
else if( condition is CommandConditions.@ScanAttachFileTableEqualityConditions.@DateUploaded )
mod.@dateUploadedColumnValue.Value = ( condition as CommandConditions.@ScanAttachFileTableEqualityConditions.@DateUploaded ).Value;
else if( condition is CommandConditions.@ScanAttachFileTableEqualityConditions.@DateUpdated )
mod.@dateUpdatedColumnValue.Value = ( condition as CommandConditions.@ScanAttachFileTableEqualityConditions.@DateUpdated ).Value;
else if( condition is CommandConditions.@ScanAttachFileTableEqualityConditions.@SuggestedFileName )
mod.@suggestedFileNameColumnValue.Value = ( condition as CommandConditions.@ScanAttachFileTableEqualityConditions.@SuggestedFileName ).Value;
else if( condition is CommandConditions.@ScanAttachFileTableEqualityConditions.@FileMimeType )
mod.@fileMimeTypeColumnValue.Value = ( condition as CommandConditions.@ScanAttachFileTableEqualityConditions.@FileMimeType ).Value;
else if( condition is CommandConditions.@ScanAttachFileTableEqualityConditions.@FileBytesEncrypted )
mod.@fileBytesEncryptedColumnValue.Value = ( condition as CommandConditions.@ScanAttachFileTableEqualityConditions.@FileBytesEncrypted ).Value;
else if( condition is CommandConditions.@ScanAttachFileTableEqualityConditions.@PatientUserID )
mod.@patientUserIDColumnValue.Value = ( condition as CommandConditions.@ScanAttachFileTableEqualityConditions.@PatientUserID ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the ScanAttachFile table.
/// </summary>
public static @ScanAttachFileModification CreateForSingleRowUpdate( System.Guid @fileID, string @encKV, System.Byte[] @encIV, string @elysiumID, string @category, string @fileStatus, DateTime @dateUploaded, DateTime @dateUpdated, string @suggestedFileName, string @fileMimeType, System.Byte[] @fileBytesEncrypted, System.Byte[] @patientUserID ) {
var mod = new @ScanAttachFileModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.ScanAttachFileTableCondition>();
mod.conditions.Add( new CommandConditions.@ScanAttachFileTableEqualityConditions.@FileID( @fileID ) );
mod.@fileIDColumnValue.Value = @fileID;
mod.@encKVColumnValue.Value = @encKV;
mod.@encIVColumnValue.Value = @encIV;
mod.@elysiumIDColumnValue.Value = @elysiumID;
mod.@categoryColumnValue.Value = @category;
mod.@fileStatusColumnValue.Value = @fileStatus;
mod.@dateUploadedColumnValue.Value = @dateUploaded;
mod.@dateUpdatedColumnValue.Value = @dateUpdated;
mod.@suggestedFileNameColumnValue.Value = @suggestedFileName;
mod.@fileMimeTypeColumnValue.Value = @fileMimeType;
mod.@fileBytesEncryptedColumnValue.Value = @fileBytesEncrypted;
mod.@patientUserIDColumnValue.Value = @patientUserID;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.ScanAttachFileTableCondition> getConditionList( CommandConditions.ScanAttachFileTableCondition requiredCondition, params CommandConditions.ScanAttachFileTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.ScanAttachFileTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @ScanAttachFileModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="fileID">Object does not allow null.</param>
/// <param name="encKV">Object does not allow null.</param>
/// <param name="encIV">Object does not allow null.</param>
/// <param name="elysiumID">Object does not allow null.</param>
/// <param name="category">Object does not allow null.</param>
/// <param name="fileStatus">Object does not allow null.</param>
/// <param name="dateUploaded">Object does not allow null.</param>
/// <param name="dateUpdated">Object does not allow null.</param>
/// <param name="suggestedFileName">Object does not allow null.</param>
/// <param name="fileMimeType">Object does not allow null.</param>
/// <param name="fileBytesEncrypted">Object allows null.</param>
/// <param name="patientUserID">Object does not allow null.</param>
public void SetAllData( System.Guid @fileID, string @encKV, System.Byte[] @encIV, string @elysiumID, string @category, string @fileStatus, DateTime @dateUploaded, DateTime @dateUpdated, string @suggestedFileName, string @fileMimeType, System.Byte[] @fileBytesEncrypted, System.Byte[] @patientUserID ) {
this.@fileIDColumnValue.Value = @fileID;
this.@encKVColumnValue.Value = @encKV;
this.@encIVColumnValue.Value = @encIV;
this.@elysiumIDColumnValue.Value = @elysiumID;
this.@categoryColumnValue.Value = @category;
this.@fileStatusColumnValue.Value = @fileStatus;
this.@dateUploadedColumnValue.Value = @dateUploaded;
this.@dateUpdatedColumnValue.Value = @dateUpdated;
this.@suggestedFileNameColumnValue.Value = @suggestedFileName;
this.@fileMimeTypeColumnValue.Value = @fileMimeType;
this.@fileBytesEncryptedColumnValue.Value = @fileBytesEncrypted;
this.@patientUserIDColumnValue.Value = @patientUserID;
}
/// <summary>
/// Executes this ScanAttachFile modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this ScanAttachFile modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "ScanAttachFile" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.ScanAttachFileTableCondition>();
conditions.Add( new CommandConditions.@ScanAttachFileTableEqualityConditions.@FileID( @FileID ) );
}
else {
var update = new InlineUpdate( "ScanAttachFile" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @fileIDColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "FileID", new DbParameterValue( @FileID, "UniqueIdentifier" ) ) );
if( @encKVColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EncKV", new DbParameterValue( @EncKV, "NVarChar" ) ) );
if( @encIVColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EncIV", new DbParameterValue( @EncIV, "VarBinary" ) ) );
if( @elysiumIDColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ElysiumID", new DbParameterValue( @ElysiumID, "NVarChar" ) ) );
if( @categoryColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Category", new DbParameterValue( @Category, "NVarChar" ) ) );
if( @fileStatusColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "FileStatus", new DbParameterValue( @FileStatus, "NVarChar" ) ) );
if( @dateUploadedColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "DateUploaded", new DbParameterValue( @DateUploaded, "DateTime" ) ) );
if( @dateUpdatedColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "DateUpdated", new DbParameterValue( @DateUpdated, "DateTime" ) ) );
if( @suggestedFileNameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "SuggestedFileName", new DbParameterValue( @SuggestedFileName, "NVarChar" ) ) );
if( @fileMimeTypeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "FileMimeType", new DbParameterValue( @FileMimeType, "NVarChar" ) ) );
if( @fileBytesEncryptedColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "FileBytesEncrypted", new DbParameterValue( @FileBytesEncrypted, "VarBinary" ) ) );
if( @patientUserIDColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PatientUserID", new DbParameterValue( @PatientUserID, "VarBinary" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@fileIDColumnValue.ClearChanged();
@encKVColumnValue.ClearChanged();
@encIVColumnValue.ClearChanged();
@elysiumIDColumnValue.ClearChanged();
@categoryColumnValue.ClearChanged();
@fileStatusColumnValue.ClearChanged();
@dateUploadedColumnValue.ClearChanged();
@dateUpdatedColumnValue.ClearChanged();
@suggestedFileNameColumnValue.ClearChanged();
@fileMimeTypeColumnValue.ClearChanged();
@fileBytesEncryptedColumnValue.ClearChanged();
@patientUserIDColumnValue.ClearChanged();
}
}
public partial class @SpecialtyModification {
/// <summary>
/// Inserts a row into the Specialty table. Returns the value of the SpecialtyID column.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="lastModified">Object allows null.</param>
/// <param name="created">Object allows null.</param>
public static int InsertRow( string @name, System.DateTime? @lastModified, System.DateTime? @created ) { 
var mod = CreateForInsert();
mod.@nameColumnValue.Value = @name;
mod.@lastModifiedColumnValue.Value = @lastModified;
mod.@createdColumnValue.Value = @created;
mod.Execute();
return mod.SpecialtyID;
}
/// <summary>
/// Inserts a row into the Specialty table. Returns the value of the SpecialtyID column.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="lastModified">Object allows null.</param>
/// <param name="created">Object allows null.</param>
public static int InsertRowWithoutAdditionalLogic( string @name, System.DateTime? @lastModified, System.DateTime? @created ) { 
var mod = CreateForInsert();
mod.@nameColumnValue.Value = @name;
mod.@lastModifiedColumnValue.Value = @lastModified;
mod.@createdColumnValue.Value = @created;
mod.ExecuteWithoutAdditionalLogic();
return mod.SpecialtyID;
}
/// <summary>
/// Updates rows in the Specialty table that match the specified conditions with the specified data.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="lastModified">Object allows null.</param>
/// <param name="created">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( string @name, System.DateTime? @lastModified, System.DateTime? @created, CommandConditions.SpecialtyTableCondition requiredCondition, params CommandConditions.SpecialtyTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@nameColumnValue.Value = @name;
mod.@lastModifiedColumnValue.Value = @lastModified;
mod.@createdColumnValue.Value = @created;
mod.Execute();
}
/// <summary>
/// Updates rows in the Specialty table that match the specified conditions with the specified data.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="lastModified">Object allows null.</param>
/// <param name="created">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( string @name, System.DateTime? @lastModified, System.DateTime? @created, CommandConditions.SpecialtyTableCondition requiredCondition, params CommandConditions.SpecialtyTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@nameColumnValue.Value = @name;
mod.@lastModifiedColumnValue.Value = @lastModified;
mod.@createdColumnValue.Value = @created;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.SpecialtyTableCondition requiredCondition, params CommandConditions.SpecialtyTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@SpecialtyTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.SpecialtyTableCondition requiredCondition, params CommandConditions.SpecialtyTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.SpecialtyTableCondition> conditions ) {
var delete = new InlineDelete( "Specialty" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.SpecialtyTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@SpecialtyTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.SpecialtyTableCondition> conditions;
private readonly DataValue<int> @specialtyIDColumnValue = new DataValue<int>();
/// <summary>
/// Gets the value for the SpecialtyID column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @SpecialtyID { get { return @specialtyIDColumnValue.Value; } }
private readonly DataValue<string> @nameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Name column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Name { get { return @nameColumnValue.Value; } set { @nameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Name has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @NameHasChanged { get { return @nameColumnValue.Changed; } }
private readonly DataValue<System.DateTime?> @lastModifiedColumnValue = new DataValue<System.DateTime?>();
/// <summary>
/// Gets or sets the value for the LastModified column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.DateTime? @LastModified { get { return @lastModifiedColumnValue.Value; } set { @lastModifiedColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LastModified has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LastModifiedHasChanged { get { return @lastModifiedColumnValue.Changed; } }
private readonly DataValue<System.DateTime?> @createdColumnValue = new DataValue<System.DateTime?>();
/// <summary>
/// Gets or sets the value for the Created column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.DateTime? @Created { get { return @createdColumnValue.Value; } set { @createdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Created has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @CreatedHasChanged { get { return @createdColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the Specialty table.
/// </summary>
public static @SpecialtyModification CreateForInsert() {
return new @SpecialtyModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the Specialty table.
/// </summary>
public static @SpecialtyModification CreateForUpdate( CommandConditions.SpecialtyTableCondition requiredCondition, params CommandConditions.SpecialtyTableCondition[] additionalConditions ) {
var mod = new @SpecialtyModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@SpecialtyTableEqualityConditions.@SpecialtyID )
mod.@specialtyIDColumnValue.Value = ( condition as CommandConditions.@SpecialtyTableEqualityConditions.@SpecialtyID ).Value;
else if( condition is CommandConditions.@SpecialtyTableEqualityConditions.@Name )
mod.@nameColumnValue.Value = ( condition as CommandConditions.@SpecialtyTableEqualityConditions.@Name ).Value;
else if( condition is CommandConditions.@SpecialtyTableEqualityConditions.@LastModified )
mod.@lastModifiedColumnValue.Value = ( condition as CommandConditions.@SpecialtyTableEqualityConditions.@LastModified ).Value;
else if( condition is CommandConditions.@SpecialtyTableEqualityConditions.@Created )
mod.@createdColumnValue.Value = ( condition as CommandConditions.@SpecialtyTableEqualityConditions.@Created ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the Specialty table.
/// </summary>
public static @SpecialtyModification CreateForSingleRowUpdate( int @specialtyID, string @name, System.DateTime? @lastModified, System.DateTime? @created ) {
var mod = new @SpecialtyModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.SpecialtyTableCondition>();
mod.conditions.Add( new CommandConditions.@SpecialtyTableEqualityConditions.@SpecialtyID( @specialtyID ) );
mod.@specialtyIDColumnValue.Value = @specialtyID;
mod.@nameColumnValue.Value = @name;
mod.@lastModifiedColumnValue.Value = @lastModified;
mod.@createdColumnValue.Value = @created;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.SpecialtyTableCondition> getConditionList( CommandConditions.SpecialtyTableCondition requiredCondition, params CommandConditions.SpecialtyTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.SpecialtyTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @SpecialtyModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="lastModified">Object allows null.</param>
/// <param name="created">Object allows null.</param>
public void SetAllData( string @name, System.DateTime? @lastModified, System.DateTime? @created ) {
this.@nameColumnValue.Value = @name;
this.@lastModifiedColumnValue.Value = @lastModified;
this.@createdColumnValue.Value = @created;
}
/// <summary>
/// Executes this Specialty modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this Specialty modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "Specialty" );
addColumnModifications( insert );
@specialtyIDColumnValue.Value = (System.Int32)Utility.ChangeType( insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection ), typeof( System.Int32 ) );
modType = ModificationType.Update;
conditions = new List<CommandConditions.SpecialtyTableCondition>();
conditions.Add( new CommandConditions.@SpecialtyTableEqualityConditions.@SpecialtyID( @SpecialtyID ) );
}
else {
var update = new InlineUpdate( "Specialty" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @nameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Name", new DbParameterValue( @Name, "NVarChar" ) ) );
if( @lastModifiedColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LastModified", new DbParameterValue( @LastModified, "DateTime" ) ) );
if( @createdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Created", new DbParameterValue( @Created, "DateTime" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@specialtyIDColumnValue.ClearChanged();
@nameColumnValue.ClearChanged();
@lastModifiedColumnValue.ClearChanged();
@createdColumnValue.ClearChanged();
}
}
public partial class @StatesModification {
/// <summary>
/// Inserts a row into the States table. Returns the value of the StateId column.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="abbreviation">Object does not allow null.</param>
public static int InsertRow( string @name, string @abbreviation ) { 
var mod = CreateForInsert();
mod.@nameColumnValue.Value = @name;
mod.@abbreviationColumnValue.Value = @abbreviation;
mod.Execute();
return mod.StateId;
}
/// <summary>
/// Inserts a row into the States table. Returns the value of the StateId column.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="abbreviation">Object does not allow null.</param>
public static int InsertRowWithoutAdditionalLogic( string @name, string @abbreviation ) { 
var mod = CreateForInsert();
mod.@nameColumnValue.Value = @name;
mod.@abbreviationColumnValue.Value = @abbreviation;
mod.ExecuteWithoutAdditionalLogic();
return mod.StateId;
}
/// <summary>
/// Updates rows in the States table that match the specified conditions with the specified data.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="abbreviation">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( string @name, string @abbreviation, CommandConditions.StatesTableCondition requiredCondition, params CommandConditions.StatesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@nameColumnValue.Value = @name;
mod.@abbreviationColumnValue.Value = @abbreviation;
mod.Execute();
}
/// <summary>
/// Updates rows in the States table that match the specified conditions with the specified data.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="abbreviation">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( string @name, string @abbreviation, CommandConditions.StatesTableCondition requiredCondition, params CommandConditions.StatesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@nameColumnValue.Value = @name;
mod.@abbreviationColumnValue.Value = @abbreviation;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.StatesTableCondition requiredCondition, params CommandConditions.StatesTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@StatesTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.StatesTableCondition requiredCondition, params CommandConditions.StatesTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.StatesTableCondition> conditions ) {
var delete = new InlineDelete( "States" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.StatesTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@StatesTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.StatesTableCondition> conditions;
private readonly DataValue<int> @stateIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets the value for the StateId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @StateId { get { return @stateIdColumnValue.Value; } }
private readonly DataValue<string> @nameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Name column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Name { get { return @nameColumnValue.Value; } set { @nameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Name has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @NameHasChanged { get { return @nameColumnValue.Changed; } }
private readonly DataValue<string> @abbreviationColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Abbreviation column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Abbreviation { get { return @abbreviationColumnValue.Value; } set { @abbreviationColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Abbreviation has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @AbbreviationHasChanged { get { return @abbreviationColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the States table.
/// </summary>
public static @StatesModification CreateForInsert() {
return new @StatesModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the States table.
/// </summary>
public static @StatesModification CreateForUpdate( CommandConditions.StatesTableCondition requiredCondition, params CommandConditions.StatesTableCondition[] additionalConditions ) {
var mod = new @StatesModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@StatesTableEqualityConditions.@StateId )
mod.@stateIdColumnValue.Value = ( condition as CommandConditions.@StatesTableEqualityConditions.@StateId ).Value;
else if( condition is CommandConditions.@StatesTableEqualityConditions.@Name )
mod.@nameColumnValue.Value = ( condition as CommandConditions.@StatesTableEqualityConditions.@Name ).Value;
else if( condition is CommandConditions.@StatesTableEqualityConditions.@Abbreviation )
mod.@abbreviationColumnValue.Value = ( condition as CommandConditions.@StatesTableEqualityConditions.@Abbreviation ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the States table.
/// </summary>
public static @StatesModification CreateForSingleRowUpdate( int @stateId, string @name, string @abbreviation ) {
var mod = new @StatesModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.StatesTableCondition>();
mod.conditions.Add( new CommandConditions.@StatesTableEqualityConditions.@StateId( @stateId ) );
mod.@stateIdColumnValue.Value = @stateId;
mod.@nameColumnValue.Value = @name;
mod.@abbreviationColumnValue.Value = @abbreviation;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.StatesTableCondition> getConditionList( CommandConditions.StatesTableCondition requiredCondition, params CommandConditions.StatesTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.StatesTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @StatesModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="abbreviation">Object does not allow null.</param>
public void SetAllData( string @name, string @abbreviation ) {
this.@nameColumnValue.Value = @name;
this.@abbreviationColumnValue.Value = @abbreviation;
}
/// <summary>
/// Executes this States modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this States modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "States" );
addColumnModifications( insert );
@stateIdColumnValue.Value = (System.Int32)Utility.ChangeType( insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection ), typeof( System.Int32 ) );
modType = ModificationType.Update;
conditions = new List<CommandConditions.StatesTableCondition>();
conditions.Add( new CommandConditions.@StatesTableEqualityConditions.@StateId( @StateId ) );
}
else {
var update = new InlineUpdate( "States" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @nameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Name", new DbParameterValue( @Name, "NVarChar" ) ) );
if( @abbreviationColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Abbreviation", new DbParameterValue( @Abbreviation, "NVarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@stateIdColumnValue.ClearChanged();
@nameColumnValue.ClearChanged();
@abbreviationColumnValue.ClearChanged();
}
}
public partial class @sysdiagramsModification {
/// <summary>
/// Inserts a row into the sysdiagrams table. Returns the value of the diagram_id column.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="principal_id">Object does not allow null.</param>
/// <param name="version">Object allows null.</param>
/// <param name="definition">Object allows null.</param>
public static int InsertRow( string @name, int @principal_id, System.Int32? @version, System.Byte[] @definition ) { 
var mod = CreateForInsert();
mod.@nameColumnValue.Value = @name;
mod.@principal_idColumnValue.Value = @principal_id;
mod.@versionColumnValue.Value = @version;
mod.@definitionColumnValue.Value = @definition;
mod.Execute();
return mod.diagram_id;
}
/// <summary>
/// Inserts a row into the sysdiagrams table. Returns the value of the diagram_id column.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="principal_id">Object does not allow null.</param>
/// <param name="version">Object allows null.</param>
/// <param name="definition">Object allows null.</param>
public static int InsertRowWithoutAdditionalLogic( string @name, int @principal_id, System.Int32? @version, System.Byte[] @definition ) { 
var mod = CreateForInsert();
mod.@nameColumnValue.Value = @name;
mod.@principal_idColumnValue.Value = @principal_id;
mod.@versionColumnValue.Value = @version;
mod.@definitionColumnValue.Value = @definition;
mod.ExecuteWithoutAdditionalLogic();
return mod.diagram_id;
}
/// <summary>
/// Updates rows in the sysdiagrams table that match the specified conditions with the specified data.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="principal_id">Object does not allow null.</param>
/// <param name="version">Object allows null.</param>
/// <param name="definition">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( string @name, int @principal_id, System.Int32? @version, System.Byte[] @definition, CommandConditions.sysdiagramsTableCondition requiredCondition, params CommandConditions.sysdiagramsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@nameColumnValue.Value = @name;
mod.@principal_idColumnValue.Value = @principal_id;
mod.@versionColumnValue.Value = @version;
mod.@definitionColumnValue.Value = @definition;
mod.Execute();
}
/// <summary>
/// Updates rows in the sysdiagrams table that match the specified conditions with the specified data.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="principal_id">Object does not allow null.</param>
/// <param name="version">Object allows null.</param>
/// <param name="definition">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( string @name, int @principal_id, System.Int32? @version, System.Byte[] @definition, CommandConditions.sysdiagramsTableCondition requiredCondition, params CommandConditions.sysdiagramsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@nameColumnValue.Value = @name;
mod.@principal_idColumnValue.Value = @principal_id;
mod.@versionColumnValue.Value = @version;
mod.@definitionColumnValue.Value = @definition;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.sysdiagramsTableCondition requiredCondition, params CommandConditions.sysdiagramsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@sysdiagramsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.sysdiagramsTableCondition requiredCondition, params CommandConditions.sysdiagramsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.sysdiagramsTableCondition> conditions ) {
var delete = new InlineDelete( "sysdiagrams" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.sysdiagramsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@sysdiagramsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.sysdiagramsTableCondition> conditions;
private readonly DataValue<string> @nameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the name column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @name { get { return @nameColumnValue.Value; } set { @nameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the name has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @nameHasChanged { get { return @nameColumnValue.Changed; } }
private readonly DataValue<int> @principal_idColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the principal_id column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @principal_id { get { return @principal_idColumnValue.Value; } set { @principal_idColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the principal_id has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @principal_idHasChanged { get { return @principal_idColumnValue.Changed; } }
private readonly DataValue<int> @diagram_idColumnValue = new DataValue<int>();
/// <summary>
/// Gets the value for the diagram_id column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @diagram_id { get { return @diagram_idColumnValue.Value; } }
private readonly DataValue<System.Int32?> @versionColumnValue = new DataValue<System.Int32?>();
/// <summary>
/// Gets or sets the value for the version column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.Int32? @version { get { return @versionColumnValue.Value; } set { @versionColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the version has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @versionHasChanged { get { return @versionColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @definitionColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the definition column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.Byte[] @definition { get { return @definitionColumnValue.Value; } set { @definitionColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the definition has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @definitionHasChanged { get { return @definitionColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the sysdiagrams table.
/// </summary>
public static @sysdiagramsModification CreateForInsert() {
return new @sysdiagramsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the sysdiagrams table.
/// </summary>
public static @sysdiagramsModification CreateForUpdate( CommandConditions.sysdiagramsTableCondition requiredCondition, params CommandConditions.sysdiagramsTableCondition[] additionalConditions ) {
var mod = new @sysdiagramsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@sysdiagramsTableEqualityConditions.@name )
mod.@nameColumnValue.Value = ( condition as CommandConditions.@sysdiagramsTableEqualityConditions.@name ).Value;
else if( condition is CommandConditions.@sysdiagramsTableEqualityConditions.@principal_id )
mod.@principal_idColumnValue.Value = ( condition as CommandConditions.@sysdiagramsTableEqualityConditions.@principal_id ).Value;
else if( condition is CommandConditions.@sysdiagramsTableEqualityConditions.@diagram_id )
mod.@diagram_idColumnValue.Value = ( condition as CommandConditions.@sysdiagramsTableEqualityConditions.@diagram_id ).Value;
else if( condition is CommandConditions.@sysdiagramsTableEqualityConditions.@version )
mod.@versionColumnValue.Value = ( condition as CommandConditions.@sysdiagramsTableEqualityConditions.@version ).Value;
else if( condition is CommandConditions.@sysdiagramsTableEqualityConditions.@definition )
mod.@definitionColumnValue.Value = ( condition as CommandConditions.@sysdiagramsTableEqualityConditions.@definition ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the sysdiagrams table.
/// </summary>
public static @sysdiagramsModification CreateForSingleRowUpdate( string @name, int @principal_id, int @diagram_id, System.Int32? @version, System.Byte[] @definition ) {
var mod = new @sysdiagramsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.sysdiagramsTableCondition>();
mod.conditions.Add( new CommandConditions.@sysdiagramsTableEqualityConditions.@diagram_id( @diagram_id ) );
mod.@nameColumnValue.Value = @name;
mod.@principal_idColumnValue.Value = @principal_id;
mod.@diagram_idColumnValue.Value = @diagram_id;
mod.@versionColumnValue.Value = @version;
mod.@definitionColumnValue.Value = @definition;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.sysdiagramsTableCondition> getConditionList( CommandConditions.sysdiagramsTableCondition requiredCondition, params CommandConditions.sysdiagramsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.sysdiagramsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @sysdiagramsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="principal_id">Object does not allow null.</param>
/// <param name="version">Object allows null.</param>
/// <param name="definition">Object allows null.</param>
public void SetAllData( string @name, int @principal_id, System.Int32? @version, System.Byte[] @definition ) {
this.@nameColumnValue.Value = @name;
this.@principal_idColumnValue.Value = @principal_id;
this.@versionColumnValue.Value = @version;
this.@definitionColumnValue.Value = @definition;
}
/// <summary>
/// Executes this sysdiagrams modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this sysdiagrams modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "sysdiagrams" );
addColumnModifications( insert );
@diagram_idColumnValue.Value = (System.Int32)Utility.ChangeType( insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection ), typeof( System.Int32 ) );
modType = ModificationType.Update;
conditions = new List<CommandConditions.sysdiagramsTableCondition>();
conditions.Add( new CommandConditions.@sysdiagramsTableEqualityConditions.@diagram_id( @diagram_id ) );
}
else {
var update = new InlineUpdate( "sysdiagrams" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @nameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "name", new DbParameterValue( @name, "NVarChar" ) ) );
if( @principal_idColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "principal_id", new DbParameterValue( @principal_id, "Int" ) ) );
if( @versionColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "version", new DbParameterValue( @version, "Int" ) ) );
if( @definitionColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "definition", new DbParameterValue( @definition, "VarBinary" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@nameColumnValue.ClearChanged();
@principal_idColumnValue.ClearChanged();
@diagram_idColumnValue.ClearChanged();
@versionColumnValue.ClearChanged();
@definitionColumnValue.ClearChanged();
}
}
public partial class @TempPreDertEventLogsModification {
/// <summary>
/// Inserts a row into the TempPreDertEventLogs table. Returns the value of the TempPreDertEventLogId column.
/// </summary>
/// <param name="eventDate">Object does not allow null.</param>
/// <param name="administratorUserId">Object does not allow null.</param>
/// <param name="affectedUserId">Object does not allow null.</param>
/// <param name="eventCode">Object does not allow null.</param>
/// <param name="logMessage">Object does not allow null.</param>
public static int InsertRow( DateTime @eventDate, int @administratorUserId, int @affectedUserId, string @eventCode, string @logMessage ) { 
var mod = CreateForInsert();
mod.@eventDateColumnValue.Value = @eventDate;
mod.@administratorUserIdColumnValue.Value = @administratorUserId;
mod.@affectedUserIdColumnValue.Value = @affectedUserId;
mod.@eventCodeColumnValue.Value = @eventCode;
mod.@logMessageColumnValue.Value = @logMessage;
mod.Execute();
return mod.TempPreDertEventLogId;
}
/// <summary>
/// Inserts a row into the TempPreDertEventLogs table. Returns the value of the TempPreDertEventLogId column.
/// </summary>
/// <param name="eventDate">Object does not allow null.</param>
/// <param name="administratorUserId">Object does not allow null.</param>
/// <param name="affectedUserId">Object does not allow null.</param>
/// <param name="eventCode">Object does not allow null.</param>
/// <param name="logMessage">Object does not allow null.</param>
public static int InsertRowWithoutAdditionalLogic( DateTime @eventDate, int @administratorUserId, int @affectedUserId, string @eventCode, string @logMessage ) { 
var mod = CreateForInsert();
mod.@eventDateColumnValue.Value = @eventDate;
mod.@administratorUserIdColumnValue.Value = @administratorUserId;
mod.@affectedUserIdColumnValue.Value = @affectedUserId;
mod.@eventCodeColumnValue.Value = @eventCode;
mod.@logMessageColumnValue.Value = @logMessage;
mod.ExecuteWithoutAdditionalLogic();
return mod.TempPreDertEventLogId;
}
/// <summary>
/// Updates rows in the TempPreDertEventLogs table that match the specified conditions with the specified data.
/// </summary>
/// <param name="eventDate">Object does not allow null.</param>
/// <param name="administratorUserId">Object does not allow null.</param>
/// <param name="affectedUserId">Object does not allow null.</param>
/// <param name="eventCode">Object does not allow null.</param>
/// <param name="logMessage">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( DateTime @eventDate, int @administratorUserId, int @affectedUserId, string @eventCode, string @logMessage, CommandConditions.TempPreDertEventLogsTableCondition requiredCondition, params CommandConditions.TempPreDertEventLogsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@eventDateColumnValue.Value = @eventDate;
mod.@administratorUserIdColumnValue.Value = @administratorUserId;
mod.@affectedUserIdColumnValue.Value = @affectedUserId;
mod.@eventCodeColumnValue.Value = @eventCode;
mod.@logMessageColumnValue.Value = @logMessage;
mod.Execute();
}
/// <summary>
/// Updates rows in the TempPreDertEventLogs table that match the specified conditions with the specified data.
/// </summary>
/// <param name="eventDate">Object does not allow null.</param>
/// <param name="administratorUserId">Object does not allow null.</param>
/// <param name="affectedUserId">Object does not allow null.</param>
/// <param name="eventCode">Object does not allow null.</param>
/// <param name="logMessage">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( DateTime @eventDate, int @administratorUserId, int @affectedUserId, string @eventCode, string @logMessage, CommandConditions.TempPreDertEventLogsTableCondition requiredCondition, params CommandConditions.TempPreDertEventLogsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@eventDateColumnValue.Value = @eventDate;
mod.@administratorUserIdColumnValue.Value = @administratorUserId;
mod.@affectedUserIdColumnValue.Value = @affectedUserId;
mod.@eventCodeColumnValue.Value = @eventCode;
mod.@logMessageColumnValue.Value = @logMessage;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.TempPreDertEventLogsTableCondition requiredCondition, params CommandConditions.TempPreDertEventLogsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@TempPreDertEventLogsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.TempPreDertEventLogsTableCondition requiredCondition, params CommandConditions.TempPreDertEventLogsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.TempPreDertEventLogsTableCondition> conditions ) {
var delete = new InlineDelete( "TempPreDertEventLogs" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.TempPreDertEventLogsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@TempPreDertEventLogsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.TempPreDertEventLogsTableCondition> conditions;
private readonly DataValue<int> @tempPreDertEventLogIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets the value for the TempPreDertEventLogId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @TempPreDertEventLogId { get { return @tempPreDertEventLogIdColumnValue.Value; } }
private readonly DataValue<DateTime> @eventDateColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the EventDate column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @EventDate { get { return @eventDateColumnValue.Value; } set { @eventDateColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EventDate has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EventDateHasChanged { get { return @eventDateColumnValue.Changed; } }
private readonly DataValue<int> @administratorUserIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the AdministratorUserId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @AdministratorUserId { get { return @administratorUserIdColumnValue.Value; } set { @administratorUserIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the AdministratorUserId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @AdministratorUserIdHasChanged { get { return @administratorUserIdColumnValue.Changed; } }
private readonly DataValue<int> @affectedUserIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the AffectedUserId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @AffectedUserId { get { return @affectedUserIdColumnValue.Value; } set { @affectedUserIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the AffectedUserId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @AffectedUserIdHasChanged { get { return @affectedUserIdColumnValue.Changed; } }
private readonly DataValue<string> @eventCodeColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the EventCode column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @EventCode { get { return @eventCodeColumnValue.Value; } set { @eventCodeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EventCode has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EventCodeHasChanged { get { return @eventCodeColumnValue.Changed; } }
private readonly DataValue<string> @logMessageColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the LogMessage column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @LogMessage { get { return @logMessageColumnValue.Value; } set { @logMessageColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LogMessage has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LogMessageHasChanged { get { return @logMessageColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the TempPreDertEventLogs table.
/// </summary>
public static @TempPreDertEventLogsModification CreateForInsert() {
return new @TempPreDertEventLogsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the TempPreDertEventLogs table.
/// </summary>
public static @TempPreDertEventLogsModification CreateForUpdate( CommandConditions.TempPreDertEventLogsTableCondition requiredCondition, params CommandConditions.TempPreDertEventLogsTableCondition[] additionalConditions ) {
var mod = new @TempPreDertEventLogsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@TempPreDertEventLogsTableEqualityConditions.@TempPreDertEventLogId )
mod.@tempPreDertEventLogIdColumnValue.Value = ( condition as CommandConditions.@TempPreDertEventLogsTableEqualityConditions.@TempPreDertEventLogId ).Value;
else if( condition is CommandConditions.@TempPreDertEventLogsTableEqualityConditions.@EventDate )
mod.@eventDateColumnValue.Value = ( condition as CommandConditions.@TempPreDertEventLogsTableEqualityConditions.@EventDate ).Value;
else if( condition is CommandConditions.@TempPreDertEventLogsTableEqualityConditions.@AdministratorUserId )
mod.@administratorUserIdColumnValue.Value = ( condition as CommandConditions.@TempPreDertEventLogsTableEqualityConditions.@AdministratorUserId ).Value;
else if( condition is CommandConditions.@TempPreDertEventLogsTableEqualityConditions.@AffectedUserId )
mod.@affectedUserIdColumnValue.Value = ( condition as CommandConditions.@TempPreDertEventLogsTableEqualityConditions.@AffectedUserId ).Value;
else if( condition is CommandConditions.@TempPreDertEventLogsTableEqualityConditions.@EventCode )
mod.@eventCodeColumnValue.Value = ( condition as CommandConditions.@TempPreDertEventLogsTableEqualityConditions.@EventCode ).Value;
else if( condition is CommandConditions.@TempPreDertEventLogsTableEqualityConditions.@LogMessage )
mod.@logMessageColumnValue.Value = ( condition as CommandConditions.@TempPreDertEventLogsTableEqualityConditions.@LogMessage ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the TempPreDertEventLogs table.
/// </summary>
public static @TempPreDertEventLogsModification CreateForSingleRowUpdate( int @tempPreDertEventLogId, DateTime @eventDate, int @administratorUserId, int @affectedUserId, string @eventCode, string @logMessage ) {
var mod = new @TempPreDertEventLogsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.TempPreDertEventLogsTableCondition>();
mod.conditions.Add( new CommandConditions.@TempPreDertEventLogsTableEqualityConditions.@TempPreDertEventLogId( @tempPreDertEventLogId ) );
mod.@tempPreDertEventLogIdColumnValue.Value = @tempPreDertEventLogId;
mod.@eventDateColumnValue.Value = @eventDate;
mod.@administratorUserIdColumnValue.Value = @administratorUserId;
mod.@affectedUserIdColumnValue.Value = @affectedUserId;
mod.@eventCodeColumnValue.Value = @eventCode;
mod.@logMessageColumnValue.Value = @logMessage;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.TempPreDertEventLogsTableCondition> getConditionList( CommandConditions.TempPreDertEventLogsTableCondition requiredCondition, params CommandConditions.TempPreDertEventLogsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.TempPreDertEventLogsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @TempPreDertEventLogsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="eventDate">Object does not allow null.</param>
/// <param name="administratorUserId">Object does not allow null.</param>
/// <param name="affectedUserId">Object does not allow null.</param>
/// <param name="eventCode">Object does not allow null.</param>
/// <param name="logMessage">Object does not allow null.</param>
public void SetAllData( DateTime @eventDate, int @administratorUserId, int @affectedUserId, string @eventCode, string @logMessage ) {
this.@eventDateColumnValue.Value = @eventDate;
this.@administratorUserIdColumnValue.Value = @administratorUserId;
this.@affectedUserIdColumnValue.Value = @affectedUserId;
this.@eventCodeColumnValue.Value = @eventCode;
this.@logMessageColumnValue.Value = @logMessage;
}
/// <summary>
/// Executes this TempPreDertEventLogs modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this TempPreDertEventLogs modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "TempPreDertEventLogs" );
addColumnModifications( insert );
@tempPreDertEventLogIdColumnValue.Value = (System.Int32)Utility.ChangeType( insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection ), typeof( System.Int32 ) );
modType = ModificationType.Update;
conditions = new List<CommandConditions.TempPreDertEventLogsTableCondition>();
conditions.Add( new CommandConditions.@TempPreDertEventLogsTableEqualityConditions.@TempPreDertEventLogId( @TempPreDertEventLogId ) );
}
else {
var update = new InlineUpdate( "TempPreDertEventLogs" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @eventDateColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EventDate", new DbParameterValue( @EventDate, "DateTime2" ) ) );
if( @administratorUserIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "AdministratorUserId", new DbParameterValue( @AdministratorUserId, "Int" ) ) );
if( @affectedUserIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "AffectedUserId", new DbParameterValue( @AffectedUserId, "Int" ) ) );
if( @eventCodeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EventCode", new DbParameterValue( @EventCode, "NVarChar" ) ) );
if( @logMessageColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LogMessage", new DbParameterValue( @LogMessage, "NVarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@tempPreDertEventLogIdColumnValue.ClearChanged();
@eventDateColumnValue.ClearChanged();
@administratorUserIdColumnValue.ClearChanged();
@affectedUserIdColumnValue.ClearChanged();
@eventCodeColumnValue.ClearChanged();
@logMessageColumnValue.ClearChanged();
}
}
public partial class @TfaMethodsModification {
/// <summary>
/// Inserts a row into the TfaMethods table. Returns the value of the TfaMethodId column.
/// </summary>
/// <param name="method">Object does not allow null.</param>
public static int InsertRow( string @method ) { 
var mod = CreateForInsert();
mod.@methodColumnValue.Value = @method;
mod.Execute();
return mod.TfaMethodId;
}
/// <summary>
/// Inserts a row into the TfaMethods table. Returns the value of the TfaMethodId column.
/// </summary>
/// <param name="method">Object does not allow null.</param>
public static int InsertRowWithoutAdditionalLogic( string @method ) { 
var mod = CreateForInsert();
mod.@methodColumnValue.Value = @method;
mod.ExecuteWithoutAdditionalLogic();
return mod.TfaMethodId;
}
/// <summary>
/// Updates rows in the TfaMethods table that match the specified conditions with the specified data.
/// </summary>
/// <param name="method">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( string @method, CommandConditions.TfaMethodsTableCondition requiredCondition, params CommandConditions.TfaMethodsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@methodColumnValue.Value = @method;
mod.Execute();
}
/// <summary>
/// Updates rows in the TfaMethods table that match the specified conditions with the specified data.
/// </summary>
/// <param name="method">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( string @method, CommandConditions.TfaMethodsTableCondition requiredCondition, params CommandConditions.TfaMethodsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@methodColumnValue.Value = @method;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.TfaMethodsTableCondition requiredCondition, params CommandConditions.TfaMethodsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@TfaMethodsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.TfaMethodsTableCondition requiredCondition, params CommandConditions.TfaMethodsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.TfaMethodsTableCondition> conditions ) {
var delete = new InlineDelete( "TfaMethods" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.TfaMethodsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@TfaMethodsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.TfaMethodsTableCondition> conditions;
private readonly DataValue<int> @tfaMethodIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets the value for the TfaMethodId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @TfaMethodId { get { return @tfaMethodIdColumnValue.Value; } }
private readonly DataValue<string> @methodColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Method column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Method { get { return @methodColumnValue.Value; } set { @methodColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Method has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @MethodHasChanged { get { return @methodColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the TfaMethods table.
/// </summary>
public static @TfaMethodsModification CreateForInsert() {
return new @TfaMethodsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the TfaMethods table.
/// </summary>
public static @TfaMethodsModification CreateForUpdate( CommandConditions.TfaMethodsTableCondition requiredCondition, params CommandConditions.TfaMethodsTableCondition[] additionalConditions ) {
var mod = new @TfaMethodsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@TfaMethodsTableEqualityConditions.@TfaMethodId )
mod.@tfaMethodIdColumnValue.Value = ( condition as CommandConditions.@TfaMethodsTableEqualityConditions.@TfaMethodId ).Value;
else if( condition is CommandConditions.@TfaMethodsTableEqualityConditions.@Method )
mod.@methodColumnValue.Value = ( condition as CommandConditions.@TfaMethodsTableEqualityConditions.@Method ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the TfaMethods table.
/// </summary>
public static @TfaMethodsModification CreateForSingleRowUpdate( int @tfaMethodId, string @method ) {
var mod = new @TfaMethodsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.TfaMethodsTableCondition>();
mod.conditions.Add( new CommandConditions.@TfaMethodsTableEqualityConditions.@TfaMethodId( @tfaMethodId ) );
mod.@tfaMethodIdColumnValue.Value = @tfaMethodId;
mod.@methodColumnValue.Value = @method;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.TfaMethodsTableCondition> getConditionList( CommandConditions.TfaMethodsTableCondition requiredCondition, params CommandConditions.TfaMethodsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.TfaMethodsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @TfaMethodsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="method">Object does not allow null.</param>
public void SetAllData( string @method ) {
this.@methodColumnValue.Value = @method;
}
/// <summary>
/// Executes this TfaMethods modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this TfaMethods modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "TfaMethods" );
addColumnModifications( insert );
@tfaMethodIdColumnValue.Value = (System.Int32)Utility.ChangeType( insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection ), typeof( System.Int32 ) );
modType = ModificationType.Update;
conditions = new List<CommandConditions.TfaMethodsTableCondition>();
conditions.Add( new CommandConditions.@TfaMethodsTableEqualityConditions.@TfaMethodId( @TfaMethodId ) );
}
else {
var update = new InlineUpdate( "TfaMethods" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @methodColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Method", new DbParameterValue( @Method, "NVarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@tfaMethodIdColumnValue.ClearChanged();
@methodColumnValue.ClearChanged();
}
}
public partial class @TrainingContentModification {
/// <summary>
/// Inserts a row into the TrainingContent table.
/// </summary>
/// <param name="trainingContentId">Object does not allow null.</param>
/// <param name="text">Object does not allow null.</param>
/// <param name="htmlBlockId">Object does not allow null.</param>
/// <param name="orderRankId">Object does not allow null.</param>
/// <param name="trainingCourseTypeId">Object does not allow null.</param>
public static void InsertRow( int @trainingContentId, string @text, int @htmlBlockId, int @orderRankId, int @trainingCourseTypeId ) { 
var mod = CreateForInsert();
mod.@trainingContentIdColumnValue.Value = @trainingContentId;
mod.@textColumnValue.Value = @text;
mod.@htmlBlockIdColumnValue.Value = @htmlBlockId;
mod.@orderRankIdColumnValue.Value = @orderRankId;
mod.@trainingCourseTypeIdColumnValue.Value = @trainingCourseTypeId;
mod.Execute();
}
/// <summary>
/// Inserts a row into the TrainingContent table.
/// </summary>
/// <param name="trainingContentId">Object does not allow null.</param>
/// <param name="text">Object does not allow null.</param>
/// <param name="htmlBlockId">Object does not allow null.</param>
/// <param name="orderRankId">Object does not allow null.</param>
/// <param name="trainingCourseTypeId">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @trainingContentId, string @text, int @htmlBlockId, int @orderRankId, int @trainingCourseTypeId ) { 
var mod = CreateForInsert();
mod.@trainingContentIdColumnValue.Value = @trainingContentId;
mod.@textColumnValue.Value = @text;
mod.@htmlBlockIdColumnValue.Value = @htmlBlockId;
mod.@orderRankIdColumnValue.Value = @orderRankId;
mod.@trainingCourseTypeIdColumnValue.Value = @trainingCourseTypeId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the TrainingContent table that match the specified conditions with the specified data.
/// </summary>
/// <param name="trainingContentId">Object does not allow null.</param>
/// <param name="text">Object does not allow null.</param>
/// <param name="htmlBlockId">Object does not allow null.</param>
/// <param name="orderRankId">Object does not allow null.</param>
/// <param name="trainingCourseTypeId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @trainingContentId, string @text, int @htmlBlockId, int @orderRankId, int @trainingCourseTypeId, CommandConditions.TrainingContentTableCondition requiredCondition, params CommandConditions.TrainingContentTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@trainingContentIdColumnValue.Value = @trainingContentId;
mod.@textColumnValue.Value = @text;
mod.@htmlBlockIdColumnValue.Value = @htmlBlockId;
mod.@orderRankIdColumnValue.Value = @orderRankId;
mod.@trainingCourseTypeIdColumnValue.Value = @trainingCourseTypeId;
mod.Execute();
}
/// <summary>
/// Updates rows in the TrainingContent table that match the specified conditions with the specified data.
/// </summary>
/// <param name="trainingContentId">Object does not allow null.</param>
/// <param name="text">Object does not allow null.</param>
/// <param name="htmlBlockId">Object does not allow null.</param>
/// <param name="orderRankId">Object does not allow null.</param>
/// <param name="trainingCourseTypeId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @trainingContentId, string @text, int @htmlBlockId, int @orderRankId, int @trainingCourseTypeId, CommandConditions.TrainingContentTableCondition requiredCondition, params CommandConditions.TrainingContentTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@trainingContentIdColumnValue.Value = @trainingContentId;
mod.@textColumnValue.Value = @text;
mod.@htmlBlockIdColumnValue.Value = @htmlBlockId;
mod.@orderRankIdColumnValue.Value = @orderRankId;
mod.@trainingCourseTypeIdColumnValue.Value = @trainingCourseTypeId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.TrainingContentTableCondition requiredCondition, params CommandConditions.TrainingContentTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@TrainingContentTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.TrainingContentTableCondition requiredCondition, params CommandConditions.TrainingContentTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.TrainingContentTableCondition> conditions ) {
var delete = new InlineDelete( "TrainingContent" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.TrainingContentTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@TrainingContentTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.TrainingContentTableCondition> conditions;
private readonly DataValue<int> @trainingContentIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the TrainingContentId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @TrainingContentId { get { return @trainingContentIdColumnValue.Value; } set { @trainingContentIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the TrainingContentId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @TrainingContentIdHasChanged { get { return @trainingContentIdColumnValue.Changed; } }
private readonly DataValue<string> @textColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Text column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Text { get { return @textColumnValue.Value; } set { @textColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Text has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @TextHasChanged { get { return @textColumnValue.Changed; } }
private readonly DataValue<int> @htmlBlockIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the HtmlBlockId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @HtmlBlockId { get { return @htmlBlockIdColumnValue.Value; } set { @htmlBlockIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the HtmlBlockId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @HtmlBlockIdHasChanged { get { return @htmlBlockIdColumnValue.Changed; } }
private readonly DataValue<int> @orderRankIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the OrderRankId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @OrderRankId { get { return @orderRankIdColumnValue.Value; } set { @orderRankIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the OrderRankId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @OrderRankIdHasChanged { get { return @orderRankIdColumnValue.Changed; } }
private readonly DataValue<int> @trainingCourseTypeIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the TrainingCourseTypeId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @TrainingCourseTypeId { get { return @trainingCourseTypeIdColumnValue.Value; } set { @trainingCourseTypeIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the TrainingCourseTypeId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @TrainingCourseTypeIdHasChanged { get { return @trainingCourseTypeIdColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the TrainingContent table.
/// </summary>
public static @TrainingContentModification CreateForInsert() {
return new @TrainingContentModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the TrainingContent table.
/// </summary>
public static @TrainingContentModification CreateForUpdate( CommandConditions.TrainingContentTableCondition requiredCondition, params CommandConditions.TrainingContentTableCondition[] additionalConditions ) {
var mod = new @TrainingContentModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@TrainingContentTableEqualityConditions.@TrainingContentId )
mod.@trainingContentIdColumnValue.Value = ( condition as CommandConditions.@TrainingContentTableEqualityConditions.@TrainingContentId ).Value;
else if( condition is CommandConditions.@TrainingContentTableEqualityConditions.@Text )
mod.@textColumnValue.Value = ( condition as CommandConditions.@TrainingContentTableEqualityConditions.@Text ).Value;
else if( condition is CommandConditions.@TrainingContentTableEqualityConditions.@HtmlBlockId )
mod.@htmlBlockIdColumnValue.Value = ( condition as CommandConditions.@TrainingContentTableEqualityConditions.@HtmlBlockId ).Value;
else if( condition is CommandConditions.@TrainingContentTableEqualityConditions.@OrderRankId )
mod.@orderRankIdColumnValue.Value = ( condition as CommandConditions.@TrainingContentTableEqualityConditions.@OrderRankId ).Value;
else if( condition is CommandConditions.@TrainingContentTableEqualityConditions.@TrainingCourseTypeId )
mod.@trainingCourseTypeIdColumnValue.Value = ( condition as CommandConditions.@TrainingContentTableEqualityConditions.@TrainingCourseTypeId ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the TrainingContent table.
/// </summary>
public static @TrainingContentModification CreateForSingleRowUpdate( int @trainingContentId, string @text, int @htmlBlockId, int @orderRankId, int @trainingCourseTypeId ) {
var mod = new @TrainingContentModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.TrainingContentTableCondition>();
mod.conditions.Add( new CommandConditions.@TrainingContentTableEqualityConditions.@TrainingContentId( @trainingContentId ) );
mod.@trainingContentIdColumnValue.Value = @trainingContentId;
mod.@textColumnValue.Value = @text;
mod.@htmlBlockIdColumnValue.Value = @htmlBlockId;
mod.@orderRankIdColumnValue.Value = @orderRankId;
mod.@trainingCourseTypeIdColumnValue.Value = @trainingCourseTypeId;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.TrainingContentTableCondition> getConditionList( CommandConditions.TrainingContentTableCondition requiredCondition, params CommandConditions.TrainingContentTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.TrainingContentTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @TrainingContentModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="trainingContentId">Object does not allow null.</param>
/// <param name="text">Object does not allow null.</param>
/// <param name="htmlBlockId">Object does not allow null.</param>
/// <param name="orderRankId">Object does not allow null.</param>
/// <param name="trainingCourseTypeId">Object does not allow null.</param>
public void SetAllData( int @trainingContentId, string @text, int @htmlBlockId, int @orderRankId, int @trainingCourseTypeId ) {
this.@trainingContentIdColumnValue.Value = @trainingContentId;
this.@textColumnValue.Value = @text;
this.@htmlBlockIdColumnValue.Value = @htmlBlockId;
this.@orderRankIdColumnValue.Value = @orderRankId;
this.@trainingCourseTypeIdColumnValue.Value = @trainingCourseTypeId;
}
/// <summary>
/// Executes this TrainingContent modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this TrainingContent modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "TrainingContent" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.TrainingContentTableCondition>();
conditions.Add( new CommandConditions.@TrainingContentTableEqualityConditions.@TrainingContentId( @TrainingContentId ) );
}
else {
var update = new InlineUpdate( "TrainingContent" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @trainingContentIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "TrainingContentId", new DbParameterValue( @TrainingContentId, "Int" ) ) );
if( @textColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Text", new DbParameterValue( @Text, "NVarChar" ) ) );
if( @htmlBlockIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "HtmlBlockId", new DbParameterValue( @HtmlBlockId, "Int" ) ) );
if( @orderRankIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "OrderRankId", new DbParameterValue( @OrderRankId, "Int" ) ) );
if( @trainingCourseTypeIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "TrainingCourseTypeId", new DbParameterValue( @TrainingCourseTypeId, "Int" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@trainingContentIdColumnValue.ClearChanged();
@textColumnValue.ClearChanged();
@htmlBlockIdColumnValue.ClearChanged();
@orderRankIdColumnValue.ClearChanged();
@trainingCourseTypeIdColumnValue.ClearChanged();
}
}
public partial class @TrainingCoursesModification {
/// <summary>
/// Inserts a row into the TrainingCourses table.
/// </summary>
/// <param name="trainingCourseId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="destinationUrl">Object does not allow null.</param>
/// <param name="isPerpetual">Object does not allow null.</param>
/// <param name="isArchived">Object does not allow null.</param>
/// <param name="trainingCourseTypeId">Object does not allow null.</param>
public static void InsertRow( int @trainingCourseId, string @name, string @destinationUrl, System.Boolean @isPerpetual, System.Boolean @isArchived, int @trainingCourseTypeId ) { 
var mod = CreateForInsert();
mod.@trainingCourseIdColumnValue.Value = @trainingCourseId;
mod.@nameColumnValue.Value = @name;
mod.@destinationUrlColumnValue.Value = @destinationUrl;
mod.@isPerpetualColumnValue.Value = @isPerpetual;
mod.@isArchivedColumnValue.Value = @isArchived;
mod.@trainingCourseTypeIdColumnValue.Value = @trainingCourseTypeId;
mod.Execute();
}
/// <summary>
/// Inserts a row into the TrainingCourses table.
/// </summary>
/// <param name="trainingCourseId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="destinationUrl">Object does not allow null.</param>
/// <param name="isPerpetual">Object does not allow null.</param>
/// <param name="isArchived">Object does not allow null.</param>
/// <param name="trainingCourseTypeId">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @trainingCourseId, string @name, string @destinationUrl, System.Boolean @isPerpetual, System.Boolean @isArchived, int @trainingCourseTypeId ) { 
var mod = CreateForInsert();
mod.@trainingCourseIdColumnValue.Value = @trainingCourseId;
mod.@nameColumnValue.Value = @name;
mod.@destinationUrlColumnValue.Value = @destinationUrl;
mod.@isPerpetualColumnValue.Value = @isPerpetual;
mod.@isArchivedColumnValue.Value = @isArchived;
mod.@trainingCourseTypeIdColumnValue.Value = @trainingCourseTypeId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the TrainingCourses table that match the specified conditions with the specified data.
/// </summary>
/// <param name="trainingCourseId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="destinationUrl">Object does not allow null.</param>
/// <param name="isPerpetual">Object does not allow null.</param>
/// <param name="isArchived">Object does not allow null.</param>
/// <param name="trainingCourseTypeId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @trainingCourseId, string @name, string @destinationUrl, System.Boolean @isPerpetual, System.Boolean @isArchived, int @trainingCourseTypeId, CommandConditions.TrainingCoursesTableCondition requiredCondition, params CommandConditions.TrainingCoursesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@trainingCourseIdColumnValue.Value = @trainingCourseId;
mod.@nameColumnValue.Value = @name;
mod.@destinationUrlColumnValue.Value = @destinationUrl;
mod.@isPerpetualColumnValue.Value = @isPerpetual;
mod.@isArchivedColumnValue.Value = @isArchived;
mod.@trainingCourseTypeIdColumnValue.Value = @trainingCourseTypeId;
mod.Execute();
}
/// <summary>
/// Updates rows in the TrainingCourses table that match the specified conditions with the specified data.
/// </summary>
/// <param name="trainingCourseId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="destinationUrl">Object does not allow null.</param>
/// <param name="isPerpetual">Object does not allow null.</param>
/// <param name="isArchived">Object does not allow null.</param>
/// <param name="trainingCourseTypeId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @trainingCourseId, string @name, string @destinationUrl, System.Boolean @isPerpetual, System.Boolean @isArchived, int @trainingCourseTypeId, CommandConditions.TrainingCoursesTableCondition requiredCondition, params CommandConditions.TrainingCoursesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@trainingCourseIdColumnValue.Value = @trainingCourseId;
mod.@nameColumnValue.Value = @name;
mod.@destinationUrlColumnValue.Value = @destinationUrl;
mod.@isPerpetualColumnValue.Value = @isPerpetual;
mod.@isArchivedColumnValue.Value = @isArchived;
mod.@trainingCourseTypeIdColumnValue.Value = @trainingCourseTypeId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.TrainingCoursesTableCondition requiredCondition, params CommandConditions.TrainingCoursesTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@TrainingCoursesTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.TrainingCoursesTableCondition requiredCondition, params CommandConditions.TrainingCoursesTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.TrainingCoursesTableCondition> conditions ) {
var delete = new InlineDelete( "TrainingCourses" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.TrainingCoursesTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@TrainingCoursesTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.TrainingCoursesTableCondition> conditions;
private readonly DataValue<int> @trainingCourseIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the TrainingCourseId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @TrainingCourseId { get { return @trainingCourseIdColumnValue.Value; } set { @trainingCourseIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the TrainingCourseId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @TrainingCourseIdHasChanged { get { return @trainingCourseIdColumnValue.Changed; } }
private readonly DataValue<string> @nameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Name column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Name { get { return @nameColumnValue.Value; } set { @nameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Name has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @NameHasChanged { get { return @nameColumnValue.Changed; } }
private readonly DataValue<string> @destinationUrlColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the DestinationUrl column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @DestinationUrl { get { return @destinationUrlColumnValue.Value; } set { @destinationUrlColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the DestinationUrl has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @DestinationUrlHasChanged { get { return @destinationUrlColumnValue.Changed; } }
private readonly DataValue<System.Boolean> @isPerpetualColumnValue = new DataValue<System.Boolean>();
/// <summary>
/// Gets or sets the value for the IsPerpetual column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Boolean @IsPerpetual { get { return @isPerpetualColumnValue.Value; } set { @isPerpetualColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the IsPerpetual has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @IsPerpetualHasChanged { get { return @isPerpetualColumnValue.Changed; } }
private readonly DataValue<System.Boolean> @isArchivedColumnValue = new DataValue<System.Boolean>();
/// <summary>
/// Gets or sets the value for the IsArchived column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Boolean @IsArchived { get { return @isArchivedColumnValue.Value; } set { @isArchivedColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the IsArchived has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @IsArchivedHasChanged { get { return @isArchivedColumnValue.Changed; } }
private readonly DataValue<int> @trainingCourseTypeIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the TrainingCourseTypeId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @TrainingCourseTypeId { get { return @trainingCourseTypeIdColumnValue.Value; } set { @trainingCourseTypeIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the TrainingCourseTypeId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @TrainingCourseTypeIdHasChanged { get { return @trainingCourseTypeIdColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the TrainingCourses table.
/// </summary>
public static @TrainingCoursesModification CreateForInsert() {
return new @TrainingCoursesModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the TrainingCourses table.
/// </summary>
public static @TrainingCoursesModification CreateForUpdate( CommandConditions.TrainingCoursesTableCondition requiredCondition, params CommandConditions.TrainingCoursesTableCondition[] additionalConditions ) {
var mod = new @TrainingCoursesModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@TrainingCoursesTableEqualityConditions.@TrainingCourseId )
mod.@trainingCourseIdColumnValue.Value = ( condition as CommandConditions.@TrainingCoursesTableEqualityConditions.@TrainingCourseId ).Value;
else if( condition is CommandConditions.@TrainingCoursesTableEqualityConditions.@Name )
mod.@nameColumnValue.Value = ( condition as CommandConditions.@TrainingCoursesTableEqualityConditions.@Name ).Value;
else if( condition is CommandConditions.@TrainingCoursesTableEqualityConditions.@DestinationUrl )
mod.@destinationUrlColumnValue.Value = ( condition as CommandConditions.@TrainingCoursesTableEqualityConditions.@DestinationUrl ).Value;
else if( condition is CommandConditions.@TrainingCoursesTableEqualityConditions.@IsPerpetual )
mod.@isPerpetualColumnValue.Value = ( condition as CommandConditions.@TrainingCoursesTableEqualityConditions.@IsPerpetual ).Value;
else if( condition is CommandConditions.@TrainingCoursesTableEqualityConditions.@IsArchived )
mod.@isArchivedColumnValue.Value = ( condition as CommandConditions.@TrainingCoursesTableEqualityConditions.@IsArchived ).Value;
else if( condition is CommandConditions.@TrainingCoursesTableEqualityConditions.@TrainingCourseTypeId )
mod.@trainingCourseTypeIdColumnValue.Value = ( condition as CommandConditions.@TrainingCoursesTableEqualityConditions.@TrainingCourseTypeId ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the TrainingCourses table.
/// </summary>
public static @TrainingCoursesModification CreateForSingleRowUpdate( int @trainingCourseId, string @name, string @destinationUrl, System.Boolean @isPerpetual, System.Boolean @isArchived, int @trainingCourseTypeId ) {
var mod = new @TrainingCoursesModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.TrainingCoursesTableCondition>();
mod.conditions.Add( new CommandConditions.@TrainingCoursesTableEqualityConditions.@TrainingCourseId( @trainingCourseId ) );
mod.@trainingCourseIdColumnValue.Value = @trainingCourseId;
mod.@nameColumnValue.Value = @name;
mod.@destinationUrlColumnValue.Value = @destinationUrl;
mod.@isPerpetualColumnValue.Value = @isPerpetual;
mod.@isArchivedColumnValue.Value = @isArchived;
mod.@trainingCourseTypeIdColumnValue.Value = @trainingCourseTypeId;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.TrainingCoursesTableCondition> getConditionList( CommandConditions.TrainingCoursesTableCondition requiredCondition, params CommandConditions.TrainingCoursesTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.TrainingCoursesTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @TrainingCoursesModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="trainingCourseId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="destinationUrl">Object does not allow null.</param>
/// <param name="isPerpetual">Object does not allow null.</param>
/// <param name="isArchived">Object does not allow null.</param>
/// <param name="trainingCourseTypeId">Object does not allow null.</param>
public void SetAllData( int @trainingCourseId, string @name, string @destinationUrl, System.Boolean @isPerpetual, System.Boolean @isArchived, int @trainingCourseTypeId ) {
this.@trainingCourseIdColumnValue.Value = @trainingCourseId;
this.@nameColumnValue.Value = @name;
this.@destinationUrlColumnValue.Value = @destinationUrl;
this.@isPerpetualColumnValue.Value = @isPerpetual;
this.@isArchivedColumnValue.Value = @isArchived;
this.@trainingCourseTypeIdColumnValue.Value = @trainingCourseTypeId;
}
/// <summary>
/// Executes this TrainingCourses modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this TrainingCourses modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "TrainingCourses" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.TrainingCoursesTableCondition>();
conditions.Add( new CommandConditions.@TrainingCoursesTableEqualityConditions.@TrainingCourseId( @TrainingCourseId ) );
}
else {
var update = new InlineUpdate( "TrainingCourses" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @trainingCourseIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "TrainingCourseId", new DbParameterValue( @TrainingCourseId, "Int" ) ) );
if( @nameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Name", new DbParameterValue( @Name, "NVarChar" ) ) );
if( @destinationUrlColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "DestinationUrl", new DbParameterValue( @DestinationUrl, "NVarChar" ) ) );
if( @isPerpetualColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "IsPerpetual", new DbParameterValue( @IsPerpetual, "Bit" ) ) );
if( @isArchivedColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "IsArchived", new DbParameterValue( @IsArchived, "Bit" ) ) );
if( @trainingCourseTypeIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "TrainingCourseTypeId", new DbParameterValue( @TrainingCourseTypeId, "Int" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@trainingCourseIdColumnValue.ClearChanged();
@nameColumnValue.ClearChanged();
@destinationUrlColumnValue.ClearChanged();
@isPerpetualColumnValue.ClearChanged();
@isArchivedColumnValue.ClearChanged();
@trainingCourseTypeIdColumnValue.ClearChanged();
}
}
public partial class @TrainingCourseTypesModification {
/// <summary>
/// Inserts a row into the TrainingCourseTypes table.
/// </summary>
/// <param name="trainingCourseTypeId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
public static void InsertRow( int @trainingCourseTypeId, string @name ) { 
var mod = CreateForInsert();
mod.@trainingCourseTypeIdColumnValue.Value = @trainingCourseTypeId;
mod.@nameColumnValue.Value = @name;
mod.Execute();
}
/// <summary>
/// Inserts a row into the TrainingCourseTypes table.
/// </summary>
/// <param name="trainingCourseTypeId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @trainingCourseTypeId, string @name ) { 
var mod = CreateForInsert();
mod.@trainingCourseTypeIdColumnValue.Value = @trainingCourseTypeId;
mod.@nameColumnValue.Value = @name;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the TrainingCourseTypes table that match the specified conditions with the specified data.
/// </summary>
/// <param name="trainingCourseTypeId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @trainingCourseTypeId, string @name, CommandConditions.TrainingCourseTypesTableCondition requiredCondition, params CommandConditions.TrainingCourseTypesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@trainingCourseTypeIdColumnValue.Value = @trainingCourseTypeId;
mod.@nameColumnValue.Value = @name;
mod.Execute();
}
/// <summary>
/// Updates rows in the TrainingCourseTypes table that match the specified conditions with the specified data.
/// </summary>
/// <param name="trainingCourseTypeId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @trainingCourseTypeId, string @name, CommandConditions.TrainingCourseTypesTableCondition requiredCondition, params CommandConditions.TrainingCourseTypesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@trainingCourseTypeIdColumnValue.Value = @trainingCourseTypeId;
mod.@nameColumnValue.Value = @name;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.TrainingCourseTypesTableCondition requiredCondition, params CommandConditions.TrainingCourseTypesTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@TrainingCourseTypesTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.TrainingCourseTypesTableCondition requiredCondition, params CommandConditions.TrainingCourseTypesTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.TrainingCourseTypesTableCondition> conditions ) {
var delete = new InlineDelete( "TrainingCourseTypes" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.TrainingCourseTypesTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@TrainingCourseTypesTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.TrainingCourseTypesTableCondition> conditions;
private readonly DataValue<int> @trainingCourseTypeIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the TrainingCourseTypeId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @TrainingCourseTypeId { get { return @trainingCourseTypeIdColumnValue.Value; } set { @trainingCourseTypeIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the TrainingCourseTypeId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @TrainingCourseTypeIdHasChanged { get { return @trainingCourseTypeIdColumnValue.Changed; } }
private readonly DataValue<string> @nameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Name column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Name { get { return @nameColumnValue.Value; } set { @nameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Name has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @NameHasChanged { get { return @nameColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the TrainingCourseTypes table.
/// </summary>
public static @TrainingCourseTypesModification CreateForInsert() {
return new @TrainingCourseTypesModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the TrainingCourseTypes table.
/// </summary>
public static @TrainingCourseTypesModification CreateForUpdate( CommandConditions.TrainingCourseTypesTableCondition requiredCondition, params CommandConditions.TrainingCourseTypesTableCondition[] additionalConditions ) {
var mod = new @TrainingCourseTypesModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@TrainingCourseTypesTableEqualityConditions.@TrainingCourseTypeId )
mod.@trainingCourseTypeIdColumnValue.Value = ( condition as CommandConditions.@TrainingCourseTypesTableEqualityConditions.@TrainingCourseTypeId ).Value;
else if( condition is CommandConditions.@TrainingCourseTypesTableEqualityConditions.@Name )
mod.@nameColumnValue.Value = ( condition as CommandConditions.@TrainingCourseTypesTableEqualityConditions.@Name ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the TrainingCourseTypes table.
/// </summary>
public static @TrainingCourseTypesModification CreateForSingleRowUpdate( int @trainingCourseTypeId, string @name ) {
var mod = new @TrainingCourseTypesModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.TrainingCourseTypesTableCondition>();
mod.conditions.Add( new CommandConditions.@TrainingCourseTypesTableEqualityConditions.@TrainingCourseTypeId( @trainingCourseTypeId ) );
mod.@trainingCourseTypeIdColumnValue.Value = @trainingCourseTypeId;
mod.@nameColumnValue.Value = @name;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.TrainingCourseTypesTableCondition> getConditionList( CommandConditions.TrainingCourseTypesTableCondition requiredCondition, params CommandConditions.TrainingCourseTypesTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.TrainingCourseTypesTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @TrainingCourseTypesModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="trainingCourseTypeId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
public void SetAllData( int @trainingCourseTypeId, string @name ) {
this.@trainingCourseTypeIdColumnValue.Value = @trainingCourseTypeId;
this.@nameColumnValue.Value = @name;
}
/// <summary>
/// Executes this TrainingCourseTypes modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this TrainingCourseTypes modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "TrainingCourseTypes" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.TrainingCourseTypesTableCondition>();
conditions.Add( new CommandConditions.@TrainingCourseTypesTableEqualityConditions.@TrainingCourseTypeId( @TrainingCourseTypeId ) );
}
else {
var update = new InlineUpdate( "TrainingCourseTypes" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @trainingCourseTypeIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "TrainingCourseTypeId", new DbParameterValue( @TrainingCourseTypeId, "Int" ) ) );
if( @nameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Name", new DbParameterValue( @Name, "NVarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@trainingCourseTypeIdColumnValue.ClearChanged();
@nameColumnValue.ClearChanged();
}
}
public partial class @UserLoginLogsModification {
/// <summary>
/// Inserts a row into the UserLoginLogs table. Returns the value of the UserLoginLogId column.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="dateTimeUtc">Object does not allow null.</param>
public static int InsertRow( int @userId, DateTime @dateTimeUtc ) { 
var mod = CreateForInsert();
mod.@userIdColumnValue.Value = @userId;
mod.@dateTimeUtcColumnValue.Value = @dateTimeUtc;
mod.Execute();
return mod.UserLoginLogId;
}
/// <summary>
/// Inserts a row into the UserLoginLogs table. Returns the value of the UserLoginLogId column.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="dateTimeUtc">Object does not allow null.</param>
public static int InsertRowWithoutAdditionalLogic( int @userId, DateTime @dateTimeUtc ) { 
var mod = CreateForInsert();
mod.@userIdColumnValue.Value = @userId;
mod.@dateTimeUtcColumnValue.Value = @dateTimeUtc;
mod.ExecuteWithoutAdditionalLogic();
return mod.UserLoginLogId;
}
/// <summary>
/// Updates rows in the UserLoginLogs table that match the specified conditions with the specified data.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="dateTimeUtc">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @userId, DateTime @dateTimeUtc, CommandConditions.UserLoginLogsTableCondition requiredCondition, params CommandConditions.UserLoginLogsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@userIdColumnValue.Value = @userId;
mod.@dateTimeUtcColumnValue.Value = @dateTimeUtc;
mod.Execute();
}
/// <summary>
/// Updates rows in the UserLoginLogs table that match the specified conditions with the specified data.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="dateTimeUtc">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @userId, DateTime @dateTimeUtc, CommandConditions.UserLoginLogsTableCondition requiredCondition, params CommandConditions.UserLoginLogsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@userIdColumnValue.Value = @userId;
mod.@dateTimeUtcColumnValue.Value = @dateTimeUtc;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.UserLoginLogsTableCondition requiredCondition, params CommandConditions.UserLoginLogsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@UserLoginLogsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.UserLoginLogsTableCondition requiredCondition, params CommandConditions.UserLoginLogsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.UserLoginLogsTableCondition> conditions ) {
var delete = new InlineDelete( "UserLoginLogs" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.UserLoginLogsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@UserLoginLogsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.UserLoginLogsTableCondition> conditions;
private readonly DataValue<int> @userLoginLogIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets the value for the UserLoginLogId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @UserLoginLogId { get { return @userLoginLogIdColumnValue.Value; } }
private readonly DataValue<int> @userIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the UserId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @UserId { get { return @userIdColumnValue.Value; } set { @userIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the UserId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @UserIdHasChanged { get { return @userIdColumnValue.Changed; } }
private readonly DataValue<DateTime> @dateTimeUtcColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the DateTimeUtc column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @DateTimeUtc { get { return @dateTimeUtcColumnValue.Value; } set { @dateTimeUtcColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the DateTimeUtc has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @DateTimeUtcHasChanged { get { return @dateTimeUtcColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the UserLoginLogs table.
/// </summary>
public static @UserLoginLogsModification CreateForInsert() {
return new @UserLoginLogsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the UserLoginLogs table.
/// </summary>
public static @UserLoginLogsModification CreateForUpdate( CommandConditions.UserLoginLogsTableCondition requiredCondition, params CommandConditions.UserLoginLogsTableCondition[] additionalConditions ) {
var mod = new @UserLoginLogsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@UserLoginLogsTableEqualityConditions.@UserLoginLogId )
mod.@userLoginLogIdColumnValue.Value = ( condition as CommandConditions.@UserLoginLogsTableEqualityConditions.@UserLoginLogId ).Value;
else if( condition is CommandConditions.@UserLoginLogsTableEqualityConditions.@UserId )
mod.@userIdColumnValue.Value = ( condition as CommandConditions.@UserLoginLogsTableEqualityConditions.@UserId ).Value;
else if( condition is CommandConditions.@UserLoginLogsTableEqualityConditions.@DateTimeUtc )
mod.@dateTimeUtcColumnValue.Value = ( condition as CommandConditions.@UserLoginLogsTableEqualityConditions.@DateTimeUtc ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the UserLoginLogs table.
/// </summary>
public static @UserLoginLogsModification CreateForSingleRowUpdate( int @userLoginLogId, int @userId, DateTime @dateTimeUtc ) {
var mod = new @UserLoginLogsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.UserLoginLogsTableCondition>();
mod.conditions.Add( new CommandConditions.@UserLoginLogsTableEqualityConditions.@UserLoginLogId( @userLoginLogId ) );
mod.@userLoginLogIdColumnValue.Value = @userLoginLogId;
mod.@userIdColumnValue.Value = @userId;
mod.@dateTimeUtcColumnValue.Value = @dateTimeUtc;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.UserLoginLogsTableCondition> getConditionList( CommandConditions.UserLoginLogsTableCondition requiredCondition, params CommandConditions.UserLoginLogsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.UserLoginLogsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @UserLoginLogsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="dateTimeUtc">Object does not allow null.</param>
public void SetAllData( int @userId, DateTime @dateTimeUtc ) {
this.@userIdColumnValue.Value = @userId;
this.@dateTimeUtcColumnValue.Value = @dateTimeUtc;
}
/// <summary>
/// Executes this UserLoginLogs modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this UserLoginLogs modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "UserLoginLogs" );
addColumnModifications( insert );
@userLoginLogIdColumnValue.Value = (System.Int32)Utility.ChangeType( insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection ), typeof( System.Int32 ) );
modType = ModificationType.Update;
conditions = new List<CommandConditions.UserLoginLogsTableCondition>();
conditions.Add( new CommandConditions.@UserLoginLogsTableEqualityConditions.@UserLoginLogId( @UserLoginLogId ) );
}
else {
var update = new InlineUpdate( "UserLoginLogs" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @userIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( @UserId, "Int" ) ) );
if( @dateTimeUtcColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "DateTimeUtc", new DbParameterValue( @DateTimeUtc, "DateTime2" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@userLoginLogIdColumnValue.ClearChanged();
@userIdColumnValue.ClearChanged();
@dateTimeUtcColumnValue.ClearChanged();
}
}
public partial class @UserLogMessagesModification {
/// <summary>
/// Inserts a row into the UserLogMessages table.
/// </summary>
/// <param name="userLogMessageId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="dateAndTime">Object does not allow null.</param>
/// <param name="iv">Object does not allow null.</param>
/// <param name="message">Object does not allow null.</param>
public static void InsertRow( int @userLogMessageId, System.Guid @userId, DateTime @dateAndTime, System.Byte[] @iv, System.Byte[] @message ) { 
var mod = CreateForInsert();
mod.@userLogMessageIdColumnValue.Value = @userLogMessageId;
mod.@userIdColumnValue.Value = @userId;
mod.@dateAndTimeColumnValue.Value = @dateAndTime;
mod.@ivColumnValue.Value = @iv;
mod.@messageColumnValue.Value = @message;
mod.Execute();
}
/// <summary>
/// Inserts a row into the UserLogMessages table.
/// </summary>
/// <param name="userLogMessageId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="dateAndTime">Object does not allow null.</param>
/// <param name="iv">Object does not allow null.</param>
/// <param name="message">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @userLogMessageId, System.Guid @userId, DateTime @dateAndTime, System.Byte[] @iv, System.Byte[] @message ) { 
var mod = CreateForInsert();
mod.@userLogMessageIdColumnValue.Value = @userLogMessageId;
mod.@userIdColumnValue.Value = @userId;
mod.@dateAndTimeColumnValue.Value = @dateAndTime;
mod.@ivColumnValue.Value = @iv;
mod.@messageColumnValue.Value = @message;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the UserLogMessages table that match the specified conditions with the specified data.
/// </summary>
/// <param name="userLogMessageId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="dateAndTime">Object does not allow null.</param>
/// <param name="iv">Object does not allow null.</param>
/// <param name="message">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @userLogMessageId, System.Guid @userId, DateTime @dateAndTime, System.Byte[] @iv, System.Byte[] @message, CommandConditions.UserLogMessagesTableCondition requiredCondition, params CommandConditions.UserLogMessagesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@userLogMessageIdColumnValue.Value = @userLogMessageId;
mod.@userIdColumnValue.Value = @userId;
mod.@dateAndTimeColumnValue.Value = @dateAndTime;
mod.@ivColumnValue.Value = @iv;
mod.@messageColumnValue.Value = @message;
mod.Execute();
}
/// <summary>
/// Updates rows in the UserLogMessages table that match the specified conditions with the specified data.
/// </summary>
/// <param name="userLogMessageId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="dateAndTime">Object does not allow null.</param>
/// <param name="iv">Object does not allow null.</param>
/// <param name="message">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @userLogMessageId, System.Guid @userId, DateTime @dateAndTime, System.Byte[] @iv, System.Byte[] @message, CommandConditions.UserLogMessagesTableCondition requiredCondition, params CommandConditions.UserLogMessagesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@userLogMessageIdColumnValue.Value = @userLogMessageId;
mod.@userIdColumnValue.Value = @userId;
mod.@dateAndTimeColumnValue.Value = @dateAndTime;
mod.@ivColumnValue.Value = @iv;
mod.@messageColumnValue.Value = @message;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.UserLogMessagesTableCondition requiredCondition, params CommandConditions.UserLogMessagesTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@UserLogMessagesTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.UserLogMessagesTableCondition requiredCondition, params CommandConditions.UserLogMessagesTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.UserLogMessagesTableCondition> conditions ) {
var delete = new InlineDelete( "UserLogMessages" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.UserLogMessagesTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@UserLogMessagesTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.UserLogMessagesTableCondition> conditions;
private readonly DataValue<int> @userLogMessageIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the UserLogMessageId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @UserLogMessageId { get { return @userLogMessageIdColumnValue.Value; } set { @userLogMessageIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the UserLogMessageId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @UserLogMessageIdHasChanged { get { return @userLogMessageIdColumnValue.Changed; } }
private readonly DataValue<System.Guid> @userIdColumnValue = new DataValue<System.Guid>();
/// <summary>
/// Gets or sets the value for the UserId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Guid @UserId { get { return @userIdColumnValue.Value; } set { @userIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the UserId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @UserIdHasChanged { get { return @userIdColumnValue.Changed; } }
private readonly DataValue<DateTime> @dateAndTimeColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the DateAndTime column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @DateAndTime { get { return @dateAndTimeColumnValue.Value; } set { @dateAndTimeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the DateAndTime has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @DateAndTimeHasChanged { get { return @dateAndTimeColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @ivColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the Iv column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @Iv { get { return @ivColumnValue.Value; } set { @ivColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Iv has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @IvHasChanged { get { return @ivColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @messageColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the Message column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @Message { get { return @messageColumnValue.Value; } set { @messageColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Message has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @MessageHasChanged { get { return @messageColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the UserLogMessages table.
/// </summary>
public static @UserLogMessagesModification CreateForInsert() {
return new @UserLogMessagesModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the UserLogMessages table.
/// </summary>
public static @UserLogMessagesModification CreateForUpdate( CommandConditions.UserLogMessagesTableCondition requiredCondition, params CommandConditions.UserLogMessagesTableCondition[] additionalConditions ) {
var mod = new @UserLogMessagesModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@UserLogMessagesTableEqualityConditions.@UserLogMessageId )
mod.@userLogMessageIdColumnValue.Value = ( condition as CommandConditions.@UserLogMessagesTableEqualityConditions.@UserLogMessageId ).Value;
else if( condition is CommandConditions.@UserLogMessagesTableEqualityConditions.@UserId )
mod.@userIdColumnValue.Value = ( condition as CommandConditions.@UserLogMessagesTableEqualityConditions.@UserId ).Value;
else if( condition is CommandConditions.@UserLogMessagesTableEqualityConditions.@DateAndTime )
mod.@dateAndTimeColumnValue.Value = ( condition as CommandConditions.@UserLogMessagesTableEqualityConditions.@DateAndTime ).Value;
else if( condition is CommandConditions.@UserLogMessagesTableEqualityConditions.@Iv )
mod.@ivColumnValue.Value = ( condition as CommandConditions.@UserLogMessagesTableEqualityConditions.@Iv ).Value;
else if( condition is CommandConditions.@UserLogMessagesTableEqualityConditions.@Message )
mod.@messageColumnValue.Value = ( condition as CommandConditions.@UserLogMessagesTableEqualityConditions.@Message ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the UserLogMessages table.
/// </summary>
public static @UserLogMessagesModification CreateForSingleRowUpdate( int @userLogMessageId, System.Guid @userId, DateTime @dateAndTime, System.Byte[] @iv, System.Byte[] @message ) {
var mod = new @UserLogMessagesModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.UserLogMessagesTableCondition>();
mod.conditions.Add( new CommandConditions.@UserLogMessagesTableEqualityConditions.@UserLogMessageId( @userLogMessageId ) );
mod.@userLogMessageIdColumnValue.Value = @userLogMessageId;
mod.@userIdColumnValue.Value = @userId;
mod.@dateAndTimeColumnValue.Value = @dateAndTime;
mod.@ivColumnValue.Value = @iv;
mod.@messageColumnValue.Value = @message;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.UserLogMessagesTableCondition> getConditionList( CommandConditions.UserLogMessagesTableCondition requiredCondition, params CommandConditions.UserLogMessagesTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.UserLogMessagesTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @UserLogMessagesModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="userLogMessageId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="dateAndTime">Object does not allow null.</param>
/// <param name="iv">Object does not allow null.</param>
/// <param name="message">Object does not allow null.</param>
public void SetAllData( int @userLogMessageId, System.Guid @userId, DateTime @dateAndTime, System.Byte[] @iv, System.Byte[] @message ) {
this.@userLogMessageIdColumnValue.Value = @userLogMessageId;
this.@userIdColumnValue.Value = @userId;
this.@dateAndTimeColumnValue.Value = @dateAndTime;
this.@ivColumnValue.Value = @iv;
this.@messageColumnValue.Value = @message;
}
/// <summary>
/// Executes this UserLogMessages modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this UserLogMessages modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "UserLogMessages" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.UserLogMessagesTableCondition>();
conditions.Add( new CommandConditions.@UserLogMessagesTableEqualityConditions.@UserLogMessageId( @UserLogMessageId ) );
}
else {
var update = new InlineUpdate( "UserLogMessages" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @userLogMessageIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "UserLogMessageId", new DbParameterValue( @UserLogMessageId, "Int" ) ) );
if( @userIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( @UserId, "UniqueIdentifier" ) ) );
if( @dateAndTimeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "DateAndTime", new DbParameterValue( @DateAndTime, "DateTime2" ) ) );
if( @ivColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Iv", new DbParameterValue( @Iv, "Binary" ) ) );
if( @messageColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Message", new DbParameterValue( @Message, "VarBinary" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@userLogMessageIdColumnValue.ClearChanged();
@userIdColumnValue.ClearChanged();
@dateAndTimeColumnValue.ClearChanged();
@ivColumnValue.ClearChanged();
@messageColumnValue.ClearChanged();
}
}
public partial class @UsersModification {
/// <summary>
/// Inserts a row into the Users table. Returns the value of the UserId column.
/// </summary>
/// <param name="emailAddress">Object does not allow null.</param>
/// <param name="roleId">Object does not allow null.</param>
/// <param name="salt">Object does not allow null.</param>
/// <param name="password">Object does not allow null.</param>
/// <param name="lastRequestDateTime">Object allows null.</param>
/// <param name="mustChangePassword">Object does not allow null.</param>
/// <param name="disabled">Object does not allow null.</param>
/// <param name="invalidPasswordAttempts">Object does not allow null.</param>
/// <param name="lastPasswordChangeDate">Object does not allow null.</param>
/// <param name="firstName">Object does not allow null.</param>
/// <param name="lastName">Object does not allow null.</param>
/// <param name="lastAlertEmailSentDateTime">Object allows null.</param>
/// <param name="createdDateTime">Object does not allow null.</param>
/// <param name="emailVerificationCode">Object does not allow null.</param>
/// <param name="emailVerifiedDateUtc">Object allows null.</param>
/// <param name="deleted">Object does not allow null.</param>
/// <param name="random2">Object does not allow null.</param>
public static int InsertRow( string @emailAddress, int @roleId, int @salt, System.Byte[] @password, System.DateTime? @lastRequestDateTime, System.Boolean @mustChangePassword, System.Boolean @disabled, System.Byte @invalidPasswordAttempts, DateTime @lastPasswordChangeDate, string @firstName, string @lastName, System.DateTime? @lastAlertEmailSentDateTime, DateTime @createdDateTime, string @emailVerificationCode, System.DateTime? @emailVerifiedDateUtc, System.Boolean @deleted, string @random2 ) { 
var mod = CreateForInsert();
mod.@emailAddressColumnValue.Value = @emailAddress;
mod.@roleIdColumnValue.Value = @roleId;
mod.@saltColumnValue.Value = @salt;
mod.@passwordColumnValue.Value = @password;
mod.@lastRequestDateTimeColumnValue.Value = @lastRequestDateTime;
mod.@mustChangePasswordColumnValue.Value = @mustChangePassword;
mod.@disabledColumnValue.Value = @disabled;
mod.@invalidPasswordAttemptsColumnValue.Value = @invalidPasswordAttempts;
mod.@lastPasswordChangeDateColumnValue.Value = @lastPasswordChangeDate;
mod.@firstNameColumnValue.Value = @firstName;
mod.@lastNameColumnValue.Value = @lastName;
mod.@lastAlertEmailSentDateTimeColumnValue.Value = @lastAlertEmailSentDateTime;
mod.@createdDateTimeColumnValue.Value = @createdDateTime;
mod.@emailVerificationCodeColumnValue.Value = @emailVerificationCode;
mod.@emailVerifiedDateUtcColumnValue.Value = @emailVerifiedDateUtc;
mod.@deletedColumnValue.Value = @deleted;
mod.@random2ColumnValue.Value = @random2;
mod.Execute();
return mod.UserId;
}
/// <summary>
/// Inserts a row into the Users table. Returns the value of the UserId column.
/// </summary>
/// <param name="emailAddress">Object does not allow null.</param>
/// <param name="roleId">Object does not allow null.</param>
/// <param name="salt">Object does not allow null.</param>
/// <param name="password">Object does not allow null.</param>
/// <param name="lastRequestDateTime">Object allows null.</param>
/// <param name="mustChangePassword">Object does not allow null.</param>
/// <param name="disabled">Object does not allow null.</param>
/// <param name="invalidPasswordAttempts">Object does not allow null.</param>
/// <param name="lastPasswordChangeDate">Object does not allow null.</param>
/// <param name="firstName">Object does not allow null.</param>
/// <param name="lastName">Object does not allow null.</param>
/// <param name="lastAlertEmailSentDateTime">Object allows null.</param>
/// <param name="createdDateTime">Object does not allow null.</param>
/// <param name="emailVerificationCode">Object does not allow null.</param>
/// <param name="emailVerifiedDateUtc">Object allows null.</param>
/// <param name="deleted">Object does not allow null.</param>
/// <param name="random2">Object does not allow null.</param>
public static int InsertRowWithoutAdditionalLogic( string @emailAddress, int @roleId, int @salt, System.Byte[] @password, System.DateTime? @lastRequestDateTime, System.Boolean @mustChangePassword, System.Boolean @disabled, System.Byte @invalidPasswordAttempts, DateTime @lastPasswordChangeDate, string @firstName, string @lastName, System.DateTime? @lastAlertEmailSentDateTime, DateTime @createdDateTime, string @emailVerificationCode, System.DateTime? @emailVerifiedDateUtc, System.Boolean @deleted, string @random2 ) { 
var mod = CreateForInsert();
mod.@emailAddressColumnValue.Value = @emailAddress;
mod.@roleIdColumnValue.Value = @roleId;
mod.@saltColumnValue.Value = @salt;
mod.@passwordColumnValue.Value = @password;
mod.@lastRequestDateTimeColumnValue.Value = @lastRequestDateTime;
mod.@mustChangePasswordColumnValue.Value = @mustChangePassword;
mod.@disabledColumnValue.Value = @disabled;
mod.@invalidPasswordAttemptsColumnValue.Value = @invalidPasswordAttempts;
mod.@lastPasswordChangeDateColumnValue.Value = @lastPasswordChangeDate;
mod.@firstNameColumnValue.Value = @firstName;
mod.@lastNameColumnValue.Value = @lastName;
mod.@lastAlertEmailSentDateTimeColumnValue.Value = @lastAlertEmailSentDateTime;
mod.@createdDateTimeColumnValue.Value = @createdDateTime;
mod.@emailVerificationCodeColumnValue.Value = @emailVerificationCode;
mod.@emailVerifiedDateUtcColumnValue.Value = @emailVerifiedDateUtc;
mod.@deletedColumnValue.Value = @deleted;
mod.@random2ColumnValue.Value = @random2;
mod.ExecuteWithoutAdditionalLogic();
return mod.UserId;
}
/// <summary>
/// Updates rows in the Users table that match the specified conditions with the specified data.
/// </summary>
/// <param name="emailAddress">Object does not allow null.</param>
/// <param name="roleId">Object does not allow null.</param>
/// <param name="salt">Object does not allow null.</param>
/// <param name="password">Object does not allow null.</param>
/// <param name="lastRequestDateTime">Object allows null.</param>
/// <param name="mustChangePassword">Object does not allow null.</param>
/// <param name="disabled">Object does not allow null.</param>
/// <param name="invalidPasswordAttempts">Object does not allow null.</param>
/// <param name="lastPasswordChangeDate">Object does not allow null.</param>
/// <param name="firstName">Object does not allow null.</param>
/// <param name="lastName">Object does not allow null.</param>
/// <param name="lastAlertEmailSentDateTime">Object allows null.</param>
/// <param name="createdDateTime">Object does not allow null.</param>
/// <param name="emailVerificationCode">Object does not allow null.</param>
/// <param name="emailVerifiedDateUtc">Object allows null.</param>
/// <param name="deleted">Object does not allow null.</param>
/// <param name="random2">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( string @emailAddress, int @roleId, int @salt, System.Byte[] @password, System.DateTime? @lastRequestDateTime, System.Boolean @mustChangePassword, System.Boolean @disabled, System.Byte @invalidPasswordAttempts, DateTime @lastPasswordChangeDate, string @firstName, string @lastName, System.DateTime? @lastAlertEmailSentDateTime, DateTime @createdDateTime, string @emailVerificationCode, System.DateTime? @emailVerifiedDateUtc, System.Boolean @deleted, string @random2, CommandConditions.UsersTableCondition requiredCondition, params CommandConditions.UsersTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@emailAddressColumnValue.Value = @emailAddress;
mod.@roleIdColumnValue.Value = @roleId;
mod.@saltColumnValue.Value = @salt;
mod.@passwordColumnValue.Value = @password;
mod.@lastRequestDateTimeColumnValue.Value = @lastRequestDateTime;
mod.@mustChangePasswordColumnValue.Value = @mustChangePassword;
mod.@disabledColumnValue.Value = @disabled;
mod.@invalidPasswordAttemptsColumnValue.Value = @invalidPasswordAttempts;
mod.@lastPasswordChangeDateColumnValue.Value = @lastPasswordChangeDate;
mod.@firstNameColumnValue.Value = @firstName;
mod.@lastNameColumnValue.Value = @lastName;
mod.@lastAlertEmailSentDateTimeColumnValue.Value = @lastAlertEmailSentDateTime;
mod.@createdDateTimeColumnValue.Value = @createdDateTime;
mod.@emailVerificationCodeColumnValue.Value = @emailVerificationCode;
mod.@emailVerifiedDateUtcColumnValue.Value = @emailVerifiedDateUtc;
mod.@deletedColumnValue.Value = @deleted;
mod.@random2ColumnValue.Value = @random2;
mod.Execute();
}
/// <summary>
/// Updates rows in the Users table that match the specified conditions with the specified data.
/// </summary>
/// <param name="emailAddress">Object does not allow null.</param>
/// <param name="roleId">Object does not allow null.</param>
/// <param name="salt">Object does not allow null.</param>
/// <param name="password">Object does not allow null.</param>
/// <param name="lastRequestDateTime">Object allows null.</param>
/// <param name="mustChangePassword">Object does not allow null.</param>
/// <param name="disabled">Object does not allow null.</param>
/// <param name="invalidPasswordAttempts">Object does not allow null.</param>
/// <param name="lastPasswordChangeDate">Object does not allow null.</param>
/// <param name="firstName">Object does not allow null.</param>
/// <param name="lastName">Object does not allow null.</param>
/// <param name="lastAlertEmailSentDateTime">Object allows null.</param>
/// <param name="createdDateTime">Object does not allow null.</param>
/// <param name="emailVerificationCode">Object does not allow null.</param>
/// <param name="emailVerifiedDateUtc">Object allows null.</param>
/// <param name="deleted">Object does not allow null.</param>
/// <param name="random2">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( string @emailAddress, int @roleId, int @salt, System.Byte[] @password, System.DateTime? @lastRequestDateTime, System.Boolean @mustChangePassword, System.Boolean @disabled, System.Byte @invalidPasswordAttempts, DateTime @lastPasswordChangeDate, string @firstName, string @lastName, System.DateTime? @lastAlertEmailSentDateTime, DateTime @createdDateTime, string @emailVerificationCode, System.DateTime? @emailVerifiedDateUtc, System.Boolean @deleted, string @random2, CommandConditions.UsersTableCondition requiredCondition, params CommandConditions.UsersTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@emailAddressColumnValue.Value = @emailAddress;
mod.@roleIdColumnValue.Value = @roleId;
mod.@saltColumnValue.Value = @salt;
mod.@passwordColumnValue.Value = @password;
mod.@lastRequestDateTimeColumnValue.Value = @lastRequestDateTime;
mod.@mustChangePasswordColumnValue.Value = @mustChangePassword;
mod.@disabledColumnValue.Value = @disabled;
mod.@invalidPasswordAttemptsColumnValue.Value = @invalidPasswordAttempts;
mod.@lastPasswordChangeDateColumnValue.Value = @lastPasswordChangeDate;
mod.@firstNameColumnValue.Value = @firstName;
mod.@lastNameColumnValue.Value = @lastName;
mod.@lastAlertEmailSentDateTimeColumnValue.Value = @lastAlertEmailSentDateTime;
mod.@createdDateTimeColumnValue.Value = @createdDateTime;
mod.@emailVerificationCodeColumnValue.Value = @emailVerificationCode;
mod.@emailVerifiedDateUtcColumnValue.Value = @emailVerifiedDateUtc;
mod.@deletedColumnValue.Value = @deleted;
mod.@random2ColumnValue.Value = @random2;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.UsersTableCondition requiredCondition, params CommandConditions.UsersTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@UsersTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.UsersTableCondition requiredCondition, params CommandConditions.UsersTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.UsersTableCondition> conditions ) {
var delete = new InlineDelete( "Users" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.UsersTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@UsersTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.UsersTableCondition> conditions;
private readonly DataValue<int> @userIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets the value for the UserId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @UserId { get { return @userIdColumnValue.Value; } }
private readonly DataValue<string> @emailAddressColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the EmailAddress column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @EmailAddress { get { return @emailAddressColumnValue.Value; } set { @emailAddressColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EmailAddress has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EmailAddressHasChanged { get { return @emailAddressColumnValue.Changed; } }
private readonly DataValue<int> @roleIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the RoleId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @RoleId { get { return @roleIdColumnValue.Value; } set { @roleIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the RoleId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @RoleIdHasChanged { get { return @roleIdColumnValue.Changed; } }
private readonly DataValue<int> @saltColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the Salt column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @Salt { get { return @saltColumnValue.Value; } set { @saltColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Salt has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @SaltHasChanged { get { return @saltColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @passwordColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the Password column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @Password { get { return @passwordColumnValue.Value; } set { @passwordColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Password has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PasswordHasChanged { get { return @passwordColumnValue.Changed; } }
private readonly DataValue<System.DateTime?> @lastRequestDateTimeColumnValue = new DataValue<System.DateTime?>();
/// <summary>
/// Gets or sets the value for the LastRequestDateTime column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.DateTime? @LastRequestDateTime { get { return @lastRequestDateTimeColumnValue.Value; } set { @lastRequestDateTimeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LastRequestDateTime has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LastRequestDateTimeHasChanged { get { return @lastRequestDateTimeColumnValue.Changed; } }
private readonly DataValue<System.Boolean> @mustChangePasswordColumnValue = new DataValue<System.Boolean>();
/// <summary>
/// Gets or sets the value for the MustChangePassword column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Boolean @MustChangePassword { get { return @mustChangePasswordColumnValue.Value; } set { @mustChangePasswordColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the MustChangePassword has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @MustChangePasswordHasChanged { get { return @mustChangePasswordColumnValue.Changed; } }
private readonly DataValue<System.Boolean> @disabledColumnValue = new DataValue<System.Boolean>();
/// <summary>
/// Gets or sets the value for the Disabled column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Boolean @Disabled { get { return @disabledColumnValue.Value; } set { @disabledColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Disabled has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @DisabledHasChanged { get { return @disabledColumnValue.Changed; } }
private readonly DataValue<System.Byte> @invalidPasswordAttemptsColumnValue = new DataValue<System.Byte>();
/// <summary>
/// Gets or sets the value for the InvalidPasswordAttempts column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte @InvalidPasswordAttempts { get { return @invalidPasswordAttemptsColumnValue.Value; } set { @invalidPasswordAttemptsColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the InvalidPasswordAttempts has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @InvalidPasswordAttemptsHasChanged { get { return @invalidPasswordAttemptsColumnValue.Changed; } }
private readonly DataValue<DateTime> @lastPasswordChangeDateColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the LastPasswordChangeDate column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @LastPasswordChangeDate { get { return @lastPasswordChangeDateColumnValue.Value; } set { @lastPasswordChangeDateColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LastPasswordChangeDate has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LastPasswordChangeDateHasChanged { get { return @lastPasswordChangeDateColumnValue.Changed; } }
private readonly DataValue<string> @firstNameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the FirstName column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @FirstName { get { return @firstNameColumnValue.Value; } set { @firstNameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the FirstName has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @FirstNameHasChanged { get { return @firstNameColumnValue.Changed; } }
private readonly DataValue<string> @lastNameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the LastName column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @LastName { get { return @lastNameColumnValue.Value; } set { @lastNameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LastName has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LastNameHasChanged { get { return @lastNameColumnValue.Changed; } }
private readonly DataValue<System.DateTime?> @lastAlertEmailSentDateTimeColumnValue = new DataValue<System.DateTime?>();
/// <summary>
/// Gets or sets the value for the LastAlertEmailSentDateTime column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.DateTime? @LastAlertEmailSentDateTime { get { return @lastAlertEmailSentDateTimeColumnValue.Value; } set { @lastAlertEmailSentDateTimeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LastAlertEmailSentDateTime has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LastAlertEmailSentDateTimeHasChanged { get { return @lastAlertEmailSentDateTimeColumnValue.Changed; } }
private readonly DataValue<DateTime> @createdDateTimeColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the CreatedDateTime column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @CreatedDateTime { get { return @createdDateTimeColumnValue.Value; } set { @createdDateTimeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the CreatedDateTime has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @CreatedDateTimeHasChanged { get { return @createdDateTimeColumnValue.Changed; } }
private readonly DataValue<string> @emailVerificationCodeColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the EmailVerificationCode column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @EmailVerificationCode { get { return @emailVerificationCodeColumnValue.Value; } set { @emailVerificationCodeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EmailVerificationCode has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EmailVerificationCodeHasChanged { get { return @emailVerificationCodeColumnValue.Changed; } }
private readonly DataValue<System.DateTime?> @emailVerifiedDateUtcColumnValue = new DataValue<System.DateTime?>();
/// <summary>
/// Gets or sets the value for the EmailVerifiedDateUtc column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.DateTime? @EmailVerifiedDateUtc { get { return @emailVerifiedDateUtcColumnValue.Value; } set { @emailVerifiedDateUtcColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EmailVerifiedDateUtc has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EmailVerifiedDateUtcHasChanged { get { return @emailVerifiedDateUtcColumnValue.Changed; } }
private readonly DataValue<System.Boolean> @deletedColumnValue = new DataValue<System.Boolean>();
/// <summary>
/// Gets or sets the value for the Deleted column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Boolean @Deleted { get { return @deletedColumnValue.Value; } set { @deletedColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Deleted has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @DeletedHasChanged { get { return @deletedColumnValue.Changed; } }
private readonly DataValue<string> @random2ColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Random2 column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Random2 { get { return @random2ColumnValue.Value; } set { @random2ColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Random2 has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @Random2HasChanged { get { return @random2ColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the Users table.
/// </summary>
public static @UsersModification CreateForInsert() {
return new @UsersModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the Users table.
/// </summary>
public static @UsersModification CreateForUpdate( CommandConditions.UsersTableCondition requiredCondition, params CommandConditions.UsersTableCondition[] additionalConditions ) {
var mod = new @UsersModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@UsersTableEqualityConditions.@UserId )
mod.@userIdColumnValue.Value = ( condition as CommandConditions.@UsersTableEqualityConditions.@UserId ).Value;
else if( condition is CommandConditions.@UsersTableEqualityConditions.@EmailAddress )
mod.@emailAddressColumnValue.Value = ( condition as CommandConditions.@UsersTableEqualityConditions.@EmailAddress ).Value;
else if( condition is CommandConditions.@UsersTableEqualityConditions.@RoleId )
mod.@roleIdColumnValue.Value = ( condition as CommandConditions.@UsersTableEqualityConditions.@RoleId ).Value;
else if( condition is CommandConditions.@UsersTableEqualityConditions.@Salt )
mod.@saltColumnValue.Value = ( condition as CommandConditions.@UsersTableEqualityConditions.@Salt ).Value;
else if( condition is CommandConditions.@UsersTableEqualityConditions.@Password )
mod.@passwordColumnValue.Value = ( condition as CommandConditions.@UsersTableEqualityConditions.@Password ).Value;
else if( condition is CommandConditions.@UsersTableEqualityConditions.@LastRequestDateTime )
mod.@lastRequestDateTimeColumnValue.Value = ( condition as CommandConditions.@UsersTableEqualityConditions.@LastRequestDateTime ).Value;
else if( condition is CommandConditions.@UsersTableEqualityConditions.@MustChangePassword )
mod.@mustChangePasswordColumnValue.Value = ( condition as CommandConditions.@UsersTableEqualityConditions.@MustChangePassword ).Value;
else if( condition is CommandConditions.@UsersTableEqualityConditions.@Disabled )
mod.@disabledColumnValue.Value = ( condition as CommandConditions.@UsersTableEqualityConditions.@Disabled ).Value;
else if( condition is CommandConditions.@UsersTableEqualityConditions.@InvalidPasswordAttempts )
mod.@invalidPasswordAttemptsColumnValue.Value = ( condition as CommandConditions.@UsersTableEqualityConditions.@InvalidPasswordAttempts ).Value;
else if( condition is CommandConditions.@UsersTableEqualityConditions.@LastPasswordChangeDate )
mod.@lastPasswordChangeDateColumnValue.Value = ( condition as CommandConditions.@UsersTableEqualityConditions.@LastPasswordChangeDate ).Value;
else if( condition is CommandConditions.@UsersTableEqualityConditions.@FirstName )
mod.@firstNameColumnValue.Value = ( condition as CommandConditions.@UsersTableEqualityConditions.@FirstName ).Value;
else if( condition is CommandConditions.@UsersTableEqualityConditions.@LastName )
mod.@lastNameColumnValue.Value = ( condition as CommandConditions.@UsersTableEqualityConditions.@LastName ).Value;
else if( condition is CommandConditions.@UsersTableEqualityConditions.@LastAlertEmailSentDateTime )
mod.@lastAlertEmailSentDateTimeColumnValue.Value = ( condition as CommandConditions.@UsersTableEqualityConditions.@LastAlertEmailSentDateTime ).Value;
else if( condition is CommandConditions.@UsersTableEqualityConditions.@CreatedDateTime )
mod.@createdDateTimeColumnValue.Value = ( condition as CommandConditions.@UsersTableEqualityConditions.@CreatedDateTime ).Value;
else if( condition is CommandConditions.@UsersTableEqualityConditions.@EmailVerificationCode )
mod.@emailVerificationCodeColumnValue.Value = ( condition as CommandConditions.@UsersTableEqualityConditions.@EmailVerificationCode ).Value;
else if( condition is CommandConditions.@UsersTableEqualityConditions.@EmailVerifiedDateUtc )
mod.@emailVerifiedDateUtcColumnValue.Value = ( condition as CommandConditions.@UsersTableEqualityConditions.@EmailVerifiedDateUtc ).Value;
else if( condition is CommandConditions.@UsersTableEqualityConditions.@Deleted )
mod.@deletedColumnValue.Value = ( condition as CommandConditions.@UsersTableEqualityConditions.@Deleted ).Value;
else if( condition is CommandConditions.@UsersTableEqualityConditions.@Random2 )
mod.@random2ColumnValue.Value = ( condition as CommandConditions.@UsersTableEqualityConditions.@Random2 ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the Users table.
/// </summary>
public static @UsersModification CreateForSingleRowUpdate( int @userId, string @emailAddress, int @roleId, int @salt, System.Byte[] @password, System.DateTime? @lastRequestDateTime, System.Boolean @mustChangePassword, System.Boolean @disabled, System.Byte @invalidPasswordAttempts, DateTime @lastPasswordChangeDate, string @firstName, string @lastName, System.DateTime? @lastAlertEmailSentDateTime, DateTime @createdDateTime, string @emailVerificationCode, System.DateTime? @emailVerifiedDateUtc, System.Boolean @deleted, string @random2 ) {
var mod = new @UsersModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.UsersTableCondition>();
mod.conditions.Add( new CommandConditions.@UsersTableEqualityConditions.@UserId( @userId ) );
mod.@userIdColumnValue.Value = @userId;
mod.@emailAddressColumnValue.Value = @emailAddress;
mod.@roleIdColumnValue.Value = @roleId;
mod.@saltColumnValue.Value = @salt;
mod.@passwordColumnValue.Value = @password;
mod.@lastRequestDateTimeColumnValue.Value = @lastRequestDateTime;
mod.@mustChangePasswordColumnValue.Value = @mustChangePassword;
mod.@disabledColumnValue.Value = @disabled;
mod.@invalidPasswordAttemptsColumnValue.Value = @invalidPasswordAttempts;
mod.@lastPasswordChangeDateColumnValue.Value = @lastPasswordChangeDate;
mod.@firstNameColumnValue.Value = @firstName;
mod.@lastNameColumnValue.Value = @lastName;
mod.@lastAlertEmailSentDateTimeColumnValue.Value = @lastAlertEmailSentDateTime;
mod.@createdDateTimeColumnValue.Value = @createdDateTime;
mod.@emailVerificationCodeColumnValue.Value = @emailVerificationCode;
mod.@emailVerifiedDateUtcColumnValue.Value = @emailVerifiedDateUtc;
mod.@deletedColumnValue.Value = @deleted;
mod.@random2ColumnValue.Value = @random2;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.UsersTableCondition> getConditionList( CommandConditions.UsersTableCondition requiredCondition, params CommandConditions.UsersTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.UsersTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @UsersModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="emailAddress">Object does not allow null.</param>
/// <param name="roleId">Object does not allow null.</param>
/// <param name="salt">Object does not allow null.</param>
/// <param name="password">Object does not allow null.</param>
/// <param name="lastRequestDateTime">Object allows null.</param>
/// <param name="mustChangePassword">Object does not allow null.</param>
/// <param name="disabled">Object does not allow null.</param>
/// <param name="invalidPasswordAttempts">Object does not allow null.</param>
/// <param name="lastPasswordChangeDate">Object does not allow null.</param>
/// <param name="firstName">Object does not allow null.</param>
/// <param name="lastName">Object does not allow null.</param>
/// <param name="lastAlertEmailSentDateTime">Object allows null.</param>
/// <param name="createdDateTime">Object does not allow null.</param>
/// <param name="emailVerificationCode">Object does not allow null.</param>
/// <param name="emailVerifiedDateUtc">Object allows null.</param>
/// <param name="deleted">Object does not allow null.</param>
/// <param name="random2">Object does not allow null.</param>
public void SetAllData( string @emailAddress, int @roleId, int @salt, System.Byte[] @password, System.DateTime? @lastRequestDateTime, System.Boolean @mustChangePassword, System.Boolean @disabled, System.Byte @invalidPasswordAttempts, DateTime @lastPasswordChangeDate, string @firstName, string @lastName, System.DateTime? @lastAlertEmailSentDateTime, DateTime @createdDateTime, string @emailVerificationCode, System.DateTime? @emailVerifiedDateUtc, System.Boolean @deleted, string @random2 ) {
this.@emailAddressColumnValue.Value = @emailAddress;
this.@roleIdColumnValue.Value = @roleId;
this.@saltColumnValue.Value = @salt;
this.@passwordColumnValue.Value = @password;
this.@lastRequestDateTimeColumnValue.Value = @lastRequestDateTime;
this.@mustChangePasswordColumnValue.Value = @mustChangePassword;
this.@disabledColumnValue.Value = @disabled;
this.@invalidPasswordAttemptsColumnValue.Value = @invalidPasswordAttempts;
this.@lastPasswordChangeDateColumnValue.Value = @lastPasswordChangeDate;
this.@firstNameColumnValue.Value = @firstName;
this.@lastNameColumnValue.Value = @lastName;
this.@lastAlertEmailSentDateTimeColumnValue.Value = @lastAlertEmailSentDateTime;
this.@createdDateTimeColumnValue.Value = @createdDateTime;
this.@emailVerificationCodeColumnValue.Value = @emailVerificationCode;
this.@emailVerifiedDateUtcColumnValue.Value = @emailVerifiedDateUtc;
this.@deletedColumnValue.Value = @deleted;
this.@random2ColumnValue.Value = @random2;
}
/// <summary>
/// Executes this Users modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this Users modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "Users" );
addColumnModifications( insert );
@userIdColumnValue.Value = (System.Int32)Utility.ChangeType( insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection ), typeof( System.Int32 ) );
modType = ModificationType.Update;
conditions = new List<CommandConditions.UsersTableCondition>();
conditions.Add( new CommandConditions.@UsersTableEqualityConditions.@UserId( @UserId ) );
}
else {
var update = new InlineUpdate( "Users" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @emailAddressColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EmailAddress", new DbParameterValue( @EmailAddress, "NVarChar" ) ) );
if( @roleIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "RoleId", new DbParameterValue( @RoleId, "Int" ) ) );
if( @saltColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Salt", new DbParameterValue( @Salt, "Int" ) ) );
if( @passwordColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Password", new DbParameterValue( @Password, "Binary" ) ) );
if( @lastRequestDateTimeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LastRequestDateTime", new DbParameterValue( @LastRequestDateTime, "SmallDateTime" ) ) );
if( @mustChangePasswordColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "MustChangePassword", new DbParameterValue( @MustChangePassword, "Bit" ) ) );
if( @disabledColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Disabled", new DbParameterValue( @Disabled, "Bit" ) ) );
if( @invalidPasswordAttemptsColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "InvalidPasswordAttempts", new DbParameterValue( @InvalidPasswordAttempts, "TinyInt" ) ) );
if( @lastPasswordChangeDateColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LastPasswordChangeDate", new DbParameterValue( @LastPasswordChangeDate, "SmallDateTime" ) ) );
if( @firstNameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "FirstName", new DbParameterValue( @FirstName, "NVarChar" ) ) );
if( @lastNameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LastName", new DbParameterValue( @LastName, "NVarChar" ) ) );
if( @lastAlertEmailSentDateTimeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LastAlertEmailSentDateTime", new DbParameterValue( @LastAlertEmailSentDateTime, "DateTime2" ) ) );
if( @createdDateTimeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "CreatedDateTime", new DbParameterValue( @CreatedDateTime, "DateTime2" ) ) );
if( @emailVerificationCodeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EmailVerificationCode", new DbParameterValue( @EmailVerificationCode, "NVarChar" ) ) );
if( @emailVerifiedDateUtcColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EmailVerifiedDateUtc", new DbParameterValue( @EmailVerifiedDateUtc, "DateTime2" ) ) );
if( @deletedColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Deleted", new DbParameterValue( @Deleted, "Bit" ) ) );
if( @random2ColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Random2", new DbParameterValue( @Random2, "NVarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@userIdColumnValue.ClearChanged();
@emailAddressColumnValue.ClearChanged();
@roleIdColumnValue.ClearChanged();
@saltColumnValue.ClearChanged();
@passwordColumnValue.ClearChanged();
@lastRequestDateTimeColumnValue.ClearChanged();
@mustChangePasswordColumnValue.ClearChanged();
@disabledColumnValue.ClearChanged();
@invalidPasswordAttemptsColumnValue.ClearChanged();
@lastPasswordChangeDateColumnValue.ClearChanged();
@firstNameColumnValue.ClearChanged();
@lastNameColumnValue.ClearChanged();
@lastAlertEmailSentDateTimeColumnValue.ClearChanged();
@createdDateTimeColumnValue.ClearChanged();
@emailVerificationCodeColumnValue.ClearChanged();
@emailVerifiedDateUtcColumnValue.ClearChanged();
@deletedColumnValue.ClearChanged();
@random2ColumnValue.ClearChanged();
}
}
public partial class @UsersToHiddenTrainingCourseTypesModification {
/// <summary>
/// Inserts a row into the UsersToHiddenTrainingCourseTypes table.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="trainingCourseTypeId">Object does not allow null.</param>
public static void InsertRow( int @userId, int @trainingCourseTypeId ) { 
var mod = CreateForInsert();
mod.@userIdColumnValue.Value = @userId;
mod.@trainingCourseTypeIdColumnValue.Value = @trainingCourseTypeId;
mod.Execute();
}
/// <summary>
/// Inserts a row into the UsersToHiddenTrainingCourseTypes table.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="trainingCourseTypeId">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @userId, int @trainingCourseTypeId ) { 
var mod = CreateForInsert();
mod.@userIdColumnValue.Value = @userId;
mod.@trainingCourseTypeIdColumnValue.Value = @trainingCourseTypeId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the UsersToHiddenTrainingCourseTypes table that match the specified conditions with the specified data.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="trainingCourseTypeId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @userId, int @trainingCourseTypeId, CommandConditions.UsersToHiddenTrainingCourseTypesTableCondition requiredCondition, params CommandConditions.UsersToHiddenTrainingCourseTypesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@userIdColumnValue.Value = @userId;
mod.@trainingCourseTypeIdColumnValue.Value = @trainingCourseTypeId;
mod.Execute();
}
/// <summary>
/// Updates rows in the UsersToHiddenTrainingCourseTypes table that match the specified conditions with the specified data.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="trainingCourseTypeId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @userId, int @trainingCourseTypeId, CommandConditions.UsersToHiddenTrainingCourseTypesTableCondition requiredCondition, params CommandConditions.UsersToHiddenTrainingCourseTypesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@userIdColumnValue.Value = @userId;
mod.@trainingCourseTypeIdColumnValue.Value = @trainingCourseTypeId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.UsersToHiddenTrainingCourseTypesTableCondition requiredCondition, params CommandConditions.UsersToHiddenTrainingCourseTypesTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@UsersToHiddenTrainingCourseTypesTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.UsersToHiddenTrainingCourseTypesTableCondition requiredCondition, params CommandConditions.UsersToHiddenTrainingCourseTypesTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.UsersToHiddenTrainingCourseTypesTableCondition> conditions ) {
var delete = new InlineDelete( "UsersToHiddenTrainingCourseTypes" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.UsersToHiddenTrainingCourseTypesTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@UsersToHiddenTrainingCourseTypesTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.UsersToHiddenTrainingCourseTypesTableCondition> conditions;
private readonly DataValue<int> @userIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the UserId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @UserId { get { return @userIdColumnValue.Value; } set { @userIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the UserId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @UserIdHasChanged { get { return @userIdColumnValue.Changed; } }
private readonly DataValue<int> @trainingCourseTypeIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the TrainingCourseTypeId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @TrainingCourseTypeId { get { return @trainingCourseTypeIdColumnValue.Value; } set { @trainingCourseTypeIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the TrainingCourseTypeId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @TrainingCourseTypeIdHasChanged { get { return @trainingCourseTypeIdColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the UsersToHiddenTrainingCourseTypes table.
/// </summary>
public static @UsersToHiddenTrainingCourseTypesModification CreateForInsert() {
return new @UsersToHiddenTrainingCourseTypesModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the UsersToHiddenTrainingCourseTypes table.
/// </summary>
public static @UsersToHiddenTrainingCourseTypesModification CreateForUpdate( CommandConditions.UsersToHiddenTrainingCourseTypesTableCondition requiredCondition, params CommandConditions.UsersToHiddenTrainingCourseTypesTableCondition[] additionalConditions ) {
var mod = new @UsersToHiddenTrainingCourseTypesModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@UsersToHiddenTrainingCourseTypesTableEqualityConditions.@UserId )
mod.@userIdColumnValue.Value = ( condition as CommandConditions.@UsersToHiddenTrainingCourseTypesTableEqualityConditions.@UserId ).Value;
else if( condition is CommandConditions.@UsersToHiddenTrainingCourseTypesTableEqualityConditions.@TrainingCourseTypeId )
mod.@trainingCourseTypeIdColumnValue.Value = ( condition as CommandConditions.@UsersToHiddenTrainingCourseTypesTableEqualityConditions.@TrainingCourseTypeId ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the UsersToHiddenTrainingCourseTypes table.
/// </summary>
public static @UsersToHiddenTrainingCourseTypesModification CreateForSingleRowUpdate( int @userId, int @trainingCourseTypeId ) {
var mod = new @UsersToHiddenTrainingCourseTypesModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.UsersToHiddenTrainingCourseTypesTableCondition>();
mod.conditions.Add( new CommandConditions.@UsersToHiddenTrainingCourseTypesTableEqualityConditions.@UserId( @userId ) );
mod.conditions.Add( new CommandConditions.@UsersToHiddenTrainingCourseTypesTableEqualityConditions.@TrainingCourseTypeId( @trainingCourseTypeId ) );
mod.@userIdColumnValue.Value = @userId;
mod.@trainingCourseTypeIdColumnValue.Value = @trainingCourseTypeId;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.UsersToHiddenTrainingCourseTypesTableCondition> getConditionList( CommandConditions.UsersToHiddenTrainingCourseTypesTableCondition requiredCondition, params CommandConditions.UsersToHiddenTrainingCourseTypesTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.UsersToHiddenTrainingCourseTypesTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @UsersToHiddenTrainingCourseTypesModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="trainingCourseTypeId">Object does not allow null.</param>
public void SetAllData( int @userId, int @trainingCourseTypeId ) {
this.@userIdColumnValue.Value = @userId;
this.@trainingCourseTypeIdColumnValue.Value = @trainingCourseTypeId;
}
/// <summary>
/// Executes this UsersToHiddenTrainingCourseTypes modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this UsersToHiddenTrainingCourseTypes modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "UsersToHiddenTrainingCourseTypes" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.UsersToHiddenTrainingCourseTypesTableCondition>();
conditions.Add( new CommandConditions.@UsersToHiddenTrainingCourseTypesTableEqualityConditions.@UserId( @UserId ) );
conditions.Add( new CommandConditions.@UsersToHiddenTrainingCourseTypesTableEqualityConditions.@TrainingCourseTypeId( @TrainingCourseTypeId ) );
}
else {
var update = new InlineUpdate( "UsersToHiddenTrainingCourseTypes" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @userIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( @UserId, "Int" ) ) );
if( @trainingCourseTypeIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "TrainingCourseTypeId", new DbParameterValue( @TrainingCourseTypeId, "Int" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@userIdColumnValue.ClearChanged();
@trainingCourseTypeIdColumnValue.ClearChanged();
}
}
public partial class @UsersToOrganizationsModification {
/// <summary>
/// Inserts a row into the UsersToOrganizations table.
/// </summary>
/// <param name="usersToOrganizationId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="organizationId">Object does not allow null.</param>
/// <param name="startDate">Object allows null.</param>
/// <param name="endDate">Object allows null.</param>
public static void InsertRow( int @usersToOrganizationId, int @userId, int @organizationId, System.DateTime? @startDate, System.DateTime? @endDate ) { 
var mod = CreateForInsert();
mod.@usersToOrganizationIdColumnValue.Value = @usersToOrganizationId;
mod.@userIdColumnValue.Value = @userId;
mod.@organizationIdColumnValue.Value = @organizationId;
mod.@startDateColumnValue.Value = @startDate;
mod.@endDateColumnValue.Value = @endDate;
mod.Execute();
}
/// <summary>
/// Inserts a row into the UsersToOrganizations table.
/// </summary>
/// <param name="usersToOrganizationId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="organizationId">Object does not allow null.</param>
/// <param name="startDate">Object allows null.</param>
/// <param name="endDate">Object allows null.</param>
public static void InsertRowWithoutAdditionalLogic( int @usersToOrganizationId, int @userId, int @organizationId, System.DateTime? @startDate, System.DateTime? @endDate ) { 
var mod = CreateForInsert();
mod.@usersToOrganizationIdColumnValue.Value = @usersToOrganizationId;
mod.@userIdColumnValue.Value = @userId;
mod.@organizationIdColumnValue.Value = @organizationId;
mod.@startDateColumnValue.Value = @startDate;
mod.@endDateColumnValue.Value = @endDate;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the UsersToOrganizations table that match the specified conditions with the specified data.
/// </summary>
/// <param name="usersToOrganizationId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="organizationId">Object does not allow null.</param>
/// <param name="startDate">Object allows null.</param>
/// <param name="endDate">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @usersToOrganizationId, int @userId, int @organizationId, System.DateTime? @startDate, System.DateTime? @endDate, CommandConditions.UsersToOrganizationsTableCondition requiredCondition, params CommandConditions.UsersToOrganizationsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@usersToOrganizationIdColumnValue.Value = @usersToOrganizationId;
mod.@userIdColumnValue.Value = @userId;
mod.@organizationIdColumnValue.Value = @organizationId;
mod.@startDateColumnValue.Value = @startDate;
mod.@endDateColumnValue.Value = @endDate;
mod.Execute();
}
/// <summary>
/// Updates rows in the UsersToOrganizations table that match the specified conditions with the specified data.
/// </summary>
/// <param name="usersToOrganizationId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="organizationId">Object does not allow null.</param>
/// <param name="startDate">Object allows null.</param>
/// <param name="endDate">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @usersToOrganizationId, int @userId, int @organizationId, System.DateTime? @startDate, System.DateTime? @endDate, CommandConditions.UsersToOrganizationsTableCondition requiredCondition, params CommandConditions.UsersToOrganizationsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@usersToOrganizationIdColumnValue.Value = @usersToOrganizationId;
mod.@userIdColumnValue.Value = @userId;
mod.@organizationIdColumnValue.Value = @organizationId;
mod.@startDateColumnValue.Value = @startDate;
mod.@endDateColumnValue.Value = @endDate;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.UsersToOrganizationsTableCondition requiredCondition, params CommandConditions.UsersToOrganizationsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@UsersToOrganizationsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.UsersToOrganizationsTableCondition requiredCondition, params CommandConditions.UsersToOrganizationsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.UsersToOrganizationsTableCondition> conditions ) {
var delete = new InlineDelete( "UsersToOrganizations" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.UsersToOrganizationsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@UsersToOrganizationsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.UsersToOrganizationsTableCondition> conditions;
private readonly DataValue<int> @usersToOrganizationIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the UsersToOrganizationId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @UsersToOrganizationId { get { return @usersToOrganizationIdColumnValue.Value; } set { @usersToOrganizationIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the UsersToOrganizationId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @UsersToOrganizationIdHasChanged { get { return @usersToOrganizationIdColumnValue.Changed; } }
private readonly DataValue<int> @userIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the UserId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @UserId { get { return @userIdColumnValue.Value; } set { @userIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the UserId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @UserIdHasChanged { get { return @userIdColumnValue.Changed; } }
private readonly DataValue<int> @organizationIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the OrganizationId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @OrganizationId { get { return @organizationIdColumnValue.Value; } set { @organizationIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the OrganizationId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @OrganizationIdHasChanged { get { return @organizationIdColumnValue.Changed; } }
private readonly DataValue<System.DateTime?> @startDateColumnValue = new DataValue<System.DateTime?>();
/// <summary>
/// Gets or sets the value for the StartDate column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.DateTime? @StartDate { get { return @startDateColumnValue.Value; } set { @startDateColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the StartDate has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @StartDateHasChanged { get { return @startDateColumnValue.Changed; } }
private readonly DataValue<System.DateTime?> @endDateColumnValue = new DataValue<System.DateTime?>();
/// <summary>
/// Gets or sets the value for the EndDate column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.DateTime? @EndDate { get { return @endDateColumnValue.Value; } set { @endDateColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EndDate has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EndDateHasChanged { get { return @endDateColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the UsersToOrganizations table.
/// </summary>
public static @UsersToOrganizationsModification CreateForInsert() {
return new @UsersToOrganizationsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the UsersToOrganizations table.
/// </summary>
public static @UsersToOrganizationsModification CreateForUpdate( CommandConditions.UsersToOrganizationsTableCondition requiredCondition, params CommandConditions.UsersToOrganizationsTableCondition[] additionalConditions ) {
var mod = new @UsersToOrganizationsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@UsersToOrganizationsTableEqualityConditions.@UsersToOrganizationId )
mod.@usersToOrganizationIdColumnValue.Value = ( condition as CommandConditions.@UsersToOrganizationsTableEqualityConditions.@UsersToOrganizationId ).Value;
else if( condition is CommandConditions.@UsersToOrganizationsTableEqualityConditions.@UserId )
mod.@userIdColumnValue.Value = ( condition as CommandConditions.@UsersToOrganizationsTableEqualityConditions.@UserId ).Value;
else if( condition is CommandConditions.@UsersToOrganizationsTableEqualityConditions.@OrganizationId )
mod.@organizationIdColumnValue.Value = ( condition as CommandConditions.@UsersToOrganizationsTableEqualityConditions.@OrganizationId ).Value;
else if( condition is CommandConditions.@UsersToOrganizationsTableEqualityConditions.@StartDate )
mod.@startDateColumnValue.Value = ( condition as CommandConditions.@UsersToOrganizationsTableEqualityConditions.@StartDate ).Value;
else if( condition is CommandConditions.@UsersToOrganizationsTableEqualityConditions.@EndDate )
mod.@endDateColumnValue.Value = ( condition as CommandConditions.@UsersToOrganizationsTableEqualityConditions.@EndDate ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the UsersToOrganizations table.
/// </summary>
public static @UsersToOrganizationsModification CreateForSingleRowUpdate( int @usersToOrganizationId, int @userId, int @organizationId, System.DateTime? @startDate, System.DateTime? @endDate ) {
var mod = new @UsersToOrganizationsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.UsersToOrganizationsTableCondition>();
mod.conditions.Add( new CommandConditions.@UsersToOrganizationsTableEqualityConditions.@UsersToOrganizationId( @usersToOrganizationId ) );
mod.@usersToOrganizationIdColumnValue.Value = @usersToOrganizationId;
mod.@userIdColumnValue.Value = @userId;
mod.@organizationIdColumnValue.Value = @organizationId;
mod.@startDateColumnValue.Value = @startDate;
mod.@endDateColumnValue.Value = @endDate;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.UsersToOrganizationsTableCondition> getConditionList( CommandConditions.UsersToOrganizationsTableCondition requiredCondition, params CommandConditions.UsersToOrganizationsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.UsersToOrganizationsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @UsersToOrganizationsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="usersToOrganizationId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="organizationId">Object does not allow null.</param>
/// <param name="startDate">Object allows null.</param>
/// <param name="endDate">Object allows null.</param>
public void SetAllData( int @usersToOrganizationId, int @userId, int @organizationId, System.DateTime? @startDate, System.DateTime? @endDate ) {
this.@usersToOrganizationIdColumnValue.Value = @usersToOrganizationId;
this.@userIdColumnValue.Value = @userId;
this.@organizationIdColumnValue.Value = @organizationId;
this.@startDateColumnValue.Value = @startDate;
this.@endDateColumnValue.Value = @endDate;
}
/// <summary>
/// Executes this UsersToOrganizations modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this UsersToOrganizations modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "UsersToOrganizations" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.UsersToOrganizationsTableCondition>();
conditions.Add( new CommandConditions.@UsersToOrganizationsTableEqualityConditions.@UsersToOrganizationId( @UsersToOrganizationId ) );
}
else {
var update = new InlineUpdate( "UsersToOrganizations" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @usersToOrganizationIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "UsersToOrganizationId", new DbParameterValue( @UsersToOrganizationId, "Int" ) ) );
if( @userIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( @UserId, "Int" ) ) );
if( @organizationIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "OrganizationId", new DbParameterValue( @OrganizationId, "Int" ) ) );
if( @startDateColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "StartDate", new DbParameterValue( @StartDate, "Date" ) ) );
if( @endDateColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EndDate", new DbParameterValue( @EndDate, "Date" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@usersToOrganizationIdColumnValue.ClearChanged();
@userIdColumnValue.ClearChanged();
@organizationIdColumnValue.ClearChanged();
@startDateColumnValue.ClearChanged();
@endDateColumnValue.ClearChanged();
}
}
public partial class @UsersToPasswordResetQuestionsModification {
/// <summary>
/// Inserts a row into the UsersToPasswordResetQuestions table.
/// </summary>
/// <param name="usersToPasswordResetQuestionId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="passwordResetQuestionId">Object does not allow null.</param>
/// <param name="iv">Object does not allow null.</param>
/// <param name="answer">Object does not allow null.</param>
public static void InsertRow( int @usersToPasswordResetQuestionId, int @userId, int @passwordResetQuestionId, System.Byte[] @iv, System.Byte[] @answer ) { 
var mod = CreateForInsert();
mod.@usersToPasswordResetQuestionIdColumnValue.Value = @usersToPasswordResetQuestionId;
mod.@userIdColumnValue.Value = @userId;
mod.@passwordResetQuestionIdColumnValue.Value = @passwordResetQuestionId;
mod.@ivColumnValue.Value = @iv;
mod.@answerColumnValue.Value = @answer;
mod.Execute();
}
/// <summary>
/// Inserts a row into the UsersToPasswordResetQuestions table.
/// </summary>
/// <param name="usersToPasswordResetQuestionId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="passwordResetQuestionId">Object does not allow null.</param>
/// <param name="iv">Object does not allow null.</param>
/// <param name="answer">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @usersToPasswordResetQuestionId, int @userId, int @passwordResetQuestionId, System.Byte[] @iv, System.Byte[] @answer ) { 
var mod = CreateForInsert();
mod.@usersToPasswordResetQuestionIdColumnValue.Value = @usersToPasswordResetQuestionId;
mod.@userIdColumnValue.Value = @userId;
mod.@passwordResetQuestionIdColumnValue.Value = @passwordResetQuestionId;
mod.@ivColumnValue.Value = @iv;
mod.@answerColumnValue.Value = @answer;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the UsersToPasswordResetQuestions table that match the specified conditions with the specified data.
/// </summary>
/// <param name="usersToPasswordResetQuestionId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="passwordResetQuestionId">Object does not allow null.</param>
/// <param name="iv">Object does not allow null.</param>
/// <param name="answer">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @usersToPasswordResetQuestionId, int @userId, int @passwordResetQuestionId, System.Byte[] @iv, System.Byte[] @answer, CommandConditions.UsersToPasswordResetQuestionsTableCondition requiredCondition, params CommandConditions.UsersToPasswordResetQuestionsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@usersToPasswordResetQuestionIdColumnValue.Value = @usersToPasswordResetQuestionId;
mod.@userIdColumnValue.Value = @userId;
mod.@passwordResetQuestionIdColumnValue.Value = @passwordResetQuestionId;
mod.@ivColumnValue.Value = @iv;
mod.@answerColumnValue.Value = @answer;
mod.Execute();
}
/// <summary>
/// Updates rows in the UsersToPasswordResetQuestions table that match the specified conditions with the specified data.
/// </summary>
/// <param name="usersToPasswordResetQuestionId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="passwordResetQuestionId">Object does not allow null.</param>
/// <param name="iv">Object does not allow null.</param>
/// <param name="answer">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @usersToPasswordResetQuestionId, int @userId, int @passwordResetQuestionId, System.Byte[] @iv, System.Byte[] @answer, CommandConditions.UsersToPasswordResetQuestionsTableCondition requiredCondition, params CommandConditions.UsersToPasswordResetQuestionsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@usersToPasswordResetQuestionIdColumnValue.Value = @usersToPasswordResetQuestionId;
mod.@userIdColumnValue.Value = @userId;
mod.@passwordResetQuestionIdColumnValue.Value = @passwordResetQuestionId;
mod.@ivColumnValue.Value = @iv;
mod.@answerColumnValue.Value = @answer;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.UsersToPasswordResetQuestionsTableCondition requiredCondition, params CommandConditions.UsersToPasswordResetQuestionsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@UsersToPasswordResetQuestionsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.UsersToPasswordResetQuestionsTableCondition requiredCondition, params CommandConditions.UsersToPasswordResetQuestionsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.UsersToPasswordResetQuestionsTableCondition> conditions ) {
var delete = new InlineDelete( "UsersToPasswordResetQuestions" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.UsersToPasswordResetQuestionsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@UsersToPasswordResetQuestionsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.UsersToPasswordResetQuestionsTableCondition> conditions;
private readonly DataValue<int> @usersToPasswordResetQuestionIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the UsersToPasswordResetQuestionId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @UsersToPasswordResetQuestionId { get { return @usersToPasswordResetQuestionIdColumnValue.Value; } set { @usersToPasswordResetQuestionIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the UsersToPasswordResetQuestionId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @UsersToPasswordResetQuestionIdHasChanged { get { return @usersToPasswordResetQuestionIdColumnValue.Changed; } }
private readonly DataValue<int> @userIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the UserId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @UserId { get { return @userIdColumnValue.Value; } set { @userIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the UserId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @UserIdHasChanged { get { return @userIdColumnValue.Changed; } }
private readonly DataValue<int> @passwordResetQuestionIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the PasswordResetQuestionId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @PasswordResetQuestionId { get { return @passwordResetQuestionIdColumnValue.Value; } set { @passwordResetQuestionIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PasswordResetQuestionId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PasswordResetQuestionIdHasChanged { get { return @passwordResetQuestionIdColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @ivColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the Iv column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @Iv { get { return @ivColumnValue.Value; } set { @ivColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Iv has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @IvHasChanged { get { return @ivColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @answerColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the Answer column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @Answer { get { return @answerColumnValue.Value; } set { @answerColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Answer has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @AnswerHasChanged { get { return @answerColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the UsersToPasswordResetQuestions table.
/// </summary>
public static @UsersToPasswordResetQuestionsModification CreateForInsert() {
return new @UsersToPasswordResetQuestionsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the UsersToPasswordResetQuestions table.
/// </summary>
public static @UsersToPasswordResetQuestionsModification CreateForUpdate( CommandConditions.UsersToPasswordResetQuestionsTableCondition requiredCondition, params CommandConditions.UsersToPasswordResetQuestionsTableCondition[] additionalConditions ) {
var mod = new @UsersToPasswordResetQuestionsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@UsersToPasswordResetQuestionsTableEqualityConditions.@UsersToPasswordResetQuestionId )
mod.@usersToPasswordResetQuestionIdColumnValue.Value = ( condition as CommandConditions.@UsersToPasswordResetQuestionsTableEqualityConditions.@UsersToPasswordResetQuestionId ).Value;
else if( condition is CommandConditions.@UsersToPasswordResetQuestionsTableEqualityConditions.@UserId )
mod.@userIdColumnValue.Value = ( condition as CommandConditions.@UsersToPasswordResetQuestionsTableEqualityConditions.@UserId ).Value;
else if( condition is CommandConditions.@UsersToPasswordResetQuestionsTableEqualityConditions.@PasswordResetQuestionId )
mod.@passwordResetQuestionIdColumnValue.Value = ( condition as CommandConditions.@UsersToPasswordResetQuestionsTableEqualityConditions.@PasswordResetQuestionId ).Value;
else if( condition is CommandConditions.@UsersToPasswordResetQuestionsTableEqualityConditions.@Iv )
mod.@ivColumnValue.Value = ( condition as CommandConditions.@UsersToPasswordResetQuestionsTableEqualityConditions.@Iv ).Value;
else if( condition is CommandConditions.@UsersToPasswordResetQuestionsTableEqualityConditions.@Answer )
mod.@answerColumnValue.Value = ( condition as CommandConditions.@UsersToPasswordResetQuestionsTableEqualityConditions.@Answer ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the UsersToPasswordResetQuestions table.
/// </summary>
public static @UsersToPasswordResetQuestionsModification CreateForSingleRowUpdate( int @usersToPasswordResetQuestionId, int @userId, int @passwordResetQuestionId, System.Byte[] @iv, System.Byte[] @answer ) {
var mod = new @UsersToPasswordResetQuestionsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.UsersToPasswordResetQuestionsTableCondition>();
mod.conditions.Add( new CommandConditions.@UsersToPasswordResetQuestionsTableEqualityConditions.@UsersToPasswordResetQuestionId( @usersToPasswordResetQuestionId ) );
mod.@usersToPasswordResetQuestionIdColumnValue.Value = @usersToPasswordResetQuestionId;
mod.@userIdColumnValue.Value = @userId;
mod.@passwordResetQuestionIdColumnValue.Value = @passwordResetQuestionId;
mod.@ivColumnValue.Value = @iv;
mod.@answerColumnValue.Value = @answer;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.UsersToPasswordResetQuestionsTableCondition> getConditionList( CommandConditions.UsersToPasswordResetQuestionsTableCondition requiredCondition, params CommandConditions.UsersToPasswordResetQuestionsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.UsersToPasswordResetQuestionsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @UsersToPasswordResetQuestionsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="usersToPasswordResetQuestionId">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="passwordResetQuestionId">Object does not allow null.</param>
/// <param name="iv">Object does not allow null.</param>
/// <param name="answer">Object does not allow null.</param>
public void SetAllData( int @usersToPasswordResetQuestionId, int @userId, int @passwordResetQuestionId, System.Byte[] @iv, System.Byte[] @answer ) {
this.@usersToPasswordResetQuestionIdColumnValue.Value = @usersToPasswordResetQuestionId;
this.@userIdColumnValue.Value = @userId;
this.@passwordResetQuestionIdColumnValue.Value = @passwordResetQuestionId;
this.@ivColumnValue.Value = @iv;
this.@answerColumnValue.Value = @answer;
}
/// <summary>
/// Executes this UsersToPasswordResetQuestions modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this UsersToPasswordResetQuestions modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "UsersToPasswordResetQuestions" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.UsersToPasswordResetQuestionsTableCondition>();
conditions.Add( new CommandConditions.@UsersToPasswordResetQuestionsTableEqualityConditions.@UsersToPasswordResetQuestionId( @UsersToPasswordResetQuestionId ) );
}
else {
var update = new InlineUpdate( "UsersToPasswordResetQuestions" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @usersToPasswordResetQuestionIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "UsersToPasswordResetQuestionId", new DbParameterValue( @UsersToPasswordResetQuestionId, "Int" ) ) );
if( @userIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( @UserId, "Int" ) ) );
if( @passwordResetQuestionIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PasswordResetQuestionId", new DbParameterValue( @PasswordResetQuestionId, "Int" ) ) );
if( @ivColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Iv", new DbParameterValue( @Iv, "Binary" ) ) );
if( @answerColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Answer", new DbParameterValue( @Answer, "VarBinary" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@usersToPasswordResetQuestionIdColumnValue.ClearChanged();
@userIdColumnValue.ClearChanged();
@passwordResetQuestionIdColumnValue.ClearChanged();
@ivColumnValue.ClearChanged();
@answerColumnValue.ClearChanged();
}
}
public partial class @VhrAccessLogsModification {
/// <summary>
/// Inserts a row into the VhrAccessLogs table. Returns the value of the VhrAccessLogId column.
/// </summary>
/// <param name="vhrProfileId">Object does not allow null.</param>
/// <param name="dateTimeUtc">Object does not allow null.</param>
public static int InsertRow( int @vhrProfileId, DateTime @dateTimeUtc ) { 
var mod = CreateForInsert();
mod.@vhrProfileIdColumnValue.Value = @vhrProfileId;
mod.@dateTimeUtcColumnValue.Value = @dateTimeUtc;
mod.Execute();
return mod.VhrAccessLogId;
}
/// <summary>
/// Inserts a row into the VhrAccessLogs table. Returns the value of the VhrAccessLogId column.
/// </summary>
/// <param name="vhrProfileId">Object does not allow null.</param>
/// <param name="dateTimeUtc">Object does not allow null.</param>
public static int InsertRowWithoutAdditionalLogic( int @vhrProfileId, DateTime @dateTimeUtc ) { 
var mod = CreateForInsert();
mod.@vhrProfileIdColumnValue.Value = @vhrProfileId;
mod.@dateTimeUtcColumnValue.Value = @dateTimeUtc;
mod.ExecuteWithoutAdditionalLogic();
return mod.VhrAccessLogId;
}
/// <summary>
/// Updates rows in the VhrAccessLogs table that match the specified conditions with the specified data.
/// </summary>
/// <param name="vhrProfileId">Object does not allow null.</param>
/// <param name="dateTimeUtc">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @vhrProfileId, DateTime @dateTimeUtc, CommandConditions.VhrAccessLogsTableCondition requiredCondition, params CommandConditions.VhrAccessLogsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@vhrProfileIdColumnValue.Value = @vhrProfileId;
mod.@dateTimeUtcColumnValue.Value = @dateTimeUtc;
mod.Execute();
}
/// <summary>
/// Updates rows in the VhrAccessLogs table that match the specified conditions with the specified data.
/// </summary>
/// <param name="vhrProfileId">Object does not allow null.</param>
/// <param name="dateTimeUtc">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @vhrProfileId, DateTime @dateTimeUtc, CommandConditions.VhrAccessLogsTableCondition requiredCondition, params CommandConditions.VhrAccessLogsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@vhrProfileIdColumnValue.Value = @vhrProfileId;
mod.@dateTimeUtcColumnValue.Value = @dateTimeUtc;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.VhrAccessLogsTableCondition requiredCondition, params CommandConditions.VhrAccessLogsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@VhrAccessLogsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.VhrAccessLogsTableCondition requiredCondition, params CommandConditions.VhrAccessLogsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.VhrAccessLogsTableCondition> conditions ) {
var delete = new InlineDelete( "VhrAccessLogs" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.VhrAccessLogsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@VhrAccessLogsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.VhrAccessLogsTableCondition> conditions;
private readonly DataValue<int> @vhrAccessLogIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets the value for the VhrAccessLogId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @VhrAccessLogId { get { return @vhrAccessLogIdColumnValue.Value; } }
private readonly DataValue<int> @vhrProfileIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the VhrProfileId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @VhrProfileId { get { return @vhrProfileIdColumnValue.Value; } set { @vhrProfileIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the VhrProfileId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @VhrProfileIdHasChanged { get { return @vhrProfileIdColumnValue.Changed; } }
private readonly DataValue<DateTime> @dateTimeUtcColumnValue = new DataValue<DateTime>();
/// <summary>
/// Gets or sets the value for the DateTimeUtc column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public DateTime @DateTimeUtc { get { return @dateTimeUtcColumnValue.Value; } set { @dateTimeUtcColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the DateTimeUtc has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @DateTimeUtcHasChanged { get { return @dateTimeUtcColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the VhrAccessLogs table.
/// </summary>
public static @VhrAccessLogsModification CreateForInsert() {
return new @VhrAccessLogsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the VhrAccessLogs table.
/// </summary>
public static @VhrAccessLogsModification CreateForUpdate( CommandConditions.VhrAccessLogsTableCondition requiredCondition, params CommandConditions.VhrAccessLogsTableCondition[] additionalConditions ) {
var mod = new @VhrAccessLogsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@VhrAccessLogsTableEqualityConditions.@VhrAccessLogId )
mod.@vhrAccessLogIdColumnValue.Value = ( condition as CommandConditions.@VhrAccessLogsTableEqualityConditions.@VhrAccessLogId ).Value;
else if( condition is CommandConditions.@VhrAccessLogsTableEqualityConditions.@VhrProfileId )
mod.@vhrProfileIdColumnValue.Value = ( condition as CommandConditions.@VhrAccessLogsTableEqualityConditions.@VhrProfileId ).Value;
else if( condition is CommandConditions.@VhrAccessLogsTableEqualityConditions.@DateTimeUtc )
mod.@dateTimeUtcColumnValue.Value = ( condition as CommandConditions.@VhrAccessLogsTableEqualityConditions.@DateTimeUtc ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the VhrAccessLogs table.
/// </summary>
public static @VhrAccessLogsModification CreateForSingleRowUpdate( int @vhrAccessLogId, int @vhrProfileId, DateTime @dateTimeUtc ) {
var mod = new @VhrAccessLogsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.VhrAccessLogsTableCondition>();
mod.conditions.Add( new CommandConditions.@VhrAccessLogsTableEqualityConditions.@VhrAccessLogId( @vhrAccessLogId ) );
mod.@vhrAccessLogIdColumnValue.Value = @vhrAccessLogId;
mod.@vhrProfileIdColumnValue.Value = @vhrProfileId;
mod.@dateTimeUtcColumnValue.Value = @dateTimeUtc;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.VhrAccessLogsTableCondition> getConditionList( CommandConditions.VhrAccessLogsTableCondition requiredCondition, params CommandConditions.VhrAccessLogsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.VhrAccessLogsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @VhrAccessLogsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="vhrProfileId">Object does not allow null.</param>
/// <param name="dateTimeUtc">Object does not allow null.</param>
public void SetAllData( int @vhrProfileId, DateTime @dateTimeUtc ) {
this.@vhrProfileIdColumnValue.Value = @vhrProfileId;
this.@dateTimeUtcColumnValue.Value = @dateTimeUtc;
}
/// <summary>
/// Executes this VhrAccessLogs modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this VhrAccessLogs modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "VhrAccessLogs" );
addColumnModifications( insert );
@vhrAccessLogIdColumnValue.Value = (System.Int32)Utility.ChangeType( insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection ), typeof( System.Int32 ) );
modType = ModificationType.Update;
conditions = new List<CommandConditions.VhrAccessLogsTableCondition>();
conditions.Add( new CommandConditions.@VhrAccessLogsTableEqualityConditions.@VhrAccessLogId( @VhrAccessLogId ) );
}
else {
var update = new InlineUpdate( "VhrAccessLogs" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @vhrProfileIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "VhrProfileId", new DbParameterValue( @VhrProfileId, "Int" ) ) );
if( @dateTimeUtcColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "DateTimeUtc", new DbParameterValue( @DateTimeUtc, "DateTime2" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@vhrAccessLogIdColumnValue.ClearChanged();
@vhrProfileIdColumnValue.ClearChanged();
@dateTimeUtcColumnValue.ClearChanged();
}
}
public partial class @VhrEnvironmentConfigurationsModification {
/// <summary>
/// Inserts a row into the VhrEnvironmentConfigurations table.
/// </summary>
/// <param name="vhrProviderId">Object does not allow null.</param>
/// <param name="vhrEnvironmentId">Object does not allow null.</param>
/// <param name="endpointUrl">Object does not allow null.</param>
/// <param name="ssoSiteId">Object does not allow null.</param>
/// <param name="ssoCertificate">Object allows null.</param>
/// <param name="ssoPassword">Object allows null.</param>
/// <param name="ssoIv">Object allows null.</param>
/// <param name="clientCertificate">Object allows null.</param>
/// <param name="clientPassword">Object allows null.</param>
/// <param name="clientIv">Object allows null.</param>
/// <param name="ssoSendingParty">Object does not allow null.</param>
/// <param name="redirectToUrl">Object does not allow null.</param>
public static void InsertRow( int @vhrProviderId, int @vhrEnvironmentId, string @endpointUrl, string @ssoSiteId, System.Byte[] @ssoCertificate, System.Byte[] @ssoPassword, System.Byte[] @ssoIv, System.Byte[] @clientCertificate, System.Byte[] @clientPassword, System.Byte[] @clientIv, string @ssoSendingParty, string @redirectToUrl ) { 
var mod = CreateForInsert();
mod.@vhrProviderIdColumnValue.Value = @vhrProviderId;
mod.@vhrEnvironmentIdColumnValue.Value = @vhrEnvironmentId;
mod.@endpointUrlColumnValue.Value = @endpointUrl;
mod.@ssoSiteIdColumnValue.Value = @ssoSiteId;
mod.@ssoCertificateColumnValue.Value = @ssoCertificate;
mod.@ssoPasswordColumnValue.Value = @ssoPassword;
mod.@ssoIvColumnValue.Value = @ssoIv;
mod.@clientCertificateColumnValue.Value = @clientCertificate;
mod.@clientPasswordColumnValue.Value = @clientPassword;
mod.@clientIvColumnValue.Value = @clientIv;
mod.@ssoSendingPartyColumnValue.Value = @ssoSendingParty;
mod.@redirectToUrlColumnValue.Value = @redirectToUrl;
mod.Execute();
}
/// <summary>
/// Inserts a row into the VhrEnvironmentConfigurations table.
/// </summary>
/// <param name="vhrProviderId">Object does not allow null.</param>
/// <param name="vhrEnvironmentId">Object does not allow null.</param>
/// <param name="endpointUrl">Object does not allow null.</param>
/// <param name="ssoSiteId">Object does not allow null.</param>
/// <param name="ssoCertificate">Object allows null.</param>
/// <param name="ssoPassword">Object allows null.</param>
/// <param name="ssoIv">Object allows null.</param>
/// <param name="clientCertificate">Object allows null.</param>
/// <param name="clientPassword">Object allows null.</param>
/// <param name="clientIv">Object allows null.</param>
/// <param name="ssoSendingParty">Object does not allow null.</param>
/// <param name="redirectToUrl">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @vhrProviderId, int @vhrEnvironmentId, string @endpointUrl, string @ssoSiteId, System.Byte[] @ssoCertificate, System.Byte[] @ssoPassword, System.Byte[] @ssoIv, System.Byte[] @clientCertificate, System.Byte[] @clientPassword, System.Byte[] @clientIv, string @ssoSendingParty, string @redirectToUrl ) { 
var mod = CreateForInsert();
mod.@vhrProviderIdColumnValue.Value = @vhrProviderId;
mod.@vhrEnvironmentIdColumnValue.Value = @vhrEnvironmentId;
mod.@endpointUrlColumnValue.Value = @endpointUrl;
mod.@ssoSiteIdColumnValue.Value = @ssoSiteId;
mod.@ssoCertificateColumnValue.Value = @ssoCertificate;
mod.@ssoPasswordColumnValue.Value = @ssoPassword;
mod.@ssoIvColumnValue.Value = @ssoIv;
mod.@clientCertificateColumnValue.Value = @clientCertificate;
mod.@clientPasswordColumnValue.Value = @clientPassword;
mod.@clientIvColumnValue.Value = @clientIv;
mod.@ssoSendingPartyColumnValue.Value = @ssoSendingParty;
mod.@redirectToUrlColumnValue.Value = @redirectToUrl;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the VhrEnvironmentConfigurations table that match the specified conditions with the specified data.
/// </summary>
/// <param name="vhrProviderId">Object does not allow null.</param>
/// <param name="vhrEnvironmentId">Object does not allow null.</param>
/// <param name="endpointUrl">Object does not allow null.</param>
/// <param name="ssoSiteId">Object does not allow null.</param>
/// <param name="ssoCertificate">Object allows null.</param>
/// <param name="ssoPassword">Object allows null.</param>
/// <param name="ssoIv">Object allows null.</param>
/// <param name="clientCertificate">Object allows null.</param>
/// <param name="clientPassword">Object allows null.</param>
/// <param name="clientIv">Object allows null.</param>
/// <param name="ssoSendingParty">Object does not allow null.</param>
/// <param name="redirectToUrl">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @vhrProviderId, int @vhrEnvironmentId, string @endpointUrl, string @ssoSiteId, System.Byte[] @ssoCertificate, System.Byte[] @ssoPassword, System.Byte[] @ssoIv, System.Byte[] @clientCertificate, System.Byte[] @clientPassword, System.Byte[] @clientIv, string @ssoSendingParty, string @redirectToUrl, CommandConditions.VhrEnvironmentConfigurationsTableCondition requiredCondition, params CommandConditions.VhrEnvironmentConfigurationsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@vhrProviderIdColumnValue.Value = @vhrProviderId;
mod.@vhrEnvironmentIdColumnValue.Value = @vhrEnvironmentId;
mod.@endpointUrlColumnValue.Value = @endpointUrl;
mod.@ssoSiteIdColumnValue.Value = @ssoSiteId;
mod.@ssoCertificateColumnValue.Value = @ssoCertificate;
mod.@ssoPasswordColumnValue.Value = @ssoPassword;
mod.@ssoIvColumnValue.Value = @ssoIv;
mod.@clientCertificateColumnValue.Value = @clientCertificate;
mod.@clientPasswordColumnValue.Value = @clientPassword;
mod.@clientIvColumnValue.Value = @clientIv;
mod.@ssoSendingPartyColumnValue.Value = @ssoSendingParty;
mod.@redirectToUrlColumnValue.Value = @redirectToUrl;
mod.Execute();
}
/// <summary>
/// Updates rows in the VhrEnvironmentConfigurations table that match the specified conditions with the specified data.
/// </summary>
/// <param name="vhrProviderId">Object does not allow null.</param>
/// <param name="vhrEnvironmentId">Object does not allow null.</param>
/// <param name="endpointUrl">Object does not allow null.</param>
/// <param name="ssoSiteId">Object does not allow null.</param>
/// <param name="ssoCertificate">Object allows null.</param>
/// <param name="ssoPassword">Object allows null.</param>
/// <param name="ssoIv">Object allows null.</param>
/// <param name="clientCertificate">Object allows null.</param>
/// <param name="clientPassword">Object allows null.</param>
/// <param name="clientIv">Object allows null.</param>
/// <param name="ssoSendingParty">Object does not allow null.</param>
/// <param name="redirectToUrl">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @vhrProviderId, int @vhrEnvironmentId, string @endpointUrl, string @ssoSiteId, System.Byte[] @ssoCertificate, System.Byte[] @ssoPassword, System.Byte[] @ssoIv, System.Byte[] @clientCertificate, System.Byte[] @clientPassword, System.Byte[] @clientIv, string @ssoSendingParty, string @redirectToUrl, CommandConditions.VhrEnvironmentConfigurationsTableCondition requiredCondition, params CommandConditions.VhrEnvironmentConfigurationsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@vhrProviderIdColumnValue.Value = @vhrProviderId;
mod.@vhrEnvironmentIdColumnValue.Value = @vhrEnvironmentId;
mod.@endpointUrlColumnValue.Value = @endpointUrl;
mod.@ssoSiteIdColumnValue.Value = @ssoSiteId;
mod.@ssoCertificateColumnValue.Value = @ssoCertificate;
mod.@ssoPasswordColumnValue.Value = @ssoPassword;
mod.@ssoIvColumnValue.Value = @ssoIv;
mod.@clientCertificateColumnValue.Value = @clientCertificate;
mod.@clientPasswordColumnValue.Value = @clientPassword;
mod.@clientIvColumnValue.Value = @clientIv;
mod.@ssoSendingPartyColumnValue.Value = @ssoSendingParty;
mod.@redirectToUrlColumnValue.Value = @redirectToUrl;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.VhrEnvironmentConfigurationsTableCondition requiredCondition, params CommandConditions.VhrEnvironmentConfigurationsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@VhrEnvironmentConfigurationsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.VhrEnvironmentConfigurationsTableCondition requiredCondition, params CommandConditions.VhrEnvironmentConfigurationsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.VhrEnvironmentConfigurationsTableCondition> conditions ) {
var delete = new InlineDelete( "VhrEnvironmentConfigurations" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.VhrEnvironmentConfigurationsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@VhrEnvironmentConfigurationsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.VhrEnvironmentConfigurationsTableCondition> conditions;
private readonly DataValue<int> @vhrProviderIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the VhrProviderId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @VhrProviderId { get { return @vhrProviderIdColumnValue.Value; } set { @vhrProviderIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the VhrProviderId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @VhrProviderIdHasChanged { get { return @vhrProviderIdColumnValue.Changed; } }
private readonly DataValue<int> @vhrEnvironmentIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the VhrEnvironmentId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @VhrEnvironmentId { get { return @vhrEnvironmentIdColumnValue.Value; } set { @vhrEnvironmentIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the VhrEnvironmentId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @VhrEnvironmentIdHasChanged { get { return @vhrEnvironmentIdColumnValue.Changed; } }
private readonly DataValue<string> @endpointUrlColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the EndpointUrl column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @EndpointUrl { get { return @endpointUrlColumnValue.Value; } set { @endpointUrlColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EndpointUrl has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EndpointUrlHasChanged { get { return @endpointUrlColumnValue.Changed; } }
private readonly DataValue<string> @ssoSiteIdColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the SsoSiteId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @SsoSiteId { get { return @ssoSiteIdColumnValue.Value; } set { @ssoSiteIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the SsoSiteId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @SsoSiteIdHasChanged { get { return @ssoSiteIdColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @ssoCertificateColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the SsoCertificate column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.Byte[] @SsoCertificate { get { return @ssoCertificateColumnValue.Value; } set { @ssoCertificateColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the SsoCertificate has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @SsoCertificateHasChanged { get { return @ssoCertificateColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @ssoPasswordColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the SsoPassword column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.Byte[] @SsoPassword { get { return @ssoPasswordColumnValue.Value; } set { @ssoPasswordColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the SsoPassword has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @SsoPasswordHasChanged { get { return @ssoPasswordColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @ssoIvColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the SsoIv column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.Byte[] @SsoIv { get { return @ssoIvColumnValue.Value; } set { @ssoIvColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the SsoIv has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @SsoIvHasChanged { get { return @ssoIvColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @clientCertificateColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the ClientCertificate column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.Byte[] @ClientCertificate { get { return @clientCertificateColumnValue.Value; } set { @clientCertificateColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ClientCertificate has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ClientCertificateHasChanged { get { return @clientCertificateColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @clientPasswordColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the ClientPassword column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.Byte[] @ClientPassword { get { return @clientPasswordColumnValue.Value; } set { @clientPasswordColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ClientPassword has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ClientPasswordHasChanged { get { return @clientPasswordColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @clientIvColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the ClientIv column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.Byte[] @ClientIv { get { return @clientIvColumnValue.Value; } set { @clientIvColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ClientIv has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ClientIvHasChanged { get { return @clientIvColumnValue.Changed; } }
private readonly DataValue<string> @ssoSendingPartyColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the SsoSendingParty column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @SsoSendingParty { get { return @ssoSendingPartyColumnValue.Value; } set { @ssoSendingPartyColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the SsoSendingParty has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @SsoSendingPartyHasChanged { get { return @ssoSendingPartyColumnValue.Changed; } }
private readonly DataValue<string> @redirectToUrlColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the RedirectToUrl column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @RedirectToUrl { get { return @redirectToUrlColumnValue.Value; } set { @redirectToUrlColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the RedirectToUrl has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @RedirectToUrlHasChanged { get { return @redirectToUrlColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the VhrEnvironmentConfigurations table.
/// </summary>
public static @VhrEnvironmentConfigurationsModification CreateForInsert() {
return new @VhrEnvironmentConfigurationsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the VhrEnvironmentConfigurations table.
/// </summary>
public static @VhrEnvironmentConfigurationsModification CreateForUpdate( CommandConditions.VhrEnvironmentConfigurationsTableCondition requiredCondition, params CommandConditions.VhrEnvironmentConfigurationsTableCondition[] additionalConditions ) {
var mod = new @VhrEnvironmentConfigurationsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@VhrEnvironmentConfigurationsTableEqualityConditions.@VhrProviderId )
mod.@vhrProviderIdColumnValue.Value = ( condition as CommandConditions.@VhrEnvironmentConfigurationsTableEqualityConditions.@VhrProviderId ).Value;
else if( condition is CommandConditions.@VhrEnvironmentConfigurationsTableEqualityConditions.@VhrEnvironmentId )
mod.@vhrEnvironmentIdColumnValue.Value = ( condition as CommandConditions.@VhrEnvironmentConfigurationsTableEqualityConditions.@VhrEnvironmentId ).Value;
else if( condition is CommandConditions.@VhrEnvironmentConfigurationsTableEqualityConditions.@EndpointUrl )
mod.@endpointUrlColumnValue.Value = ( condition as CommandConditions.@VhrEnvironmentConfigurationsTableEqualityConditions.@EndpointUrl ).Value;
else if( condition is CommandConditions.@VhrEnvironmentConfigurationsTableEqualityConditions.@SsoSiteId )
mod.@ssoSiteIdColumnValue.Value = ( condition as CommandConditions.@VhrEnvironmentConfigurationsTableEqualityConditions.@SsoSiteId ).Value;
else if( condition is CommandConditions.@VhrEnvironmentConfigurationsTableEqualityConditions.@SsoCertificate )
mod.@ssoCertificateColumnValue.Value = ( condition as CommandConditions.@VhrEnvironmentConfigurationsTableEqualityConditions.@SsoCertificate ).Value;
else if( condition is CommandConditions.@VhrEnvironmentConfigurationsTableEqualityConditions.@SsoPassword )
mod.@ssoPasswordColumnValue.Value = ( condition as CommandConditions.@VhrEnvironmentConfigurationsTableEqualityConditions.@SsoPassword ).Value;
else if( condition is CommandConditions.@VhrEnvironmentConfigurationsTableEqualityConditions.@SsoIv )
mod.@ssoIvColumnValue.Value = ( condition as CommandConditions.@VhrEnvironmentConfigurationsTableEqualityConditions.@SsoIv ).Value;
else if( condition is CommandConditions.@VhrEnvironmentConfigurationsTableEqualityConditions.@ClientCertificate )
mod.@clientCertificateColumnValue.Value = ( condition as CommandConditions.@VhrEnvironmentConfigurationsTableEqualityConditions.@ClientCertificate ).Value;
else if( condition is CommandConditions.@VhrEnvironmentConfigurationsTableEqualityConditions.@ClientPassword )
mod.@clientPasswordColumnValue.Value = ( condition as CommandConditions.@VhrEnvironmentConfigurationsTableEqualityConditions.@ClientPassword ).Value;
else if( condition is CommandConditions.@VhrEnvironmentConfigurationsTableEqualityConditions.@ClientIv )
mod.@clientIvColumnValue.Value = ( condition as CommandConditions.@VhrEnvironmentConfigurationsTableEqualityConditions.@ClientIv ).Value;
else if( condition is CommandConditions.@VhrEnvironmentConfigurationsTableEqualityConditions.@SsoSendingParty )
mod.@ssoSendingPartyColumnValue.Value = ( condition as CommandConditions.@VhrEnvironmentConfigurationsTableEqualityConditions.@SsoSendingParty ).Value;
else if( condition is CommandConditions.@VhrEnvironmentConfigurationsTableEqualityConditions.@RedirectToUrl )
mod.@redirectToUrlColumnValue.Value = ( condition as CommandConditions.@VhrEnvironmentConfigurationsTableEqualityConditions.@RedirectToUrl ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the VhrEnvironmentConfigurations table.
/// </summary>
public static @VhrEnvironmentConfigurationsModification CreateForSingleRowUpdate( int @vhrProviderId, int @vhrEnvironmentId, string @endpointUrl, string @ssoSiteId, System.Byte[] @ssoCertificate, System.Byte[] @ssoPassword, System.Byte[] @ssoIv, System.Byte[] @clientCertificate, System.Byte[] @clientPassword, System.Byte[] @clientIv, string @ssoSendingParty, string @redirectToUrl ) {
var mod = new @VhrEnvironmentConfigurationsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.VhrEnvironmentConfigurationsTableCondition>();
mod.conditions.Add( new CommandConditions.@VhrEnvironmentConfigurationsTableEqualityConditions.@VhrProviderId( @vhrProviderId ) );
mod.conditions.Add( new CommandConditions.@VhrEnvironmentConfigurationsTableEqualityConditions.@VhrEnvironmentId( @vhrEnvironmentId ) );
mod.@vhrProviderIdColumnValue.Value = @vhrProviderId;
mod.@vhrEnvironmentIdColumnValue.Value = @vhrEnvironmentId;
mod.@endpointUrlColumnValue.Value = @endpointUrl;
mod.@ssoSiteIdColumnValue.Value = @ssoSiteId;
mod.@ssoCertificateColumnValue.Value = @ssoCertificate;
mod.@ssoPasswordColumnValue.Value = @ssoPassword;
mod.@ssoIvColumnValue.Value = @ssoIv;
mod.@clientCertificateColumnValue.Value = @clientCertificate;
mod.@clientPasswordColumnValue.Value = @clientPassword;
mod.@clientIvColumnValue.Value = @clientIv;
mod.@ssoSendingPartyColumnValue.Value = @ssoSendingParty;
mod.@redirectToUrlColumnValue.Value = @redirectToUrl;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.VhrEnvironmentConfigurationsTableCondition> getConditionList( CommandConditions.VhrEnvironmentConfigurationsTableCondition requiredCondition, params CommandConditions.VhrEnvironmentConfigurationsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.VhrEnvironmentConfigurationsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @VhrEnvironmentConfigurationsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="vhrProviderId">Object does not allow null.</param>
/// <param name="vhrEnvironmentId">Object does not allow null.</param>
/// <param name="endpointUrl">Object does not allow null.</param>
/// <param name="ssoSiteId">Object does not allow null.</param>
/// <param name="ssoCertificate">Object allows null.</param>
/// <param name="ssoPassword">Object allows null.</param>
/// <param name="ssoIv">Object allows null.</param>
/// <param name="clientCertificate">Object allows null.</param>
/// <param name="clientPassword">Object allows null.</param>
/// <param name="clientIv">Object allows null.</param>
/// <param name="ssoSendingParty">Object does not allow null.</param>
/// <param name="redirectToUrl">Object does not allow null.</param>
public void SetAllData( int @vhrProviderId, int @vhrEnvironmentId, string @endpointUrl, string @ssoSiteId, System.Byte[] @ssoCertificate, System.Byte[] @ssoPassword, System.Byte[] @ssoIv, System.Byte[] @clientCertificate, System.Byte[] @clientPassword, System.Byte[] @clientIv, string @ssoSendingParty, string @redirectToUrl ) {
this.@vhrProviderIdColumnValue.Value = @vhrProviderId;
this.@vhrEnvironmentIdColumnValue.Value = @vhrEnvironmentId;
this.@endpointUrlColumnValue.Value = @endpointUrl;
this.@ssoSiteIdColumnValue.Value = @ssoSiteId;
this.@ssoCertificateColumnValue.Value = @ssoCertificate;
this.@ssoPasswordColumnValue.Value = @ssoPassword;
this.@ssoIvColumnValue.Value = @ssoIv;
this.@clientCertificateColumnValue.Value = @clientCertificate;
this.@clientPasswordColumnValue.Value = @clientPassword;
this.@clientIvColumnValue.Value = @clientIv;
this.@ssoSendingPartyColumnValue.Value = @ssoSendingParty;
this.@redirectToUrlColumnValue.Value = @redirectToUrl;
}
/// <summary>
/// Executes this VhrEnvironmentConfigurations modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this VhrEnvironmentConfigurations modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "VhrEnvironmentConfigurations" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.VhrEnvironmentConfigurationsTableCondition>();
conditions.Add( new CommandConditions.@VhrEnvironmentConfigurationsTableEqualityConditions.@VhrProviderId( @VhrProviderId ) );
conditions.Add( new CommandConditions.@VhrEnvironmentConfigurationsTableEqualityConditions.@VhrEnvironmentId( @VhrEnvironmentId ) );
}
else {
var update = new InlineUpdate( "VhrEnvironmentConfigurations" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @vhrProviderIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "VhrProviderId", new DbParameterValue( @VhrProviderId, "Int" ) ) );
if( @vhrEnvironmentIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "VhrEnvironmentId", new DbParameterValue( @VhrEnvironmentId, "Int" ) ) );
if( @endpointUrlColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EndpointUrl", new DbParameterValue( @EndpointUrl, "NVarChar" ) ) );
if( @ssoSiteIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "SsoSiteId", new DbParameterValue( @SsoSiteId, "NVarChar" ) ) );
if( @ssoCertificateColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "SsoCertificate", new DbParameterValue( @SsoCertificate, "VarBinary" ) ) );
if( @ssoPasswordColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "SsoPassword", new DbParameterValue( @SsoPassword, "VarBinary" ) ) );
if( @ssoIvColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "SsoIv", new DbParameterValue( @SsoIv, "Binary" ) ) );
if( @clientCertificateColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ClientCertificate", new DbParameterValue( @ClientCertificate, "VarBinary" ) ) );
if( @clientPasswordColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ClientPassword", new DbParameterValue( @ClientPassword, "VarBinary" ) ) );
if( @clientIvColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ClientIv", new DbParameterValue( @ClientIv, "Binary" ) ) );
if( @ssoSendingPartyColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "SsoSendingParty", new DbParameterValue( @SsoSendingParty, "NVarChar" ) ) );
if( @redirectToUrlColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "RedirectToUrl", new DbParameterValue( @RedirectToUrl, "NVarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@vhrProviderIdColumnValue.ClearChanged();
@vhrEnvironmentIdColumnValue.ClearChanged();
@endpointUrlColumnValue.ClearChanged();
@ssoSiteIdColumnValue.ClearChanged();
@ssoCertificateColumnValue.ClearChanged();
@ssoPasswordColumnValue.ClearChanged();
@ssoIvColumnValue.ClearChanged();
@clientCertificateColumnValue.ClearChanged();
@clientPasswordColumnValue.ClearChanged();
@clientIvColumnValue.ClearChanged();
@ssoSendingPartyColumnValue.ClearChanged();
@redirectToUrlColumnValue.ClearChanged();
}
}
public partial class @VhrEnvironmentsModification {
/// <summary>
/// Inserts a row into the VhrEnvironments table.
/// </summary>
/// <param name="vhrEnvironmentId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
public static void InsertRow( int @vhrEnvironmentId, string @name ) { 
var mod = CreateForInsert();
mod.@vhrEnvironmentIdColumnValue.Value = @vhrEnvironmentId;
mod.@nameColumnValue.Value = @name;
mod.Execute();
}
/// <summary>
/// Inserts a row into the VhrEnvironments table.
/// </summary>
/// <param name="vhrEnvironmentId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @vhrEnvironmentId, string @name ) { 
var mod = CreateForInsert();
mod.@vhrEnvironmentIdColumnValue.Value = @vhrEnvironmentId;
mod.@nameColumnValue.Value = @name;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the VhrEnvironments table that match the specified conditions with the specified data.
/// </summary>
/// <param name="vhrEnvironmentId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @vhrEnvironmentId, string @name, CommandConditions.VhrEnvironmentsTableCondition requiredCondition, params CommandConditions.VhrEnvironmentsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@vhrEnvironmentIdColumnValue.Value = @vhrEnvironmentId;
mod.@nameColumnValue.Value = @name;
mod.Execute();
}
/// <summary>
/// Updates rows in the VhrEnvironments table that match the specified conditions with the specified data.
/// </summary>
/// <param name="vhrEnvironmentId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @vhrEnvironmentId, string @name, CommandConditions.VhrEnvironmentsTableCondition requiredCondition, params CommandConditions.VhrEnvironmentsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@vhrEnvironmentIdColumnValue.Value = @vhrEnvironmentId;
mod.@nameColumnValue.Value = @name;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.VhrEnvironmentsTableCondition requiredCondition, params CommandConditions.VhrEnvironmentsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@VhrEnvironmentsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.VhrEnvironmentsTableCondition requiredCondition, params CommandConditions.VhrEnvironmentsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.VhrEnvironmentsTableCondition> conditions ) {
var delete = new InlineDelete( "VhrEnvironments" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.VhrEnvironmentsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@VhrEnvironmentsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.VhrEnvironmentsTableCondition> conditions;
private readonly DataValue<int> @vhrEnvironmentIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the VhrEnvironmentId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @VhrEnvironmentId { get { return @vhrEnvironmentIdColumnValue.Value; } set { @vhrEnvironmentIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the VhrEnvironmentId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @VhrEnvironmentIdHasChanged { get { return @vhrEnvironmentIdColumnValue.Changed; } }
private readonly DataValue<string> @nameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Name column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Name { get { return @nameColumnValue.Value; } set { @nameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Name has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @NameHasChanged { get { return @nameColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the VhrEnvironments table.
/// </summary>
public static @VhrEnvironmentsModification CreateForInsert() {
return new @VhrEnvironmentsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the VhrEnvironments table.
/// </summary>
public static @VhrEnvironmentsModification CreateForUpdate( CommandConditions.VhrEnvironmentsTableCondition requiredCondition, params CommandConditions.VhrEnvironmentsTableCondition[] additionalConditions ) {
var mod = new @VhrEnvironmentsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@VhrEnvironmentsTableEqualityConditions.@VhrEnvironmentId )
mod.@vhrEnvironmentIdColumnValue.Value = ( condition as CommandConditions.@VhrEnvironmentsTableEqualityConditions.@VhrEnvironmentId ).Value;
else if( condition is CommandConditions.@VhrEnvironmentsTableEqualityConditions.@Name )
mod.@nameColumnValue.Value = ( condition as CommandConditions.@VhrEnvironmentsTableEqualityConditions.@Name ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the VhrEnvironments table.
/// </summary>
public static @VhrEnvironmentsModification CreateForSingleRowUpdate( int @vhrEnvironmentId, string @name ) {
var mod = new @VhrEnvironmentsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.VhrEnvironmentsTableCondition>();
mod.conditions.Add( new CommandConditions.@VhrEnvironmentsTableEqualityConditions.@VhrEnvironmentId( @vhrEnvironmentId ) );
mod.@vhrEnvironmentIdColumnValue.Value = @vhrEnvironmentId;
mod.@nameColumnValue.Value = @name;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.VhrEnvironmentsTableCondition> getConditionList( CommandConditions.VhrEnvironmentsTableCondition requiredCondition, params CommandConditions.VhrEnvironmentsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.VhrEnvironmentsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @VhrEnvironmentsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="vhrEnvironmentId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
public void SetAllData( int @vhrEnvironmentId, string @name ) {
this.@vhrEnvironmentIdColumnValue.Value = @vhrEnvironmentId;
this.@nameColumnValue.Value = @name;
}
/// <summary>
/// Executes this VhrEnvironments modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this VhrEnvironments modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "VhrEnvironments" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.VhrEnvironmentsTableCondition>();
conditions.Add( new CommandConditions.@VhrEnvironmentsTableEqualityConditions.@VhrEnvironmentId( @VhrEnvironmentId ) );
}
else {
var update = new InlineUpdate( "VhrEnvironments" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @vhrEnvironmentIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "VhrEnvironmentId", new DbParameterValue( @VhrEnvironmentId, "Int" ) ) );
if( @nameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Name", new DbParameterValue( @Name, "NVarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@vhrEnvironmentIdColumnValue.ClearChanged();
@nameColumnValue.ClearChanged();
}
}
public partial class @VhrProfilesModification {
/// <summary>
/// Inserts a row into the VhrProfiles table.
/// </summary>
/// <param name="vhrProfileId">Object does not allow null.</param>
/// <param name="vhrUserName">Object does not allow null.</param>
/// <param name="description">Object does not allow null.</param>
/// <param name="deleted">Object does not allow null.</param>
/// <param name="vhrProviderId">Object does not allow null.</param>
/// <param name="disabled">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="vhrEnvironmentId">Object does not allow null.</param>
public static void InsertRow( int @vhrProfileId, string @vhrUserName, string @description, System.Boolean @deleted, int @vhrProviderId, System.Boolean @disabled, int @userId, int @vhrEnvironmentId ) { 
var mod = CreateForInsert();
mod.@vhrProfileIdColumnValue.Value = @vhrProfileId;
mod.@vhrUserNameColumnValue.Value = @vhrUserName;
mod.@descriptionColumnValue.Value = @description;
mod.@deletedColumnValue.Value = @deleted;
mod.@vhrProviderIdColumnValue.Value = @vhrProviderId;
mod.@disabledColumnValue.Value = @disabled;
mod.@userIdColumnValue.Value = @userId;
mod.@vhrEnvironmentIdColumnValue.Value = @vhrEnvironmentId;
mod.Execute();
}
/// <summary>
/// Inserts a row into the VhrProfiles table.
/// </summary>
/// <param name="vhrProfileId">Object does not allow null.</param>
/// <param name="vhrUserName">Object does not allow null.</param>
/// <param name="description">Object does not allow null.</param>
/// <param name="deleted">Object does not allow null.</param>
/// <param name="vhrProviderId">Object does not allow null.</param>
/// <param name="disabled">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="vhrEnvironmentId">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @vhrProfileId, string @vhrUserName, string @description, System.Boolean @deleted, int @vhrProviderId, System.Boolean @disabled, int @userId, int @vhrEnvironmentId ) { 
var mod = CreateForInsert();
mod.@vhrProfileIdColumnValue.Value = @vhrProfileId;
mod.@vhrUserNameColumnValue.Value = @vhrUserName;
mod.@descriptionColumnValue.Value = @description;
mod.@deletedColumnValue.Value = @deleted;
mod.@vhrProviderIdColumnValue.Value = @vhrProviderId;
mod.@disabledColumnValue.Value = @disabled;
mod.@userIdColumnValue.Value = @userId;
mod.@vhrEnvironmentIdColumnValue.Value = @vhrEnvironmentId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the VhrProfiles table that match the specified conditions with the specified data.
/// </summary>
/// <param name="vhrProfileId">Object does not allow null.</param>
/// <param name="vhrUserName">Object does not allow null.</param>
/// <param name="description">Object does not allow null.</param>
/// <param name="deleted">Object does not allow null.</param>
/// <param name="vhrProviderId">Object does not allow null.</param>
/// <param name="disabled">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="vhrEnvironmentId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @vhrProfileId, string @vhrUserName, string @description, System.Boolean @deleted, int @vhrProviderId, System.Boolean @disabled, int @userId, int @vhrEnvironmentId, CommandConditions.VhrProfilesTableCondition requiredCondition, params CommandConditions.VhrProfilesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@vhrProfileIdColumnValue.Value = @vhrProfileId;
mod.@vhrUserNameColumnValue.Value = @vhrUserName;
mod.@descriptionColumnValue.Value = @description;
mod.@deletedColumnValue.Value = @deleted;
mod.@vhrProviderIdColumnValue.Value = @vhrProviderId;
mod.@disabledColumnValue.Value = @disabled;
mod.@userIdColumnValue.Value = @userId;
mod.@vhrEnvironmentIdColumnValue.Value = @vhrEnvironmentId;
mod.Execute();
}
/// <summary>
/// Updates rows in the VhrProfiles table that match the specified conditions with the specified data.
/// </summary>
/// <param name="vhrProfileId">Object does not allow null.</param>
/// <param name="vhrUserName">Object does not allow null.</param>
/// <param name="description">Object does not allow null.</param>
/// <param name="deleted">Object does not allow null.</param>
/// <param name="vhrProviderId">Object does not allow null.</param>
/// <param name="disabled">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="vhrEnvironmentId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @vhrProfileId, string @vhrUserName, string @description, System.Boolean @deleted, int @vhrProviderId, System.Boolean @disabled, int @userId, int @vhrEnvironmentId, CommandConditions.VhrProfilesTableCondition requiredCondition, params CommandConditions.VhrProfilesTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@vhrProfileIdColumnValue.Value = @vhrProfileId;
mod.@vhrUserNameColumnValue.Value = @vhrUserName;
mod.@descriptionColumnValue.Value = @description;
mod.@deletedColumnValue.Value = @deleted;
mod.@vhrProviderIdColumnValue.Value = @vhrProviderId;
mod.@disabledColumnValue.Value = @disabled;
mod.@userIdColumnValue.Value = @userId;
mod.@vhrEnvironmentIdColumnValue.Value = @vhrEnvironmentId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.VhrProfilesTableCondition requiredCondition, params CommandConditions.VhrProfilesTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@VhrProfilesTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.VhrProfilesTableCondition requiredCondition, params CommandConditions.VhrProfilesTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.VhrProfilesTableCondition> conditions ) {
var delete = new InlineDelete( "VhrProfiles" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.VhrProfilesTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@VhrProfilesTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.VhrProfilesTableCondition> conditions;
private readonly DataValue<int> @vhrProfileIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the VhrProfileId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @VhrProfileId { get { return @vhrProfileIdColumnValue.Value; } set { @vhrProfileIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the VhrProfileId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @VhrProfileIdHasChanged { get { return @vhrProfileIdColumnValue.Changed; } }
private readonly DataValue<string> @vhrUserNameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the VhrUserName column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @VhrUserName { get { return @vhrUserNameColumnValue.Value; } set { @vhrUserNameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the VhrUserName has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @VhrUserNameHasChanged { get { return @vhrUserNameColumnValue.Changed; } }
private readonly DataValue<string> @descriptionColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Description column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Description { get { return @descriptionColumnValue.Value; } set { @descriptionColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Description has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @DescriptionHasChanged { get { return @descriptionColumnValue.Changed; } }
private readonly DataValue<System.Boolean> @deletedColumnValue = new DataValue<System.Boolean>();
/// <summary>
/// Gets or sets the value for the Deleted column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Boolean @Deleted { get { return @deletedColumnValue.Value; } set { @deletedColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Deleted has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @DeletedHasChanged { get { return @deletedColumnValue.Changed; } }
private readonly DataValue<int> @vhrProviderIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the VhrProviderId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @VhrProviderId { get { return @vhrProviderIdColumnValue.Value; } set { @vhrProviderIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the VhrProviderId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @VhrProviderIdHasChanged { get { return @vhrProviderIdColumnValue.Changed; } }
private readonly DataValue<System.Boolean> @disabledColumnValue = new DataValue<System.Boolean>();
/// <summary>
/// Gets or sets the value for the Disabled column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Boolean @Disabled { get { return @disabledColumnValue.Value; } set { @disabledColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Disabled has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @DisabledHasChanged { get { return @disabledColumnValue.Changed; } }
private readonly DataValue<int> @userIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the UserId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @UserId { get { return @userIdColumnValue.Value; } set { @userIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the UserId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @UserIdHasChanged { get { return @userIdColumnValue.Changed; } }
private readonly DataValue<int> @vhrEnvironmentIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the VhrEnvironmentId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @VhrEnvironmentId { get { return @vhrEnvironmentIdColumnValue.Value; } set { @vhrEnvironmentIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the VhrEnvironmentId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @VhrEnvironmentIdHasChanged { get { return @vhrEnvironmentIdColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the VhrProfiles table.
/// </summary>
public static @VhrProfilesModification CreateForInsert() {
return new @VhrProfilesModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the VhrProfiles table.
/// </summary>
public static @VhrProfilesModification CreateForUpdate( CommandConditions.VhrProfilesTableCondition requiredCondition, params CommandConditions.VhrProfilesTableCondition[] additionalConditions ) {
var mod = new @VhrProfilesModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@VhrProfilesTableEqualityConditions.@VhrProfileId )
mod.@vhrProfileIdColumnValue.Value = ( condition as CommandConditions.@VhrProfilesTableEqualityConditions.@VhrProfileId ).Value;
else if( condition is CommandConditions.@VhrProfilesTableEqualityConditions.@VhrUserName )
mod.@vhrUserNameColumnValue.Value = ( condition as CommandConditions.@VhrProfilesTableEqualityConditions.@VhrUserName ).Value;
else if( condition is CommandConditions.@VhrProfilesTableEqualityConditions.@Description )
mod.@descriptionColumnValue.Value = ( condition as CommandConditions.@VhrProfilesTableEqualityConditions.@Description ).Value;
else if( condition is CommandConditions.@VhrProfilesTableEqualityConditions.@Deleted )
mod.@deletedColumnValue.Value = ( condition as CommandConditions.@VhrProfilesTableEqualityConditions.@Deleted ).Value;
else if( condition is CommandConditions.@VhrProfilesTableEqualityConditions.@VhrProviderId )
mod.@vhrProviderIdColumnValue.Value = ( condition as CommandConditions.@VhrProfilesTableEqualityConditions.@VhrProviderId ).Value;
else if( condition is CommandConditions.@VhrProfilesTableEqualityConditions.@Disabled )
mod.@disabledColumnValue.Value = ( condition as CommandConditions.@VhrProfilesTableEqualityConditions.@Disabled ).Value;
else if( condition is CommandConditions.@VhrProfilesTableEqualityConditions.@UserId )
mod.@userIdColumnValue.Value = ( condition as CommandConditions.@VhrProfilesTableEqualityConditions.@UserId ).Value;
else if( condition is CommandConditions.@VhrProfilesTableEqualityConditions.@VhrEnvironmentId )
mod.@vhrEnvironmentIdColumnValue.Value = ( condition as CommandConditions.@VhrProfilesTableEqualityConditions.@VhrEnvironmentId ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the VhrProfiles table.
/// </summary>
public static @VhrProfilesModification CreateForSingleRowUpdate( int @vhrProfileId, string @vhrUserName, string @description, System.Boolean @deleted, int @vhrProviderId, System.Boolean @disabled, int @userId, int @vhrEnvironmentId ) {
var mod = new @VhrProfilesModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.VhrProfilesTableCondition>();
mod.conditions.Add( new CommandConditions.@VhrProfilesTableEqualityConditions.@VhrProfileId( @vhrProfileId ) );
mod.@vhrProfileIdColumnValue.Value = @vhrProfileId;
mod.@vhrUserNameColumnValue.Value = @vhrUserName;
mod.@descriptionColumnValue.Value = @description;
mod.@deletedColumnValue.Value = @deleted;
mod.@vhrProviderIdColumnValue.Value = @vhrProviderId;
mod.@disabledColumnValue.Value = @disabled;
mod.@userIdColumnValue.Value = @userId;
mod.@vhrEnvironmentIdColumnValue.Value = @vhrEnvironmentId;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.VhrProfilesTableCondition> getConditionList( CommandConditions.VhrProfilesTableCondition requiredCondition, params CommandConditions.VhrProfilesTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.VhrProfilesTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @VhrProfilesModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="vhrProfileId">Object does not allow null.</param>
/// <param name="vhrUserName">Object does not allow null.</param>
/// <param name="description">Object does not allow null.</param>
/// <param name="deleted">Object does not allow null.</param>
/// <param name="vhrProviderId">Object does not allow null.</param>
/// <param name="disabled">Object does not allow null.</param>
/// <param name="userId">Object does not allow null.</param>
/// <param name="vhrEnvironmentId">Object does not allow null.</param>
public void SetAllData( int @vhrProfileId, string @vhrUserName, string @description, System.Boolean @deleted, int @vhrProviderId, System.Boolean @disabled, int @userId, int @vhrEnvironmentId ) {
this.@vhrProfileIdColumnValue.Value = @vhrProfileId;
this.@vhrUserNameColumnValue.Value = @vhrUserName;
this.@descriptionColumnValue.Value = @description;
this.@deletedColumnValue.Value = @deleted;
this.@vhrProviderIdColumnValue.Value = @vhrProviderId;
this.@disabledColumnValue.Value = @disabled;
this.@userIdColumnValue.Value = @userId;
this.@vhrEnvironmentIdColumnValue.Value = @vhrEnvironmentId;
}
/// <summary>
/// Executes this VhrProfiles modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this VhrProfiles modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "VhrProfiles" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.VhrProfilesTableCondition>();
conditions.Add( new CommandConditions.@VhrProfilesTableEqualityConditions.@VhrProfileId( @VhrProfileId ) );
}
else {
var update = new InlineUpdate( "VhrProfiles" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @vhrProfileIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "VhrProfileId", new DbParameterValue( @VhrProfileId, "Int" ) ) );
if( @vhrUserNameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "VhrUserName", new DbParameterValue( @VhrUserName, "NVarChar" ) ) );
if( @descriptionColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Description", new DbParameterValue( @Description, "NVarChar" ) ) );
if( @deletedColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Deleted", new DbParameterValue( @Deleted, "Bit" ) ) );
if( @vhrProviderIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "VhrProviderId", new DbParameterValue( @VhrProviderId, "Int" ) ) );
if( @disabledColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Disabled", new DbParameterValue( @Disabled, "Bit" ) ) );
if( @userIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( @UserId, "Int" ) ) );
if( @vhrEnvironmentIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "VhrEnvironmentId", new DbParameterValue( @VhrEnvironmentId, "Int" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@vhrProfileIdColumnValue.ClearChanged();
@vhrUserNameColumnValue.ClearChanged();
@descriptionColumnValue.ClearChanged();
@deletedColumnValue.ClearChanged();
@vhrProviderIdColumnValue.ClearChanged();
@disabledColumnValue.ClearChanged();
@userIdColumnValue.ClearChanged();
@vhrEnvironmentIdColumnValue.ClearChanged();
}
}
public partial class @VhrProvidersModification {
/// <summary>
/// Inserts a row into the VhrProviders table.
/// </summary>
/// <param name="vhrProviderId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="isVhr">Object does not allow null.</param>
/// <param name="archived">Object does not allow null.</param>
public static void InsertRow( int @vhrProviderId, string @name, System.Boolean @isVhr, System.Boolean @archived ) { 
var mod = CreateForInsert();
mod.@vhrProviderIdColumnValue.Value = @vhrProviderId;
mod.@nameColumnValue.Value = @name;
mod.@isVhrColumnValue.Value = @isVhr;
mod.@archivedColumnValue.Value = @archived;
mod.Execute();
}
/// <summary>
/// Inserts a row into the VhrProviders table.
/// </summary>
/// <param name="vhrProviderId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="isVhr">Object does not allow null.</param>
/// <param name="archived">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @vhrProviderId, string @name, System.Boolean @isVhr, System.Boolean @archived ) { 
var mod = CreateForInsert();
mod.@vhrProviderIdColumnValue.Value = @vhrProviderId;
mod.@nameColumnValue.Value = @name;
mod.@isVhrColumnValue.Value = @isVhr;
mod.@archivedColumnValue.Value = @archived;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the VhrProviders table that match the specified conditions with the specified data.
/// </summary>
/// <param name="vhrProviderId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="isVhr">Object does not allow null.</param>
/// <param name="archived">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @vhrProviderId, string @name, System.Boolean @isVhr, System.Boolean @archived, CommandConditions.VhrProvidersTableCondition requiredCondition, params CommandConditions.VhrProvidersTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@vhrProviderIdColumnValue.Value = @vhrProviderId;
mod.@nameColumnValue.Value = @name;
mod.@isVhrColumnValue.Value = @isVhr;
mod.@archivedColumnValue.Value = @archived;
mod.Execute();
}
/// <summary>
/// Updates rows in the VhrProviders table that match the specified conditions with the specified data.
/// </summary>
/// <param name="vhrProviderId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="isVhr">Object does not allow null.</param>
/// <param name="archived">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @vhrProviderId, string @name, System.Boolean @isVhr, System.Boolean @archived, CommandConditions.VhrProvidersTableCondition requiredCondition, params CommandConditions.VhrProvidersTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@vhrProviderIdColumnValue.Value = @vhrProviderId;
mod.@nameColumnValue.Value = @name;
mod.@isVhrColumnValue.Value = @isVhr;
mod.@archivedColumnValue.Value = @archived;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.VhrProvidersTableCondition requiredCondition, params CommandConditions.VhrProvidersTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@VhrProvidersTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.VhrProvidersTableCondition requiredCondition, params CommandConditions.VhrProvidersTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.VhrProvidersTableCondition> conditions ) {
var delete = new InlineDelete( "VhrProviders" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.VhrProvidersTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@VhrProvidersTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.VhrProvidersTableCondition> conditions;
private readonly DataValue<int> @vhrProviderIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the VhrProviderId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @VhrProviderId { get { return @vhrProviderIdColumnValue.Value; } set { @vhrProviderIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the VhrProviderId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @VhrProviderIdHasChanged { get { return @vhrProviderIdColumnValue.Changed; } }
private readonly DataValue<string> @nameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Name column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Name { get { return @nameColumnValue.Value; } set { @nameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Name has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @NameHasChanged { get { return @nameColumnValue.Changed; } }
private readonly DataValue<System.Boolean> @isVhrColumnValue = new DataValue<System.Boolean>();
/// <summary>
/// Gets or sets the value for the IsVhr column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Boolean @IsVhr { get { return @isVhrColumnValue.Value; } set { @isVhrColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the IsVhr has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @IsVhrHasChanged { get { return @isVhrColumnValue.Changed; } }
private readonly DataValue<System.Boolean> @archivedColumnValue = new DataValue<System.Boolean>();
/// <summary>
/// Gets or sets the value for the Archived column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Boolean @Archived { get { return @archivedColumnValue.Value; } set { @archivedColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Archived has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ArchivedHasChanged { get { return @archivedColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the VhrProviders table.
/// </summary>
public static @VhrProvidersModification CreateForInsert() {
return new @VhrProvidersModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the VhrProviders table.
/// </summary>
public static @VhrProvidersModification CreateForUpdate( CommandConditions.VhrProvidersTableCondition requiredCondition, params CommandConditions.VhrProvidersTableCondition[] additionalConditions ) {
var mod = new @VhrProvidersModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@VhrProvidersTableEqualityConditions.@VhrProviderId )
mod.@vhrProviderIdColumnValue.Value = ( condition as CommandConditions.@VhrProvidersTableEqualityConditions.@VhrProviderId ).Value;
else if( condition is CommandConditions.@VhrProvidersTableEqualityConditions.@Name )
mod.@nameColumnValue.Value = ( condition as CommandConditions.@VhrProvidersTableEqualityConditions.@Name ).Value;
else if( condition is CommandConditions.@VhrProvidersTableEqualityConditions.@IsVhr )
mod.@isVhrColumnValue.Value = ( condition as CommandConditions.@VhrProvidersTableEqualityConditions.@IsVhr ).Value;
else if( condition is CommandConditions.@VhrProvidersTableEqualityConditions.@Archived )
mod.@archivedColumnValue.Value = ( condition as CommandConditions.@VhrProvidersTableEqualityConditions.@Archived ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the VhrProviders table.
/// </summary>
public static @VhrProvidersModification CreateForSingleRowUpdate( int @vhrProviderId, string @name, System.Boolean @isVhr, System.Boolean @archived ) {
var mod = new @VhrProvidersModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.VhrProvidersTableCondition>();
mod.conditions.Add( new CommandConditions.@VhrProvidersTableEqualityConditions.@VhrProviderId( @vhrProviderId ) );
mod.@vhrProviderIdColumnValue.Value = @vhrProviderId;
mod.@nameColumnValue.Value = @name;
mod.@isVhrColumnValue.Value = @isVhr;
mod.@archivedColumnValue.Value = @archived;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.VhrProvidersTableCondition> getConditionList( CommandConditions.VhrProvidersTableCondition requiredCondition, params CommandConditions.VhrProvidersTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.VhrProvidersTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @VhrProvidersModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="vhrProviderId">Object does not allow null.</param>
/// <param name="name">Object does not allow null.</param>
/// <param name="isVhr">Object does not allow null.</param>
/// <param name="archived">Object does not allow null.</param>
public void SetAllData( int @vhrProviderId, string @name, System.Boolean @isVhr, System.Boolean @archived ) {
this.@vhrProviderIdColumnValue.Value = @vhrProviderId;
this.@nameColumnValue.Value = @name;
this.@isVhrColumnValue.Value = @isVhr;
this.@archivedColumnValue.Value = @archived;
}
/// <summary>
/// Executes this VhrProviders modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this VhrProviders modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "VhrProviders" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.VhrProvidersTableCondition>();
conditions.Add( new CommandConditions.@VhrProvidersTableEqualityConditions.@VhrProviderId( @VhrProviderId ) );
}
else {
var update = new InlineUpdate( "VhrProviders" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @vhrProviderIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "VhrProviderId", new DbParameterValue( @VhrProviderId, "Int" ) ) );
if( @nameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Name", new DbParameterValue( @Name, "VarChar" ) ) );
if( @isVhrColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "IsVhr", new DbParameterValue( @IsVhr, "Bit" ) ) );
if( @archivedColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Archived", new DbParameterValue( @Archived, "Bit" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@vhrProviderIdColumnValue.ClearChanged();
@nameColumnValue.ClearChanged();
@isVhrColumnValue.ClearChanged();
@archivedColumnValue.ClearChanged();
}
}
public partial class @VitalsDataSourceModification {
/// <summary>
/// Inserts a row into the VitalsDataSource table. Returns the value of the Id column.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="isAutoSyncEnabled">Object does not allow null.</param>
/// <param name="lastSyncTime">Object allows null.</param>
/// <param name="isEnrollable">Object does not allow null.</param>
/// <param name="allowsMultipleEnrollments">Object does not allow null.</param>
/// <param name="displayOrder">Object does not allow null.</param>
/// <param name="connectCredentialsFormPath">Object does not allow null.</param>
/// <param name="internalIdentifier">Object does not allow null.</param>
/// <param name="vitalsRecordOrderDescription">Object does not allow null.</param>
public static int InsertRow( string @name, System.Boolean @isAutoSyncEnabled, System.DateTime? @lastSyncTime, System.Boolean @isEnrollable, System.Boolean @allowsMultipleEnrollments, int @displayOrder, string @connectCredentialsFormPath, string @internalIdentifier, string @vitalsRecordOrderDescription ) { 
var mod = CreateForInsert();
mod.@nameColumnValue.Value = @name;
mod.@isAutoSyncEnabledColumnValue.Value = @isAutoSyncEnabled;
mod.@lastSyncTimeColumnValue.Value = @lastSyncTime;
mod.@isEnrollableColumnValue.Value = @isEnrollable;
mod.@allowsMultipleEnrollmentsColumnValue.Value = @allowsMultipleEnrollments;
mod.@displayOrderColumnValue.Value = @displayOrder;
mod.@connectCredentialsFormPathColumnValue.Value = @connectCredentialsFormPath;
mod.@internalIdentifierColumnValue.Value = @internalIdentifier;
mod.@vitalsRecordOrderDescriptionColumnValue.Value = @vitalsRecordOrderDescription;
mod.Execute();
return mod.Id;
}
/// <summary>
/// Inserts a row into the VitalsDataSource table. Returns the value of the Id column.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="isAutoSyncEnabled">Object does not allow null.</param>
/// <param name="lastSyncTime">Object allows null.</param>
/// <param name="isEnrollable">Object does not allow null.</param>
/// <param name="allowsMultipleEnrollments">Object does not allow null.</param>
/// <param name="displayOrder">Object does not allow null.</param>
/// <param name="connectCredentialsFormPath">Object does not allow null.</param>
/// <param name="internalIdentifier">Object does not allow null.</param>
/// <param name="vitalsRecordOrderDescription">Object does not allow null.</param>
public static int InsertRowWithoutAdditionalLogic( string @name, System.Boolean @isAutoSyncEnabled, System.DateTime? @lastSyncTime, System.Boolean @isEnrollable, System.Boolean @allowsMultipleEnrollments, int @displayOrder, string @connectCredentialsFormPath, string @internalIdentifier, string @vitalsRecordOrderDescription ) { 
var mod = CreateForInsert();
mod.@nameColumnValue.Value = @name;
mod.@isAutoSyncEnabledColumnValue.Value = @isAutoSyncEnabled;
mod.@lastSyncTimeColumnValue.Value = @lastSyncTime;
mod.@isEnrollableColumnValue.Value = @isEnrollable;
mod.@allowsMultipleEnrollmentsColumnValue.Value = @allowsMultipleEnrollments;
mod.@displayOrderColumnValue.Value = @displayOrder;
mod.@connectCredentialsFormPathColumnValue.Value = @connectCredentialsFormPath;
mod.@internalIdentifierColumnValue.Value = @internalIdentifier;
mod.@vitalsRecordOrderDescriptionColumnValue.Value = @vitalsRecordOrderDescription;
mod.ExecuteWithoutAdditionalLogic();
return mod.Id;
}
/// <summary>
/// Updates rows in the VitalsDataSource table that match the specified conditions with the specified data.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="isAutoSyncEnabled">Object does not allow null.</param>
/// <param name="lastSyncTime">Object allows null.</param>
/// <param name="isEnrollable">Object does not allow null.</param>
/// <param name="allowsMultipleEnrollments">Object does not allow null.</param>
/// <param name="displayOrder">Object does not allow null.</param>
/// <param name="connectCredentialsFormPath">Object does not allow null.</param>
/// <param name="internalIdentifier">Object does not allow null.</param>
/// <param name="vitalsRecordOrderDescription">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( string @name, System.Boolean @isAutoSyncEnabled, System.DateTime? @lastSyncTime, System.Boolean @isEnrollable, System.Boolean @allowsMultipleEnrollments, int @displayOrder, string @connectCredentialsFormPath, string @internalIdentifier, string @vitalsRecordOrderDescription, CommandConditions.VitalsDataSourceTableCondition requiredCondition, params CommandConditions.VitalsDataSourceTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@nameColumnValue.Value = @name;
mod.@isAutoSyncEnabledColumnValue.Value = @isAutoSyncEnabled;
mod.@lastSyncTimeColumnValue.Value = @lastSyncTime;
mod.@isEnrollableColumnValue.Value = @isEnrollable;
mod.@allowsMultipleEnrollmentsColumnValue.Value = @allowsMultipleEnrollments;
mod.@displayOrderColumnValue.Value = @displayOrder;
mod.@connectCredentialsFormPathColumnValue.Value = @connectCredentialsFormPath;
mod.@internalIdentifierColumnValue.Value = @internalIdentifier;
mod.@vitalsRecordOrderDescriptionColumnValue.Value = @vitalsRecordOrderDescription;
mod.Execute();
}
/// <summary>
/// Updates rows in the VitalsDataSource table that match the specified conditions with the specified data.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="isAutoSyncEnabled">Object does not allow null.</param>
/// <param name="lastSyncTime">Object allows null.</param>
/// <param name="isEnrollable">Object does not allow null.</param>
/// <param name="allowsMultipleEnrollments">Object does not allow null.</param>
/// <param name="displayOrder">Object does not allow null.</param>
/// <param name="connectCredentialsFormPath">Object does not allow null.</param>
/// <param name="internalIdentifier">Object does not allow null.</param>
/// <param name="vitalsRecordOrderDescription">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( string @name, System.Boolean @isAutoSyncEnabled, System.DateTime? @lastSyncTime, System.Boolean @isEnrollable, System.Boolean @allowsMultipleEnrollments, int @displayOrder, string @connectCredentialsFormPath, string @internalIdentifier, string @vitalsRecordOrderDescription, CommandConditions.VitalsDataSourceTableCondition requiredCondition, params CommandConditions.VitalsDataSourceTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@nameColumnValue.Value = @name;
mod.@isAutoSyncEnabledColumnValue.Value = @isAutoSyncEnabled;
mod.@lastSyncTimeColumnValue.Value = @lastSyncTime;
mod.@isEnrollableColumnValue.Value = @isEnrollable;
mod.@allowsMultipleEnrollmentsColumnValue.Value = @allowsMultipleEnrollments;
mod.@displayOrderColumnValue.Value = @displayOrder;
mod.@connectCredentialsFormPathColumnValue.Value = @connectCredentialsFormPath;
mod.@internalIdentifierColumnValue.Value = @internalIdentifier;
mod.@vitalsRecordOrderDescriptionColumnValue.Value = @vitalsRecordOrderDescription;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.VitalsDataSourceTableCondition requiredCondition, params CommandConditions.VitalsDataSourceTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@VitalsDataSourceTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.VitalsDataSourceTableCondition requiredCondition, params CommandConditions.VitalsDataSourceTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.VitalsDataSourceTableCondition> conditions ) {
var delete = new InlineDelete( "VitalsDataSource" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.VitalsDataSourceTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@VitalsDataSourceTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.VitalsDataSourceTableCondition> conditions;
private readonly DataValue<int> @idColumnValue = new DataValue<int>();
/// <summary>
/// Gets the value for the Id column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @Id { get { return @idColumnValue.Value; } }
private readonly DataValue<string> @nameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Name column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Name { get { return @nameColumnValue.Value; } set { @nameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Name has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @NameHasChanged { get { return @nameColumnValue.Changed; } }
private readonly DataValue<System.Boolean> @isAutoSyncEnabledColumnValue = new DataValue<System.Boolean>();
/// <summary>
/// Gets or sets the value for the IsAutoSyncEnabled column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Boolean @IsAutoSyncEnabled { get { return @isAutoSyncEnabledColumnValue.Value; } set { @isAutoSyncEnabledColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the IsAutoSyncEnabled has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @IsAutoSyncEnabledHasChanged { get { return @isAutoSyncEnabledColumnValue.Changed; } }
private readonly DataValue<System.DateTime?> @lastSyncTimeColumnValue = new DataValue<System.DateTime?>();
/// <summary>
/// Gets or sets the value for the LastSyncTime column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.DateTime? @LastSyncTime { get { return @lastSyncTimeColumnValue.Value; } set { @lastSyncTimeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LastSyncTime has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LastSyncTimeHasChanged { get { return @lastSyncTimeColumnValue.Changed; } }
private readonly DataValue<System.Boolean> @isEnrollableColumnValue = new DataValue<System.Boolean>();
/// <summary>
/// Gets or sets the value for the IsEnrollable column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Boolean @IsEnrollable { get { return @isEnrollableColumnValue.Value; } set { @isEnrollableColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the IsEnrollable has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @IsEnrollableHasChanged { get { return @isEnrollableColumnValue.Changed; } }
private readonly DataValue<System.Boolean> @allowsMultipleEnrollmentsColumnValue = new DataValue<System.Boolean>();
/// <summary>
/// Gets or sets the value for the AllowsMultipleEnrollments column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Boolean @AllowsMultipleEnrollments { get { return @allowsMultipleEnrollmentsColumnValue.Value; } set { @allowsMultipleEnrollmentsColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the AllowsMultipleEnrollments has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @AllowsMultipleEnrollmentsHasChanged { get { return @allowsMultipleEnrollmentsColumnValue.Changed; } }
private readonly DataValue<int> @displayOrderColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the DisplayOrder column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @DisplayOrder { get { return @displayOrderColumnValue.Value; } set { @displayOrderColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the DisplayOrder has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @DisplayOrderHasChanged { get { return @displayOrderColumnValue.Changed; } }
private readonly DataValue<string> @connectCredentialsFormPathColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the ConnectCredentialsFormPath column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @ConnectCredentialsFormPath { get { return @connectCredentialsFormPathColumnValue.Value; } set { @connectCredentialsFormPathColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ConnectCredentialsFormPath has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ConnectCredentialsFormPathHasChanged { get { return @connectCredentialsFormPathColumnValue.Changed; } }
private readonly DataValue<string> @internalIdentifierColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the InternalIdentifier column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @InternalIdentifier { get { return @internalIdentifierColumnValue.Value; } set { @internalIdentifierColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the InternalIdentifier has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @InternalIdentifierHasChanged { get { return @internalIdentifierColumnValue.Changed; } }
private readonly DataValue<string> @vitalsRecordOrderDescriptionColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the VitalsRecordOrderDescription column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @VitalsRecordOrderDescription { get { return @vitalsRecordOrderDescriptionColumnValue.Value; } set { @vitalsRecordOrderDescriptionColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the VitalsRecordOrderDescription has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @VitalsRecordOrderDescriptionHasChanged { get { return @vitalsRecordOrderDescriptionColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the VitalsDataSource table.
/// </summary>
public static @VitalsDataSourceModification CreateForInsert() {
return new @VitalsDataSourceModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the VitalsDataSource table.
/// </summary>
public static @VitalsDataSourceModification CreateForUpdate( CommandConditions.VitalsDataSourceTableCondition requiredCondition, params CommandConditions.VitalsDataSourceTableCondition[] additionalConditions ) {
var mod = new @VitalsDataSourceModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@VitalsDataSourceTableEqualityConditions.@Id )
mod.@idColumnValue.Value = ( condition as CommandConditions.@VitalsDataSourceTableEqualityConditions.@Id ).Value;
else if( condition is CommandConditions.@VitalsDataSourceTableEqualityConditions.@Name )
mod.@nameColumnValue.Value = ( condition as CommandConditions.@VitalsDataSourceTableEqualityConditions.@Name ).Value;
else if( condition is CommandConditions.@VitalsDataSourceTableEqualityConditions.@IsAutoSyncEnabled )
mod.@isAutoSyncEnabledColumnValue.Value = ( condition as CommandConditions.@VitalsDataSourceTableEqualityConditions.@IsAutoSyncEnabled ).Value;
else if( condition is CommandConditions.@VitalsDataSourceTableEqualityConditions.@LastSyncTime )
mod.@lastSyncTimeColumnValue.Value = ( condition as CommandConditions.@VitalsDataSourceTableEqualityConditions.@LastSyncTime ).Value;
else if( condition is CommandConditions.@VitalsDataSourceTableEqualityConditions.@IsEnrollable )
mod.@isEnrollableColumnValue.Value = ( condition as CommandConditions.@VitalsDataSourceTableEqualityConditions.@IsEnrollable ).Value;
else if( condition is CommandConditions.@VitalsDataSourceTableEqualityConditions.@AllowsMultipleEnrollments )
mod.@allowsMultipleEnrollmentsColumnValue.Value = ( condition as CommandConditions.@VitalsDataSourceTableEqualityConditions.@AllowsMultipleEnrollments ).Value;
else if( condition is CommandConditions.@VitalsDataSourceTableEqualityConditions.@DisplayOrder )
mod.@displayOrderColumnValue.Value = ( condition as CommandConditions.@VitalsDataSourceTableEqualityConditions.@DisplayOrder ).Value;
else if( condition is CommandConditions.@VitalsDataSourceTableEqualityConditions.@ConnectCredentialsFormPath )
mod.@connectCredentialsFormPathColumnValue.Value = ( condition as CommandConditions.@VitalsDataSourceTableEqualityConditions.@ConnectCredentialsFormPath ).Value;
else if( condition is CommandConditions.@VitalsDataSourceTableEqualityConditions.@InternalIdentifier )
mod.@internalIdentifierColumnValue.Value = ( condition as CommandConditions.@VitalsDataSourceTableEqualityConditions.@InternalIdentifier ).Value;
else if( condition is CommandConditions.@VitalsDataSourceTableEqualityConditions.@VitalsRecordOrderDescription )
mod.@vitalsRecordOrderDescriptionColumnValue.Value = ( condition as CommandConditions.@VitalsDataSourceTableEqualityConditions.@VitalsRecordOrderDescription ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the VitalsDataSource table.
/// </summary>
public static @VitalsDataSourceModification CreateForSingleRowUpdate( int @id, string @name, System.Boolean @isAutoSyncEnabled, System.DateTime? @lastSyncTime, System.Boolean @isEnrollable, System.Boolean @allowsMultipleEnrollments, int @displayOrder, string @connectCredentialsFormPath, string @internalIdentifier, string @vitalsRecordOrderDescription ) {
var mod = new @VitalsDataSourceModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.VitalsDataSourceTableCondition>();
mod.conditions.Add( new CommandConditions.@VitalsDataSourceTableEqualityConditions.@Id( @id ) );
mod.@idColumnValue.Value = @id;
mod.@nameColumnValue.Value = @name;
mod.@isAutoSyncEnabledColumnValue.Value = @isAutoSyncEnabled;
mod.@lastSyncTimeColumnValue.Value = @lastSyncTime;
mod.@isEnrollableColumnValue.Value = @isEnrollable;
mod.@allowsMultipleEnrollmentsColumnValue.Value = @allowsMultipleEnrollments;
mod.@displayOrderColumnValue.Value = @displayOrder;
mod.@connectCredentialsFormPathColumnValue.Value = @connectCredentialsFormPath;
mod.@internalIdentifierColumnValue.Value = @internalIdentifier;
mod.@vitalsRecordOrderDescriptionColumnValue.Value = @vitalsRecordOrderDescription;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.VitalsDataSourceTableCondition> getConditionList( CommandConditions.VitalsDataSourceTableCondition requiredCondition, params CommandConditions.VitalsDataSourceTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.VitalsDataSourceTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @VitalsDataSourceModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="isAutoSyncEnabled">Object does not allow null.</param>
/// <param name="lastSyncTime">Object allows null.</param>
/// <param name="isEnrollable">Object does not allow null.</param>
/// <param name="allowsMultipleEnrollments">Object does not allow null.</param>
/// <param name="displayOrder">Object does not allow null.</param>
/// <param name="connectCredentialsFormPath">Object does not allow null.</param>
/// <param name="internalIdentifier">Object does not allow null.</param>
/// <param name="vitalsRecordOrderDescription">Object does not allow null.</param>
public void SetAllData( string @name, System.Boolean @isAutoSyncEnabled, System.DateTime? @lastSyncTime, System.Boolean @isEnrollable, System.Boolean @allowsMultipleEnrollments, int @displayOrder, string @connectCredentialsFormPath, string @internalIdentifier, string @vitalsRecordOrderDescription ) {
this.@nameColumnValue.Value = @name;
this.@isAutoSyncEnabledColumnValue.Value = @isAutoSyncEnabled;
this.@lastSyncTimeColumnValue.Value = @lastSyncTime;
this.@isEnrollableColumnValue.Value = @isEnrollable;
this.@allowsMultipleEnrollmentsColumnValue.Value = @allowsMultipleEnrollments;
this.@displayOrderColumnValue.Value = @displayOrder;
this.@connectCredentialsFormPathColumnValue.Value = @connectCredentialsFormPath;
this.@internalIdentifierColumnValue.Value = @internalIdentifier;
this.@vitalsRecordOrderDescriptionColumnValue.Value = @vitalsRecordOrderDescription;
}
/// <summary>
/// Executes this VitalsDataSource modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this VitalsDataSource modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "VitalsDataSource" );
addColumnModifications( insert );
@idColumnValue.Value = (System.Int32)Utility.ChangeType( insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection ), typeof( System.Int32 ) );
modType = ModificationType.Update;
conditions = new List<CommandConditions.VitalsDataSourceTableCondition>();
conditions.Add( new CommandConditions.@VitalsDataSourceTableEqualityConditions.@Id( @Id ) );
}
else {
var update = new InlineUpdate( "VitalsDataSource" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @nameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Name", new DbParameterValue( @Name, "NVarChar" ) ) );
if( @isAutoSyncEnabledColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "IsAutoSyncEnabled", new DbParameterValue( @IsAutoSyncEnabled, "Bit" ) ) );
if( @lastSyncTimeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LastSyncTime", new DbParameterValue( @LastSyncTime, "DateTime" ) ) );
if( @isEnrollableColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "IsEnrollable", new DbParameterValue( @IsEnrollable, "Bit" ) ) );
if( @allowsMultipleEnrollmentsColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "AllowsMultipleEnrollments", new DbParameterValue( @AllowsMultipleEnrollments, "Bit" ) ) );
if( @displayOrderColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "DisplayOrder", new DbParameterValue( @DisplayOrder, "Int" ) ) );
if( @connectCredentialsFormPathColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ConnectCredentialsFormPath", new DbParameterValue( @ConnectCredentialsFormPath, "NVarChar" ) ) );
if( @internalIdentifierColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "InternalIdentifier", new DbParameterValue( @InternalIdentifier, "NVarChar" ) ) );
if( @vitalsRecordOrderDescriptionColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "VitalsRecordOrderDescription", new DbParameterValue( @VitalsRecordOrderDescription, "NVarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@idColumnValue.ClearChanged();
@nameColumnValue.ClearChanged();
@isAutoSyncEnabledColumnValue.ClearChanged();
@lastSyncTimeColumnValue.ClearChanged();
@isEnrollableColumnValue.ClearChanged();
@allowsMultipleEnrollmentsColumnValue.ClearChanged();
@displayOrderColumnValue.ClearChanged();
@connectCredentialsFormPathColumnValue.ClearChanged();
@internalIdentifierColumnValue.ClearChanged();
@vitalsRecordOrderDescriptionColumnValue.ClearChanged();
}
}
public partial class @VitalsEnrollmentModification {
/// <summary>
/// Inserts a row into the VitalsEnrollment table. Returns the value of the Id column.
/// </summary>
/// <param name="dataSourceId">Object does not allow null.</param>
/// <param name="encKV">Object does not allow null.</param>
/// <param name="encIV">Object does not allow null.</param>
/// <param name="patientUsername">Object does not allow null.</param>
/// <param name="enrollmentName">Object does not allow null.</param>
/// <param name="credentials">Object does not allow null.</param>
/// <param name="dataSourceUniqueId">Object does not allow null.</param>
public static int InsertRow( int @dataSourceId, string @encKV, System.Byte[] @encIV, string @patientUsername, string @enrollmentName, string @credentials, string @dataSourceUniqueId ) { 
var mod = CreateForInsert();
mod.@dataSourceIdColumnValue.Value = @dataSourceId;
mod.@encKVColumnValue.Value = @encKV;
mod.@encIVColumnValue.Value = @encIV;
mod.@patientUsernameColumnValue.Value = @patientUsername;
mod.@enrollmentNameColumnValue.Value = @enrollmentName;
mod.@credentialsColumnValue.Value = @credentials;
mod.@dataSourceUniqueIdColumnValue.Value = @dataSourceUniqueId;
mod.Execute();
return mod.Id;
}
/// <summary>
/// Inserts a row into the VitalsEnrollment table. Returns the value of the Id column.
/// </summary>
/// <param name="dataSourceId">Object does not allow null.</param>
/// <param name="encKV">Object does not allow null.</param>
/// <param name="encIV">Object does not allow null.</param>
/// <param name="patientUsername">Object does not allow null.</param>
/// <param name="enrollmentName">Object does not allow null.</param>
/// <param name="credentials">Object does not allow null.</param>
/// <param name="dataSourceUniqueId">Object does not allow null.</param>
public static int InsertRowWithoutAdditionalLogic( int @dataSourceId, string @encKV, System.Byte[] @encIV, string @patientUsername, string @enrollmentName, string @credentials, string @dataSourceUniqueId ) { 
var mod = CreateForInsert();
mod.@dataSourceIdColumnValue.Value = @dataSourceId;
mod.@encKVColumnValue.Value = @encKV;
mod.@encIVColumnValue.Value = @encIV;
mod.@patientUsernameColumnValue.Value = @patientUsername;
mod.@enrollmentNameColumnValue.Value = @enrollmentName;
mod.@credentialsColumnValue.Value = @credentials;
mod.@dataSourceUniqueIdColumnValue.Value = @dataSourceUniqueId;
mod.ExecuteWithoutAdditionalLogic();
return mod.Id;
}
/// <summary>
/// Updates rows in the VitalsEnrollment table that match the specified conditions with the specified data.
/// </summary>
/// <param name="dataSourceId">Object does not allow null.</param>
/// <param name="encKV">Object does not allow null.</param>
/// <param name="encIV">Object does not allow null.</param>
/// <param name="patientUsername">Object does not allow null.</param>
/// <param name="enrollmentName">Object does not allow null.</param>
/// <param name="credentials">Object does not allow null.</param>
/// <param name="dataSourceUniqueId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @dataSourceId, string @encKV, System.Byte[] @encIV, string @patientUsername, string @enrollmentName, string @credentials, string @dataSourceUniqueId, CommandConditions.VitalsEnrollmentTableCondition requiredCondition, params CommandConditions.VitalsEnrollmentTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@dataSourceIdColumnValue.Value = @dataSourceId;
mod.@encKVColumnValue.Value = @encKV;
mod.@encIVColumnValue.Value = @encIV;
mod.@patientUsernameColumnValue.Value = @patientUsername;
mod.@enrollmentNameColumnValue.Value = @enrollmentName;
mod.@credentialsColumnValue.Value = @credentials;
mod.@dataSourceUniqueIdColumnValue.Value = @dataSourceUniqueId;
mod.Execute();
}
/// <summary>
/// Updates rows in the VitalsEnrollment table that match the specified conditions with the specified data.
/// </summary>
/// <param name="dataSourceId">Object does not allow null.</param>
/// <param name="encKV">Object does not allow null.</param>
/// <param name="encIV">Object does not allow null.</param>
/// <param name="patientUsername">Object does not allow null.</param>
/// <param name="enrollmentName">Object does not allow null.</param>
/// <param name="credentials">Object does not allow null.</param>
/// <param name="dataSourceUniqueId">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @dataSourceId, string @encKV, System.Byte[] @encIV, string @patientUsername, string @enrollmentName, string @credentials, string @dataSourceUniqueId, CommandConditions.VitalsEnrollmentTableCondition requiredCondition, params CommandConditions.VitalsEnrollmentTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@dataSourceIdColumnValue.Value = @dataSourceId;
mod.@encKVColumnValue.Value = @encKV;
mod.@encIVColumnValue.Value = @encIV;
mod.@patientUsernameColumnValue.Value = @patientUsername;
mod.@enrollmentNameColumnValue.Value = @enrollmentName;
mod.@credentialsColumnValue.Value = @credentials;
mod.@dataSourceUniqueIdColumnValue.Value = @dataSourceUniqueId;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.VitalsEnrollmentTableCondition requiredCondition, params CommandConditions.VitalsEnrollmentTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@VitalsEnrollmentTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.VitalsEnrollmentTableCondition requiredCondition, params CommandConditions.VitalsEnrollmentTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.VitalsEnrollmentTableCondition> conditions ) {
var delete = new InlineDelete( "VitalsEnrollment" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.VitalsEnrollmentTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@VitalsEnrollmentTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.VitalsEnrollmentTableCondition> conditions;
private readonly DataValue<int> @idColumnValue = new DataValue<int>();
/// <summary>
/// Gets the value for the Id column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @Id { get { return @idColumnValue.Value; } }
private readonly DataValue<int> @dataSourceIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the DataSourceId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @DataSourceId { get { return @dataSourceIdColumnValue.Value; } set { @dataSourceIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the DataSourceId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @DataSourceIdHasChanged { get { return @dataSourceIdColumnValue.Changed; } }
private readonly DataValue<string> @encKVColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the EncKV column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @EncKV { get { return @encKVColumnValue.Value; } set { @encKVColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EncKV has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EncKVHasChanged { get { return @encKVColumnValue.Changed; } }
private readonly DataValue<System.Byte[]> @encIVColumnValue = new DataValue<System.Byte[]>();
/// <summary>
/// Gets or sets the value for the EncIV column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Byte[] @EncIV { get { return @encIVColumnValue.Value; } set { @encIVColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EncIV has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EncIVHasChanged { get { return @encIVColumnValue.Changed; } }
private readonly DataValue<string> @patientUsernameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the PatientUsername column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @PatientUsername { get { return @patientUsernameColumnValue.Value; } set { @patientUsernameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the PatientUsername has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @PatientUsernameHasChanged { get { return @patientUsernameColumnValue.Changed; } }
private readonly DataValue<string> @enrollmentNameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the EnrollmentName column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @EnrollmentName { get { return @enrollmentNameColumnValue.Value; } set { @enrollmentNameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EnrollmentName has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EnrollmentNameHasChanged { get { return @enrollmentNameColumnValue.Changed; } }
private readonly DataValue<string> @credentialsColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Credentials column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Credentials { get { return @credentialsColumnValue.Value; } set { @credentialsColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Credentials has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @CredentialsHasChanged { get { return @credentialsColumnValue.Changed; } }
private readonly DataValue<string> @dataSourceUniqueIdColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the DataSourceUniqueId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @DataSourceUniqueId { get { return @dataSourceUniqueIdColumnValue.Value; } set { @dataSourceUniqueIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the DataSourceUniqueId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @DataSourceUniqueIdHasChanged { get { return @dataSourceUniqueIdColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the VitalsEnrollment table.
/// </summary>
public static @VitalsEnrollmentModification CreateForInsert() {
return new @VitalsEnrollmentModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the VitalsEnrollment table.
/// </summary>
public static @VitalsEnrollmentModification CreateForUpdate( CommandConditions.VitalsEnrollmentTableCondition requiredCondition, params CommandConditions.VitalsEnrollmentTableCondition[] additionalConditions ) {
var mod = new @VitalsEnrollmentModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@VitalsEnrollmentTableEqualityConditions.@Id )
mod.@idColumnValue.Value = ( condition as CommandConditions.@VitalsEnrollmentTableEqualityConditions.@Id ).Value;
else if( condition is CommandConditions.@VitalsEnrollmentTableEqualityConditions.@DataSourceId )
mod.@dataSourceIdColumnValue.Value = ( condition as CommandConditions.@VitalsEnrollmentTableEqualityConditions.@DataSourceId ).Value;
else if( condition is CommandConditions.@VitalsEnrollmentTableEqualityConditions.@EncKV )
mod.@encKVColumnValue.Value = ( condition as CommandConditions.@VitalsEnrollmentTableEqualityConditions.@EncKV ).Value;
else if( condition is CommandConditions.@VitalsEnrollmentTableEqualityConditions.@EncIV )
mod.@encIVColumnValue.Value = ( condition as CommandConditions.@VitalsEnrollmentTableEqualityConditions.@EncIV ).Value;
else if( condition is CommandConditions.@VitalsEnrollmentTableEqualityConditions.@PatientUsername )
mod.@patientUsernameColumnValue.Value = ( condition as CommandConditions.@VitalsEnrollmentTableEqualityConditions.@PatientUsername ).Value;
else if( condition is CommandConditions.@VitalsEnrollmentTableEqualityConditions.@EnrollmentName )
mod.@enrollmentNameColumnValue.Value = ( condition as CommandConditions.@VitalsEnrollmentTableEqualityConditions.@EnrollmentName ).Value;
else if( condition is CommandConditions.@VitalsEnrollmentTableEqualityConditions.@Credentials )
mod.@credentialsColumnValue.Value = ( condition as CommandConditions.@VitalsEnrollmentTableEqualityConditions.@Credentials ).Value;
else if( condition is CommandConditions.@VitalsEnrollmentTableEqualityConditions.@DataSourceUniqueId )
mod.@dataSourceUniqueIdColumnValue.Value = ( condition as CommandConditions.@VitalsEnrollmentTableEqualityConditions.@DataSourceUniqueId ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the VitalsEnrollment table.
/// </summary>
public static @VitalsEnrollmentModification CreateForSingleRowUpdate( int @id, int @dataSourceId, string @encKV, System.Byte[] @encIV, string @patientUsername, string @enrollmentName, string @credentials, string @dataSourceUniqueId ) {
var mod = new @VitalsEnrollmentModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.VitalsEnrollmentTableCondition>();
mod.conditions.Add( new CommandConditions.@VitalsEnrollmentTableEqualityConditions.@Id( @id ) );
mod.@idColumnValue.Value = @id;
mod.@dataSourceIdColumnValue.Value = @dataSourceId;
mod.@encKVColumnValue.Value = @encKV;
mod.@encIVColumnValue.Value = @encIV;
mod.@patientUsernameColumnValue.Value = @patientUsername;
mod.@enrollmentNameColumnValue.Value = @enrollmentName;
mod.@credentialsColumnValue.Value = @credentials;
mod.@dataSourceUniqueIdColumnValue.Value = @dataSourceUniqueId;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.VitalsEnrollmentTableCondition> getConditionList( CommandConditions.VitalsEnrollmentTableCondition requiredCondition, params CommandConditions.VitalsEnrollmentTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.VitalsEnrollmentTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @VitalsEnrollmentModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="dataSourceId">Object does not allow null.</param>
/// <param name="encKV">Object does not allow null.</param>
/// <param name="encIV">Object does not allow null.</param>
/// <param name="patientUsername">Object does not allow null.</param>
/// <param name="enrollmentName">Object does not allow null.</param>
/// <param name="credentials">Object does not allow null.</param>
/// <param name="dataSourceUniqueId">Object does not allow null.</param>
public void SetAllData( int @dataSourceId, string @encKV, System.Byte[] @encIV, string @patientUsername, string @enrollmentName, string @credentials, string @dataSourceUniqueId ) {
this.@dataSourceIdColumnValue.Value = @dataSourceId;
this.@encKVColumnValue.Value = @encKV;
this.@encIVColumnValue.Value = @encIV;
this.@patientUsernameColumnValue.Value = @patientUsername;
this.@enrollmentNameColumnValue.Value = @enrollmentName;
this.@credentialsColumnValue.Value = @credentials;
this.@dataSourceUniqueIdColumnValue.Value = @dataSourceUniqueId;
}
/// <summary>
/// Executes this VitalsEnrollment modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this VitalsEnrollment modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "VitalsEnrollment" );
addColumnModifications( insert );
@idColumnValue.Value = (System.Int32)Utility.ChangeType( insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection ), typeof( System.Int32 ) );
modType = ModificationType.Update;
conditions = new List<CommandConditions.VitalsEnrollmentTableCondition>();
conditions.Add( new CommandConditions.@VitalsEnrollmentTableEqualityConditions.@Id( @Id ) );
}
else {
var update = new InlineUpdate( "VitalsEnrollment" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @dataSourceIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "DataSourceId", new DbParameterValue( @DataSourceId, "Int" ) ) );
if( @encKVColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EncKV", new DbParameterValue( @EncKV, "VarChar" ) ) );
if( @encIVColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EncIV", new DbParameterValue( @EncIV, "VarBinary" ) ) );
if( @patientUsernameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "PatientUsername", new DbParameterValue( @PatientUsername, "NVarChar" ) ) );
if( @enrollmentNameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EnrollmentName", new DbParameterValue( @EnrollmentName, "NVarChar" ) ) );
if( @credentialsColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Credentials", new DbParameterValue( @Credentials, "NVarChar" ) ) );
if( @dataSourceUniqueIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "DataSourceUniqueId", new DbParameterValue( @DataSourceUniqueId, "NVarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@idColumnValue.ClearChanged();
@dataSourceIdColumnValue.ClearChanged();
@encKVColumnValue.ClearChanged();
@encIVColumnValue.ClearChanged();
@patientUsernameColumnValue.ClearChanged();
@enrollmentNameColumnValue.ClearChanged();
@credentialsColumnValue.ClearChanged();
@dataSourceUniqueIdColumnValue.ClearChanged();
}
}
public partial class @VitalsEnrollmentEventsModification {
/// <summary>
/// Inserts a row into the VitalsEnrollmentEvents table. Returns the value of the VitalsEnrollmentEventId column.
/// </summary>
/// <param name="vitalsDataSourceId">Object does not allow null.</param>
/// <param name="enrolledDateTime">Object allows null.</param>
/// <param name="unenrolledDateTime">Object allows null.</param>
public static int InsertRow( int @vitalsDataSourceId, System.DateTime? @enrolledDateTime, System.DateTime? @unenrolledDateTime ) { 
var mod = CreateForInsert();
mod.@vitalsDataSourceIdColumnValue.Value = @vitalsDataSourceId;
mod.@enrolledDateTimeColumnValue.Value = @enrolledDateTime;
mod.@unenrolledDateTimeColumnValue.Value = @unenrolledDateTime;
mod.Execute();
return mod.VitalsEnrollmentEventId;
}
/// <summary>
/// Inserts a row into the VitalsEnrollmentEvents table. Returns the value of the VitalsEnrollmentEventId column.
/// </summary>
/// <param name="vitalsDataSourceId">Object does not allow null.</param>
/// <param name="enrolledDateTime">Object allows null.</param>
/// <param name="unenrolledDateTime">Object allows null.</param>
public static int InsertRowWithoutAdditionalLogic( int @vitalsDataSourceId, System.DateTime? @enrolledDateTime, System.DateTime? @unenrolledDateTime ) { 
var mod = CreateForInsert();
mod.@vitalsDataSourceIdColumnValue.Value = @vitalsDataSourceId;
mod.@enrolledDateTimeColumnValue.Value = @enrolledDateTime;
mod.@unenrolledDateTimeColumnValue.Value = @unenrolledDateTime;
mod.ExecuteWithoutAdditionalLogic();
return mod.VitalsEnrollmentEventId;
}
/// <summary>
/// Updates rows in the VitalsEnrollmentEvents table that match the specified conditions with the specified data.
/// </summary>
/// <param name="vitalsDataSourceId">Object does not allow null.</param>
/// <param name="enrolledDateTime">Object allows null.</param>
/// <param name="unenrolledDateTime">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @vitalsDataSourceId, System.DateTime? @enrolledDateTime, System.DateTime? @unenrolledDateTime, CommandConditions.VitalsEnrollmentEventsTableCondition requiredCondition, params CommandConditions.VitalsEnrollmentEventsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@vitalsDataSourceIdColumnValue.Value = @vitalsDataSourceId;
mod.@enrolledDateTimeColumnValue.Value = @enrolledDateTime;
mod.@unenrolledDateTimeColumnValue.Value = @unenrolledDateTime;
mod.Execute();
}
/// <summary>
/// Updates rows in the VitalsEnrollmentEvents table that match the specified conditions with the specified data.
/// </summary>
/// <param name="vitalsDataSourceId">Object does not allow null.</param>
/// <param name="enrolledDateTime">Object allows null.</param>
/// <param name="unenrolledDateTime">Object allows null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @vitalsDataSourceId, System.DateTime? @enrolledDateTime, System.DateTime? @unenrolledDateTime, CommandConditions.VitalsEnrollmentEventsTableCondition requiredCondition, params CommandConditions.VitalsEnrollmentEventsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@vitalsDataSourceIdColumnValue.Value = @vitalsDataSourceId;
mod.@enrolledDateTimeColumnValue.Value = @enrolledDateTime;
mod.@unenrolledDateTimeColumnValue.Value = @unenrolledDateTime;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.VitalsEnrollmentEventsTableCondition requiredCondition, params CommandConditions.VitalsEnrollmentEventsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@VitalsEnrollmentEventsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.VitalsEnrollmentEventsTableCondition requiredCondition, params CommandConditions.VitalsEnrollmentEventsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.VitalsEnrollmentEventsTableCondition> conditions ) {
var delete = new InlineDelete( "VitalsEnrollmentEvents" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.VitalsEnrollmentEventsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@VitalsEnrollmentEventsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.VitalsEnrollmentEventsTableCondition> conditions;
private readonly DataValue<int> @vitalsEnrollmentEventIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets the value for the VitalsEnrollmentEventId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @VitalsEnrollmentEventId { get { return @vitalsEnrollmentEventIdColumnValue.Value; } }
private readonly DataValue<int> @vitalsDataSourceIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the VitalsDataSourceId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @VitalsDataSourceId { get { return @vitalsDataSourceIdColumnValue.Value; } set { @vitalsDataSourceIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the VitalsDataSourceId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @VitalsDataSourceIdHasChanged { get { return @vitalsDataSourceIdColumnValue.Changed; } }
private readonly DataValue<System.DateTime?> @enrolledDateTimeColumnValue = new DataValue<System.DateTime?>();
/// <summary>
/// Gets or sets the value for the EnrolledDateTime column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.DateTime? @EnrolledDateTime { get { return @enrolledDateTimeColumnValue.Value; } set { @enrolledDateTimeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the EnrolledDateTime has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @EnrolledDateTimeHasChanged { get { return @enrolledDateTimeColumnValue.Changed; } }
private readonly DataValue<System.DateTime?> @unenrolledDateTimeColumnValue = new DataValue<System.DateTime?>();
/// <summary>
/// Gets or sets the value for the UnenrolledDateTime column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.DateTime? @UnenrolledDateTime { get { return @unenrolledDateTimeColumnValue.Value; } set { @unenrolledDateTimeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the UnenrolledDateTime has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @UnenrolledDateTimeHasChanged { get { return @unenrolledDateTimeColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the VitalsEnrollmentEvents table.
/// </summary>
public static @VitalsEnrollmentEventsModification CreateForInsert() {
return new @VitalsEnrollmentEventsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the VitalsEnrollmentEvents table.
/// </summary>
public static @VitalsEnrollmentEventsModification CreateForUpdate( CommandConditions.VitalsEnrollmentEventsTableCondition requiredCondition, params CommandConditions.VitalsEnrollmentEventsTableCondition[] additionalConditions ) {
var mod = new @VitalsEnrollmentEventsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@VitalsEnrollmentEventsTableEqualityConditions.@VitalsEnrollmentEventId )
mod.@vitalsEnrollmentEventIdColumnValue.Value = ( condition as CommandConditions.@VitalsEnrollmentEventsTableEqualityConditions.@VitalsEnrollmentEventId ).Value;
else if( condition is CommandConditions.@VitalsEnrollmentEventsTableEqualityConditions.@VitalsDataSourceId )
mod.@vitalsDataSourceIdColumnValue.Value = ( condition as CommandConditions.@VitalsEnrollmentEventsTableEqualityConditions.@VitalsDataSourceId ).Value;
else if( condition is CommandConditions.@VitalsEnrollmentEventsTableEqualityConditions.@EnrolledDateTime )
mod.@enrolledDateTimeColumnValue.Value = ( condition as CommandConditions.@VitalsEnrollmentEventsTableEqualityConditions.@EnrolledDateTime ).Value;
else if( condition is CommandConditions.@VitalsEnrollmentEventsTableEqualityConditions.@UnenrolledDateTime )
mod.@unenrolledDateTimeColumnValue.Value = ( condition as CommandConditions.@VitalsEnrollmentEventsTableEqualityConditions.@UnenrolledDateTime ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the VitalsEnrollmentEvents table.
/// </summary>
public static @VitalsEnrollmentEventsModification CreateForSingleRowUpdate( int @vitalsEnrollmentEventId, int @vitalsDataSourceId, System.DateTime? @enrolledDateTime, System.DateTime? @unenrolledDateTime ) {
var mod = new @VitalsEnrollmentEventsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.VitalsEnrollmentEventsTableCondition>();
mod.conditions.Add( new CommandConditions.@VitalsEnrollmentEventsTableEqualityConditions.@VitalsEnrollmentEventId( @vitalsEnrollmentEventId ) );
mod.@vitalsEnrollmentEventIdColumnValue.Value = @vitalsEnrollmentEventId;
mod.@vitalsDataSourceIdColumnValue.Value = @vitalsDataSourceId;
mod.@enrolledDateTimeColumnValue.Value = @enrolledDateTime;
mod.@unenrolledDateTimeColumnValue.Value = @unenrolledDateTime;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.VitalsEnrollmentEventsTableCondition> getConditionList( CommandConditions.VitalsEnrollmentEventsTableCondition requiredCondition, params CommandConditions.VitalsEnrollmentEventsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.VitalsEnrollmentEventsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @VitalsEnrollmentEventsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="vitalsDataSourceId">Object does not allow null.</param>
/// <param name="enrolledDateTime">Object allows null.</param>
/// <param name="unenrolledDateTime">Object allows null.</param>
public void SetAllData( int @vitalsDataSourceId, System.DateTime? @enrolledDateTime, System.DateTime? @unenrolledDateTime ) {
this.@vitalsDataSourceIdColumnValue.Value = @vitalsDataSourceId;
this.@enrolledDateTimeColumnValue.Value = @enrolledDateTime;
this.@unenrolledDateTimeColumnValue.Value = @unenrolledDateTime;
}
/// <summary>
/// Executes this VitalsEnrollmentEvents modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this VitalsEnrollmentEvents modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "VitalsEnrollmentEvents" );
addColumnModifications( insert );
@vitalsEnrollmentEventIdColumnValue.Value = (System.Int32)Utility.ChangeType( insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection ), typeof( System.Int32 ) );
modType = ModificationType.Update;
conditions = new List<CommandConditions.VitalsEnrollmentEventsTableCondition>();
conditions.Add( new CommandConditions.@VitalsEnrollmentEventsTableEqualityConditions.@VitalsEnrollmentEventId( @VitalsEnrollmentEventId ) );
}
else {
var update = new InlineUpdate( "VitalsEnrollmentEvents" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @vitalsDataSourceIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "VitalsDataSourceId", new DbParameterValue( @VitalsDataSourceId, "Int" ) ) );
if( @enrolledDateTimeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "EnrolledDateTime", new DbParameterValue( @EnrolledDateTime, "SmallDateTime" ) ) );
if( @unenrolledDateTimeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "UnenrolledDateTime", new DbParameterValue( @UnenrolledDateTime, "SmallDateTime" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@vitalsEnrollmentEventIdColumnValue.ClearChanged();
@vitalsDataSourceIdColumnValue.ClearChanged();
@enrolledDateTimeColumnValue.ClearChanged();
@unenrolledDateTimeColumnValue.ClearChanged();
}
}
public partial class @WorkgroupModification {
/// <summary>
/// Inserts a row into the Workgroup table. Returns the value of the WorkGroupID column.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="lastUpdated">Object allows null.</param>
/// <param name="created">Object allows null.</param>
/// <param name="healthPlanID">Object allows null.</param>
/// <param name="consentLevel">Object does not allow null.</param>
/// <param name="hidden">Object does not allow null.</param>
public static int InsertRow( string @name, System.DateTime? @lastUpdated, System.DateTime? @created, System.Int32? @healthPlanID, int @consentLevel, System.Boolean @hidden ) { 
var mod = CreateForInsert();
mod.@nameColumnValue.Value = @name;
mod.@lastUpdatedColumnValue.Value = @lastUpdated;
mod.@createdColumnValue.Value = @created;
mod.@healthPlanIDColumnValue.Value = @healthPlanID;
mod.@consentLevelColumnValue.Value = @consentLevel;
mod.@hiddenColumnValue.Value = @hidden;
mod.Execute();
return mod.WorkGroupID;
}
/// <summary>
/// Inserts a row into the Workgroup table. Returns the value of the WorkGroupID column.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="lastUpdated">Object allows null.</param>
/// <param name="created">Object allows null.</param>
/// <param name="healthPlanID">Object allows null.</param>
/// <param name="consentLevel">Object does not allow null.</param>
/// <param name="hidden">Object does not allow null.</param>
public static int InsertRowWithoutAdditionalLogic( string @name, System.DateTime? @lastUpdated, System.DateTime? @created, System.Int32? @healthPlanID, int @consentLevel, System.Boolean @hidden ) { 
var mod = CreateForInsert();
mod.@nameColumnValue.Value = @name;
mod.@lastUpdatedColumnValue.Value = @lastUpdated;
mod.@createdColumnValue.Value = @created;
mod.@healthPlanIDColumnValue.Value = @healthPlanID;
mod.@consentLevelColumnValue.Value = @consentLevel;
mod.@hiddenColumnValue.Value = @hidden;
mod.ExecuteWithoutAdditionalLogic();
return mod.WorkGroupID;
}
/// <summary>
/// Updates rows in the Workgroup table that match the specified conditions with the specified data.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="lastUpdated">Object allows null.</param>
/// <param name="created">Object allows null.</param>
/// <param name="healthPlanID">Object allows null.</param>
/// <param name="consentLevel">Object does not allow null.</param>
/// <param name="hidden">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( string @name, System.DateTime? @lastUpdated, System.DateTime? @created, System.Int32? @healthPlanID, int @consentLevel, System.Boolean @hidden, CommandConditions.WorkgroupTableCondition requiredCondition, params CommandConditions.WorkgroupTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@nameColumnValue.Value = @name;
mod.@lastUpdatedColumnValue.Value = @lastUpdated;
mod.@createdColumnValue.Value = @created;
mod.@healthPlanIDColumnValue.Value = @healthPlanID;
mod.@consentLevelColumnValue.Value = @consentLevel;
mod.@hiddenColumnValue.Value = @hidden;
mod.Execute();
}
/// <summary>
/// Updates rows in the Workgroup table that match the specified conditions with the specified data.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="lastUpdated">Object allows null.</param>
/// <param name="created">Object allows null.</param>
/// <param name="healthPlanID">Object allows null.</param>
/// <param name="consentLevel">Object does not allow null.</param>
/// <param name="hidden">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( string @name, System.DateTime? @lastUpdated, System.DateTime? @created, System.Int32? @healthPlanID, int @consentLevel, System.Boolean @hidden, CommandConditions.WorkgroupTableCondition requiredCondition, params CommandConditions.WorkgroupTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@nameColumnValue.Value = @name;
mod.@lastUpdatedColumnValue.Value = @lastUpdated;
mod.@createdColumnValue.Value = @created;
mod.@healthPlanIDColumnValue.Value = @healthPlanID;
mod.@consentLevelColumnValue.Value = @consentLevel;
mod.@hiddenColumnValue.Value = @hidden;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.WorkgroupTableCondition requiredCondition, params CommandConditions.WorkgroupTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@WorkgroupTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.WorkgroupTableCondition requiredCondition, params CommandConditions.WorkgroupTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.WorkgroupTableCondition> conditions ) {
var delete = new InlineDelete( "Workgroup" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.WorkgroupTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@WorkgroupTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.WorkgroupTableCondition> conditions;
private readonly DataValue<int> @workGroupIDColumnValue = new DataValue<int>();
/// <summary>
/// Gets the value for the WorkGroupID column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @WorkGroupID { get { return @workGroupIDColumnValue.Value; } }
private readonly DataValue<string> @nameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the Name column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @Name { get { return @nameColumnValue.Value; } set { @nameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Name has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @NameHasChanged { get { return @nameColumnValue.Changed; } }
private readonly DataValue<System.DateTime?> @lastUpdatedColumnValue = new DataValue<System.DateTime?>();
/// <summary>
/// Gets or sets the value for the LastUpdated column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.DateTime? @LastUpdated { get { return @lastUpdatedColumnValue.Value; } set { @lastUpdatedColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LastUpdated has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LastUpdatedHasChanged { get { return @lastUpdatedColumnValue.Changed; } }
private readonly DataValue<System.DateTime?> @createdColumnValue = new DataValue<System.DateTime?>();
/// <summary>
/// Gets or sets the value for the Created column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.DateTime? @Created { get { return @createdColumnValue.Value; } set { @createdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Created has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @CreatedHasChanged { get { return @createdColumnValue.Changed; } }
private readonly DataValue<System.Int32?> @healthPlanIDColumnValue = new DataValue<System.Int32?>();
/// <summary>
/// Gets or sets the value for the HealthPlanID column. Throws an exception if the value has not been initialized. Object allows null.
/// </summary>
public System.Int32? @HealthPlanID { get { return @healthPlanIDColumnValue.Value; } set { @healthPlanIDColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the HealthPlanID has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @HealthPlanIDHasChanged { get { return @healthPlanIDColumnValue.Changed; } }
private readonly DataValue<int> @consentLevelColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the ConsentLevel column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @ConsentLevel { get { return @consentLevelColumnValue.Value; } set { @consentLevelColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ConsentLevel has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ConsentLevelHasChanged { get { return @consentLevelColumnValue.Changed; } }
private readonly DataValue<System.Boolean> @hiddenColumnValue = new DataValue<System.Boolean>();
/// <summary>
/// Gets or sets the value for the Hidden column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public System.Boolean @Hidden { get { return @hiddenColumnValue.Value; } set { @hiddenColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the Hidden has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @HiddenHasChanged { get { return @hiddenColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the Workgroup table.
/// </summary>
public static @WorkgroupModification CreateForInsert() {
return new @WorkgroupModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the Workgroup table.
/// </summary>
public static @WorkgroupModification CreateForUpdate( CommandConditions.WorkgroupTableCondition requiredCondition, params CommandConditions.WorkgroupTableCondition[] additionalConditions ) {
var mod = new @WorkgroupModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@WorkgroupTableEqualityConditions.@WorkGroupID )
mod.@workGroupIDColumnValue.Value = ( condition as CommandConditions.@WorkgroupTableEqualityConditions.@WorkGroupID ).Value;
else if( condition is CommandConditions.@WorkgroupTableEqualityConditions.@Name )
mod.@nameColumnValue.Value = ( condition as CommandConditions.@WorkgroupTableEqualityConditions.@Name ).Value;
else if( condition is CommandConditions.@WorkgroupTableEqualityConditions.@LastUpdated )
mod.@lastUpdatedColumnValue.Value = ( condition as CommandConditions.@WorkgroupTableEqualityConditions.@LastUpdated ).Value;
else if( condition is CommandConditions.@WorkgroupTableEqualityConditions.@Created )
mod.@createdColumnValue.Value = ( condition as CommandConditions.@WorkgroupTableEqualityConditions.@Created ).Value;
else if( condition is CommandConditions.@WorkgroupTableEqualityConditions.@HealthPlanID )
mod.@healthPlanIDColumnValue.Value = ( condition as CommandConditions.@WorkgroupTableEqualityConditions.@HealthPlanID ).Value;
else if( condition is CommandConditions.@WorkgroupTableEqualityConditions.@ConsentLevel )
mod.@consentLevelColumnValue.Value = ( condition as CommandConditions.@WorkgroupTableEqualityConditions.@ConsentLevel ).Value;
else if( condition is CommandConditions.@WorkgroupTableEqualityConditions.@Hidden )
mod.@hiddenColumnValue.Value = ( condition as CommandConditions.@WorkgroupTableEqualityConditions.@Hidden ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the Workgroup table.
/// </summary>
public static @WorkgroupModification CreateForSingleRowUpdate( int @workGroupID, string @name, System.DateTime? @lastUpdated, System.DateTime? @created, System.Int32? @healthPlanID, int @consentLevel, System.Boolean @hidden ) {
var mod = new @WorkgroupModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.WorkgroupTableCondition>();
mod.conditions.Add( new CommandConditions.@WorkgroupTableEqualityConditions.@WorkGroupID( @workGroupID ) );
mod.@workGroupIDColumnValue.Value = @workGroupID;
mod.@nameColumnValue.Value = @name;
mod.@lastUpdatedColumnValue.Value = @lastUpdated;
mod.@createdColumnValue.Value = @created;
mod.@healthPlanIDColumnValue.Value = @healthPlanID;
mod.@consentLevelColumnValue.Value = @consentLevel;
mod.@hiddenColumnValue.Value = @hidden;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.WorkgroupTableCondition> getConditionList( CommandConditions.WorkgroupTableCondition requiredCondition, params CommandConditions.WorkgroupTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.WorkgroupTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @WorkgroupModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="name">Object does not allow null.</param>
/// <param name="lastUpdated">Object allows null.</param>
/// <param name="created">Object allows null.</param>
/// <param name="healthPlanID">Object allows null.</param>
/// <param name="consentLevel">Object does not allow null.</param>
/// <param name="hidden">Object does not allow null.</param>
public void SetAllData( string @name, System.DateTime? @lastUpdated, System.DateTime? @created, System.Int32? @healthPlanID, int @consentLevel, System.Boolean @hidden ) {
this.@nameColumnValue.Value = @name;
this.@lastUpdatedColumnValue.Value = @lastUpdated;
this.@createdColumnValue.Value = @created;
this.@healthPlanIDColumnValue.Value = @healthPlanID;
this.@consentLevelColumnValue.Value = @consentLevel;
this.@hiddenColumnValue.Value = @hidden;
}
/// <summary>
/// Executes this Workgroup modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this Workgroup modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "Workgroup" );
addColumnModifications( insert );
@workGroupIDColumnValue.Value = (System.Int32)Utility.ChangeType( insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection ), typeof( System.Int32 ) );
modType = ModificationType.Update;
conditions = new List<CommandConditions.WorkgroupTableCondition>();
conditions.Add( new CommandConditions.@WorkgroupTableEqualityConditions.@WorkGroupID( @WorkGroupID ) );
}
else {
var update = new InlineUpdate( "Workgroup" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @nameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Name", new DbParameterValue( @Name, "NVarChar" ) ) );
if( @lastUpdatedColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LastUpdated", new DbParameterValue( @LastUpdated, "DateTime" ) ) );
if( @createdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Created", new DbParameterValue( @Created, "DateTime" ) ) );
if( @healthPlanIDColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "HealthPlanID", new DbParameterValue( @HealthPlanID, "Int" ) ) );
if( @consentLevelColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ConsentLevel", new DbParameterValue( @ConsentLevel, "Int" ) ) );
if( @hiddenColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "Hidden", new DbParameterValue( @Hidden, "Bit" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@workGroupIDColumnValue.ClearChanged();
@nameColumnValue.ClearChanged();
@lastUpdatedColumnValue.ClearChanged();
@createdColumnValue.ClearChanged();
@healthPlanIDColumnValue.ClearChanged();
@consentLevelColumnValue.ClearChanged();
@hiddenColumnValue.ClearChanged();
}
}
public partial class @WorkgroupLocationsModification {
/// <summary>
/// Inserts a row into the WorkgroupLocations table.
/// </summary>
/// <param name="workgroupLocationId">Object does not allow null.</param>
/// <param name="workgroupId">Object does not allow null.</param>
/// <param name="locationName">Object does not allow null.</param>
public static void InsertRow( int @workgroupLocationId, int @workgroupId, string @locationName ) { 
var mod = CreateForInsert();
mod.@workgroupLocationIdColumnValue.Value = @workgroupLocationId;
mod.@workgroupIdColumnValue.Value = @workgroupId;
mod.@locationNameColumnValue.Value = @locationName;
mod.Execute();
}
/// <summary>
/// Inserts a row into the WorkgroupLocations table.
/// </summary>
/// <param name="workgroupLocationId">Object does not allow null.</param>
/// <param name="workgroupId">Object does not allow null.</param>
/// <param name="locationName">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @workgroupLocationId, int @workgroupId, string @locationName ) { 
var mod = CreateForInsert();
mod.@workgroupLocationIdColumnValue.Value = @workgroupLocationId;
mod.@workgroupIdColumnValue.Value = @workgroupId;
mod.@locationNameColumnValue.Value = @locationName;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the WorkgroupLocations table that match the specified conditions with the specified data.
/// </summary>
/// <param name="workgroupLocationId">Object does not allow null.</param>
/// <param name="workgroupId">Object does not allow null.</param>
/// <param name="locationName">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @workgroupLocationId, int @workgroupId, string @locationName, CommandConditions.WorkgroupLocationsTableCondition requiredCondition, params CommandConditions.WorkgroupLocationsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@workgroupLocationIdColumnValue.Value = @workgroupLocationId;
mod.@workgroupIdColumnValue.Value = @workgroupId;
mod.@locationNameColumnValue.Value = @locationName;
mod.Execute();
}
/// <summary>
/// Updates rows in the WorkgroupLocations table that match the specified conditions with the specified data.
/// </summary>
/// <param name="workgroupLocationId">Object does not allow null.</param>
/// <param name="workgroupId">Object does not allow null.</param>
/// <param name="locationName">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @workgroupLocationId, int @workgroupId, string @locationName, CommandConditions.WorkgroupLocationsTableCondition requiredCondition, params CommandConditions.WorkgroupLocationsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@workgroupLocationIdColumnValue.Value = @workgroupLocationId;
mod.@workgroupIdColumnValue.Value = @workgroupId;
mod.@locationNameColumnValue.Value = @locationName;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.WorkgroupLocationsTableCondition requiredCondition, params CommandConditions.WorkgroupLocationsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@WorkgroupLocationsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.WorkgroupLocationsTableCondition requiredCondition, params CommandConditions.WorkgroupLocationsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.WorkgroupLocationsTableCondition> conditions ) {
var delete = new InlineDelete( "WorkgroupLocations" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.WorkgroupLocationsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@WorkgroupLocationsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.WorkgroupLocationsTableCondition> conditions;
private readonly DataValue<int> @workgroupLocationIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the WorkgroupLocationId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @WorkgroupLocationId { get { return @workgroupLocationIdColumnValue.Value; } set { @workgroupLocationIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the WorkgroupLocationId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @WorkgroupLocationIdHasChanged { get { return @workgroupLocationIdColumnValue.Changed; } }
private readonly DataValue<int> @workgroupIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the WorkgroupId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @WorkgroupId { get { return @workgroupIdColumnValue.Value; } set { @workgroupIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the WorkgroupId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @WorkgroupIdHasChanged { get { return @workgroupIdColumnValue.Changed; } }
private readonly DataValue<string> @locationNameColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the LocationName column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @LocationName { get { return @locationNameColumnValue.Value; } set { @locationNameColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the LocationName has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @LocationNameHasChanged { get { return @locationNameColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the WorkgroupLocations table.
/// </summary>
public static @WorkgroupLocationsModification CreateForInsert() {
return new @WorkgroupLocationsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the WorkgroupLocations table.
/// </summary>
public static @WorkgroupLocationsModification CreateForUpdate( CommandConditions.WorkgroupLocationsTableCondition requiredCondition, params CommandConditions.WorkgroupLocationsTableCondition[] additionalConditions ) {
var mod = new @WorkgroupLocationsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@WorkgroupLocationsTableEqualityConditions.@WorkgroupLocationId )
mod.@workgroupLocationIdColumnValue.Value = ( condition as CommandConditions.@WorkgroupLocationsTableEqualityConditions.@WorkgroupLocationId ).Value;
else if( condition is CommandConditions.@WorkgroupLocationsTableEqualityConditions.@WorkgroupId )
mod.@workgroupIdColumnValue.Value = ( condition as CommandConditions.@WorkgroupLocationsTableEqualityConditions.@WorkgroupId ).Value;
else if( condition is CommandConditions.@WorkgroupLocationsTableEqualityConditions.@LocationName )
mod.@locationNameColumnValue.Value = ( condition as CommandConditions.@WorkgroupLocationsTableEqualityConditions.@LocationName ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the WorkgroupLocations table.
/// </summary>
public static @WorkgroupLocationsModification CreateForSingleRowUpdate( int @workgroupLocationId, int @workgroupId, string @locationName ) {
var mod = new @WorkgroupLocationsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.WorkgroupLocationsTableCondition>();
mod.conditions.Add( new CommandConditions.@WorkgroupLocationsTableEqualityConditions.@WorkgroupLocationId( @workgroupLocationId ) );
mod.@workgroupLocationIdColumnValue.Value = @workgroupLocationId;
mod.@workgroupIdColumnValue.Value = @workgroupId;
mod.@locationNameColumnValue.Value = @locationName;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.WorkgroupLocationsTableCondition> getConditionList( CommandConditions.WorkgroupLocationsTableCondition requiredCondition, params CommandConditions.WorkgroupLocationsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.WorkgroupLocationsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @WorkgroupLocationsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="workgroupLocationId">Object does not allow null.</param>
/// <param name="workgroupId">Object does not allow null.</param>
/// <param name="locationName">Object does not allow null.</param>
public void SetAllData( int @workgroupLocationId, int @workgroupId, string @locationName ) {
this.@workgroupLocationIdColumnValue.Value = @workgroupLocationId;
this.@workgroupIdColumnValue.Value = @workgroupId;
this.@locationNameColumnValue.Value = @locationName;
}
/// <summary>
/// Executes this WorkgroupLocations modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this WorkgroupLocations modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "WorkgroupLocations" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.WorkgroupLocationsTableCondition>();
conditions.Add( new CommandConditions.@WorkgroupLocationsTableEqualityConditions.@WorkgroupLocationId( @WorkgroupLocationId ) );
}
else {
var update = new InlineUpdate( "WorkgroupLocations" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @workgroupLocationIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "WorkgroupLocationId", new DbParameterValue( @WorkgroupLocationId, "Int" ) ) );
if( @workgroupIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "WorkgroupId", new DbParameterValue( @WorkgroupId, "Int" ) ) );
if( @locationNameColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "LocationName", new DbParameterValue( @LocationName, "NVarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@workgroupLocationIdColumnValue.ClearChanged();
@workgroupIdColumnValue.ClearChanged();
@locationNameColumnValue.ClearChanged();
}
}
public partial class @ZipCodesToDeploymentCoordinatorsModification {
/// <summary>
/// Inserts a row into the ZipCodesToDeploymentCoordinators table.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="zipCode">Object does not allow null.</param>
public static void InsertRow( int @userId, string @zipCode ) { 
var mod = CreateForInsert();
mod.@userIdColumnValue.Value = @userId;
mod.@zipCodeColumnValue.Value = @zipCode;
mod.Execute();
}
/// <summary>
/// Inserts a row into the ZipCodesToDeploymentCoordinators table.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="zipCode">Object does not allow null.</param>
public static void InsertRowWithoutAdditionalLogic( int @userId, string @zipCode ) { 
var mod = CreateForInsert();
mod.@userIdColumnValue.Value = @userId;
mod.@zipCodeColumnValue.Value = @zipCode;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// Updates rows in the ZipCodesToDeploymentCoordinators table that match the specified conditions with the specified data.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="zipCode">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRows( int @userId, string @zipCode, CommandConditions.ZipCodesToDeploymentCoordinatorsTableCondition requiredCondition, params CommandConditions.ZipCodesToDeploymentCoordinatorsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@userIdColumnValue.Value = @userId;
mod.@zipCodeColumnValue.Value = @zipCode;
mod.Execute();
}
/// <summary>
/// Updates rows in the ZipCodesToDeploymentCoordinators table that match the specified conditions with the specified data.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="zipCode">Object does not allow null.</param>
/// <param name="requiredCondition">A condition.</param>
/// <param name="additionalConditions">Additional conditions.</param>
public static void UpdateRowsWithoutAdditionalLogic( int @userId, string @zipCode, CommandConditions.ZipCodesToDeploymentCoordinatorsTableCondition requiredCondition, params CommandConditions.ZipCodesToDeploymentCoordinatorsTableCondition[] additionalConditions ) {
var mod = CreateForUpdate( requiredCondition, additionalConditions );
mod.@userIdColumnValue.Value = @userId;
mod.@zipCodeColumnValue.Value = @zipCode;
mod.ExecuteWithoutAdditionalLogic();
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRows( CommandConditions.ZipCodesToDeploymentCoordinatorsTableCondition requiredCondition, params CommandConditions.ZipCodesToDeploymentCoordinatorsTableCondition[] additionalConditions ) {
return DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( () => {
var conditions = getConditionList( requiredCondition, additionalConditions );
PostDeleteCall<IEnumerable<TableRetrieval.@ZipCodesToDeploymentCoordinatorsTableRetrieval.Row>> postDeleteCall = null;
preDelete( conditions, ref postDeleteCall );
var rowsDeleted = deleteRows( conditions );
if( postDeleteCall != null )
postDeleteCall.Execute();
return rowsDeleted;
} );
}
/// <summary>
/// <para>Deletes the rows that match the specified conditions and returns the number of rows deleted.</para><para>WARNING: After calling this method, delete referenced rows in other tables that are no longer needed.</para>
/// </summary>
public static int DeleteRowsWithoutAdditionalLogic( CommandConditions.ZipCodesToDeploymentCoordinatorsTableCondition requiredCondition, params CommandConditions.ZipCodesToDeploymentCoordinatorsTableCondition[] additionalConditions ) {
var conditions = getConditionList( requiredCondition, additionalConditions );
var rowsDeleted = deleteRows( conditions );
return rowsDeleted;
}
private static int deleteRows( List<CommandConditions.ZipCodesToDeploymentCoordinatorsTableCondition> conditions ) {
var delete = new InlineDelete( "ZipCodesToDeploymentCoordinators" );
conditions.ForEach( condition => delete.AddCondition( condition.CommandCondition ) );
try {
return delete.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
static partial void preDelete( List<CommandConditions.ZipCodesToDeploymentCoordinatorsTableCondition> conditions, ref PostDeleteCall<IEnumerable<TableRetrieval.@ZipCodesToDeploymentCoordinatorsTableRetrieval.Row>> postDeleteCall );
private ModificationType modType;
private List<CommandConditions.ZipCodesToDeploymentCoordinatorsTableCondition> conditions;
private readonly DataValue<int> @userIdColumnValue = new DataValue<int>();
/// <summary>
/// Gets or sets the value for the UserId column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public int @UserId { get { return @userIdColumnValue.Value; } set { @userIdColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the UserId has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @UserIdHasChanged { get { return @userIdColumnValue.Changed; } }
private readonly DataValue<string> @zipCodeColumnValue = new DataValue<string>();
/// <summary>
/// Gets or sets the value for the ZipCode column. Throws an exception if the value has not been initialized. Object does not allow null.
/// </summary>
public string @ZipCode { get { return @zipCodeColumnValue.Value; } set { @zipCodeColumnValue.Value = value; } }
/// <summary>
/// Indicates whether or not the value for the ZipCode has been set since object creation or the last call to Execute, whichever was latest.
/// </summary>
public bool @ZipCodeHasChanged { get { return @zipCodeColumnValue.Changed; } }
/// <summary>
/// Creates a modification object in insert mode, which can be used to do a piecemeal insert of a new row in the ZipCodesToDeploymentCoordinators table.
/// </summary>
public static @ZipCodesToDeploymentCoordinatorsModification CreateForInsert() {
return new @ZipCodesToDeploymentCoordinatorsModification { modType = ModificationType.Insert };
}
/// <summary>
/// Creates a modification object in update mode with the specified conditions, which can be used to do a piecemeal update of the ZipCodesToDeploymentCoordinators table.
/// </summary>
public static @ZipCodesToDeploymentCoordinatorsModification CreateForUpdate( CommandConditions.ZipCodesToDeploymentCoordinatorsTableCondition requiredCondition, params CommandConditions.ZipCodesToDeploymentCoordinatorsTableCondition[] additionalConditions ) {
var mod = new @ZipCodesToDeploymentCoordinatorsModification { modType = ModificationType.Update, conditions = getConditionList( requiredCondition, additionalConditions ) };
foreach( var condition in mod.conditions ) {
if( condition is CommandConditions.@ZipCodesToDeploymentCoordinatorsTableEqualityConditions.@UserId )
mod.@userIdColumnValue.Value = ( condition as CommandConditions.@ZipCodesToDeploymentCoordinatorsTableEqualityConditions.@UserId ).Value;
else if( condition is CommandConditions.@ZipCodesToDeploymentCoordinatorsTableEqualityConditions.@ZipCode )
mod.@zipCodeColumnValue.Value = ( condition as CommandConditions.@ZipCodesToDeploymentCoordinatorsTableEqualityConditions.@ZipCode ).Value;
}

mod.markColumnValuesUnchanged();
return mod;
}
/// <summary>
/// Creates a modification object in single-row update mode with the specified current data. All column values in this object will have HasChanged = false, despite being initialized. This object can then be used to do a piecemeal update of the ZipCodesToDeploymentCoordinators table.
/// </summary>
public static @ZipCodesToDeploymentCoordinatorsModification CreateForSingleRowUpdate( int @userId, string @zipCode ) {
var mod = new @ZipCodesToDeploymentCoordinatorsModification { modType = ModificationType.Update };
mod.conditions = new List<CommandConditions.ZipCodesToDeploymentCoordinatorsTableCondition>();
mod.conditions.Add( new CommandConditions.@ZipCodesToDeploymentCoordinatorsTableEqualityConditions.@UserId( @userId ) );
mod.conditions.Add( new CommandConditions.@ZipCodesToDeploymentCoordinatorsTableEqualityConditions.@ZipCode( @zipCode ) );
mod.@userIdColumnValue.Value = @userId;
mod.@zipCodeColumnValue.Value = @zipCode;
mod.markColumnValuesUnchanged();
return mod;
}
private static List<CommandConditions.ZipCodesToDeploymentCoordinatorsTableCondition> getConditionList( CommandConditions.ZipCodesToDeploymentCoordinatorsTableCondition requiredCondition, params CommandConditions.ZipCodesToDeploymentCoordinatorsTableCondition[] additionalConditions ) {
var conditions = new List<CommandConditions.ZipCodesToDeploymentCoordinatorsTableCondition>();
conditions.Add( requiredCondition );
foreach( var condition in additionalConditions )
conditions.Add( condition );
return conditions;
}
private @ZipCodesToDeploymentCoordinatorsModification() {}
/// <summary>
/// Sets all column values. This is useful for enforcing the number of arguments when deferred execution is needed.
/// </summary>
/// <param name="userId">Object does not allow null.</param>
/// <param name="zipCode">Object does not allow null.</param>
public void SetAllData( int @userId, string @zipCode ) {
this.@userIdColumnValue.Value = @userId;
this.@zipCodeColumnValue.Value = @zipCode;
}
/// <summary>
/// Executes this ZipCodesToDeploymentCoordinators modification, persisting all changes. Executes any pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void Execute() {
DataAccessState.Current.PrimaryDatabaseConnection.ExecuteInTransaction( delegate {
var frozenModType = modType;
if( frozenModType == ModificationType.Insert )
preInsert();
else if( frozenModType == ModificationType.Update )
preUpdate();
executeInsertOrUpdate();
if( frozenModType == ModificationType.Insert )
postInsert();
else if( frozenModType == ModificationType.Update )
postUpdate();
markColumnValuesUnchanged();
} );
}
partial void preInsert();
partial void preUpdate();
/// <summary>
/// Executes this ZipCodesToDeploymentCoordinators modification, persisting all changes. Does not execute pre-insert, pre-update, post-insert, or post-update logic that may exist in the class.
/// </summary>
public void ExecuteWithoutAdditionalLogic() {
executeInsertOrUpdate();
markColumnValuesUnchanged();
}
private void executeInsertOrUpdate() {
try {
if( modType == ModificationType.Insert ) {
var insert = new InlineInsert( "ZipCodesToDeploymentCoordinators" );
addColumnModifications( insert );
insert.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
modType = ModificationType.Update;
conditions = new List<CommandConditions.ZipCodesToDeploymentCoordinatorsTableCondition>();
conditions.Add( new CommandConditions.@ZipCodesToDeploymentCoordinatorsTableEqualityConditions.@UserId( @UserId ) );
conditions.Add( new CommandConditions.@ZipCodesToDeploymentCoordinatorsTableEqualityConditions.@ZipCode( @ZipCode ) );
}
else {
var update = new InlineUpdate( "ZipCodesToDeploymentCoordinators" );
addColumnModifications( update );
conditions.ForEach( condition => update.AddCondition( condition.CommandCondition ) );
update.Execute( DataAccessState.Current.PrimaryDatabaseConnection );
}
}
catch(Exception e) {
rethrowAsDataModificationExceptionIfNecessary( e );
throw;
}
}
private void addColumnModifications( InlineDbModificationCommand cmd ) {
if( @userIdColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "UserId", new DbParameterValue( @UserId, "Int" ) ) );
if( @zipCodeColumnValue.Changed )
cmd.AddColumnModification( new InlineDbCommandColumnValue( "ZipCode", new DbParameterValue( @ZipCode, "VarChar" ) ) );
}
private static void rethrowAsDataModificationExceptionIfNecessary( System.Exception e ) {
var constraintNamesToViolationErrorMessages = new Dictionary<string,string>();
populateConstraintNamesToViolationErrorMessages( constraintNamesToViolationErrorMessages );
foreach( var pair in constraintNamesToViolationErrorMessages )
if( e.GetBaseException().Message.ToLower().Contains( pair.Key.ToLower() ) ) throw new DataModificationException( pair.Value );
}
static partial void populateConstraintNamesToViolationErrorMessages( Dictionary<string,string> constraintNamesToViolationErrorMessages );
partial void postInsert();
partial void postUpdate();
private void markColumnValuesUnchanged() {
@userIdColumnValue.ClearChanged();
@zipCodeColumnValue.ClearChanged();
}
}
}


